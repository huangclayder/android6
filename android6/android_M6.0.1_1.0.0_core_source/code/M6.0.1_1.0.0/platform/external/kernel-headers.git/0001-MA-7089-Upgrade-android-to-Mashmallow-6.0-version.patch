From 6a93ea85e7ecec0dce51946aed9ff12912334ca7 Mon Sep 17 00:00:00 2001
From: Xiaowen Liu <xiaowen.liu@freescale.com>
Date: Mon, 12 Oct 2015 10:25:14 -0400
Subject: [PATCH] MA-7089 Upgrade android to Mashmallow 6.0 version.

update to kernel 3.14 headers.
1) prepare kernel headers.
$mkdir kernel_source
$mv kernel_imx kernel_source/
$cd kernel_source && mv kernel_imx common
2) get kernel headers.
$bionic/libc/kernel/tools/generate_uapi_headers.sh --use-kernel-dir kernel_source
3) update kernel headers.
$cd bionic/
$libc/kernel/tools/update_all.py

Signed-off-by: Xiaowen Liu <xiaowen.liu@freescale.com>
---
 original/uapi/asm-arm/asm/hwcap.h               |   9 -
 original/uapi/asm-arm/asm/unistd.h              |   5 -
 original/uapi/asm-arm64/asm/posix_types.h       |   9 -
 original/uapi/asm-arm64/asm/sigcontext.h        |   7 -
 original/uapi/asm-generic/fcntl.h               |  19 +-
 original/uapi/asm-generic/mman-common.h         |   2 +-
 original/uapi/asm-generic/resource.h            |   7 +
 original/uapi/asm-generic/unistd.h              |  13 +-
 original/uapi/asm-mips/asm/inst.h               | 454 +++++++++++-------------
 original/uapi/asm-mips/asm/ioctls.h             |   2 -
 original/uapi/asm-mips/asm/kvm.h                |  35 --
 original/uapi/asm-mips/asm/kvm_para.h           |   6 +-
 original/uapi/asm-mips/asm/ptrace.h             |  27 +-
 original/uapi/asm-mips/asm/swab.h               |  18 +-
 original/uapi/asm-mips/asm/types.h              |   5 +-
 original/uapi/asm-mips/asm/unistd.h             |  27 +-
 original/uapi/asm-x86/asm/e820.h                |   5 +
 original/uapi/asm-x86/asm/kvm.h                 |   3 -
 original/uapi/asm-x86/asm/msr-index.h           |  82 ++---
 original/uapi/asm-x86/asm/unistd_32.h           |   5 -
 original/uapi/asm-x86/asm/unistd_64.h           |   6 -
 original/uapi/asm-x86/asm/unistd_x32.h          |   6 -
 original/uapi/asm-x86/asm/vsyscall.h            |   7 +-
 original/uapi/drm/drm.h                         |  19 +-
 original/uapi/drm/drm_mode.h                    |  21 --
 original/uapi/drm/exynos_drm.h                  |  40 +++
 original/uapi/drm/i915_drm.h                    |  17 -
 original/uapi/drm/msm_drm.h                     |  12 -
 original/uapi/drm/nouveau_drm.h                 |  11 -
 original/uapi/drm/radeon_drm.h                  |  50 +--
 original/uapi/drm/tegra_drm.h                   |  70 +---
 original/uapi/drm/vmwgfx_drm.h                  |  12 +-
 original/uapi/linux/audit.h                     |  40 +--
 original/uapi/linux/binder.h                    |  24 +-
 original/uapi/linux/bsg.h                       |  11 +-
 original/uapi/linux/btrfs.h                     |  20 +-
 original/uapi/linux/can.h                       |  38 +-
 original/uapi/linux/can/bcm.h                   |   6 +-
 original/uapi/linux/can/error.h                 |   6 +-
 original/uapi/linux/can/gw.h                    |   6 +-
 original/uapi/linux/can/netlink.h               |  13 +-
 original/uapi/linux/can/raw.h                   |   6 +-
 original/uapi/linux/capability.h                |  11 +-
 original/uapi/linux/capi.h                      |   2 +-
 original/uapi/linux/dcbnl.h                     |   3 +-
 original/uapi/linux/dm-ioctl.h                  |   4 +-
 original/uapi/linux/elf-em.h                    |   1 -
 original/uapi/linux/elf.h                       |   2 -
 original/uapi/linux/errqueue.h                  |  20 --
 original/uapi/linux/ethtool.h                   |   1 -
 original/uapi/linux/falloc.h                    |  35 --
 original/uapi/linux/fcntl.h                     |  15 -
 original/uapi/linux/fib_rules.h                 |   2 +
 original/uapi/linux/filter.h                    |  59 ++-
 original/uapi/linux/fs.h                        |   4 -
 original/uapi/linux/fuse.h                      |  32 +-
 original/uapi/linux/genwqe/genwqe_card.h        |   3 +-
 original/uapi/linux/gfs2_ondisk.h               |  14 +-
 original/uapi/linux/i8k.h                       |   3 +-
 original/uapi/linux/if.h                        | 134 +++----
 original/uapi/linux/if_bridge.h                 |   1 -
 original/uapi/linux/if_ether.h                  |   7 +-
 original/uapi/linux/if_fddi.h                   |  90 +++--
 original/uapi/linux/if_link.h                   |  43 +--
 original/uapi/linux/if_packet.h                 |   2 +-
 original/uapi/linux/if_pppox.h                  |   6 +-
 original/uapi/linux/if_tunnel.h                 |  19 +-
 original/uapi/linux/in.h                        |   4 -
 original/uapi/linux/in6.h                       |   5 -
 original/uapi/linux/inet_diag.h                 |  13 +-
 original/uapi/linux/input.h                     |  32 +-
 original/uapi/linux/ion.h                       |  12 +-
 original/uapi/linux/ip_vs.h                     |   3 -
 original/uapi/linux/ipu.h                       | 300 ++++++++++++++++
 original/uapi/linux/ipv6.h                      |   3 +-
 original/uapi/linux/isl29023.h                  |  47 +++
 original/uapi/linux/kernel-page-flags.h         |   1 -
 original/uapi/linux/kexec.h                     |  11 -
 original/uapi/linux/kvm.h                       |  99 +-----
 original/uapi/linux/kvm_para.h                  |   3 -
 original/uapi/linux/l2tp.h                      |   2 -
 original/uapi/linux/mxc_asrc.h                  | 126 +++++++
 original/uapi/linux/mxc_dcic.h                  |  47 +++
 original/uapi/linux/mxc_sim_interface.h         | 124 +++++++
 original/uapi/linux/mxc_v4l2.h                  |  56 +++
 original/uapi/linux/mxcfb.h                     | 198 +++++++++++
 original/uapi/linux/neighbour.h                 |   1 -
 original/uapi/linux/net_tstamp.h                |  10 +-
 original/uapi/linux/netdevice.h                 |  12 -
 original/uapi/linux/netfilter/ipset/ip_set.h    |  24 --
 original/uapi/linux/netfilter/nf_nat.h          |   5 -
 original/uapi/linux/netfilter/nf_tables.h       | 106 +-----
 original/uapi/linux/netfilter/nfnetlink.h       |   2 -
 original/uapi/linux/netfilter/nfnetlink_acct.h  |  17 -
 original/uapi/linux/netfilter/xt_IDLETIMER.h    |   8 +
 original/uapi/linux/netfilter/xt_bpf.h          |   4 +-
 original/uapi/linux/netfilter/xt_set.h          |  10 -
 original/uapi/linux/netfilter/xt_socket.h       |   5 +
 original/uapi/linux/netfilter_arp/arpt_mangle.h |   2 +-
 original/uapi/linux/nfc.h                       |  25 +-
 original/uapi/linux/nfsd/export.h               |   5 +-
 original/uapi/linux/nfsd/nfsfh.h                |  32 +-
 original/uapi/linux/nl80211.h                   | 280 +--------------
 original/uapi/linux/nvme.h                      |  51 +--
 original/uapi/linux/openvswitch.h               |  48 +--
 original/uapi/linux/pci_regs.h                  |   3 +-
 original/uapi/linux/perf_event.h                |  35 +-
 original/uapi/linux/pfkeyv2.h                   |  15 +-
 original/uapi/linux/prctl.h                     |  31 +-
 original/uapi/linux/pxp_device.h                |  63 ++++
 original/uapi/linux/pxp_dma.h                   | 283 +++++++++++++++
 original/uapi/linux/raid/md_u.h                 |   1 +
 original/uapi/linux/random.h                    |   9 -
 original/uapi/linux/rtnetlink.h                 |   1 +
 original/uapi/linux/sched.h                     |   2 +-
 original/uapi/linux/sctp.h                      | 102 ++----
 original/uapi/linux/seccomp.h                   |   7 -
 original/uapi/linux/serial_core.h               |  11 +-
 original/uapi/linux/serial_reg.h                |   7 +-
 original/uapi/linux/serio.h                     |   1 -
 original/uapi/linux/shm.h                       |  17 +-
 original/uapi/linux/snmp.h                      |   6 -
 original/uapi/linux/sockios.h                   |   1 +
 original/uapi/linux/spi/spidev.h                |  14 +-
 original/uapi/linux/sysctl.h                    |   1 -
 original/uapi/linux/tcp.h                       |   3 -
 original/uapi/linux/tcp_metrics.h               |   7 +-
 original/uapi/linux/tipc.h                      |  23 --
 original/uapi/linux/tipc_config.h               |  12 +-
 original/uapi/linux/udp.h                       |   2 -
 original/uapi/linux/uhid.h                      | 117 +-----
 original/uapi/linux/uinput.h                    |  22 +-
 original/uapi/linux/usb/cdc.h                   |  12 -
 original/uapi/linux/usb/ch9.h                   |  17 +
 original/uapi/linux/usb/functionfs.h            | 135 +------
 original/uapi/linux/usbdevice_fs.h              |  12 +-
 original/uapi/linux/v4l2-common.h               |  10 -
 original/uapi/linux/v4l2-controls.h             |  57 ---
 original/uapi/linux/v4l2-dv-timings.h           |  87 -----
 original/uapi/linux/v4l2-mediabus.h             |  14 +-
 original/uapi/linux/v4l2-subdev.h               |  48 +--
 original/uapi/linux/version.h                   |   2 +-
 original/uapi/linux/vfio.h                      |  43 ---
 original/uapi/linux/videodev2.h                 | 204 ++---------
 original/uapi/linux/virtio_blk.h                |   5 -
 original/uapi/linux/xfrm.h                      |  17 -
 original/uapi/mtd/mtd-abi.h                     |   1 -
 original/uapi/mtd/ubi-user.h                    |  22 --
 original/uapi/rdma/ib_user_mad.h                |  42 ---
 original/uapi/rdma/ib_user_verbs.h              |  16 -
 original/uapi/rdma/rdma_netlink.h               |  96 +----
 original/uapi/sound/asound.h                    |  18 +-
 original/uapi/sound/compress_offload.h          |  14 +-
 original/uapi/sound/compress_params.h           |  14 +-
 original/uapi/sound/firewire.h                  |  23 +-
 original/uapi/video/adf.h                       |  12 +-
 156 files changed, 2120 insertions(+), 3024 deletions(-)

diff --git a/original/uapi/asm-arm/asm/hwcap.h b/original/uapi/asm-arm/asm/hwcap.h
index 20d12f2..7dcc10d 100644
--- a/original/uapi/asm-arm/asm/hwcap.h
+++ b/original/uapi/asm-arm/asm/hwcap.h
@@ -28,13 +28,4 @@
 #define HWCAP_LPAE	(1 << 20)
 #define HWCAP_EVTSTRM	(1 << 21)
 
-/*
- * HWCAP2 flags - for elf_hwcap2 (in kernel) and AT_HWCAP2
- */
-#define HWCAP2_AES	(1 << 0)
-#define HWCAP2_PMULL	(1 << 1)
-#define HWCAP2_SHA1	(1 << 2)
-#define HWCAP2_SHA2	(1 << 3)
-#define HWCAP2_CRC32	(1 << 4)
-
 #endif /* _UAPI__ASMARM_HWCAP_H */
diff --git a/original/uapi/asm-arm/asm/unistd.h b/original/uapi/asm-arm/asm/unistd.h
index 705bb76..c377633 100644
--- a/original/uapi/asm-arm/asm/unistd.h
+++ b/original/uapi/asm-arm/asm/unistd.h
@@ -408,11 +408,6 @@
 #define __NR_finit_module		(__NR_SYSCALL_BASE+379)
 #define __NR_sched_setattr		(__NR_SYSCALL_BASE+380)
 #define __NR_sched_getattr		(__NR_SYSCALL_BASE+381)
-#define __NR_renameat2			(__NR_SYSCALL_BASE+382)
-#define __NR_seccomp			(__NR_SYSCALL_BASE+383)
-#define __NR_getrandom			(__NR_SYSCALL_BASE+384)
-#define __NR_memfd_create		(__NR_SYSCALL_BASE+385)
-#define __NR_bpf			(__NR_SYSCALL_BASE+386)
 
 /*
  * The following SWIs are ARM private.
diff --git a/original/uapi/asm-arm64/asm/posix_types.h b/original/uapi/asm-arm64/asm/posix_types.h
index 7985ff6..22cae62 100644
--- a/original/uapi/asm-arm64/asm/posix_types.h
+++ b/original/uapi/asm-arm64/asm/posix_types.h
@@ -1,10 +1 @@
-#ifndef __ASM_POSIX_TYPES_H
-#define __ASM_POSIX_TYPES_H
-
-typedef unsigned short __kernel_old_uid_t;
-typedef unsigned short __kernel_old_gid_t;
-#define __kernel_old_uid_t __kernel_old_uid_t
-
 #include <asm-generic/posix_types.h>
-
-#endif /*  __ASM_POSIX_TYPES_H */
diff --git a/original/uapi/asm-arm64/asm/sigcontext.h b/original/uapi/asm-arm64/asm/sigcontext.h
index ee469be..690ad51 100644
--- a/original/uapi/asm-arm64/asm/sigcontext.h
+++ b/original/uapi/asm-arm64/asm/sigcontext.h
@@ -53,12 +53,5 @@ struct fpsimd_context {
 	__uint128_t vregs[32];
 };
 
-/* ESR_EL1 context */
-#define ESR_MAGIC	0x45535201
-
-struct esr_context {
-	struct _aarch64_ctx head;
-	__u64 esr;
-};
 
 #endif /* _UAPI__ASM_SIGCONTEXT_H */
diff --git a/original/uapi/asm-generic/fcntl.h b/original/uapi/asm-generic/fcntl.h
index 7543b3e..95e46c8 100644
--- a/original/uapi/asm-generic/fcntl.h
+++ b/original/uapi/asm-generic/fcntl.h
@@ -132,22 +132,6 @@
 #define F_GETOWNER_UIDS	17
 #endif
 
-/*
- * Open File Description Locks
- *
- * Usually record locks held by a process are released on *any* close and are
- * not inherited across a fork().
- *
- * These cmd values will set locks that conflict with process-associated
- * record  locks, but are "owned" by the open file description, not the
- * process. This means that they are inherited across fork() like BSD (flock)
- * locks, and they are only released automatically when the last reference to
- * the the open file against which they were acquired is put.
- */
-#define F_OFD_GETLK	36
-#define F_OFD_SETLK	37
-#define F_OFD_SETLKW	38
-
 #define F_OWNER_TID	0
 #define F_OWNER_PID	1
 #define F_OWNER_PGRP	2
@@ -202,6 +186,8 @@ struct flock {
 };
 #endif
 
+#ifndef CONFIG_64BIT
+
 #ifndef HAVE_ARCH_STRUCT_FLOCK64
 #ifndef __ARCH_FLOCK64_PAD
 #define __ARCH_FLOCK64_PAD
@@ -216,5 +202,6 @@ struct flock64 {
 	__ARCH_FLOCK64_PAD
 };
 #endif
+#endif /* !CONFIG_64BIT */
 
 #endif /* _ASM_GENERIC_FCNTL_H */
diff --git a/original/uapi/asm-generic/mman-common.h b/original/uapi/asm-generic/mman-common.h
index ddc3b36..4164529 100644
--- a/original/uapi/asm-generic/mman-common.h
+++ b/original/uapi/asm-generic/mman-common.h
@@ -50,7 +50,7 @@
 
 #define MADV_DONTDUMP   16		/* Explicity exclude from the core dump,
 					   overrides the coredump filter bits */
-#define MADV_DODUMP	17		/* Clear the MADV_DONTDUMP flag */
+#define MADV_DODUMP	17		/* Clear the MADV_NODUMP flag */
 
 /* compatibility flags */
 #define MAP_FILE	0
diff --git a/original/uapi/asm-generic/resource.h b/original/uapi/asm-generic/resource.h
index c6d10af..f863428 100644
--- a/original/uapi/asm-generic/resource.h
+++ b/original/uapi/asm-generic/resource.h
@@ -57,5 +57,12 @@
 # define RLIM_INFINITY		(~0UL)
 #endif
 
+/*
+ * RLIMIT_STACK default maximum - some architectures override it:
+ */
+#ifndef _STK_LIM_MAX
+# define _STK_LIM_MAX		RLIM_INFINITY
+#endif
+
 
 #endif /* _UAPI_ASM_GENERIC_RESOURCE_H */
diff --git a/original/uapi/asm-generic/unistd.h b/original/uapi/asm-generic/unistd.h
index 22749c1..dde8041 100644
--- a/original/uapi/asm-generic/unistd.h
+++ b/original/uapi/asm-generic/unistd.h
@@ -191,7 +191,6 @@ __SYSCALL(__NR_quotactl, sys_quotactl)
 
 /* fs/readdir.c */
 #define __NR_getdents64 61
-#define __ARCH_WANT_COMPAT_SYS_GETDENTS64
 __SC_COMP(__NR_getdents64, sys_getdents64, compat_sys_getdents64)
 
 /* fs/read_write.c */
@@ -697,19 +696,9 @@ __SYSCALL(__NR_finit_module, sys_finit_module)
 __SYSCALL(__NR_sched_setattr, sys_sched_setattr)
 #define __NR_sched_getattr 275
 __SYSCALL(__NR_sched_getattr, sys_sched_getattr)
-#define __NR_renameat2 276
-__SYSCALL(__NR_renameat2, sys_renameat2)
-#define __NR_seccomp 277
-__SYSCALL(__NR_seccomp, sys_seccomp)
-#define __NR_getrandom 278
-__SYSCALL(__NR_getrandom, sys_getrandom)
-#define __NR_memfd_create 279
-__SYSCALL(__NR_memfd_create, sys_memfd_create)
-#define __NR_bpf 280
-__SYSCALL(__NR_bpf, sys_bpf)
 
 #undef __NR_syscalls
-#define __NR_syscalls 281
+#define __NR_syscalls 276
 
 /*
  * All syscalls below here should go away really,
diff --git a/original/uapi/asm-mips/asm/inst.h b/original/uapi/asm-mips/asm/inst.h
index 4bfdb9d..f25181b 100644
--- a/original/uapi/asm-mips/asm/inst.h
+++ b/original/uapi/asm-mips/asm/inst.h
@@ -8,13 +8,10 @@
  * Copyright (C) 1996, 2000 by Ralf Baechle
  * Copyright (C) 2006 by Thiemo Seufer
  * Copyright (C) 2012 MIPS Technologies, Inc.  All rights reserved.
- * Copyright (C) 2014 Imagination Technologies Ltd.
  */
 #ifndef _UAPI_ASM_INST_H
 #define _UAPI_ASM_INST_H
 
-#include <asm/bitfield.h>
-
 /*
  * Major opcodes; before MIPS IV cop1x was called cop3.
  */
@@ -76,17 +73,10 @@ enum spec2_op {
 enum spec3_op {
 	ext_op, dextm_op, dextu_op, dext_op,
 	ins_op, dinsm_op, dinsu_op, dins_op,
-	yield_op  = 0x09, lx_op     = 0x0a,
-	lwle_op   = 0x19, lwre_op   = 0x1a,
-	cachee_op = 0x1b, sbe_op    = 0x1c,
-	she_op    = 0x1d, sce_op    = 0x1e,
-	swe_op    = 0x1f, bshfl_op  = 0x20,
-	swle_op   = 0x21, swre_op   = 0x22,
-	prefe_op  = 0x23, dbshfl_op = 0x24,
-	lbue_op   = 0x28, lhue_op   = 0x29,
-	lbe_op    = 0x2c, lhe_op    = 0x2d,
-	lle_op    = 0x2e, lwe_op    = 0x2f,
-	rdhwr_op  = 0x3b
+	lx_op = 0x0a,
+	bshfl_op = 0x20,
+	dbshfl_op = 0x24,
+	rdhwr_op = 0x3b
 };
 
 /*
@@ -128,8 +118,7 @@ enum bcop_op {
 enum cop0_coi_func {
 	tlbr_op	      = 0x01, tlbwi_op	    = 0x02,
 	tlbwr_op      = 0x06, tlbp_op	    = 0x08,
-	rfe_op	      = 0x10, eret_op	    = 0x18,
-	wait_op       = 0x20,
+	rfe_op	      = 0x10, eret_op	    = 0x18
 };
 
 /*
@@ -206,16 +195,6 @@ enum lx_func {
 };
 
 /*
- * BSHFL opcodes
- */
-enum bshfl_func {
-	wsbh_op = 0x2,
-	dshd_op = 0x5,
-	seb_op  = 0x10,
-	seh_op  = 0x18,
-};
-
-/*
  * (microMIPS) Major opcodes.
  */
 enum mm_major_op {
@@ -258,23 +237,17 @@ enum mm_32i_minor_op {
 enum mm_32a_minor_op {
 	mm_sll32_op = 0x000,
 	mm_ins_op = 0x00c,
-	mm_sllv32_op = 0x010,
 	mm_ext_op = 0x02c,
 	mm_pool32axf_op = 0x03c,
 	mm_srl32_op = 0x040,
 	mm_sra_op = 0x080,
-	mm_srlv32_op = 0x090,
 	mm_rotr_op = 0x0c0,
 	mm_lwxs_op = 0x118,
 	mm_addu32_op = 0x150,
 	mm_subu32_op = 0x1d0,
-	mm_wsbh_op = 0x1ec,
-	mm_mul_op = 0x210,
 	mm_and_op = 0x250,
 	mm_or32_op = 0x290,
 	mm_xor32_op = 0x310,
-	mm_slt_op = 0x350,
-	mm_sltu_op = 0x390,
 };
 
 /*
@@ -314,20 +287,15 @@ enum mm_32axf_minor_op {
 	mm_mfc0_op = 0x003,
 	mm_mtc0_op = 0x00b,
 	mm_tlbp_op = 0x00d,
-	mm_mfhi32_op = 0x035,
 	mm_jalr_op = 0x03c,
 	mm_tlbr_op = 0x04d,
-	mm_mflo32_op = 0x075,
 	mm_jalrhb_op = 0x07c,
 	mm_tlbwi_op = 0x08d,
 	mm_tlbwr_op = 0x0cd,
 	mm_jalrs_op = 0x13c,
 	mm_jalrshb_op = 0x17c,
-	mm_sync_op = 0x1ad,
 	mm_syscall_op = 0x22d,
-	mm_wait_op = 0x24d,
 	mm_eret_op = 0x3cd,
-	mm_divu_op = 0x5dc,
 };
 
 /*
@@ -505,116 +473,125 @@ enum MIPS6e_i8_func {
  */
 #define MM_NOP16	0x0c00
 
+/*
+ * Damn ...  bitfields depend from byteorder :-(
+ */
+#ifdef __MIPSEB__
+#define BITFIELD_FIELD(field, more)					\
+	field;								\
+	more
+
+#elif defined(__MIPSEL__)
+
+#define BITFIELD_FIELD(field, more)					\
+	more								\
+	field;
+
+#else /* !defined (__MIPSEB__) && !defined (__MIPSEL__) */
+#error "MIPS but neither __MIPSEL__ nor __MIPSEB__?"
+#endif
+
 struct j_format {
-	__BITFIELD_FIELD(unsigned int opcode : 6, /* Jump format */
-	__BITFIELD_FIELD(unsigned int target : 26,
+	BITFIELD_FIELD(unsigned int opcode : 6, /* Jump format */
+	BITFIELD_FIELD(unsigned int target : 26,
 	;))
 };
 
 struct i_format {			/* signed immediate format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(signed int simmediate : 16,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(signed int simmediate : 16,
 	;))))
 };
 
 struct u_format {			/* unsigned immediate format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int uimmediate : 16,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int uimmediate : 16,
 	;))))
 };
 
 struct c_format {			/* Cache (>= R6000) format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int c_op : 3,
-	__BITFIELD_FIELD(unsigned int cache : 2,
-	__BITFIELD_FIELD(unsigned int simmediate : 16,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int c_op : 3,
+	BITFIELD_FIELD(unsigned int cache : 2,
+	BITFIELD_FIELD(unsigned int simmediate : 16,
 	;)))))
 };
 
 struct r_format {			/* Register format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int rd : 5,
-	__BITFIELD_FIELD(unsigned int re : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int rd : 5,
+	BITFIELD_FIELD(unsigned int re : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct p_format {		/* Performance counter format (R10000) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int rd : 5,
-	__BITFIELD_FIELD(unsigned int re : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int rd : 5,
+	BITFIELD_FIELD(unsigned int re : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct f_format {			/* FPU register format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int : 1,
-	__BITFIELD_FIELD(unsigned int fmt : 4,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int rd : 5,
-	__BITFIELD_FIELD(unsigned int re : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int : 1,
+	BITFIELD_FIELD(unsigned int fmt : 4,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int rd : 5,
+	BITFIELD_FIELD(unsigned int re : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;)))))))
 };
 
 struct ma_format {		/* FPU multiply and add format (MIPS IV) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int fr : 5,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int func : 4,
-	__BITFIELD_FIELD(unsigned int fmt : 2,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int fr : 5,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int func : 4,
+	BITFIELD_FIELD(unsigned int fmt : 2,
 	;)))))))
 };
 
 struct b_format {			/* BREAK and SYSCALL */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int code : 20,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int code : 20,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;)))
 };
 
 struct ps_format {			/* MIPS-3D / paired single format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct v_format {				/* MDMX vector format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int sel : 4,
-	__BITFIELD_FIELD(unsigned int fmt : 1,
-	__BITFIELD_FIELD(unsigned int vt : 5,
-	__BITFIELD_FIELD(unsigned int vs : 5,
-	__BITFIELD_FIELD(unsigned int vd : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int sel : 4,
+	BITFIELD_FIELD(unsigned int fmt : 1,
+	BITFIELD_FIELD(unsigned int vt : 5,
+	BITFIELD_FIELD(unsigned int vs : 5,
+	BITFIELD_FIELD(unsigned int vd : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;)))))))
 };
 
-struct spec3_format {   /* SPEC3 */
-	__BITFIELD_FIELD(unsigned int opcode:6,
-	__BITFIELD_FIELD(unsigned int rs:5,
-	__BITFIELD_FIELD(unsigned int rt:5,
-	__BITFIELD_FIELD(signed int simmediate:9,
-	__BITFIELD_FIELD(unsigned int func:7,
-	;)))))
-};
-
 /*
  * microMIPS instruction formats (32-bit length)
  *
@@ -623,141 +600,141 @@ struct spec3_format {   /* SPEC3 */
  *	if it is MIPS32 instruction re-encoded for use in the microMIPS ASE.
  */
 struct fb_format {		/* FPU branch format (MIPS32) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int bc : 5,
-	__BITFIELD_FIELD(unsigned int cc : 3,
-	__BITFIELD_FIELD(unsigned int flag : 2,
-	__BITFIELD_FIELD(signed int simmediate : 16,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int bc : 5,
+	BITFIELD_FIELD(unsigned int cc : 3,
+	BITFIELD_FIELD(unsigned int flag : 2,
+	BITFIELD_FIELD(signed int simmediate : 16,
 	;)))))
 };
 
 struct fp0_format {		/* FPU multiply and add format (MIPS32) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int fmt : 5,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int fmt : 5,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_fp0_format {		/* FPU multipy and add format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int fmt : 3,
-	__BITFIELD_FIELD(unsigned int op : 2,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int fmt : 3,
+	BITFIELD_FIELD(unsigned int op : 2,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;)))))))
 };
 
 struct fp1_format {		/* FPU mfc1 and cfc1 format (MIPS32) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int op : 5,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int op : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_fp1_format {		/* FPU mfc1 and cfc1 format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fmt : 2,
-	__BITFIELD_FIELD(unsigned int op : 8,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fmt : 2,
+	BITFIELD_FIELD(unsigned int op : 8,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_fp2_format {		/* FPU movt and movf format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int cc : 3,
-	__BITFIELD_FIELD(unsigned int zero : 2,
-	__BITFIELD_FIELD(unsigned int fmt : 2,
-	__BITFIELD_FIELD(unsigned int op : 3,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int cc : 3,
+	BITFIELD_FIELD(unsigned int zero : 2,
+	BITFIELD_FIELD(unsigned int fmt : 2,
+	BITFIELD_FIELD(unsigned int op : 3,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))))
 };
 
 struct mm_fp3_format {		/* FPU abs and neg format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fmt : 3,
-	__BITFIELD_FIELD(unsigned int op : 7,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fmt : 3,
+	BITFIELD_FIELD(unsigned int op : 7,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_fp4_format {		/* FPU c.cond format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int cc : 3,
-	__BITFIELD_FIELD(unsigned int fmt : 3,
-	__BITFIELD_FIELD(unsigned int cond : 4,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int cc : 3,
+	BITFIELD_FIELD(unsigned int fmt : 3,
+	BITFIELD_FIELD(unsigned int cond : 4,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;)))))))
 };
 
 struct mm_fp5_format {		/* FPU lwxc1 and swxc1 format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int index : 5,
-	__BITFIELD_FIELD(unsigned int base : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int op : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int index : 5,
+	BITFIELD_FIELD(unsigned int base : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int op : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct fp6_format {		/* FPU madd and msub format (MIPS IV) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int fr : 5,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int fr : 5,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_fp6_format {		/* FPU madd and msub format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int ft : 5,
-	__BITFIELD_FIELD(unsigned int fs : 5,
-	__BITFIELD_FIELD(unsigned int fd : 5,
-	__BITFIELD_FIELD(unsigned int fr : 5,
-	__BITFIELD_FIELD(unsigned int func : 6,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int ft : 5,
+	BITFIELD_FIELD(unsigned int fs : 5,
+	BITFIELD_FIELD(unsigned int fd : 5,
+	BITFIELD_FIELD(unsigned int fr : 5,
+	BITFIELD_FIELD(unsigned int func : 6,
 	;))))))
 };
 
 struct mm_i_format {		/* Immediate format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(unsigned int rs : 5,
-	__BITFIELD_FIELD(signed int simmediate : 16,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(signed int simmediate : 16,
 	;))))
 };
 
 struct mm_m_format {		/* Multi-word load/store format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rd : 5,
-	__BITFIELD_FIELD(unsigned int base : 5,
-	__BITFIELD_FIELD(unsigned int func : 4,
-	__BITFIELD_FIELD(signed int simmediate : 12,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rd : 5,
+	BITFIELD_FIELD(unsigned int base : 5,
+	BITFIELD_FIELD(unsigned int func : 4,
+	BITFIELD_FIELD(signed int simmediate : 12,
 	;)))))
 };
 
 struct mm_x_format {		/* Scaled indexed load format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int index : 5,
-	__BITFIELD_FIELD(unsigned int base : 5,
-	__BITFIELD_FIELD(unsigned int rd : 5,
-	__BITFIELD_FIELD(unsigned int func : 11,
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int index : 5,
+	BITFIELD_FIELD(unsigned int base : 5,
+	BITFIELD_FIELD(unsigned int rd : 5,
+	BITFIELD_FIELD(unsigned int func : 11,
 	;)))))
 };
 
@@ -765,51 +742,51 @@ struct mm_x_format {		/* Scaled indexed load format (microMIPS) */
  * microMIPS instruction formats (16-bit length)
  */
 struct mm_b0_format {		/* Unconditional branch format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(signed int simmediate : 10,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(signed int simmediate : 10,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;)))
 };
 
 struct mm_b1_format {		/* Conditional branch format (microMIPS) */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rs : 3,
-	__BITFIELD_FIELD(signed int simmediate : 7,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 3,
+	BITFIELD_FIELD(signed int simmediate : 7,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;))))
 };
 
 struct mm16_m_format {		/* Multi-word load/store format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int func : 4,
-	__BITFIELD_FIELD(unsigned int rlist : 2,
-	__BITFIELD_FIELD(unsigned int imm : 4,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int func : 4,
+	BITFIELD_FIELD(unsigned int rlist : 2,
+	BITFIELD_FIELD(unsigned int imm : 4,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;)))))
 };
 
 struct mm16_rb_format {		/* Signed immediate format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 3,
-	__BITFIELD_FIELD(unsigned int base : 3,
-	__BITFIELD_FIELD(signed int simmediate : 4,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 3,
+	BITFIELD_FIELD(unsigned int base : 3,
+	BITFIELD_FIELD(signed int simmediate : 4,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;)))))
 };
 
 struct mm16_r3_format {		/* Load from global pointer format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 3,
-	__BITFIELD_FIELD(signed int simmediate : 7,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 3,
+	BITFIELD_FIELD(signed int simmediate : 7,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;))))
 };
 
 struct mm16_r5_format {		/* Load/store from stack pointer format */
-	__BITFIELD_FIELD(unsigned int opcode : 6,
-	__BITFIELD_FIELD(unsigned int rt : 5,
-	__BITFIELD_FIELD(signed int simmediate : 5,
-	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(signed int simmediate : 5,
+	BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;))))
 };
 
@@ -817,57 +794,57 @@ struct mm16_r5_format {		/* Load/store from stack pointer format */
  * MIPS16e instruction formats (16-bit length)
  */
 struct m16e_rr {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int rx : 3,
-	__BITFIELD_FIELD(unsigned int nd : 1,
-	__BITFIELD_FIELD(unsigned int l : 1,
-	__BITFIELD_FIELD(unsigned int ra : 1,
-	__BITFIELD_FIELD(unsigned int func : 5,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int rx : 3,
+	BITFIELD_FIELD(unsigned int nd : 1,
+	BITFIELD_FIELD(unsigned int l : 1,
+	BITFIELD_FIELD(unsigned int ra : 1,
+	BITFIELD_FIELD(unsigned int func : 5,
 	;))))))
 };
 
 struct m16e_jal {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int x : 1,
-	__BITFIELD_FIELD(unsigned int imm20_16 : 5,
-	__BITFIELD_FIELD(signed int imm25_21 : 5,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int x : 1,
+	BITFIELD_FIELD(unsigned int imm20_16 : 5,
+	BITFIELD_FIELD(signed int imm25_21 : 5,
 	;))))
 };
 
 struct m16e_i64 {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int func : 3,
-	__BITFIELD_FIELD(unsigned int imm : 8,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int func : 3,
+	BITFIELD_FIELD(unsigned int imm : 8,
 	;)))
 };
 
 struct m16e_ri64 {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int func : 3,
-	__BITFIELD_FIELD(unsigned int ry : 3,
-	__BITFIELD_FIELD(unsigned int imm : 5,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int func : 3,
+	BITFIELD_FIELD(unsigned int ry : 3,
+	BITFIELD_FIELD(unsigned int imm : 5,
 	;))))
 };
 
 struct m16e_ri {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int rx : 3,
-	__BITFIELD_FIELD(unsigned int imm : 8,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int rx : 3,
+	BITFIELD_FIELD(unsigned int imm : 8,
 	;)))
 };
 
 struct m16e_rri {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int rx : 3,
-	__BITFIELD_FIELD(unsigned int ry : 3,
-	__BITFIELD_FIELD(unsigned int imm : 5,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int rx : 3,
+	BITFIELD_FIELD(unsigned int ry : 3,
+	BITFIELD_FIELD(unsigned int imm : 5,
 	;))))
 };
 
 struct m16e_i8 {
-	__BITFIELD_FIELD(unsigned int opcode : 5,
-	__BITFIELD_FIELD(unsigned int func : 3,
-	__BITFIELD_FIELD(unsigned int imm : 8,
+	BITFIELD_FIELD(unsigned int opcode : 5,
+	BITFIELD_FIELD(unsigned int func : 3,
+	BITFIELD_FIELD(unsigned int imm : 8,
 	;)))
 };
 
@@ -886,7 +863,6 @@ union mips_instruction {
 	struct b_format b_format;
 	struct ps_format ps_format;
 	struct v_format v_format;
-	struct spec3_format spec3_format;
 	struct fb_format fb_format;
 	struct fp0_format fp0_format;
 	struct mm_fp0_format mm_fp0_format;
diff --git a/original/uapi/asm-mips/asm/ioctls.h b/original/uapi/asm-mips/asm/ioctls.h
index 740219c..b1e6377 100644
--- a/original/uapi/asm-mips/asm/ioctls.h
+++ b/original/uapi/asm-mips/asm/ioctls.h
@@ -81,8 +81,6 @@
 #define TCSETS2		_IOW('T', 0x2B, struct termios2)
 #define TCSETSW2	_IOW('T', 0x2C, struct termios2)
 #define TCSETSF2	_IOW('T', 0x2D, struct termios2)
-#define TIOCGRS485	_IOR('T', 0x2E, struct serial_rs485)
-#define TIOCSRS485	_IOWR('T', 0x2F, struct serial_rs485)
 #define TIOCGPTN	_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
 #define TIOCSPTLCK	_IOW('T', 0x31, int)  /* Lock/unlock Pty */
 #define TIOCGDEV	_IOR('T', 0x32, unsigned int) /* Get primary device node of /dev/console */
diff --git a/original/uapi/asm-mips/asm/kvm.h b/original/uapi/asm-mips/asm/kvm.h
index 2c04b6d..f09ff5a 100644
--- a/original/uapi/asm-mips/asm/kvm.h
+++ b/original/uapi/asm-mips/asm/kvm.h
@@ -106,41 +106,6 @@ struct kvm_fpu {
 #define KVM_REG_MIPS_LO (KVM_REG_MIPS | KVM_REG_SIZE_U64 | 33)
 #define KVM_REG_MIPS_PC (KVM_REG_MIPS | KVM_REG_SIZE_U64 | 34)
 
-/* KVM specific control registers */
-
-/*
- * CP0_Count control
- * DC:    Set 0: Master disable CP0_Count and set COUNT_RESUME to now
- *        Set 1: Master re-enable CP0_Count with unchanged bias, handling timer
- *               interrupts since COUNT_RESUME
- *        This can be used to freeze the timer to get a consistent snapshot of
- *        the CP0_Count and timer interrupt pending state, while also resuming
- *        safely without losing time or guest timer interrupts.
- * Other: Reserved, do not change.
- */
-#define KVM_REG_MIPS_COUNT_CTL		(KVM_REG_MIPS | KVM_REG_SIZE_U64 | \
-					 0x20000 | 0)
-#define KVM_REG_MIPS_COUNT_CTL_DC	0x00000001
-
-/*
- * CP0_Count resume monotonic nanoseconds
- * The monotonic nanosecond time of the last set of COUNT_CTL.DC (master
- * disable). Any reads and writes of Count related registers while
- * COUNT_CTL.DC=1 will appear to occur at this time. When COUNT_CTL.DC is
- * cleared again (master enable) any timer interrupts since this time will be
- * emulated.
- * Modifications to times in the future are rejected.
- */
-#define KVM_REG_MIPS_COUNT_RESUME	(KVM_REG_MIPS | KVM_REG_SIZE_U64 | \
-					 0x20000 | 1)
-/*
- * CP0_Count rate in Hz
- * Specifies the rate of the CP0_Count timer in Hz. Modifications occur without
- * discontinuities in CP0_Count.
- */
-#define KVM_REG_MIPS_COUNT_HZ		(KVM_REG_MIPS | KVM_REG_SIZE_U64 | \
-					 0x20000 | 2)
-
 /*
  * KVM MIPS specific structures and definitions
  *
diff --git a/original/uapi/asm-mips/asm/kvm_para.h b/original/uapi/asm-mips/asm/kvm_para.h
index 7e16d7c..14fab8f 100644
--- a/original/uapi/asm-mips/asm/kvm_para.h
+++ b/original/uapi/asm-mips/asm/kvm_para.h
@@ -1,5 +1 @@
-#ifndef _UAPI_ASM_MIPS_KVM_PARA_H
-#define _UAPI_ASM_MIPS_KVM_PARA_H
-
-
-#endif /* _UAPI_ASM_MIPS_KVM_PARA_H */
+#include <asm-generic/kvm_para.h>
diff --git a/original/uapi/asm-mips/asm/ptrace.h b/original/uapi/asm-mips/asm/ptrace.h
index 91a3d19..b26f7e3 100644
--- a/original/uapi/asm-mips/asm/ptrace.h
+++ b/original/uapi/asm-mips/asm/ptrace.h
@@ -9,8 +9,6 @@
 #ifndef _UAPI_ASM_PTRACE_H
 #define _UAPI_ASM_PTRACE_H
 
-#include <linux/types.h>
-
 /* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
 #define FPR_BASE	32
 #define PC		64
@@ -24,27 +22,24 @@
 #define DSP_CONTROL	77
 #define ACX		78
 
+#ifndef __KERNEL__
 /*
- * This struct defines the registers as used by PTRACE_{GET,SET}REGS. The
- * format is the same for both 32- and 64-bit processes. Registers for 32-bit
- * processes are sign extended.
+ * This struct defines the way the registers are stored on the stack during a
+ * system call/exception. As usual the registers k0/k1 aren't being saved.
  */
-#ifdef __KERNEL__
-struct user_pt_regs {
-#else
 struct pt_regs {
-#endif
 	/* Saved main processor registers. */
-	__u64 regs[32];
+	unsigned long regs[32];
 
 	/* Saved special registers. */
-	__u64 lo;
-	__u64 hi;
-	__u64 cp0_epc;
-	__u64 cp0_badvaddr;
-	__u64 cp0_status;
-	__u64 cp0_cause;
+	unsigned long cp0_status;
+	unsigned long hi;
+	unsigned long lo;
+	unsigned long cp0_badvaddr;
+	unsigned long cp0_cause;
+	unsigned long cp0_epc;
 } __attribute__ ((aligned (8)));
+#endif /* __KERNEL__ */
 
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
 #define PTRACE_GETREGS		12
diff --git a/original/uapi/asm-mips/asm/swab.h b/original/uapi/asm-mips/asm/swab.h
index 8f2d184..ac9a8f9 100644
--- a/original/uapi/asm-mips/asm/swab.h
+++ b/original/uapi/asm-mips/asm/swab.h
@@ -13,16 +13,12 @@
 
 #define __SWAB_64_THRU_32__
 
-#if (defined(__mips_isa_rev) && (__mips_isa_rev >= 2)) ||		\
-    defined(_MIPS_ARCH_LOONGSON3A)
+#if defined(__mips_isa_rev) && (__mips_isa_rev >= 2)
 
 static inline __attribute_const__ __u16 __arch_swab16(__u16 x)
 {
 	__asm__(
-	"	.set	push			\n"
-	"	.set	arch=mips32r2		\n"
 	"	wsbh	%0, %1			\n"
-	"	.set	pop			\n"
 	: "=r" (x)
 	: "r" (x));
 
@@ -33,11 +29,8 @@ static inline __attribute_const__ __u16 __arch_swab16(__u16 x)
 static inline __attribute_const__ __u32 __arch_swab32(__u32 x)
 {
 	__asm__(
-	"	.set	push			\n"
-	"	.set	arch=mips32r2		\n"
 	"	wsbh	%0, %1			\n"
 	"	rotr	%0, %0, 16		\n"
-	"	.set	pop			\n"
 	: "=r" (x)
 	: "r" (x));
 
@@ -53,11 +46,8 @@ static inline __attribute_const__ __u32 __arch_swab32(__u32 x)
 static inline __attribute_const__ __u64 __arch_swab64(__u64 x)
 {
 	__asm__(
-	"	.set	push			\n"
-	"	.set	arch=mips64r2		\n"
-	"	dsbh	%0, %1			\n"
-	"	dshd	%0, %0			\n"
-	"	.set	pop			\n"
+	"	dsbh	%0, %1\n"
+	"	dshd	%0, %0"
 	: "=r" (x)
 	: "r" (x));
 
@@ -65,5 +55,5 @@ static inline __attribute_const__ __u64 __arch_swab64(__u64 x)
 }
 #define __arch_swab64 __arch_swab64
 #endif /* __mips64 */
-#endif /* MIPS R2 or newer or Loongson 3A */
+#endif /* MIPS R2 or newer  */
 #endif /* _ASM_SWAB_H */
diff --git a/original/uapi/asm-mips/asm/types.h b/original/uapi/asm-mips/asm/types.h
index f3dd9ff..7ac9d0b 100644
--- a/original/uapi/asm-mips/asm/types.h
+++ b/original/uapi/asm-mips/asm/types.h
@@ -14,12 +14,9 @@
 /*
  * We don't use int-l64.h for the kernel anymore but still use it for
  * userspace to avoid code changes.
- *
- * However, some user programs (e.g. perf) may not want this. They can
- * flag __SANE_USERSPACE_TYPES__ to get int-ll64.h here.
  */
 #ifndef __KERNEL__
-# if _MIPS_SZLONG == 64 && !defined(__SANE_USERSPACE_TYPES__)
+# if _MIPS_SZLONG == 64
 #  include <asm-generic/int-l64.h>
 # else
 #  include <asm-generic/int-ll64.h>
diff --git a/original/uapi/asm-mips/asm/unistd.h b/original/uapi/asm-mips/asm/unistd.h
index d001bb1..d6e154a 100644
--- a/original/uapi/asm-mips/asm/unistd.h
+++ b/original/uapi/asm-mips/asm/unistd.h
@@ -371,21 +371,16 @@
 #define __NR_finit_module		(__NR_Linux + 348)
 #define __NR_sched_setattr		(__NR_Linux + 349)
 #define __NR_sched_getattr		(__NR_Linux + 350)
-#define __NR_renameat2			(__NR_Linux + 351)
-#define __NR_seccomp			(__NR_Linux + 352)
-#define __NR_getrandom			(__NR_Linux + 353)
-#define __NR_memfd_create		(__NR_Linux + 354)
-#define __NR_bpf			(__NR_Linux + 355)
 
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		355
+#define __NR_Linux_syscalls		350
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
 #define __NR_O32_Linux			4000
-#define __NR_O32_Linux_syscalls		355
+#define __NR_O32_Linux_syscalls		350
 
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 
@@ -704,21 +699,16 @@
 #define __NR_getdents64			(__NR_Linux + 308)
 #define __NR_sched_setattr		(__NR_Linux + 309)
 #define __NR_sched_getattr		(__NR_Linux + 310)
-#define __NR_renameat2			(__NR_Linux + 311)
-#define __NR_seccomp			(__NR_Linux + 312)
-#define __NR_getrandom			(__NR_Linux + 313)
-#define __NR_memfd_create		(__NR_Linux + 314)
-#define __NR_bpf			(__NR_Linux + 315)
 
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
-#define __NR_Linux_syscalls		315
+#define __NR_Linux_syscalls		310
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #define __NR_64_Linux			5000
-#define __NR_64_Linux_syscalls		315
+#define __NR_64_Linux_syscalls		310
 
 #if _MIPS_SIM == _MIPS_SIM_NABI32
 
@@ -1041,20 +1031,15 @@
 #define __NR_finit_module		(__NR_Linux + 312)
 #define __NR_sched_setattr		(__NR_Linux + 313)
 #define __NR_sched_getattr		(__NR_Linux + 314)
-#define __NR_renameat2			(__NR_Linux + 315)
-#define __NR_seccomp			(__NR_Linux + 316)
-#define __NR_getrandom			(__NR_Linux + 317)
-#define __NR_memfd_create		(__NR_Linux + 318)
-#define __NR_bpf			(__NR_Linux + 319)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		319
+#define __NR_Linux_syscalls		314
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
 #define __NR_N32_Linux			6000
-#define __NR_N32_Linux_syscalls		319
+#define __NR_N32_Linux_syscalls		314
 
 #endif /* _UAPI_ASM_UNISTD_H */
diff --git a/original/uapi/asm-x86/asm/e820.h b/original/uapi/asm-x86/asm/e820.h
index d993e33..bbae024 100644
--- a/original/uapi/asm-x86/asm/e820.h
+++ b/original/uapi/asm-x86/asm/e820.h
@@ -21,6 +21,11 @@
  * this size.
  */
 
+/*
+ * Odd: 'make headers_check' complains about numa.h if I try
+ * to collapse the next two #ifdef lines to a single line:
+ *	#if defined(__KERNEL__) && defined(CONFIG_EFI)
+ */
 #ifndef __KERNEL__
 #define E820_X_MAX E820MAX
 #endif
diff --git a/original/uapi/asm-x86/asm/kvm.h b/original/uapi/asm-x86/asm/kvm.h
index d7dcef5..d3a8778 100644
--- a/original/uapi/asm-x86/asm/kvm.h
+++ b/original/uapi/asm-x86/asm/kvm.h
@@ -23,10 +23,7 @@
 #define GP_VECTOR 13
 #define PF_VECTOR 14
 #define MF_VECTOR 16
-#define AC_VECTOR 17
 #define MC_VECTOR 18
-#define XM_VECTOR 19
-#define VE_VECTOR 20
 
 /* Select x86 specific features in <linux/kvm.h> */
 #define __KVM_HAVE_PIT
diff --git a/original/uapi/asm-x86/asm/msr-index.h b/original/uapi/asm-x86/asm/msr-index.h
index e21331c..c19fc60 100644
--- a/original/uapi/asm-x86/asm/msr-index.h
+++ b/original/uapi/asm-x86/asm/msr-index.h
@@ -149,9 +149,6 @@
 
 #define MSR_CORE_C1_RES			0x00000660
 
-#define MSR_CC6_DEMOTION_POLICY_CONFIG	0x00000668
-#define MSR_MC6_DEMOTION_POLICY_CONFIG	0x00000669
-
 #define MSR_AMD64_MC0_MASK		0xc0010044
 
 #define MSR_IA32_MCx_CTL(x)		(MSR_IA32_MC0_CTL + 4*(x))
@@ -298,9 +295,6 @@
 #define MSR_SMI_COUNT			0x00000034
 #define MSR_IA32_FEATURE_CONTROL        0x0000003a
 #define MSR_IA32_TSC_ADJUST             0x0000003b
-#define MSR_IA32_BNDCFGS		0x00000d90
-
-#define MSR_IA32_XSS			0x00000da0
 
 #define FEATURE_CONTROL_LOCKED				(1<<0)
 #define FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX	(1<<1)
@@ -374,58 +368,33 @@
 #define THERM_LOG_THRESHOLD1           (1 << 9)
 
 /* MISC_ENABLE bits: architectural */
-#define MSR_IA32_MISC_ENABLE_FAST_STRING_BIT		0
-#define MSR_IA32_MISC_ENABLE_FAST_STRING		(1ULL << MSR_IA32_MISC_ENABLE_FAST_STRING_BIT)
-#define MSR_IA32_MISC_ENABLE_TCC_BIT			1
-#define MSR_IA32_MISC_ENABLE_TCC			(1ULL << MSR_IA32_MISC_ENABLE_TCC_BIT)
-#define MSR_IA32_MISC_ENABLE_EMON_BIT			7
-#define MSR_IA32_MISC_ENABLE_EMON			(1ULL << MSR_IA32_MISC_ENABLE_EMON_BIT)
-#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT		11
-#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL		(1ULL << MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT)
-#define MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT		12
-#define MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL		(1ULL << MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT)
-#define MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT	16
-#define MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP		(1ULL << MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT)
-#define MSR_IA32_MISC_ENABLE_MWAIT_BIT			18
-#define MSR_IA32_MISC_ENABLE_MWAIT			(1ULL << MSR_IA32_MISC_ENABLE_MWAIT_BIT)
-#define MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT		22
-#define MSR_IA32_MISC_ENABLE_LIMIT_CPUID		(1ULL << MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT)
-#define MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT		23
-#define MSR_IA32_MISC_ENABLE_XTPR_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT		34
-#define MSR_IA32_MISC_ENABLE_XD_DISABLE			(1ULL << MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT)
+#define MSR_IA32_MISC_ENABLE_FAST_STRING	(1ULL << 0)
+#define MSR_IA32_MISC_ENABLE_TCC		(1ULL << 1)
+#define MSR_IA32_MISC_ENABLE_EMON		(1ULL << 7)
+#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL	(1ULL << 11)
+#define MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL	(1ULL << 12)
+#define MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP	(1ULL << 16)
+#define MSR_IA32_MISC_ENABLE_MWAIT		(1ULL << 18)
+#define MSR_IA32_MISC_ENABLE_LIMIT_CPUID	(1ULL << 22)
+#define MSR_IA32_MISC_ENABLE_XTPR_DISABLE	(1ULL << 23)
+#define MSR_IA32_MISC_ENABLE_XD_DISABLE		(1ULL << 34)
 
 /* MISC_ENABLE bits: model-specific, meaning may vary from core to core */
-#define MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT		2
-#define MSR_IA32_MISC_ENABLE_X87_COMPAT			(1ULL << MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT)
-#define MSR_IA32_MISC_ENABLE_TM1_BIT			3
-#define MSR_IA32_MISC_ENABLE_TM1			(1ULL << MSR_IA32_MISC_ENABLE_TM1_BIT)
-#define MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT	4
-#define MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT	6
-#define MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT		8
-#define MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK		(1ULL << MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT)
-#define MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT	9
-#define MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_FERR_BIT			10
-#define MSR_IA32_MISC_ENABLE_FERR			(1ULL << MSR_IA32_MISC_ENABLE_FERR_BIT)
-#define MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT		10
-#define MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX		(1ULL << MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT)
-#define MSR_IA32_MISC_ENABLE_TM2_BIT			13
-#define MSR_IA32_MISC_ENABLE_TM2			(1ULL << MSR_IA32_MISC_ENABLE_TM2_BIT)
-#define MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT	19
-#define MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT		20
-#define MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK		(1ULL << MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT)
-#define MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT		24
-#define MSR_IA32_MISC_ENABLE_L1D_CONTEXT		(1ULL << MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT)
-#define MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT	37
-#define MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT		38
-#define MSR_IA32_MISC_ENABLE_TURBO_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT)
-#define MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT	39
-#define MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE		(1ULL << MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT)
+#define MSR_IA32_MISC_ENABLE_X87_COMPAT		(1ULL << 2)
+#define MSR_IA32_MISC_ENABLE_TM1		(1ULL << 3)
+#define MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE	(1ULL << 4)
+#define MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE	(1ULL << 6)
+#define MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK	(1ULL << 8)
+#define MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE	(1ULL << 9)
+#define MSR_IA32_MISC_ENABLE_FERR		(1ULL << 10)
+#define MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX	(1ULL << 10)
+#define MSR_IA32_MISC_ENABLE_TM2		(1ULL << 13)
+#define MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE	(1ULL << 19)
+#define MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK	(1ULL << 20)
+#define MSR_IA32_MISC_ENABLE_L1D_CONTEXT	(1ULL << 24)
+#define MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE	(1ULL << 37)
+#define MSR_IA32_MISC_ENABLE_TURBO_DISABLE	(1ULL << 38)
+#define MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE	(1ULL << 39)
 
 #define MSR_IA32_TSC_DEADLINE		0x000006E0
 
@@ -563,7 +532,6 @@
 
 /* VMX_BASIC bits and bitmasks */
 #define VMX_BASIC_VMCS_SIZE_SHIFT	32
-#define VMX_BASIC_TRUE_CTLS		(1ULL << 55)
 #define VMX_BASIC_64		0x0001000000000000LLU
 #define VMX_BASIC_MEM_TYPE_SHIFT	50
 #define VMX_BASIC_MEM_TYPE_MASK	0x003c000000000000LLU
diff --git a/original/uapi/asm-x86/asm/unistd_32.h b/original/uapi/asm-x86/asm/unistd_32.h
index 9fa0a07..909d5bc 100644
--- a/original/uapi/asm-x86/asm/unistd_32.h
+++ b/original/uapi/asm-x86/asm/unistd_32.h
@@ -350,10 +350,5 @@
 #define __NR_finit_module 350
 #define __NR_sched_setattr 351
 #define __NR_sched_getattr 352
-#define __NR_renameat2 353
-#define __NR_seccomp 354
-#define __NR_getrandom 355
-#define __NR_memfd_create 356
-#define __NR_bpf 357
 
 #endif /* _ASM_X86_UNISTD_32_H */
diff --git a/original/uapi/asm-x86/asm/unistd_64.h b/original/uapi/asm-x86/asm/unistd_64.h
index 6865587..0a72e11 100644
--- a/original/uapi/asm-x86/asm/unistd_64.h
+++ b/original/uapi/asm-x86/asm/unistd_64.h
@@ -317,11 +317,5 @@
 #define __NR_finit_module 313
 #define __NR_sched_setattr 314
 #define __NR_sched_getattr 315
-#define __NR_renameat2 316
-#define __NR_seccomp 317
-#define __NR_getrandom 318
-#define __NR_memfd_create 319
-#define __NR_kexec_file_load 320
-#define __NR_bpf 321
 
 #endif /* _ASM_X86_UNISTD_64_H */
diff --git a/original/uapi/asm-x86/asm/unistd_x32.h b/original/uapi/asm-x86/asm/unistd_x32.h
index 1688af4..4b90010 100644
--- a/original/uapi/asm-x86/asm/unistd_x32.h
+++ b/original/uapi/asm-x86/asm/unistd_x32.h
@@ -273,12 +273,6 @@
 #define __NR_finit_module (__X32_SYSCALL_BIT + 313)
 #define __NR_sched_setattr (__X32_SYSCALL_BIT + 314)
 #define __NR_sched_getattr (__X32_SYSCALL_BIT + 315)
-#define __NR_renameat2 (__X32_SYSCALL_BIT + 316)
-#define __NR_seccomp (__X32_SYSCALL_BIT + 317)
-#define __NR_getrandom (__X32_SYSCALL_BIT + 318)
-#define __NR_memfd_create (__X32_SYSCALL_BIT + 319)
-#define __NR_kexec_file_load (__X32_SYSCALL_BIT + 320)
-#define __NR_bpf (__X32_SYSCALL_BIT + 321)
 #define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)
 #define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)
 #define __NR_ioctl (__X32_SYSCALL_BIT + 514)
diff --git a/original/uapi/asm-x86/asm/vsyscall.h b/original/uapi/asm-x86/asm/vsyscall.h
index b97dd6e..85dc1b3 100644
--- a/original/uapi/asm-x86/asm/vsyscall.h
+++ b/original/uapi/asm-x86/asm/vsyscall.h
@@ -7,6 +7,11 @@ enum vsyscall_num {
 	__NR_vgetcpu,
 };
 
-#define VSYSCALL_ADDR (-10UL << 20)
+#define VSYSCALL_START (-10UL << 20)
+#define VSYSCALL_SIZE 1024
+#define VSYSCALL_END (-2UL << 20)
+#define VSYSCALL_MAPPED_PAGES 1
+#define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))
+
 
 #endif /* _UAPI_ASM_X86_VSYSCALL_H */
diff --git a/original/uapi/drm/drm.h b/original/uapi/drm/drm.h
index b0b8556..b06c8ed 100644
--- a/original/uapi/drm/drm.h
+++ b/original/uapi/drm/drm.h
@@ -619,15 +619,6 @@ struct drm_gem_open {
 #define  DRM_PRIME_CAP_EXPORT		0x2
 #define DRM_CAP_TIMESTAMP_MONOTONIC	0x6
 #define DRM_CAP_ASYNC_PAGE_FLIP		0x7
-/*
- * The CURSOR_WIDTH and CURSOR_HEIGHT capabilities return a valid widthxheight
- * combination for the hardware cursor. The intention is that a hardware
- * agnostic userspace can query a cursor plane size to use.
- *
- * Note that the cross-driver contract is to merely return a valid size;
- * drivers are free to attach another meaning on top, eg. i915 returns the
- * maximum plane size.
- */
 #define DRM_CAP_CURSOR_WIDTH		0x8
 #define DRM_CAP_CURSOR_HEIGHT		0x9
 
@@ -646,14 +637,6 @@ struct drm_get_cap {
  */
 #define DRM_CLIENT_CAP_STEREO_3D	1
 
-/**
- * DRM_CLIENT_CAP_UNIVERSAL_PLANES
- *
- * If set to 1, the DRM core will expose all planes (overlay, primary, and
- * cursor) to userspace.
- */
-#define DRM_CLIENT_CAP_UNIVERSAL_PLANES  2
-
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;
@@ -780,7 +763,7 @@ struct drm_prime_handle {
 
 /**
  * Device specific ioctls should only be in their respective headers
- * The device specific ioctl range is from 0x40 to 0x9f.
+ * The device specific ioctl range is from 0x40 to 0x99.
  * Generic IOCTLS restart at 0xA0.
  *
  * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and
diff --git a/original/uapi/drm/drm_mode.h b/original/uapi/drm/drm_mode.h
index a0db2d4..f104c26 100644
--- a/original/uapi/drm/drm_mode.h
+++ b/original/uapi/drm/drm_mode.h
@@ -88,11 +88,6 @@
 #define DRM_MODE_SCALE_CENTER		2 /* Centered, no scaling */
 #define DRM_MODE_SCALE_ASPECT		3 /* Full screen, preserve aspect */
 
-/* Picture aspect ratio options */
-#define DRM_MODE_PICTURE_ASPECT_NONE	0
-#define DRM_MODE_PICTURE_ASPECT_4_3	1
-#define DRM_MODE_PICTURE_ASPECT_16_9	2
-
 /* Dithering mode options */
 #define DRM_MODE_DITHERING_OFF	0
 #define DRM_MODE_DITHERING_ON	1
@@ -186,7 +181,6 @@ struct drm_mode_get_plane_res {
 #define DRM_MODE_ENCODER_TVDAC	4
 #define DRM_MODE_ENCODER_VIRTUAL 5
 #define DRM_MODE_ENCODER_DSI	6
-#define DRM_MODE_ENCODER_DPMST	7
 
 struct drm_mode_get_encoder {
 	__u32 encoder_id;
@@ -257,21 +251,6 @@ struct drm_mode_get_connector {
 #define DRM_MODE_PROP_BLOB	(1<<4)
 #define DRM_MODE_PROP_BITMASK	(1<<5) /* bitmask of enumerated types */
 
-/* non-extended types: legacy bitmask, one bit per type: */
-#define DRM_MODE_PROP_LEGACY_TYPE  ( \
-		DRM_MODE_PROP_RANGE | \
-		DRM_MODE_PROP_ENUM | \
-		DRM_MODE_PROP_BLOB | \
-		DRM_MODE_PROP_BITMASK)
-
-/* extended-types: rather than continue to consume a bit per type,
- * grab a chunk of the bits to use as integer type id.
- */
-#define DRM_MODE_PROP_EXTENDED_TYPE	0x0000ffc0
-#define DRM_MODE_PROP_TYPE(n)		((n) << 6)
-#define DRM_MODE_PROP_OBJECT		DRM_MODE_PROP_TYPE(1)
-#define DRM_MODE_PROP_SIGNED_RANGE	DRM_MODE_PROP_TYPE(2)
-
 struct drm_mode_property_enum {
 	__u64 value;
 	char name[DRM_PROP_NAME_LEN];
diff --git a/original/uapi/drm/exynos_drm.h b/original/uapi/drm/exynos_drm.h
index 5575ed1..d584412 100644
--- a/original/uapi/drm/exynos_drm.h
+++ b/original/uapi/drm/exynos_drm.h
@@ -33,6 +33,38 @@ struct drm_exynos_gem_create {
 };
 
 /**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *	- this value should be set by user.
+ */
+struct drm_exynos_gem_map_off {
+	unsigned int handle;
+	unsigned int pad;
+	uint64_t offset;
+};
+
+/**
+ * A structure for mapping buffer.
+ *
+ * @handle: a handle to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @size: memory size to be mapped.
+ * @mapped: having user virtual address mmaped.
+ *	- this variable would be filled by exynos gem module
+ *	of kernel side with user virtual address which is allocated
+ *	by do_mmap().
+ */
+struct drm_exynos_gem_mmap {
+	unsigned int handle;
+	unsigned int pad;
+	uint64_t size;
+	uint64_t mapped;
+};
+
+/**
  * A structure to gem information.
  *
  * @handle: a handle to gem object created.
@@ -284,6 +316,8 @@ struct drm_exynos_ipp_cmd_ctrl {
 };
 
 #define DRM_EXYNOS_GEM_CREATE		0x00
+#define DRM_EXYNOS_GEM_MAP_OFFSET	0x01
+#define DRM_EXYNOS_GEM_MMAP		0x02
 /* Reserved 0x03 ~ 0x05 for exynos specific gem ioctl */
 #define DRM_EXYNOS_GEM_GET		0x04
 #define DRM_EXYNOS_VIDI_CONNECTION	0x07
@@ -302,6 +336,12 @@ struct drm_exynos_ipp_cmd_ctrl {
 #define DRM_IOCTL_EXYNOS_GEM_CREATE		DRM_IOWR(DRM_COMMAND_BASE + \
 		DRM_EXYNOS_GEM_CREATE, struct drm_exynos_gem_create)
 
+#define DRM_IOCTL_EXYNOS_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_EXYNOS_GEM_MAP_OFFSET, struct drm_exynos_gem_map_off)
+
+#define DRM_IOCTL_EXYNOS_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_EXYNOS_GEM_MMAP, struct drm_exynos_gem_mmap)
+
 #define DRM_IOCTL_EXYNOS_GEM_GET	DRM_IOWR(DRM_COMMAND_BASE + \
 		DRM_EXYNOS_GEM_GET,	struct drm_exynos_gem_info)
 
diff --git a/original/uapi/drm/i915_drm.h b/original/uapi/drm/i915_drm.h
index ff57f07..126bfaa 100644
--- a/original/uapi/drm/i915_drm.h
+++ b/original/uapi/drm/i915_drm.h
@@ -223,7 +223,6 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_GEM_GET_CACHING	0x30
 #define DRM_I915_REG_READ		0x31
 #define DRM_I915_GET_RESET_STATS	0x32
-#define DRM_I915_GEM_USERPTR		0x33
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -274,7 +273,6 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
 #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
 #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
-#define DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, struct drm_i915_gem_userptr)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -339,7 +337,6 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_EXEC_NO_RELOC	 25
 #define I915_PARAM_HAS_EXEC_HANDLE_LUT   26
 #define I915_PARAM_HAS_WT     	 	 27
-#define I915_PARAM_CMD_PARSER_VERSION	 28
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -1052,18 +1049,4 @@ struct drm_i915_reset_stats {
 	__u32 pad;
 };
 
-struct drm_i915_gem_userptr {
-	__u64 user_ptr;
-	__u64 user_size;
-	__u32 flags;
-#define I915_USERPTR_READ_ONLY 0x1
-#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
-	/**
-	 * Returned handle for the object.
-	 *
-	 * Object handles are nonzero.
-	 */
-	__u32 handle;
-};
-
 #endif /* _UAPI_I915_DRM_H_ */
diff --git a/original/uapi/drm/msm_drm.h b/original/uapi/drm/msm_drm.h
index 0664c31..d3c6207 100644
--- a/original/uapi/drm/msm_drm.h
+++ b/original/uapi/drm/msm_drm.h
@@ -50,7 +50,6 @@ struct drm_msm_timespec {
 
 #define MSM_PARAM_GPU_ID     0x01
 #define MSM_PARAM_GMEM_SIZE  0x02
-#define MSM_PARAM_CHIP_ID    0x03
 
 struct drm_msm_param {
 	uint32_t pipe;           /* in, MSM_PIPE_x */
@@ -70,12 +69,6 @@ struct drm_msm_param {
 #define MSM_BO_WC            0x00020000
 #define MSM_BO_UNCACHED      0x00040000
 
-#define MSM_BO_FLAGS         (MSM_BO_SCANOUT | \
-                              MSM_BO_GPU_READONLY | \
-                              MSM_BO_CACHED | \
-                              MSM_BO_WC | \
-                              MSM_BO_UNCACHED)
-
 struct drm_msm_gem_new {
 	uint64_t size;           /* in */
 	uint32_t flags;          /* in, mask of MSM_BO_x */
@@ -92,8 +85,6 @@ struct drm_msm_gem_info {
 #define MSM_PREP_WRITE       0x02
 #define MSM_PREP_NOSYNC      0x04
 
-#define MSM_PREP_FLAGS       (MSM_PREP_READ | MSM_PREP_WRITE | MSM_PREP_NOSYNC)
-
 struct drm_msm_gem_cpu_prep {
 	uint32_t handle;         /* in */
 	uint32_t op;             /* in, mask of MSM_PREP_x */
@@ -161,9 +152,6 @@ struct drm_msm_gem_submit_cmd {
  */
 #define MSM_SUBMIT_BO_READ             0x0001
 #define MSM_SUBMIT_BO_WRITE            0x0002
-
-#define MSM_SUBMIT_BO_FLAGS            (MSM_SUBMIT_BO_READ | MSM_SUBMIT_BO_WRITE)
-
 struct drm_msm_gem_submit_bo {
 	uint32_t flags;          /* in, mask of MSM_SUBMIT_BO_x */
 	uint32_t handle;         /* in, GEM handle */
diff --git a/original/uapi/drm/nouveau_drm.h b/original/uapi/drm/nouveau_drm.h
index 0d7608d..2a5769f 100644
--- a/original/uapi/drm/nouveau_drm.h
+++ b/original/uapi/drm/nouveau_drm.h
@@ -25,16 +25,6 @@
 #ifndef __NOUVEAU_DRM_H__
 #define __NOUVEAU_DRM_H__
 
-#define DRM_NOUVEAU_EVENT_NVIF                                       0x80000000
-
-/* reserved object handles when using deprecated object APIs - these
- * are here so that libdrm can allow interoperability with the new
- * object APIs
- */
-#define NOUVEAU_ABI16_CLIENT   0xffffffff
-#define NOUVEAU_ABI16_DEVICE   0xdddddddd
-#define NOUVEAU_ABI16_CHAN(n) (0xcccc0000 | (n))
-
 #define NOUVEAU_GEM_DOMAIN_CPU       (1 << 0)
 #define NOUVEAU_GEM_DOMAIN_VRAM      (1 << 1)
 #define NOUVEAU_GEM_DOMAIN_GART      (1 << 2)
@@ -133,7 +123,6 @@ struct drm_nouveau_gem_cpu_fini {
 #define DRM_NOUVEAU_GROBJ_ALLOC        0x04 /* deprecated */
 #define DRM_NOUVEAU_NOTIFIEROBJ_ALLOC  0x05 /* deprecated */
 #define DRM_NOUVEAU_GPUOBJ_FREE        0x06 /* deprecated */
-#define DRM_NOUVEAU_NVIF               0x07
 #define DRM_NOUVEAU_GEM_NEW            0x40
 #define DRM_NOUVEAU_GEM_PUSHBUF        0x41
 #define DRM_NOUVEAU_GEM_CPU_PREP       0x42
diff --git a/original/uapi/drm/radeon_drm.h b/original/uapi/drm/radeon_drm.h
index 50d0fb4..d9ea3a7 100644
--- a/original/uapi/drm/radeon_drm.h
+++ b/original/uapi/drm/radeon_drm.h
@@ -510,8 +510,6 @@ typedef struct {
 #define DRM_RADEON_GEM_GET_TILING	0x29
 #define DRM_RADEON_GEM_BUSY		0x2a
 #define DRM_RADEON_GEM_VA		0x2b
-#define DRM_RADEON_GEM_OP		0x2c
-#define DRM_RADEON_GEM_USERPTR		0x2d
 
 #define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)
 #define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)
@@ -554,8 +552,6 @@ typedef struct {
 #define DRM_IOCTL_RADEON_GEM_GET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_GET_TILING, struct drm_radeon_gem_get_tiling)
 #define DRM_IOCTL_RADEON_GEM_BUSY	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_BUSY, struct drm_radeon_gem_busy)
 #define DRM_IOCTL_RADEON_GEM_VA		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_VA, struct drm_radeon_gem_va)
-#define DRM_IOCTL_RADEON_GEM_OP		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_OP, struct drm_radeon_gem_op)
-#define DRM_IOCTL_RADEON_GEM_USERPTR	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_USERPTR, struct drm_radeon_gem_userptr)
 
 typedef struct drm_radeon_init {
 	enum {
@@ -798,13 +794,7 @@ struct drm_radeon_gem_info {
 	uint64_t	vram_visible;
 };
 
-#define RADEON_GEM_NO_BACKING_STORE	(1 << 0)
-#define RADEON_GEM_GTT_UC		(1 << 1)
-#define RADEON_GEM_GTT_WC		(1 << 2)
-/* BO is expected to be accessed by the CPU */
-#define RADEON_GEM_CPU_ACCESS		(1 << 3)
-/* CPU access is not expected to work for this BO */
-#define RADEON_GEM_NO_CPU_ACCESS	(1 << 4)
+#define RADEON_GEM_NO_BACKING_STORE 1
 
 struct drm_radeon_gem_create {
 	uint64_t	size;
@@ -814,23 +804,6 @@ struct drm_radeon_gem_create {
 	uint32_t	flags;
 };
 
-/*
- * This is not a reliable API and you should expect it to fail for any
- * number of reasons and have fallback path that do not use userptr to
- * perform any operation.
- */
-#define RADEON_GEM_USERPTR_READONLY	(1 << 0)
-#define RADEON_GEM_USERPTR_ANONONLY	(1 << 1)
-#define RADEON_GEM_USERPTR_VALIDATE	(1 << 2)
-#define RADEON_GEM_USERPTR_REGISTER	(1 << 3)
-
-struct drm_radeon_gem_userptr {
-	uint64_t		addr;
-	uint64_t		size;
-	uint32_t		flags;
-	uint32_t		handle;
-};
-
 #define RADEON_TILING_MACRO				0x1
 #define RADEON_TILING_MICRO				0x2
 #define RADEON_TILING_SWAP_16BIT			0x4
@@ -911,16 +884,6 @@ struct drm_radeon_gem_pwrite {
 	uint64_t data_ptr;
 };
 
-/* Sets or returns a value associated with a buffer. */
-struct drm_radeon_gem_op {
-	uint32_t	handle; /* buffer */
-	uint32_t	op;     /* RADEON_GEM_OP_* */
-	uint64_t	value;  /* input or return value */
-};
-
-#define RADEON_GEM_OP_GET_INITIAL_DOMAIN	0
-#define RADEON_GEM_OP_SET_INITIAL_DOMAIN	1
-
 #define RADEON_VA_MAP			1
 #define RADEON_VA_UNMAP			2
 
@@ -956,7 +919,6 @@ struct drm_radeon_gem_va {
 #define RADEON_CS_RING_COMPUTE      1
 #define RADEON_CS_RING_DMA          2
 #define RADEON_CS_RING_UVD          3
-#define RADEON_CS_RING_VCE          4
 /* The third dword of RADEON_CHUNK_ID_FLAGS is a sint32 that sets the priority */
 /* 0 = normal, + = higher priority, - = lower priority */
 
@@ -967,7 +929,6 @@ struct drm_radeon_cs_chunk {
 };
 
 /* drm_radeon_cs_reloc.flags */
-#define RADEON_RELOC_PRIO_MASK		(0xf << 0)
 
 struct drm_radeon_cs_reloc {
 	uint32_t		handle;
@@ -1026,14 +987,7 @@ struct drm_radeon_cs {
 #define RADEON_INFO_SI_BACKEND_ENABLED_MASK	0x19
 /* max engine clock - needed for OpenCL */
 #define RADEON_INFO_MAX_SCLK		0x1a
-/* version of VCE firmware */
-#define RADEON_INFO_VCE_FW_VERSION	0x1b
-/* version of VCE feedback */
-#define RADEON_INFO_VCE_FB_VERSION	0x1c
-#define RADEON_INFO_NUM_BYTES_MOVED	0x1d
-#define RADEON_INFO_VRAM_USAGE		0x1e
-#define RADEON_INFO_GTT_USAGE		0x1f
-#define RADEON_INFO_ACTIVE_CU_COUNT	0x20
+
 
 struct drm_radeon_info {
 	uint32_t		request;
diff --git a/original/uapi/drm/tegra_drm.h b/original/uapi/drm/tegra_drm.h
index c15d781..c28de1a 100644
--- a/original/uapi/drm/tegra_drm.h
+++ b/original/uapi/drm/tegra_drm.h
@@ -1,23 +1,17 @@
 /*
  * Copyright (c) 2012-2013, NVIDIA CORPORATION.  All rights reserved.
  *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef _UAPI_TEGRA_DRM_H_
@@ -129,44 +123,6 @@ struct drm_tegra_submit {
 	__u32 reserved[5];	/* future expansion */
 };
 
-#define DRM_TEGRA_GEM_TILING_MODE_PITCH 0
-#define DRM_TEGRA_GEM_TILING_MODE_TILED 1
-#define DRM_TEGRA_GEM_TILING_MODE_BLOCK 2
-
-struct drm_tegra_gem_set_tiling {
-	/* input */
-	__u32 handle;
-	__u32 mode;
-	__u32 value;
-	__u32 pad;
-};
-
-struct drm_tegra_gem_get_tiling {
-	/* input */
-	__u32 handle;
-	/* output */
-	__u32 mode;
-	__u32 value;
-	__u32 pad;
-};
-
-#define DRM_TEGRA_GEM_BOTTOM_UP		(1 << 0)
-#define DRM_TEGRA_GEM_FLAGS		(DRM_TEGRA_GEM_BOTTOM_UP)
-
-struct drm_tegra_gem_set_flags {
-	/* input */
-	__u32 handle;
-	/* output */
-	__u32 flags;
-};
-
-struct drm_tegra_gem_get_flags {
-	/* input */
-	__u32 handle;
-	/* output */
-	__u32 flags;
-};
-
 #define DRM_TEGRA_GEM_CREATE		0x00
 #define DRM_TEGRA_GEM_MMAP		0x01
 #define DRM_TEGRA_SYNCPT_READ		0x02
@@ -177,10 +133,6 @@ struct drm_tegra_gem_get_flags {
 #define DRM_TEGRA_GET_SYNCPT		0x07
 #define DRM_TEGRA_SUBMIT		0x08
 #define DRM_TEGRA_GET_SYNCPT_BASE	0x09
-#define DRM_TEGRA_GEM_SET_TILING	0x0a
-#define DRM_TEGRA_GEM_GET_TILING	0x0b
-#define DRM_TEGRA_GEM_SET_FLAGS		0x0c
-#define DRM_TEGRA_GEM_GET_FLAGS		0x0d
 
 #define DRM_IOCTL_TEGRA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_CREATE, struct drm_tegra_gem_create)
 #define DRM_IOCTL_TEGRA_GEM_MMAP DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_MMAP, struct drm_tegra_gem_mmap)
@@ -192,9 +144,5 @@ struct drm_tegra_gem_get_flags {
 #define DRM_IOCTL_TEGRA_GET_SYNCPT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT, struct drm_tegra_get_syncpt)
 #define DRM_IOCTL_TEGRA_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SUBMIT, struct drm_tegra_submit)
 #define DRM_IOCTL_TEGRA_GET_SYNCPT_BASE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT_BASE, struct drm_tegra_get_syncpt_base)
-#define DRM_IOCTL_TEGRA_GEM_SET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_TILING, struct drm_tegra_gem_set_tiling)
-#define DRM_IOCTL_TEGRA_GEM_GET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_TILING, struct drm_tegra_gem_get_tiling)
-#define DRM_IOCTL_TEGRA_GEM_SET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_FLAGS, struct drm_tegra_gem_set_flags)
-#define DRM_IOCTL_TEGRA_GEM_GET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_FLAGS, struct drm_tegra_gem_get_flags)
 
 #endif
diff --git a/original/uapi/drm/vmwgfx_drm.h b/original/uapi/drm/vmwgfx_drm.h
index c472bed..33b7395 100644
--- a/original/uapi/drm/vmwgfx_drm.h
+++ b/original/uapi/drm/vmwgfx_drm.h
@@ -90,15 +90,6 @@
 #define DRM_VMW_PARAM_MAX_MOB_SIZE     10
 
 /**
- * enum drm_vmw_handle_type - handle type for ref ioctls
- *
- */
-enum drm_vmw_handle_type {
-	DRM_VMW_HANDLE_LEGACY = 0,
-	DRM_VMW_HANDLE_PRIME = 1
-};
-
-/**
  * struct drm_vmw_getparam_arg
  *
  * @value: Returned value. //Out
@@ -186,7 +177,6 @@ struct drm_vmw_surface_create_req {
  * struct drm_wmv_surface_arg
  *
  * @sid: Surface id of created surface or surface to destroy or reference.
- * @handle_type: Handle type for DRM_VMW_REF_SURFACE Ioctl.
  *
  * Output data from the DRM_VMW_CREATE_SURFACE Ioctl.
  * Input argument to the DRM_VMW_UNREF_SURFACE Ioctl.
@@ -195,7 +185,7 @@ struct drm_vmw_surface_create_req {
 
 struct drm_vmw_surface_arg {
 	int32_t sid;
-	enum drm_vmw_handle_type handle_type;
+	uint32_t pad64;
 };
 
 /**
diff --git a/original/uapi/linux/audit.h b/original/uapi/linux/audit.h
index 584bb01..2d48fe1 100644
--- a/original/uapi/linux/audit.h
+++ b/original/uapi/linux/audit.h
@@ -70,6 +70,7 @@
 #define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
 #define AUDIT_SET_FEATURE	1018	/* Turn an audit feature on or off */
 #define AUDIT_GET_FEATURE	1019	/* Get which features are enabled */
+#define AUDIT_FEATURE_CHANGE	1020	/* audit log listing feature changes */
 
 #define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
 #define AUDIT_USER_AVC		1107	/* We filter this differently */
@@ -108,8 +109,6 @@
 #define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
 #define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
 #define AUDIT_SECCOMP		1326	/* Secure Computing event */
-#define AUDIT_PROCTITLE		1327	/* Proctitle emit event */
-#define AUDIT_FEATURE_CHANGE	1328	/* audit log listing feature changes */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -331,18 +330,9 @@ enum {
 #define AUDIT_FAIL_PRINTK	1
 #define AUDIT_FAIL_PANIC	2
 
-/*
- * These bits disambiguate different calling conventions that share an
- * ELF machine type, bitness, and endianness
- */
-#define __AUDIT_ARCH_CONVENTION_MASK 0x30000000
-#define __AUDIT_ARCH_CONVENTION_MIPS64_N32 0x20000000
-
 /* distinguish syscall tables */
 #define __AUDIT_ARCH_64BIT 0x80000000
 #define __AUDIT_ARCH_LE	   0x40000000
-
-#define AUDIT_ARCH_AARCH64	(EM_AARCH64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_ARMEB	(EM_ARM)
@@ -352,22 +342,15 @@ enum {
 #define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_M32R		(EM_M32R)
 #define AUDIT_ARCH_M68K		(EM_68K)
-#define AUDIT_ARCH_MICROBLAZE	(EM_MICROBLAZE)
 #define AUDIT_ARCH_MIPS		(EM_MIPS)
 #define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_MIPS64N32	(EM_MIPS|__AUDIT_ARCH_64BIT|\
-				 __AUDIT_ARCH_CONVENTION_MIPS64_N32)
 #define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_MIPSEL64N32	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE|\
-				 __AUDIT_ARCH_CONVENTION_MIPS64_N32)
 #define AUDIT_ARCH_OPENRISC	(EM_OPENRISC)
 #define AUDIT_ARCH_PARISC	(EM_PARISC)
 #define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_PPC		(EM_PPC)
-/* do not define AUDIT_ARCH_PPCLE since it is not supported by audit */
 #define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_PPC64LE	(EM_PPC64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_S390		(EM_S390)
 #define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_SH		(EM_SH)
@@ -389,14 +372,6 @@ enum {
  */
 #define AUDIT_MESSAGE_TEXT_MAX	8560
 
-/* Multicast Netlink socket groups (default up to 32) */
-enum audit_nlgrps {
-	AUDIT_NLGRP_NONE,	/* Group 0 not used */
-	AUDIT_NLGRP_READLOG,	/* "best effort" read only socket */
-	__AUDIT_NLGRP_MAX
-};
-#define AUDIT_NLGRP_MAX                (__AUDIT_NLGRP_MAX - 1)
-
 struct audit_status {
 	__u32		mask;		/* Bit mask for valid entries */
 	__u32		enabled;	/* 1 = enabled, 0 = disabled */
@@ -448,4 +423,17 @@ struct audit_rule_data {
 	char		buf[0];	/* string fields buffer */
 };
 
+/* audit_rule is supported to maintain backward compatibility with
+ * userspace.  It supports integer fields only and corresponds to
+ * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
+ */
+struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
+	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	__u32		field_count;
+	__u32		mask[AUDIT_BITMASK_SIZE];
+	__u32		fields[AUDIT_MAX_FIELDS];
+	__u32		values[AUDIT_MAX_FIELDS];
+};
+
 #endif /* _UAPI_LINUX_AUDIT_H_ */
diff --git a/original/uapi/linux/binder.h b/original/uapi/linux/binder.h
index dba4cef..04c735d 100644
--- a/original/uapi/linux/binder.h
+++ b/original/uapi/linux/binder.h
@@ -97,11 +97,11 @@ struct binder_version {
 #endif
 
 #define BINDER_WRITE_READ		_IOWR('b', 1, struct binder_write_read)
-#define BINDER_SET_IDLE_TIMEOUT		_IOW('b', 3, __s64)
-#define BINDER_SET_MAX_THREADS		_IOW('b', 5, __u32)
-#define BINDER_SET_IDLE_PRIORITY	_IOW('b', 6, __s32)
-#define BINDER_SET_CONTEXT_MGR		_IOW('b', 7, __s32)
-#define BINDER_THREAD_EXIT		_IOW('b', 8, __s32)
+#define	BINDER_SET_IDLE_TIMEOUT		_IOW('b', 3, __s64)
+#define	BINDER_SET_MAX_THREADS		_IOW('b', 5, __u32)
+#define	BINDER_SET_IDLE_PRIORITY	_IOW('b', 6, __s32)
+#define	BINDER_SET_CONTEXT_MGR		_IOW('b', 7, __s32)
+#define	BINDER_THREAD_EXIT		_IOW('b', 8, __s32)
 #define BINDER_VERSION			_IOWR('b', 9, struct binder_version)
 
 /*
@@ -131,10 +131,8 @@ struct binder_transaction_data {
 	 * identifying the target and contents of the transaction.
 	 */
 	union {
-		/* target descriptor of command transaction */
-		__u32	handle;
-		/* target descriptor of return transaction */
-		binder_uintptr_t ptr;
+		__u32	handle;	/* target descriptor of command transaction */
+		binder_uintptr_t ptr;	/* target descriptor of return transaction */
 	} target;
 	binder_uintptr_t	cookie;	/* target object cookie */
 	__u32		code;		/* transaction command */
@@ -169,7 +167,7 @@ struct binder_ptr_cookie {
 struct binder_handle_cookie {
 	__u32 handle;
 	binder_uintptr_t cookie;
-} __packed;
+} __attribute__((packed));
 
 struct binder_pri_desc {
 	__s32 priority;
@@ -327,15 +325,13 @@ enum binder_driver_command_protocol {
 	 * of looping threads it has available.
 	 */
 
-	BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14,
-						struct binder_handle_cookie),
+	BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14, struct binder_handle_cookie),
 	/*
 	 * int: handle
 	 * void *: cookie
 	 */
 
-	BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15,
-						struct binder_handle_cookie),
+	BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15, struct binder_handle_cookie),
 	/*
 	 * int: handle
 	 * void *: cookie
diff --git a/original/uapi/linux/bsg.h b/original/uapi/linux/bsg.h
index 02986cf..7a12e1c 100644
--- a/original/uapi/linux/bsg.h
+++ b/original/uapi/linux/bsg.h
@@ -10,13 +10,12 @@
 #define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2
 
 /*
- * For flag constants below:
- * sg.h sg_io_hdr also has bits defined for it's flags member. These
- * two flag values (0x10 and 0x20) have the same meaning in sg.h . For
- * bsg the BSG_FLAG_Q_AT_HEAD flag is ignored since it is the deafult.
+ * For flags member below
+ * sg.h sg_io_hdr also has bits defined for it's flags member. However
+ * none of these bits are implemented/used by bsg. The bits below are
+ * allocated to not conflict with sg.h ones anyway.
  */
-#define BSG_FLAG_Q_AT_TAIL 0x10 /* default is Q_AT_HEAD */
-#define BSG_FLAG_Q_AT_HEAD 0x20
+#define BSG_FLAG_Q_AT_TAIL 0x10 /* default, == 0 at this bit, is Q_AT_HEAD */
 
 struct sg_io_v4 {
 	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
diff --git a/original/uapi/linux/btrfs.h b/original/uapi/linux/btrfs.h
index 2f47824..b4d6909 100644
--- a/original/uapi/linux/btrfs.h
+++ b/original/uapi/linux/btrfs.h
@@ -38,7 +38,6 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16
-#define BTRFS_UUID_UNPARSED_SIZE	37
 
 #define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
 
@@ -182,11 +181,7 @@ struct btrfs_ioctl_fs_info_args {
 	__u64 max_id;				/* out */
 	__u64 num_devices;			/* out */
 	__u8 fsid[BTRFS_FSID_SIZE];		/* out */
-	__u32 nodesize;				/* out */
-	__u32 sectorsize;			/* out */
-	__u32 clone_alignment;			/* out */
-	__u32 reserved32;
-	__u64 reserved[122];			/* pad to 1k */
+	__u64 reserved[124];			/* pad to 1k */
 };
 
 struct btrfs_ioctl_feature_flags {
@@ -216,8 +211,7 @@ struct btrfs_balance_args {
 
 	__u64 flags;
 
-	__u64 limit;		/* limit number of processed chunks */
-	__u64 unused[7];
+	__u64 unused[8];
 } __attribute__ ((__packed__));
 
 /* report balance progress to userspace */
@@ -307,14 +301,6 @@ struct btrfs_ioctl_search_args {
 	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];
 };
 
-struct btrfs_ioctl_search_args_v2 {
-	struct btrfs_ioctl_search_key key; /* in/out - search parameters */
-	__u64 buf_size;		   /* in - size of buffer
-					    * out - on EOVERFLOW: needed size
-					    *       to store item */
-	__u64 buf[0];                       /* out - found items */
-};
-
 struct btrfs_ioctl_clone_range_args {
   __s64 src_fd;
   __u64 src_offset, src_length;
@@ -567,8 +553,6 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				struct btrfs_ioctl_defrag_range_args)
 #define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \
 				   struct btrfs_ioctl_search_args)
-#define BTRFS_IOC_TREE_SEARCH_V2 _IOWR(BTRFS_IOCTL_MAGIC, 17, \
-					   struct btrfs_ioctl_search_args_v2)
 #define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
 				   struct btrfs_ioctl_ino_lookup_args)
 #define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
diff --git a/original/uapi/linux/can.h b/original/uapi/linux/can.h
index 41892f7..e52958d 100644
--- a/original/uapi/linux/can.h
+++ b/original/uapi/linux/can.h
@@ -8,42 +8,10 @@
  * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
  * All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of Volkswagen nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * Alternatively, provided that this notice is retained in full, this
- * software may be distributed under the terms of the GNU General
- * Public License ("GPL") version 2, in which case the provisions of the
- * GPL apply INSTEAD OF those given above.
- *
- * The provided data structures and external interfaces from this code
- * are not restricted to be used by modules with a GPL compatible license.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
- * DAMAGE.
  */
 
-#ifndef _UAPI_CAN_H
-#define _UAPI_CAN_H
+#ifndef CAN_H
+#define CAN_H
 
 #include <linux/types.h>
 #include <linux/socket.h>
@@ -191,4 +159,4 @@ struct can_filter {
 
 #define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
 
-#endif /* !_UAPI_CAN_H */
+#endif /* CAN_H */
diff --git a/original/uapi/linux/can/bcm.h b/original/uapi/linux/can/bcm.h
index 89ddb9d..382251a 100644
--- a/original/uapi/linux/can/bcm.h
+++ b/original/uapi/linux/can/bcm.h
@@ -41,8 +41,8 @@
  * DAMAGE.
  */
 
-#ifndef _UAPI_CAN_BCM_H
-#define _UAPI_CAN_BCM_H
+#ifndef CAN_BCM_H
+#define CAN_BCM_H
 
 #include <linux/types.h>
 #include <linux/can.h>
@@ -95,4 +95,4 @@ enum {
 #define TX_RESET_MULTI_IDX  0x0200
 #define RX_RTR_FRAME        0x0400
 
-#endif /* !_UAPI_CAN_BCM_H */
+#endif /* CAN_BCM_H */
diff --git a/original/uapi/linux/can/error.h b/original/uapi/linux/can/error.h
index c247446..b632045 100644
--- a/original/uapi/linux/can/error.h
+++ b/original/uapi/linux/can/error.h
@@ -41,8 +41,8 @@
  * DAMAGE.
  */
 
-#ifndef _UAPI_CAN_ERROR_H
-#define _UAPI_CAN_ERROR_H
+#ifndef CAN_ERROR_H
+#define CAN_ERROR_H
 
 #define CAN_ERR_DLC 8 /* dlc for error message frames */
 
@@ -120,4 +120,4 @@
 
 /* controller specific additional information / data[5..7] */
 
-#endif /* _UAPI_CAN_ERROR_H */
+#endif /* CAN_ERROR_H */
diff --git a/original/uapi/linux/can/gw.h b/original/uapi/linux/can/gw.h
index 3e6184c..844c896 100644
--- a/original/uapi/linux/can/gw.h
+++ b/original/uapi/linux/can/gw.h
@@ -41,8 +41,8 @@
  * DAMAGE.
  */
 
-#ifndef _UAPI_CAN_GW_H
-#define _UAPI_CAN_GW_H
+#ifndef CAN_GW_H
+#define CAN_GW_H
 
 #include <linux/types.h>
 #include <linux/can.h>
@@ -200,4 +200,4 @@ enum {
  *         Beware of sending unpacked or aligned structs!
  */
 
-#endif /* !_UAPI_CAN_GW_H */
+#endif
diff --git a/original/uapi/linux/can/netlink.h b/original/uapi/linux/can/netlink.h
index 94ffe0c..df944ed 100644
--- a/original/uapi/linux/can/netlink.h
+++ b/original/uapi/linux/can/netlink.h
@@ -15,8 +15,8 @@
  * GNU General Public License for more details.
  */
 
-#ifndef _UAPI_CAN_NETLINK_H
-#define _UAPI_CAN_NETLINK_H
+#ifndef CAN_NETLINK_H
+#define CAN_NETLINK_H
 
 #include <linux/types.h>
 
@@ -92,13 +92,10 @@ struct can_ctrlmode {
 };
 
 #define CAN_CTRLMODE_LOOPBACK		0x01	/* Loopback mode */
-#define CAN_CTRLMODE_LISTENONLY		0x02	/* Listen-only mode */
+#define CAN_CTRLMODE_LISTENONLY		0x02 	/* Listen-only mode */
 #define CAN_CTRLMODE_3_SAMPLES		0x04	/* Triple sampling mode */
 #define CAN_CTRLMODE_ONE_SHOT		0x08	/* One-Shot mode */
 #define CAN_CTRLMODE_BERR_REPORTING	0x10	/* Bus-error reporting */
-#define CAN_CTRLMODE_FD			0x20	/* CAN FD mode */
-#define CAN_CTRLMODE_PRESUME_ACK	0x40	/* Ignore missing CAN ACKs */
-#define CAN_CTRLMODE_FD_NON_ISO		0x80	/* CAN FD in non-ISO mode */
 
 /*
  * CAN device statistics
@@ -125,11 +122,9 @@ enum {
 	IFLA_CAN_RESTART_MS,
 	IFLA_CAN_RESTART,
 	IFLA_CAN_BERR_COUNTER,
-	IFLA_CAN_DATA_BITTIMING,
-	IFLA_CAN_DATA_BITTIMING_CONST,
 	__IFLA_CAN_MAX
 };
 
 #define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
 
-#endif /* !_UAPI_CAN_NETLINK_H */
+#endif /* CAN_NETLINK_H */
diff --git a/original/uapi/linux/can/raw.h b/original/uapi/linux/can/raw.h
index 78ec76f..c7d8c33 100644
--- a/original/uapi/linux/can/raw.h
+++ b/original/uapi/linux/can/raw.h
@@ -42,8 +42,8 @@
  * DAMAGE.
  */
 
-#ifndef _UAPI_CAN_RAW_H
-#define _UAPI_CAN_RAW_H
+#ifndef CAN_RAW_H
+#define CAN_RAW_H
 
 #include <linux/can.h>
 
@@ -59,4 +59,4 @@ enum {
 	CAN_RAW_FD_FRAMES,	/* allow CAN FD frames (default:off) */
 };
 
-#endif /* !_UAPI_CAN_RAW_H */
+#endif
diff --git a/original/uapi/linux/capability.h b/original/uapi/linux/capability.h
index 12c37a1..ba478fa 100644
--- a/original/uapi/linux/capability.h
+++ b/original/uapi/linux/capability.h
@@ -308,12 +308,8 @@ struct vfs_cap_data {
 
 #define CAP_LEASE            28
 
-/* Allow writing the audit log via unicast netlink socket */
-
 #define CAP_AUDIT_WRITE      29
 
-/* Allow configuration of audit via unicast netlink socket */
-
 #define CAP_AUDIT_CONTROL    30
 
 #define CAP_SETFCAP	     31
@@ -347,12 +343,7 @@ struct vfs_cap_data {
 
 #define CAP_BLOCK_SUSPEND    36
 
-/* Allow reading the audit log via multicast netlink socket */
-
-#define CAP_AUDIT_READ		37
-
-
-#define CAP_LAST_CAP         CAP_AUDIT_READ
+#define CAP_LAST_CAP         CAP_BLOCK_SUSPEND
 
 #define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
 
diff --git a/original/uapi/linux/capi.h b/original/uapi/linux/capi.h
index 7b145fd..65100d6 100644
--- a/original/uapi/linux/capi.h
+++ b/original/uapi/linux/capi.h
@@ -102,7 +102,7 @@ typedef struct capi_manufacturer_cmd {
 
 /*
  * member contr is input for
- * CAPI_GET_MANUFACTURER, CAPI_GET_VERSION, CAPI_GET_SERIAL
+ * CAPI_GET_MANUFACTURER, CAPI_VERSION, CAPI_GET_SERIAL
  * and CAPI_GET_PROFILE
  */
 typedef union capi_ioctl_struct {
diff --git a/original/uapi/linux/dcbnl.h b/original/uapi/linux/dcbnl.h
index e711f20..6bb4338 100644
--- a/original/uapi/linux/dcbnl.h
+++ b/original/uapi/linux/dcbnl.h
@@ -148,8 +148,7 @@ struct cee_pfc {
  *
  * @selector: protocol identifier type
  * @protocol: protocol of type indicated
- * @priority: 3-bit unsigned integer indicating priority for IEEE
- *            8-bit 802.1p user priority bitmap for CEE
+ * @priority: 3-bit unsigned integer indicating priority
  *
  * ----
  *  Selector field values
diff --git a/original/uapi/linux/dm-ioctl.h b/original/uapi/linux/dm-ioctl.h
index 3315ab2..c8a4302 100644
--- a/original/uapi/linux/dm-ioctl.h
+++ b/original/uapi/linux/dm-ioctl.h
@@ -267,9 +267,9 @@ enum {
 #define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)
 
 #define DM_VERSION_MAJOR	4
-#define DM_VERSION_MINOR	28
+#define DM_VERSION_MINOR	27
 #define DM_VERSION_PATCHLEVEL	0
-#define DM_VERSION_EXTRA	"-ioctl (2014-09-17)"
+#define DM_VERSION_EXTRA	"-ioctl (2013-10-30)"
 
 /* Status bits */
 #define DM_READONLY_FLAG	(1 << 0) /* In/Out */
diff --git a/original/uapi/linux/elf-em.h b/original/uapi/linux/elf-em.h
index aa90bc9..01529bd 100644
--- a/original/uapi/linux/elf-em.h
+++ b/original/uapi/linux/elf-em.h
@@ -32,7 +32,6 @@
 #define EM_V850		87	/* NEC v850 */
 #define EM_M32R		88	/* Renesas M32R */
 #define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
-#define EM_OPENRISC     92     /* OpenRISC 32-bit embedded processor */
 #define EM_BLACKFIN     106     /* ADI Blackfin Processor */
 #define EM_TI_C6000	140	/* TI C6X DSPs */
 #define EM_AARCH64	183	/* ARM 64 bit */
diff --git a/original/uapi/linux/elf.h b/original/uapi/linux/elf.h
index ea9bf25..ef6103b 100644
--- a/original/uapi/linux/elf.h
+++ b/original/uapi/linux/elf.h
@@ -391,8 +391,6 @@ typedef struct elf64_shdr {
 #define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
 #define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
 #define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
-#define NT_S390_VXRS_LOW	0x309	/* s390 vector registers 0-15 upper half */
-#define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
 #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
diff --git a/original/uapi/linux/errqueue.h b/original/uapi/linux/errqueue.h
index 07bdce1..aacd4fb 100644
--- a/original/uapi/linux/errqueue.h
+++ b/original/uapi/linux/errqueue.h
@@ -22,25 +22,5 @@ struct sock_extended_err {
 
 #define SO_EE_OFFENDER(ee)	((struct sockaddr*)((ee)+1))
 
-/**
- *	struct scm_timestamping - timestamps exposed through cmsg
- *
- *	The timestamping interfaces SO_TIMESTAMPING, MSG_TSTAMP_*
- *	communicate network timestamps by passing this struct in a cmsg with
- *	recvmsg(). See Documentation/networking/timestamping.txt for details.
- */
-struct scm_timestamping {
-	struct timespec ts[3];
-};
-
-/* The type of scm_timestamping, passed in sock_extended_err ee_info.
- * This defines the type of ts[0]. For SCM_TSTAMP_SND only, if ts[0]
- * is zero, then this is a hardware timestamp and recorded in ts[2].
- */
-enum {
-	SCM_TSTAMP_SND,		/* driver passed skb to NIC, or HW */
-	SCM_TSTAMP_SCHED,	/* data entered the packet scheduler */
-	SCM_TSTAMP_ACK,		/* data acknowledged by peer */
-};
 
 #endif /* _UAPI_LINUX_ERRQUEUE_H */
diff --git a/original/uapi/linux/ethtool.h b/original/uapi/linux/ethtool.h
index 99b4305..7a364f2 100644
--- a/original/uapi/linux/ethtool.h
+++ b/original/uapi/linux/ethtool.h
@@ -212,7 +212,6 @@ struct ethtool_value {
 enum tunable_id {
 	ETHTOOL_ID_UNSPEC,
 	ETHTOOL_RX_COPYBREAK,
-	ETHTOOL_TX_COPYBREAK,
 };
 
 enum tunable_type_id {
diff --git a/original/uapi/linux/falloc.h b/original/uapi/linux/falloc.h
index d1197ae..990c4cc 100644
--- a/original/uapi/linux/falloc.h
+++ b/original/uapi/linux/falloc.h
@@ -5,40 +5,5 @@
 #define FALLOC_FL_PUNCH_HOLE	0x02 /* de-allocates range */
 #define FALLOC_FL_NO_HIDE_STALE	0x04 /* reserved codepoint */
 
-/*
- * FALLOC_FL_COLLAPSE_RANGE is used to remove a range of a file
- * without leaving a hole in the file. The contents of the file beyond
- * the range being removed is appended to the start offset of the range
- * being removed (i.e. the hole that was punched is "collapsed"),
- * resulting in a file layout that looks like the range that was
- * removed never existed. As such collapsing a range of a file changes
- * the size of the file, reducing it by the same length of the range
- * that has been removed by the operation.
- *
- * Different filesystems may implement different limitations on the
- * granularity of the operation. Most will limit operations to
- * filesystem block size boundaries, but this boundary may be larger or
- * smaller depending on the filesystem and/or the configuration of the
- * filesystem or file.
- *
- * Attempting to collapse a range that crosses the end of the file is
- * considered an illegal operation - just use ftruncate(2) if you need
- * to collapse a range that crosses EOF.
- */
-#define FALLOC_FL_COLLAPSE_RANGE	0x08
-
-/*
- * FALLOC_FL_ZERO_RANGE is used to convert a range of file to zeros preferably
- * without issuing data IO. Blocks should be preallocated for the regions that
- * span holes in the file, and the entire range is preferable converted to
- * unwritten extents - even though file system may choose to zero out the
- * extent or do whatever which will result in reading zeros from the range
- * while the range remains allocated for the file.
- *
- * This can be also used to preallocate blocks past EOF in the same way as
- * with fallocate. Flag FALLOC_FL_KEEP_SIZE should cause the inode
- * size to remain the same.
- */
-#define FALLOC_FL_ZERO_RANGE		0x10
 
 #endif /* _UAPI_FALLOC_H_ */
diff --git a/original/uapi/linux/fcntl.h b/original/uapi/linux/fcntl.h
index beed138..074b886 100644
--- a/original/uapi/linux/fcntl.h
+++ b/original/uapi/linux/fcntl.h
@@ -28,21 +28,6 @@
 #define F_GETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 8)
 
 /*
- * Set/Get seals
- */
-#define F_ADD_SEALS	(F_LINUX_SPECIFIC_BASE + 9)
-#define F_GET_SEALS	(F_LINUX_SPECIFIC_BASE + 10)
-
-/*
- * Types of seals
- */
-#define F_SEAL_SEAL	0x0001	/* prevent further seals from being set */
-#define F_SEAL_SHRINK	0x0002	/* prevent file from shrinking */
-#define F_SEAL_GROW	0x0004	/* prevent file from growing */
-#define F_SEAL_WRITE	0x0008	/* prevent writes */
-/* (1U << 31) is reserved for signed error codes */
-
-/*
  * Types of directory notifications that may be requested.
  */
 #define DN_ACCESS	0x00000001	/* File accessed */
diff --git a/original/uapi/linux/fib_rules.h b/original/uapi/linux/fib_rules.h
index 2b82d7e..743e300 100644
--- a/original/uapi/linux/fib_rules.h
+++ b/original/uapi/linux/fib_rules.h
@@ -49,6 +49,8 @@ enum {
 	FRA_TABLE,	/* Extended table id */
 	FRA_FWMASK,	/* mask for netfilter mark */
 	FRA_OIFNAME,
+	FRA_UID_START,	/* UID range */
+	FRA_UID_END,
 	__FRA_MAX
 };
 
diff --git a/original/uapi/linux/filter.h b/original/uapi/linux/filter.h
index 47785d5..8eb9cca 100644
--- a/original/uapi/linux/filter.h
+++ b/original/uapi/linux/filter.h
@@ -7,7 +7,7 @@
 
 #include <linux/compiler.h>
 #include <linux/types.h>
-#include <linux/bpf_common.h>
+
 
 /*
  * Current version of the filter code architecture.
@@ -32,6 +32,56 @@ struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
 	struct sock_filter __user *filter;
 };
 
+/*
+ * Instruction classes
+ */
+
+#define BPF_CLASS(code) ((code) & 0x07)
+#define         BPF_LD          0x00
+#define         BPF_LDX         0x01
+#define         BPF_ST          0x02
+#define         BPF_STX         0x03
+#define         BPF_ALU         0x04
+#define         BPF_JMP         0x05
+#define         BPF_RET         0x06
+#define         BPF_MISC        0x07
+
+/* ld/ldx fields */
+#define BPF_SIZE(code)  ((code) & 0x18)
+#define         BPF_W           0x00
+#define         BPF_H           0x08
+#define         BPF_B           0x10
+#define BPF_MODE(code)  ((code) & 0xe0)
+#define         BPF_IMM         0x00
+#define         BPF_ABS         0x20
+#define         BPF_IND         0x40
+#define         BPF_MEM         0x60
+#define         BPF_LEN         0x80
+#define         BPF_MSH         0xa0
+
+/* alu/jmp fields */
+#define BPF_OP(code)    ((code) & 0xf0)
+#define         BPF_ADD         0x00
+#define         BPF_SUB         0x10
+#define         BPF_MUL         0x20
+#define         BPF_DIV         0x30
+#define         BPF_OR          0x40
+#define         BPF_AND         0x50
+#define         BPF_LSH         0x60
+#define         BPF_RSH         0x70
+#define         BPF_NEG         0x80
+#define		BPF_MOD		0x90
+#define		BPF_XOR		0xa0
+
+#define         BPF_JA          0x00
+#define         BPF_JEQ         0x10
+#define         BPF_JGT         0x20
+#define         BPF_JGE         0x30
+#define         BPF_JSET        0x40
+#define BPF_SRC(code)   ((code) & 0x08)
+#define         BPF_K           0x00
+#define         BPF_X           0x08
+
 /* ret - BPF_K and BPF_X also apply */
 #define BPF_RVAL(code)  ((code) & 0x18)
 #define         BPF_A           0x10
@@ -41,6 +91,10 @@ struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
 #define         BPF_TAX         0x00
 #define         BPF_TXA         0x80
 
+#ifndef BPF_MAXINSNS
+#define BPF_MAXINSNS 4096
+#endif
+
 /*
  * Macros for filter block array initializers.
  */
@@ -76,8 +130,7 @@ struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
 #define SKF_AD_VLAN_TAG	44
 #define SKF_AD_VLAN_TAG_PRESENT 48
 #define SKF_AD_PAY_OFFSET	52
-#define SKF_AD_RANDOM	56
-#define SKF_AD_MAX	60
+#define SKF_AD_MAX	56
 #define SKF_NET_OFF   (-0x100000)
 #define SKF_LL_OFF    (-0x200000)
 
diff --git a/original/uapi/linux/fs.h b/original/uapi/linux/fs.h
index 3735fa0..6c28b61 100644
--- a/original/uapi/linux/fs.h
+++ b/original/uapi/linux/fs.h
@@ -35,10 +35,6 @@
 #define SEEK_HOLE	4	/* seek to the next hole */
 #define SEEK_MAX	SEEK_HOLE
 
-#define RENAME_NOREPLACE	(1 << 0)	/* Don't overwrite target */
-#define RENAME_EXCHANGE		(1 << 1)	/* Exchange source and dest */
-#define RENAME_WHITEOUT		(1 << 2)	/* Whiteout source */
-
 struct fstrim_range {
 	__u64 start;
 	__u64 len;
diff --git a/original/uapi/linux/fuse.h b/original/uapi/linux/fuse.h
index 25084a0..60bb2f9 100644
--- a/original/uapi/linux/fuse.h
+++ b/original/uapi/linux/fuse.h
@@ -93,15 +93,6 @@
  *
  * 7.22
  *  - add FUSE_ASYNC_DIO
- *
- * 7.23
- *  - add FUSE_WRITEBACK_CACHE
- *  - add time_gran to fuse_init_out
- *  - add reserved space to fuse_init_out
- *  - add FATTR_CTIME
- *  - add ctime and ctimensec to fuse_setattr_in
- *  - add FUSE_RENAME2 request
- *  - add FUSE_NO_OPEN_SUPPORT flag
  */
 
 #ifndef _LINUX_FUSE_H
@@ -137,7 +128,7 @@
 #define FUSE_KERNEL_VERSION 7
 
 /** Minor version number of this interface */
-#define FUSE_KERNEL_MINOR_VERSION 23
+#define FUSE_KERNEL_MINOR_VERSION 22
 
 /** The node ID of the root inode */
 #define FUSE_ROOT_ID 1
@@ -197,7 +188,6 @@ struct fuse_file_lock {
 #define FATTR_ATIME_NOW	(1 << 7)
 #define FATTR_MTIME_NOW	(1 << 8)
 #define FATTR_LOCKOWNER	(1 << 9)
-#define FATTR_CTIME	(1 << 10)
 
 /**
  * Flags returned by the OPEN request
@@ -229,8 +219,6 @@ struct fuse_file_lock {
  * FUSE_DO_READDIRPLUS: do READDIRPLUS (READDIR+LOOKUP in one)
  * FUSE_READDIRPLUS_AUTO: adaptive readdirplus
  * FUSE_ASYNC_DIO: asynchronous direct I/O submission
- * FUSE_WRITEBACK_CACHE: use writeback cache for buffered writes
- * FUSE_NO_OPEN_SUPPORT: kernel supports zero-message opens
  */
 #define FUSE_ASYNC_READ		(1 << 0)
 #define FUSE_POSIX_LOCKS	(1 << 1)
@@ -248,8 +236,6 @@ struct fuse_file_lock {
 #define FUSE_DO_READDIRPLUS	(1 << 13)
 #define FUSE_READDIRPLUS_AUTO	(1 << 14)
 #define FUSE_ASYNC_DIO		(1 << 15)
-#define FUSE_WRITEBACK_CACHE	(1 << 16)
-#define FUSE_NO_OPEN_SUPPORT	(1 << 17)
 
 /**
  * CUSE INIT request/reply flags
@@ -357,7 +343,6 @@ enum fuse_opcode {
 	FUSE_BATCH_FORGET  = 42,
 	FUSE_FALLOCATE     = 43,
 	FUSE_READDIRPLUS   = 44,
-	FUSE_RENAME2       = 45,
 
 	/* CUSE specific operations */
 	CUSE_INIT          = 4096,
@@ -436,12 +421,6 @@ struct fuse_rename_in {
 	uint64_t	newdir;
 };
 
-struct fuse_rename2_in {
-	uint64_t	newdir;
-	uint32_t	flags;
-	uint32_t	padding;
-};
-
 struct fuse_link_in {
 	uint64_t	oldnodeid;
 };
@@ -454,10 +433,10 @@ struct fuse_setattr_in {
 	uint64_t	lock_owner;
 	uint64_t	atime;
 	uint64_t	mtime;
-	uint64_t	ctime;
+	uint64_t	unused2;
 	uint32_t	atimensec;
 	uint32_t	mtimensec;
-	uint32_t	ctimensec;
+	uint32_t	unused3;
 	uint32_t	mode;
 	uint32_t	unused4;
 	uint32_t	uid;
@@ -575,9 +554,6 @@ struct fuse_init_in {
 	uint32_t	flags;
 };
 
-#define FUSE_COMPAT_INIT_OUT_SIZE 8
-#define FUSE_COMPAT_22_INIT_OUT_SIZE 24
-
 struct fuse_init_out {
 	uint32_t	major;
 	uint32_t	minor;
@@ -586,8 +562,6 @@ struct fuse_init_out {
 	uint16_t	max_background;
 	uint16_t	congestion_threshold;
 	uint32_t	max_write;
-	uint32_t	time_gran;
-	uint32_t	unused[9];
 };
 
 #define CUSE_INIT_INFO_MAX 4096
diff --git a/original/uapi/linux/genwqe/genwqe_card.h b/original/uapi/linux/genwqe/genwqe_card.h
index baa93fb..795e957 100644
--- a/original/uapi/linux/genwqe/genwqe_card.h
+++ b/original/uapi/linux/genwqe/genwqe_card.h
@@ -8,7 +8,7 @@
  *
  * Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  * Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
- * Author: Michael Jung <mijung@gmx.net>
+ * Author: Michael Jung <mijung@de.ibm.com>
  * Author: Michael Ruettger <michael@ibmra.de>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -328,7 +328,6 @@ enum genwqe_card_state {
 	GENWQE_CARD_UNUSED = 0,
 	GENWQE_CARD_USED = 1,
 	GENWQE_CARD_FATAL_ERROR = 2,
-	GENWQE_CARD_RELOAD_BITSTREAM = 3,
 	GENWQE_CARD_STATE_MAX,
 };
 
diff --git a/original/uapi/linux/gfs2_ondisk.h b/original/uapi/linux/gfs2_ondisk.h
index 1a763ea..0f24c07 100644
--- a/original/uapi/linux/gfs2_ondisk.h
+++ b/original/uapi/linux/gfs2_ondisk.h
@@ -20,7 +20,7 @@
 
 #define GFS2_MOUNT_LOCK		0
 #define GFS2_LIVE_LOCK		1
-#define GFS2_FREEZE_LOCK	2
+#define GFS2_TRANS_LOCK		2
 #define GFS2_RENAME_LOCK	3
 #define GFS2_CONTROL_LOCK	4
 #define GFS2_MOUNTED_LOCK	5
@@ -304,13 +304,7 @@ struct gfs2_dirent {
 	__be16 de_rec_len;
 	__be16 de_name_len;
 	__be16 de_type;
-	union {
-		__u8 __pad[14];
-		struct {
-			__be16 de_rahead;
-			__u8 pad2[12];
-		};
-	};
+	__u8 __pad[14];
 };
 
 /*
@@ -353,9 +347,9 @@ struct gfs2_leaf {
  * metadata header. Each inode, if it has extended attributes, will
  * have either a single block containing the extended attribute headers
  * or a single indirect block pointing to blocks containing the
- * extended attribute headers.
+ * extended attribure headers.
  *
- * The maximum size of the data part of an extended attribute is 64k
+ * The maximim size of the data part of an extended attribute is 64k
  * so the number of blocks required depends upon block size. Since the
  * block size also determines the number of pointers in an indirect
  * block, its a fairly complicated calculation to work out the maximum
diff --git a/original/uapi/linux/i8k.h b/original/uapi/linux/i8k.h
index 133d02f..1c45ba5 100644
--- a/original/uapi/linux/i8k.h
+++ b/original/uapi/linux/i8k.h
@@ -34,8 +34,7 @@
 #define I8K_FAN_OFF		0
 #define I8K_FAN_LOW		1
 #define I8K_FAN_HIGH		2
-#define I8K_FAN_TURBO		3
-#define I8K_FAN_MAX		I8K_FAN_TURBO
+#define I8K_FAN_MAX		I8K_FAN_HIGH
 
 #define I8K_VOL_UP		1
 #define I8K_VOL_DOWN		2
diff --git a/original/uapi/linux/if.h b/original/uapi/linux/if.h
index 9cf2394..d758163 100644
--- a/original/uapi/linux/if.h
+++ b/original/uapi/linux/if.h
@@ -27,91 +27,65 @@
 #define	IFALIASZ	256
 #include <linux/hdlc/ioctl.h>
 
-/**
- * enum net_device_flags - &struct net_device flags
- *
- * These are the &struct net_device flags, they can be set by drivers, the
- * kernel and some can be triggered by userspace. Userspace can query and
- * set these flags using userspace utilities but there is also a sysfs
- * entry available for all dev flags which can be queried and set. These flags
- * are shared for all types of net_devices. The sysfs entries are available
- * via /sys/class/net/<dev>/flags. Flags which can be toggled through sysfs
- * are annotated below, note that only a few flags can be toggled and some
- * other flags are always always preserved from the original net_device flags
- * even if you try to set them via sysfs. Flags which are always preserved
- * are kept under the flag grouping @IFF_VOLATILE. Flags which are volatile
- * are annotated below as such.
- *
- * You should have a pretty good reason to be extending these flags.
- *
- * @IFF_UP: interface is up. Can be toggled through sysfs.
- * @IFF_BROADCAST: broadcast address valid. Volatile.
- * @IFF_DEBUG: turn on debugging. Can be toggled through sysfs.
- * @IFF_LOOPBACK: is a loopback net. Volatile.
- * @IFF_POINTOPOINT: interface is has p-p link. Volatile.
- * @IFF_NOTRAILERS: avoid use of trailers. Can be toggled through sysfs.
- *	Volatile.
- * @IFF_RUNNING: interface RFC2863 OPER_UP. Volatile.
- * @IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile.
- * @IFF_PROMISC: receive all packets. Can be toggled through sysfs.
- * @IFF_ALLMULTI: receive all multicast packets. Can be toggled through
- *	sysfs.
- * @IFF_MASTER: master of a load balancer. Volatile.
- * @IFF_SLAVE: slave of a load balancer. Volatile.
- * @IFF_MULTICAST: Supports multicast. Can be toggled through sysfs.
- * @IFF_PORTSEL: can set media type. Can be toggled through sysfs.
- * @IFF_AUTOMEDIA: auto media select active. Can be toggled through sysfs.
- * @IFF_DYNAMIC: dialup device with changing addresses. Can be toggled
- *	through sysfs.
- * @IFF_LOWER_UP: driver signals L1 up. Volatile.
- * @IFF_DORMANT: driver signals dormant. Volatile.
- * @IFF_ECHO: echo sent packets. Volatile.
- */
-enum net_device_flags {
-	IFF_UP				= 1<<0,  /* sysfs */
-	IFF_BROADCAST			= 1<<1,  /* volatile */
-	IFF_DEBUG			= 1<<2,  /* sysfs */
-	IFF_LOOPBACK			= 1<<3,  /* volatile */
-	IFF_POINTOPOINT			= 1<<4,  /* volatile */
-	IFF_NOTRAILERS			= 1<<5,  /* sysfs */
-	IFF_RUNNING			= 1<<6,  /* volatile */
-	IFF_NOARP			= 1<<7,  /* sysfs */
-	IFF_PROMISC			= 1<<8,  /* sysfs */
-	IFF_ALLMULTI			= 1<<9,  /* sysfs */
-	IFF_MASTER			= 1<<10, /* volatile */
-	IFF_SLAVE			= 1<<11, /* volatile */
-	IFF_MULTICAST			= 1<<12, /* sysfs */
-	IFF_PORTSEL			= 1<<13, /* sysfs */
-	IFF_AUTOMEDIA			= 1<<14, /* sysfs */
-	IFF_DYNAMIC			= 1<<15, /* sysfs */
-	IFF_LOWER_UP			= 1<<16, /* volatile */
-	IFF_DORMANT			= 1<<17, /* volatile */
-	IFF_ECHO			= 1<<18, /* volatile */
-};
+/* Standard interface flags (netdevice->flags). */
+#define	IFF_UP		0x1		/* interface is up		*/
+#define	IFF_BROADCAST	0x2		/* broadcast address valid	*/
+#define	IFF_DEBUG	0x4		/* turn on debugging		*/
+#define	IFF_LOOPBACK	0x8		/* is a loopback net		*/
+#define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	*/
+#define	IFF_NOTRAILERS	0x20		/* avoid use of trailers	*/
+#define	IFF_RUNNING	0x40		/* interface RFC2863 OPER_UP	*/
+#define	IFF_NOARP	0x80		/* no ARP protocol		*/
+#define	IFF_PROMISC	0x100		/* receive all packets		*/
+#define	IFF_ALLMULTI	0x200		/* receive all multicast packets*/
+
+#define IFF_MASTER	0x400		/* master of a load balancer 	*/
+#define IFF_SLAVE	0x800		/* slave of a load balancer	*/
 
-#define IFF_UP				IFF_UP
-#define IFF_BROADCAST			IFF_BROADCAST
-#define IFF_DEBUG			IFF_DEBUG
-#define IFF_LOOPBACK			IFF_LOOPBACK
-#define IFF_POINTOPOINT			IFF_POINTOPOINT
-#define IFF_NOTRAILERS			IFF_NOTRAILERS
-#define IFF_RUNNING			IFF_RUNNING
-#define IFF_NOARP			IFF_NOARP
-#define IFF_PROMISC			IFF_PROMISC
-#define IFF_ALLMULTI			IFF_ALLMULTI
-#define IFF_MASTER			IFF_MASTER
-#define IFF_SLAVE			IFF_SLAVE
-#define IFF_MULTICAST			IFF_MULTICAST
-#define IFF_PORTSEL			IFF_PORTSEL
-#define IFF_AUTOMEDIA			IFF_AUTOMEDIA
-#define IFF_DYNAMIC			IFF_DYNAMIC
-#define IFF_LOWER_UP			IFF_LOWER_UP
-#define IFF_DORMANT			IFF_DORMANT
-#define IFF_ECHO			IFF_ECHO
+#define IFF_MULTICAST	0x1000		/* Supports multicast		*/
+
+#define IFF_PORTSEL	0x2000          /* can set media type		*/
+#define IFF_AUTOMEDIA	0x4000		/* auto media select active	*/
+#define IFF_DYNAMIC	0x8000		/* dialup device with changing addresses*/
+
+#define IFF_LOWER_UP	0x10000		/* driver signals L1 up		*/
+#define IFF_DORMANT	0x20000		/* driver signals dormant	*/
+
+#define IFF_ECHO	0x40000		/* echo sent packets		*/
 
 #define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
 		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
 
+/* Private (from user) interface flags (netdevice->priv_flags). */
+#define IFF_802_1Q_VLAN 0x1             /* 802.1Q VLAN device.          */
+#define IFF_EBRIDGE	0x2		/* Ethernet bridging device.	*/
+#define IFF_SLAVE_INACTIVE	0x4	/* bonding slave not the curr. active */
+#define IFF_MASTER_8023AD	0x8	/* bonding master, 802.3ad. 	*/
+#define IFF_MASTER_ALB	0x10		/* bonding master, balance-alb.	*/
+#define IFF_BONDING	0x20		/* bonding master or slave	*/
+#define IFF_SLAVE_NEEDARP 0x40		/* need ARPs for validation	*/
+#define IFF_ISATAP	0x80		/* ISATAP interface (RFC4214)	*/
+#define IFF_MASTER_ARPMON 0x100		/* bonding master, ARP mon in use */
+#define IFF_WAN_HDLC	0x200		/* WAN HDLC device		*/
+#define IFF_XMIT_DST_RELEASE 0x400	/* dev_hard_start_xmit() is allowed to
+					 * release skb->dst
+					 */
+#define IFF_DONT_BRIDGE 0x800		/* disallow bridging this ether dev */
+#define IFF_DISABLE_NETPOLL	0x1000	/* disable netpoll at run-time */
+#define IFF_MACVLAN_PORT	0x2000	/* device used as macvlan port */
+#define IFF_BRIDGE_PORT	0x4000		/* device used as bridge port */
+#define IFF_OVS_DATAPATH	0x8000	/* device used as Open vSwitch
+					 * datapath port */
+#define IFF_TX_SKB_SHARING	0x10000	/* The interface supports sharing
+					 * skbs on transmit */
+#define IFF_UNICAST_FLT	0x20000		/* Supports unicast filtering	*/
+#define IFF_TEAM_PORT	0x40000		/* device used as team port */
+#define IFF_SUPP_NOFCS	0x80000		/* device supports sending custom FCS */
+#define IFF_LIVE_ADDR_CHANGE 0x100000	/* device supports hardware address
+					 * change when it's running */
+#define IFF_MACVLAN 0x200000		/* Macvlan device */
+
+
 #define IF_GET_IFACE	0x0001		/* for querying only */
 #define IF_GET_PROTO	0x0002
 
diff --git a/original/uapi/linux/if_bridge.h b/original/uapi/linux/if_bridge.h
index da17e45..39f621a 100644
--- a/original/uapi/linux/if_bridge.h
+++ b/original/uapi/linux/if_bridge.h
@@ -15,7 +15,6 @@
 
 #include <linux/types.h>
 #include <linux/if_ether.h>
-#include <linux/in6.h>
 
 #define SYSFS_BRIDGE_ATTR	"bridge"
 #define SYSFS_BRIDGE_FDB	"brforward"
diff --git a/original/uapi/linux/if_ether.h b/original/uapi/linux/if_ether.h
index aa63ed0..2ce0f6a 100644
--- a/original/uapi/linux/if_ether.h
+++ b/original/uapi/linux/if_ether.h
@@ -68,11 +68,11 @@
 #define ETH_P_SLOW	0x8809		/* Slow Protocol. See 802.3ad 43B */
 #define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
 					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
 #define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
 #define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
 #define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
-#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
-#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
 #define ETH_P_LINK_CTL	0x886c		/* HPNA, wlan link local tunnel */
 #define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
 					 * over Ethernet
@@ -89,8 +89,6 @@
 #define ETH_P_FCOE	0x8906		/* Fibre Channel over Ethernet  */
 #define ETH_P_TDLS	0x890D          /* TDLS */
 #define ETH_P_FIP	0x8914		/* FCoE Initialization Protocol */
-#define ETH_P_80221	0x8917		/* IEEE 802.21 Media Independent Handover Protocol */
-#define ETH_P_LOOPBACK	0x9000		/* Ethernet loopback packet, per IEEE 802.3 */
 #define ETH_P_QINQ1	0x9100		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
 #define ETH_P_QINQ2	0x9200		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
 #define ETH_P_QINQ3	0x9300		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
@@ -128,7 +126,6 @@
 #define ETH_P_PHONET	0x00F5		/* Nokia Phonet frames          */
 #define ETH_P_IEEE802154 0x00F6		/* IEEE802.15.4 frame		*/
 #define ETH_P_CAIF	0x00F7		/* ST-Ericsson CAIF protocol	*/
-#define ETH_P_XDSA	0x00F8		/* Multiplexed DSA protocol	*/
 
 /*
  *	This is an Ethernet frame header.
diff --git a/original/uapi/linux/if_fddi.h b/original/uapi/linux/if_fddi.h
index 1086cd9..0d36909 100644
--- a/original/uapi/linux/if_fddi.h
+++ b/original/uapi/linux/if_fddi.h
@@ -30,76 +30,74 @@
  *  Define max and min legal sizes.  The frame sizes do not include
  *  4 byte FCS/CRC (frame check sequence).
  */
-#define FDDI_K_ALEN		6	/* Octets in one FDDI address */
-#define FDDI_K_8022_HLEN	16	/* Total octets in 802.2 header */
-#define FDDI_K_SNAP_HLEN	21	/* Total octets in 802.2 SNAP header */
-#define FDDI_K_8022_ZLEN	16	/* Min octets in 802.2 frame sans
-					   FCS */
-#define FDDI_K_SNAP_ZLEN	21	/* Min octets in 802.2 SNAP frame sans
-					   FCS */
+#define FDDI_K_ALEN			6		/* Octets in one FDDI address */
+#define FDDI_K_8022_HLEN	16		/* Total octets in 802.2 header */
+#define FDDI_K_SNAP_HLEN	21		/* Total octets in 802.2 SNAP header */
+#define FDDI_K_8022_ZLEN	16		/* Min octets in 802.2 frame sans FCS */
+#define FDDI_K_SNAP_ZLEN	21		/* Min octets in 802.2 SNAP frame sans FCS */
 #define FDDI_K_8022_DLEN	4475	/* Max octets in 802.2 payload */
 #define FDDI_K_SNAP_DLEN	4470	/* Max octets in 802.2 SNAP payload */
-#define FDDI_K_LLC_ZLEN		13	/* Min octets in LLC frame sans FCS */
+#define FDDI_K_LLC_ZLEN		13		/* Min octets in LLC frame sans FCS */
 #define FDDI_K_LLC_LEN		4491	/* Max octets in LLC frame sans FCS */
-#define FDDI_K_OUI_LEN		3	/* Octets in OUI in 802.2 SNAP
-					   header */
 
 /* Define FDDI Frame Control (FC) Byte values */
-#define FDDI_FC_K_VOID			0x00
-#define FDDI_FC_K_NON_RESTRICTED_TOKEN	0x80
-#define FDDI_FC_K_RESTRICTED_TOKEN	0xC0
-#define FDDI_FC_K_SMT_MIN		0x41
-#define FDDI_FC_K_SMT_MAX		0x4F
-#define FDDI_FC_K_MAC_MIN		0xC1
-#define FDDI_FC_K_MAC_MAX		0xCF
-#define FDDI_FC_K_ASYNC_LLC_MIN		0x50
-#define FDDI_FC_K_ASYNC_LLC_DEF		0x54
-#define FDDI_FC_K_ASYNC_LLC_MAX		0x5F
-#define FDDI_FC_K_SYNC_LLC_MIN		0xD0
-#define FDDI_FC_K_SYNC_LLC_MAX		0xD7
-#define FDDI_FC_K_IMPLEMENTOR_MIN	0x60
-#define FDDI_FC_K_IMPLEMENTOR_MAX	0x6F
-#define FDDI_FC_K_RESERVED_MIN		0x70
-#define FDDI_FC_K_RESERVED_MAX		0x7F
+#define FDDI_FC_K_VOID					0x00	
+#define FDDI_FC_K_NON_RESTRICTED_TOKEN	0x80	
+#define FDDI_FC_K_RESTRICTED_TOKEN		0xC0	
+#define FDDI_FC_K_SMT_MIN				0x41
+#define FDDI_FC_K_SMT_MAX		   		0x4F
+#define FDDI_FC_K_MAC_MIN				0xC1
+#define FDDI_FC_K_MAC_MAX		  		0xCF	
+#define FDDI_FC_K_ASYNC_LLC_MIN			0x50
+#define FDDI_FC_K_ASYNC_LLC_DEF			0x54
+#define FDDI_FC_K_ASYNC_LLC_MAX			0x5F
+#define FDDI_FC_K_SYNC_LLC_MIN			0xD0
+#define FDDI_FC_K_SYNC_LLC_MAX			0xD7
+#define FDDI_FC_K_IMPLEMENTOR_MIN		0x60
+#define FDDI_FC_K_IMPLEMENTOR_MAX  		0x6F
+#define FDDI_FC_K_RESERVED_MIN			0x70
+#define FDDI_FC_K_RESERVED_MAX			0x7F
 
 /* Define LLC and SNAP constants */
-#define FDDI_EXTENDED_SAP		0xAA
+#define FDDI_EXTENDED_SAP	0xAA
 #define FDDI_UI_CMD			0x03
 
 /* Define 802.2 Type 1 header */
 struct fddi_8022_1_hdr {
-	__u8	dsap;			/* destination service access point */
-	__u8	ssap;			/* source service access point */
-	__u8	ctrl;			/* control byte #1 */
+	__u8	dsap;					/* destination service access point */
+	__u8	ssap;					/* source service access point */
+	__u8	ctrl;					/* control byte #1 */
 } __attribute__((packed));
 
 /* Define 802.2 Type 2 header */
 struct fddi_8022_2_hdr {
-	__u8	dsap;			/* destination service access point */
-	__u8	ssap;			/* source service access point */
-	__u8	ctrl_1;			/* control byte #1 */
-	__u8	ctrl_2;			/* control byte #2 */
+	__u8	dsap;					/* destination service access point */
+	__u8	ssap;					/* source service access point */
+	__u8	ctrl_1;					/* control byte #1 */
+	__u8	ctrl_2;					/* control byte #2 */
 } __attribute__((packed));
 
 /* Define 802.2 SNAP header */
+#define FDDI_K_OUI_LEN	3
 struct fddi_snap_hdr {
-	__u8	dsap;			/* always 0xAA */
-	__u8	ssap;			/* always 0xAA */
-	__u8	ctrl;			/* always 0x03 */
+	__u8	dsap;					/* always 0xAA */
+	__u8	ssap;					/* always 0xAA */
+	__u8	ctrl;					/* always 0x03 */
 	__u8	oui[FDDI_K_OUI_LEN];	/* organizational universal id */
-	__be16	ethertype;		/* packet type ID field */
+	__be16	ethertype;				/* packet type ID field */
 } __attribute__((packed));
 
 /* Define FDDI LLC frame header */
 struct fddihdr {
-	__u8	fc;			/* frame control */
-	__u8	daddr[FDDI_K_ALEN];	/* destination address */
-	__u8	saddr[FDDI_K_ALEN];	/* source address */
-	union {
-		struct fddi_8022_1_hdr	llc_8022_1;
-		struct fddi_8022_2_hdr	llc_8022_2;
-		struct fddi_snap_hdr	llc_snap;
-	} hdr;
+	__u8	fc;						/* frame control */
+	__u8	daddr[FDDI_K_ALEN];		/* destination address */
+	__u8	saddr[FDDI_K_ALEN];		/* source address */
+	union
+		{
+		struct fddi_8022_1_hdr		llc_8022_1;
+		struct fddi_8022_2_hdr		llc_8022_2;
+		struct fddi_snap_hdr		llc_snap;
+		} hdr;
 } __attribute__((packed));
 
 
diff --git a/original/uapi/linux/if_link.h b/original/uapi/linux/if_link.h
index 0bdb77e..16410b6 100644
--- a/original/uapi/linux/if_link.h
+++ b/original/uapi/linux/if_link.h
@@ -144,7 +144,6 @@ enum {
 	IFLA_NUM_RX_QUEUES,
 	IFLA_CARRIER,
 	IFLA_PHYS_PORT_ID,
-	IFLA_CARRIER_CHANGES,
 	__IFLA_MAX
 };
 
@@ -204,29 +203,11 @@ enum {
 	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
 	IFLA_INET6_ICMP6STATS,	/* statistics (icmpv6)		*/
 	IFLA_INET6_TOKEN,	/* device token			*/
-	IFLA_INET6_ADDR_GEN_MODE, /* implicit address generator mode */
 	__IFLA_INET6_MAX
 };
 
 #define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
 
-enum in6_addr_gen_mode {
-	IN6_ADDR_GEN_MODE_EUI64,
-	IN6_ADDR_GEN_MODE_NONE,
-};
-
-/* Bridge section */
-
-enum {
-	IFLA_BR_UNSPEC,
-	IFLA_BR_FORWARD_DELAY,
-	IFLA_BR_HELLO_TIME,
-	IFLA_BR_MAX_AGE,
-	__IFLA_BR_MAX,
-};
-
-#define IFLA_BR_MAX	(__IFLA_BR_MAX - 1)
-
 enum {
 	BRIDGE_MODE_UNSPEC,
 	BRIDGE_MODE_HAIRPIN,
@@ -303,10 +284,6 @@ enum {
 	IFLA_MACVLAN_UNSPEC,
 	IFLA_MACVLAN_MODE,
 	IFLA_MACVLAN_FLAGS,
-	IFLA_MACVLAN_MACADDR_MODE,
-	IFLA_MACVLAN_MACADDR,
-	IFLA_MACVLAN_MACADDR_DATA,
-	IFLA_MACVLAN_MACADDR_COUNT,
 	__IFLA_MACVLAN_MAX,
 };
 
@@ -317,14 +294,6 @@ enum macvlan_mode {
 	MACVLAN_MODE_VEPA    = 2, /* talk to other ports through ext bridge */
 	MACVLAN_MODE_BRIDGE  = 4, /* talk to bridge ports directly */
 	MACVLAN_MODE_PASSTHRU = 8,/* take over the underlying device */
-	MACVLAN_MODE_SOURCE  = 16,/* use source MAC address list to assign */
-};
-
-enum macvlan_macaddr_mode {
-	MACVLAN_MACADDR_ADD,
-	MACVLAN_MACADDR_DEL,
-	MACVLAN_MACADDR_FLUSH,
-	MACVLAN_MACADDR_SET,
 };
 
 #define MACVLAN_FLAG_NOPROMISC	1
@@ -349,9 +318,6 @@ enum {
 	IFLA_VXLAN_PORT,	/* destination port */
 	IFLA_VXLAN_GROUP6,
 	IFLA_VXLAN_LOCAL6,
-	IFLA_VXLAN_UDP_CSUM,
-	IFLA_VXLAN_UDP_ZERO_CSUM6_TX,
-	IFLA_VXLAN_UDP_ZERO_CSUM6_RX,
 	__IFLA_VXLAN_MAX
 };
 #define IFLA_VXLAN_MAX	(__IFLA_VXLAN_MAX - 1)
@@ -432,10 +398,9 @@ enum {
 	IFLA_VF_UNSPEC,
 	IFLA_VF_MAC,		/* Hardware queue specific attributes */
 	IFLA_VF_VLAN,
-	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
+	IFLA_VF_TX_RATE,	/* TX Bandwidth Allocation */
 	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
 	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
-	IFLA_VF_RATE,		/* Min and Max TX Bandwidth Allocation */
 	__IFLA_VF_MAX,
 };
 
@@ -457,12 +422,6 @@ struct ifla_vf_tx_rate {
 	__u32 rate; /* Max TX bandwidth in Mbps, 0 disables throttling */
 };
 
-struct ifla_vf_rate {
-	__u32 vf;
-	__u32 min_tx_rate; /* Min Bandwidth in Mbps */
-	__u32 max_tx_rate; /* Max Bandwidth in Mbps */
-};
-
 struct ifla_vf_spoofchk {
 	__u32 vf;
 	__u32 setting;
diff --git a/original/uapi/linux/if_packet.h b/original/uapi/linux/if_packet.h
index da2d668..bac27fa 100644
--- a/original/uapi/linux/if_packet.h
+++ b/original/uapi/linux/if_packet.h
@@ -108,7 +108,7 @@ struct tpacket_auxdata {
 
 /* Rx and Tx ring - header status */
 #define TP_STATUS_TS_SOFTWARE		(1 << 29)
-#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30) /* deprecated, never set */
+#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30)
 #define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
 
 /* Rx ring - feature request bits */
diff --git a/original/uapi/linux/if_pppox.h b/original/uapi/linux/if_pppox.h
index e128769..5861d45 100644
--- a/original/uapi/linux/if_pppox.h
+++ b/original/uapi/linux/if_pppox.h
@@ -23,6 +23,8 @@
 #include <linux/socket.h>
 #include <linux/if_ether.h>
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppolac.h>
+#include <linux/if_pppopns.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -56,7 +58,9 @@ struct pptp_addr {
 #define PX_PROTO_OE    0 /* Currently just PPPoE */
 #define PX_PROTO_OL2TP 1 /* Now L2TP also */
 #define PX_PROTO_PPTP  2
-#define PX_MAX_PROTO   3
+#define PX_PROTO_OLAC  3
+#define PX_PROTO_OPNS  4
+#define PX_MAX_PROTO   5
 
 struct sockaddr_pppox {
 	__kernel_sa_family_t sa_family;       /* address family, AF_PPPOX */
diff --git a/original/uapi/linux/if_tunnel.h b/original/uapi/linux/if_tunnel.h
index 280d9e0..aee73d0 100644
--- a/original/uapi/linux/if_tunnel.h
+++ b/original/uapi/linux/if_tunnel.h
@@ -53,23 +53,10 @@ enum {
 	IFLA_IPTUN_6RD_RELAY_PREFIX,
 	IFLA_IPTUN_6RD_PREFIXLEN,
 	IFLA_IPTUN_6RD_RELAY_PREFIXLEN,
-	IFLA_IPTUN_ENCAP_TYPE,
-	IFLA_IPTUN_ENCAP_FLAGS,
-	IFLA_IPTUN_ENCAP_SPORT,
-	IFLA_IPTUN_ENCAP_DPORT,
 	__IFLA_IPTUN_MAX,
 };
 #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
 
-enum tunnel_encap_types {
-	TUNNEL_ENCAP_NONE,
-	TUNNEL_ENCAP_FOU,
-	TUNNEL_ENCAP_GUE,
-};
-
-#define TUNNEL_ENCAP_FLAG_CSUM		(1<<0)
-#define TUNNEL_ENCAP_FLAG_CSUM6		(1<<1)
-
 /* SIT-mode i_flags */
 #define	SIT_ISATAP	0x0001
 
@@ -107,17 +94,13 @@ enum {
 	IFLA_GRE_ENCAP_LIMIT,
 	IFLA_GRE_FLOWINFO,
 	IFLA_GRE_FLAGS,
-	IFLA_GRE_ENCAP_TYPE,
-	IFLA_GRE_ENCAP_FLAGS,
-	IFLA_GRE_ENCAP_SPORT,
-	IFLA_GRE_ENCAP_DPORT,
 	__IFLA_GRE_MAX,
 };
 
 #define IFLA_GRE_MAX	(__IFLA_GRE_MAX - 1)
 
 /* VTI-mode i_flags */
-#define VTI_ISVTI ((__force __be16)0x0001)
+#define VTI_ISVTI 0x0001
 
 enum {
 	IFLA_VTI_UNSPEC,
diff --git a/original/uapi/linux/in.h b/original/uapi/linux/in.h
index c33a65e..393c5de 100644
--- a/original/uapi/linux/in.h
+++ b/original/uapi/linux/in.h
@@ -120,10 +120,6 @@ struct in_addr {
  * this socket to prevent accepting spoofed ones.
  */
 #define IP_PMTUDISC_INTERFACE		4
-/* weaker version of IP_PMTUDISC_INTERFACE, which allos packets to get
- * fragmented if they exeed the interface mtu
- */
-#define IP_PMTUDISC_OMIT		5
 
 #define IP_MULTICAST_IF			32
 #define IP_MULTICAST_TTL 		33
diff --git a/original/uapi/linux/in6.h b/original/uapi/linux/in6.h
index 79b12b0..4c399ae 100644
--- a/original/uapi/linux/in6.h
+++ b/original/uapi/linux/in6.h
@@ -185,10 +185,6 @@ struct in6_flowlabel_req {
  * also see comments on IP_PMTUDISC_INTERFACE
  */
 #define IPV6_PMTUDISC_INTERFACE		4
-/* weaker version of IPV6_PMTUDISC_INTERFACE, which allows packets to
- * get fragmented if they exceed the interface mtu
- */
-#define IPV6_PMTUDISC_OMIT		5
 
 /* Flowlabel */
 #define IPV6_FLOWLABEL_MGR	32
@@ -262,7 +258,6 @@ struct in6_flowlabel_req {
  * IP6T_SO_ORIGINAL_DST		80
  */
 
-#define IPV6_AUTOFLOWLABEL	70
 /* RFC5014: Source address selection */
 #define IPV6_ADDR_PREFERENCES	72
 
diff --git a/original/uapi/linux/inet_diag.h b/original/uapi/linux/inet_diag.h
index d65c0a0..bbde90f 100644
--- a/original/uapi/linux/inet_diag.h
+++ b/original/uapi/linux/inet_diag.h
@@ -110,10 +110,10 @@ enum {
 	INET_DIAG_TCLASS,
 	INET_DIAG_SKMEMINFO,
 	INET_DIAG_SHUTDOWN,
-	INET_DIAG_DCTCPINFO,
 };
 
-#define INET_DIAG_MAX INET_DIAG_DCTCPINFO
+#define INET_DIAG_MAX INET_DIAG_SHUTDOWN
+
 
 /* INET_DIAG_MEM */
 
@@ -133,14 +133,5 @@ struct tcpvegas_info {
 	__u32	tcpv_minrtt;
 };
 
-/* INET_DIAG_DCTCPINFO */
-
-struct tcp_dctcp_info {
-	__u16	dctcp_enabled;
-	__u16	dctcp_ce_state;
-	__u32	dctcp_alpha;
-	__u32	dctcp_ab_ecn;
-	__u32	dctcp_ab_tot;
-};
 
 #endif /* _UAPI_INET_DIAG_H_ */
diff --git a/original/uapi/linux/input.h b/original/uapi/linux/input.h
index a1d7e93..a99f7bc 100644
--- a/original/uapi/linux/input.h
+++ b/original/uapi/linux/input.h
@@ -152,7 +152,12 @@ struct input_keymap_entry {
 #define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
 
 #define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
-#define EVIOCREVOKE		_IOW('E', 0x91, int)			/* Revoke device access */
+
+/* HACK: disable conflicting EVIOCREVOKE until Android userspace stops using EVIOCSSUSPENDBLOCK */
+/*#define EVIOCREVOKE		_IOW('E', 0x91, int)*/			/* Revoke device access */
+
+#define EVIOCGSUSPENDBLOCK	_IOR('E', 0x91, int)			/* get suspend block enable */
+#define EVIOCSSUSPENDBLOCK	_IOW('E', 0x91, int)			/* set suspend block enable */
 
 #define EVIOCSCLOCKID		_IOW('E', 0xa0, int)			/* Set clockid to be used for timestamps */
 
@@ -165,7 +170,6 @@ struct input_keymap_entry {
 #define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
 #define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
 #define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
 
 #define INPUT_PROP_MAX			0x1f
 #define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
@@ -463,10 +467,7 @@ struct input_keymap_entry {
 #define KEY_VIDEO_NEXT		241	/* drive next video source */
 #define KEY_VIDEO_PREV		242	/* drive previous video source */
 #define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
+#define KEY_BRIGHTNESS_ZERO	244	/* brightness off, use ambient */
 #define KEY_DISPLAY_OFF		245	/* display device to off state */
 
 #define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
@@ -636,7 +637,6 @@ struct input_keymap_entry {
 #define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
 #define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
 #define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
 #define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
 #define KEY_LOGOFF		0x1b1   /* AL Logoff */
 
@@ -728,24 +728,6 @@ struct input_keymap_entry {
 
 #define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
 
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
 #define BTN_TRIGGER_HAPPY		0x2c0
 #define BTN_TRIGGER_HAPPY1		0x2c0
 #define BTN_TRIGGER_HAPPY2		0x2c1
diff --git a/original/uapi/linux/ion.h b/original/uapi/linux/ion.h
index 6aa4956..f09e7c1 100644
--- a/original/uapi/linux/ion.h
+++ b/original/uapi/linux/ion.h
@@ -27,12 +27,12 @@ typedef int ion_user_handle_t;
  * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
  * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
  * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
- *				 carveout heap, allocations are physically
- *				 contiguous
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
  * @ION_HEAP_TYPE_DMA:		 memory allocated via DMA API
  * @ION_NUM_HEAPS:		 helper for iterating over heaps, a bit mask
- *				 is used to identify the heaps, so only 32
- *				 total heap types are supported
+ * 				 is used to identify the heaps, so only 32
+ * 				 total heap types are supported
  */
 enum ion_heap_type {
 	ION_HEAP_TYPE_SYSTEM,
@@ -50,7 +50,7 @@ enum ion_heap_type {
 #define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
 #define ION_HEAP_TYPE_DMA_MASK		(1 << ION_HEAP_TYPE_DMA)
 
-#define ION_NUM_HEAP_IDS		(sizeof(unsigned int) * 8)
+#define ION_NUM_HEAP_IDS		sizeof(unsigned int) * 8
 
 /**
  * allocation flags - the lower 16 bits are used by core ion, the upper 16
@@ -78,7 +78,7 @@ enum ion_heap_type {
  * @align:		required alignment of the allocation
  * @heap_id_mask:	mask of heap ids to allocate from
  * @flags:		flags passed to heap
- * @handle:		pointer that will be populated with a cookie to use to
+ * @handle:		pointer that will be populated with a cookie to use to 
  *			refer to this allocation
  *
  * Provided by userspace as an argument to the ioctl
diff --git a/original/uapi/linux/ip_vs.h b/original/uapi/linux/ip_vs.h
index cabe95d..fbcffe8 100644
--- a/original/uapi/linux/ip_vs.h
+++ b/original/uapi/linux/ip_vs.h
@@ -384,9 +384,6 @@ enum {
 	IPVS_DEST_ATTR_PERSIST_CONNS,	/* persistent connections */
 
 	IPVS_DEST_ATTR_STATS,		/* nested attribute for dest stats */
-
-	IPVS_DEST_ATTR_ADDR_FAMILY,	/* Address family of address */
-
 	__IPVS_DEST_ATTR_MAX,
 };
 
diff --git a/original/uapi/linux/ipu.h b/original/uapi/linux/ipu.h
new file mode 100644
index 0000000..9657a26
--- /dev/null
+++ b/original/uapi/linux/ipu.h
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file uapi/linux/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+#ifndef __KERNEL__
+#ifndef __cplusplus
+typedef unsigned char bool;
+#endif
+#define irqreturn_t int
+#define dma_addr_t int
+#define uint32_t unsigned int
+#define uint16_t unsigned short
+#define uint8_t unsigned char
+#define u32 unsigned int
+#define u8 unsigned char
+#define __u32 u32
+#endif
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of VDI MOTION select
+ */
+typedef enum {
+	MED_MOTION = 0,
+	LOW_MOTION = 1,
+	HIGH_MOTION = 2,
+} ipu_motion_sel;
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name GPU Tile Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GPU32_SB_ST  fourcc('5', 'P', '4', 'S') /*!< 32bit split buf 4x4 standard */
+#define IPU_PIX_FMT_GPU32_SB_SRT fourcc('5', 'P', '4', 'R') /*!< 32bit split buf 4x4 super */
+#define IPU_PIX_FMT_GPU32_ST     fourcc('5', 'I', '4', 'S') /*!< 32bit single buf 4x4 standard */
+#define IPU_PIX_FMT_GPU32_SRT    fourcc('5', 'I', '4', 'R') /*!< 32bit single buf 4x4 super */
+#define IPU_PIX_FMT_GPU16_SB_ST  fourcc('4', 'P', '8', 'S') /*!< 16bit split buf 8x4 standard */
+#define IPU_PIX_FMT_GPU16_SB_SRT fourcc('4', 'P', '8', 'R') /*!< 16bit split buf 8x4 super */
+#define IPU_PIX_FMT_GPU16_ST     fourcc('4', 'I', '8', 'S') /*!< 16bit single buf 8x4 standard */
+#define IPU_PIX_FMT_GPU16_SRT    fourcc('4', 'I', '8', 'R') /*!< 16bit single buf 8x4 super */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_16 fourcc('I', 'P', 'U', '2')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_BGRA4444 fourcc('4', '4', '4', '4')	/*!< 16  RGBA-4-4-4-4 */
+#define IPU_PIX_FMT_BGRA5551 fourcc('5', '5', '5', '1')	/*!< 16  RGBA-5-5-5-1 */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_GBR24   fourcc('G', 'B', 'R', '3')	/*!< 24  GBR-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVYU 4:2:2 */
+#define IPU_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 VYYU 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+#define IPU_PIX_FMT_VYU444  fourcc('V', '4', '4', '4')	/*!< 24 VYU 4:4:4 */
+#define IPU_PIX_FMT_AYUV    fourcc('A', 'Y', 'U', 'V')	/*!< 32 AYUV 4:4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define PRE_PIX_FMT_NV21    fourcc('N', 'V', '2', '1') /* 12  Y/CbCr 4:2:0  */
+#define IPU_PIX_FMT_NV16    fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
+#define PRE_PIX_FMT_NV61    fourcc('N', 'V', '6', '1') /* 16  Y/CbCr 4:2:2  */
+/* two planes -- 12  tiled Y/CbCr 4:2:0  */
+#define IPU_PIX_FMT_TILED_NV12    fourcc('T', 'N', 'V', 'P')
+#define IPU_PIX_FMT_TILED_NV12F   fourcc('T', 'N', 'V', 'F')
+
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/* non-interleaved 4:4:4 */
+#define IPU_PIX_FMT_YUV444P fourcc('4', '4', '4', 'P')	/*!< 24 YUV 4:4:4 */
+/*! @} */
+#define IPU_PIX_FMT_TILED_NV12_MBALIGN	(16)
+#define TILED_NV12_FRAME_SIZE(w, h)	\
+		(ALIGN((w) * (h), SZ_4K) + ALIGN((w) * (h) / 2, SZ_4K))
+/* IPU device */
+typedef enum {
+	RGB_CS,
+	YUV_CS,
+	NULL_CS
+} cs_t;
+
+struct ipu_pos {
+	u32 x;
+	u32 y;
+};
+
+struct ipu_crop {
+	struct ipu_pos pos;
+	u32 w;
+	u32 h;
+};
+
+struct ipu_deinterlace {
+	bool	enable;
+	u8	motion; /*see ipu_motion_sel*/
+#define IPU_DEINTERLACE_FIELD_TOP	0
+#define IPU_DEINTERLACE_FIELD_BOTTOM	1
+#define IPU_DEINTERLACE_FIELD_MASK	\
+		(IPU_DEINTERLACE_FIELD_TOP | IPU_DEINTERLACE_FIELD_BOTTOM)
+	/* deinterlace frame rate double flags */
+#define IPU_DEINTERLACE_RATE_EN		0x80
+#define IPU_DEINTERLACE_RATE_FRAME1	0x40
+#define IPU_DEINTERLACE_RATE_MASK	\
+		(IPU_DEINTERLACE_RATE_EN | IPU_DEINTERLACE_RATE_FRAME1)
+#define IPU_DEINTERLACE_MAX_FRAME	2
+	u8	field_fmt;
+};
+
+struct ipu_input {
+	u32 width;
+	u32 height;
+	u32 format;
+	struct ipu_crop crop;
+	dma_addr_t paddr;
+
+	struct ipu_deinterlace deinterlace;
+	dma_addr_t paddr_n; /*valid when deinterlace enable*/
+};
+
+struct ipu_alpha {
+#define IPU_ALPHA_MODE_GLOBAL	0
+#define IPU_ALPHA_MODE_LOCAL	1
+	u8 mode;
+	u8 gvalue; /* 0~255 */
+	dma_addr_t loc_alp_paddr;
+};
+
+struct ipu_colorkey {
+	bool enable;
+	u32 value; /* RGB 24bit */
+};
+
+struct ipu_overlay {
+	u32	width;
+	u32	height;
+	u32	format;
+	struct ipu_crop crop;
+	struct ipu_alpha alpha;
+	struct ipu_colorkey colorkey;
+	dma_addr_t paddr;
+};
+
+struct ipu_output {
+	u32	width;
+	u32	height;
+	u32	format;
+	u8	rotate;
+	struct ipu_crop crop;
+	dma_addr_t paddr;
+};
+
+struct ipu_task {
+	struct ipu_input input;
+	struct ipu_output output;
+
+	bool overlay_en;
+	struct ipu_overlay overlay;
+
+#define IPU_TASK_PRIORITY_NORMAL 0
+#define IPU_TASK_PRIORITY_HIGH	1
+	u8	priority;
+
+#define	IPU_TASK_ID_ANY	0
+#define	IPU_TASK_ID_VF	1
+#define	IPU_TASK_ID_PP	2
+#define	IPU_TASK_ID_MAX 3
+	u8	task_id;
+
+	int	timeout;
+};
+
+enum {
+	IPU_CHECK_OK = 0,
+	IPU_CHECK_WARN_INPUT_OFFS_NOT8ALIGN = 0x1,
+	IPU_CHECK_WARN_OUTPUT_OFFS_NOT8ALIGN = 0x2,
+	IPU_CHECK_WARN_OVERLAY_OFFS_NOT8ALIGN = 0x4,
+	IPU_CHECK_ERR_MIN,
+	IPU_CHECK_ERR_INPUT_CROP,
+	IPU_CHECK_ERR_OUTPUT_CROP,
+	IPU_CHECK_ERR_OVERLAY_CROP,
+	IPU_CHECK_ERR_INPUT_OVER_LIMIT,
+	IPU_CHECK_ERR_OV_OUT_NO_FIT,
+	IPU_CHECK_ERR_OVERLAY_WITH_VDI,
+	IPU_CHECK_ERR_PROC_NO_NEED,
+	IPU_CHECK_ERR_SPLIT_INPUTW_OVER,
+	IPU_CHECK_ERR_SPLIT_INPUTH_OVER,
+	IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER,
+	IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER,
+	IPU_CHECK_ERR_SPLIT_WITH_ROT,
+	IPU_CHECK_ERR_NOT_SUPPORT,
+	IPU_CHECK_ERR_NOT16ALIGN,
+	IPU_CHECK_ERR_W_DOWNSIZE_OVER,
+	IPU_CHECK_ERR_H_DOWNSIZE_OVER,
+};
+
+/* IOCTL commands */
+#define IPU_CHECK_TASK		_IOWR('I', 0x1, struct ipu_task)
+#define IPU_QUEUE_TASK		_IOW('I', 0x2, struct ipu_task)
+#define IPU_ALLOC		_IOWR('I', 0x3, int)
+#define IPU_FREE		_IOW('I', 0x4, int)
+
+#endif
diff --git a/original/uapi/linux/ipv6.h b/original/uapi/linux/ipv6.h
index efa2666..d28c98f 100644
--- a/original/uapi/linux/ipv6.h
+++ b/original/uapi/linux/ipv6.h
@@ -160,10 +160,11 @@ enum {
 	DEVCONF_ACCEPT_DAD,
 	DEVCONF_FORCE_TLLAO,
 	DEVCONF_NDISC_NOTIFY,
+	DEVCONF_ACCEPT_RA_RT_TABLE,
 	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL,
 	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL,
 	DEVCONF_SUPPRESS_FRAG_NDISC,
-	DEVCONF_ACCEPT_RA_FROM_LOCAL,
+	DEVCONF_USE_OPTIMISTIC,
 	DEVCONF_MAX
 };
 
diff --git a/original/uapi/linux/isl29023.h b/original/uapi/linux/isl29023.h
new file mode 100644
index 0000000..9fddf42
--- /dev/null
+++ b/original/uapi/linux/isl29023.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __UAPI_LINUX_ISL29023_H__
+#define __UAPI_LINUX_ISL29023_H__
+
+#include <linux/types.h>
+
+#define ISL29023_PD_MODE	0x0
+#define ISL29023_ALS_ONCE_MODE	0x1
+#define ISL29023_IR_ONCE_MODE	0x2
+#define ISL29023_ALS_CONT_MODE	0x5
+#define ISL29023_IR_CONT_MODE	0x6
+
+#define ISL29023_INT_PERSISTS_1		0x0
+#define ISL29023_INT_PERSISTS_4		0x1
+#define ISL29023_INT_PERSISTS_8		0x2
+#define ISL29023_INT_PERSISTS_16	0x3
+
+#define ISL29023_RES_16		0x0
+#define ISL29023_RES_12		0x1
+#define ISL29023_RES_8		0x2
+#define ISL29023_RES_4		0x3
+
+#define ISL29023_RANGE_1K	0x0
+#define ISL29023_RANGE_4K	0x1
+#define ISL29023_RANGE_16K	0x2
+#define ISL29023_RANGE_64K	0x3
+
+#endif
diff --git a/original/uapi/linux/kernel-page-flags.h b/original/uapi/linux/kernel-page-flags.h
index 2f96d23..5116a0e 100644
--- a/original/uapi/linux/kernel-page-flags.h
+++ b/original/uapi/linux/kernel-page-flags.h
@@ -31,7 +31,6 @@
 
 #define KPF_KSM			21
 #define KPF_THP			22
-#define KPF_BALLOON		23
 
 
 #endif /* _UAPILINUX_KERNEL_PAGE_FLAGS_H */
diff --git a/original/uapi/linux/kexec.h b/original/uapi/linux/kexec.h
index 6925f5b..d6629d4 100644
--- a/original/uapi/linux/kexec.h
+++ b/original/uapi/linux/kexec.h
@@ -13,17 +13,6 @@
 #define KEXEC_PRESERVE_CONTEXT	0x00000002
 #define KEXEC_ARCH_MASK		0xffff0000
 
-/*
- * Kexec file load interface flags.
- * KEXEC_FILE_UNLOAD : Unload already loaded kexec/kdump image.
- * KEXEC_FILE_ON_CRASH : Load/unload operation belongs to kdump image.
- * KEXEC_FILE_NO_INITRAMFS : No initramfs is being loaded. Ignore the initrd
- *                           fd field.
- */
-#define KEXEC_FILE_UNLOAD	0x00000001
-#define KEXEC_FILE_ON_CRASH	0x00000002
-#define KEXEC_FILE_NO_INITRAMFS	0x00000004
-
 /* These values match the ELF architecture values.
  * Unless there is a good reason that should continue to be the case.
  */
diff --git a/original/uapi/linux/kvm.h b/original/uapi/linux/kvm.h
index 6076882..cbc65ee 100644
--- a/original/uapi/linux/kvm.h
+++ b/original/uapi/linux/kvm.h
@@ -162,7 +162,7 @@ struct kvm_pit_config {
 #define KVM_EXIT_TPR_ACCESS       12
 #define KVM_EXIT_S390_SIEIC       13
 #define KVM_EXIT_S390_RESET       14
-#define KVM_EXIT_DCR              15 /* deprecated */
+#define KVM_EXIT_DCR              15
 #define KVM_EXIT_NMI              16
 #define KVM_EXIT_INTERNAL_ERROR   17
 #define KVM_EXIT_OSI              18
@@ -268,7 +268,7 @@ struct kvm_run {
 			__u64 trans_exc_code;
 			__u32 pgm_code;
 		} s390_ucontrol;
-		/* KVM_EXIT_DCR (deprecated) */
+		/* KVM_EXIT_DCR */
 		struct {
 			__u32 dcrn;
 			__u32 data;
@@ -407,10 +407,6 @@ struct kvm_vapic_addr {
 #define KVM_MP_STATE_INIT_RECEIVED     2
 #define KVM_MP_STATE_HALTED            3
 #define KVM_MP_STATE_SIPI_RECEIVED     4
-#define KVM_MP_STATE_STOPPED           5
-#define KVM_MP_STATE_CHECK_STOP        6
-#define KVM_MP_STATE_OPERATING         7
-#define KVM_MP_STATE_LOAD              8
 
 struct kvm_mp_state {
 	__u32 mp_state;
@@ -426,11 +422,7 @@ struct kvm_s390_psw {
 #define KVM_S390_PROGRAM_INT		0xfffe0001u
 #define KVM_S390_SIGP_SET_PREFIX	0xfffe0002u
 #define KVM_S390_RESTART		0xfffe0003u
-#define KVM_S390_INT_PFAULT_INIT	0xfffe0004u
-#define KVM_S390_INT_PFAULT_DONE	0xfffe0005u
 #define KVM_S390_MCHK			0xfffe1000u
-#define KVM_S390_INT_CLOCK_COMP		0xffff1004u
-#define KVM_S390_INT_CPU_TIMER		0xffff1005u
 #define KVM_S390_INT_VIRTIO		0xffff2603u
 #define KVM_S390_INT_SERVICE		0xffff2401u
 #define KVM_S390_INT_EMERGENCY		0xffff1201u
@@ -451,69 +443,6 @@ struct kvm_s390_interrupt {
 	__u64 parm64;
 };
 
-struct kvm_s390_io_info {
-	__u16 subchannel_id;
-	__u16 subchannel_nr;
-	__u32 io_int_parm;
-	__u32 io_int_word;
-};
-
-struct kvm_s390_ext_info {
-	__u32 ext_params;
-	__u32 pad;
-	__u64 ext_params2;
-};
-
-struct kvm_s390_pgm_info {
-	__u64 trans_exc_code;
-	__u64 mon_code;
-	__u64 per_address;
-	__u32 data_exc_code;
-	__u16 code;
-	__u16 mon_class_nr;
-	__u8 per_code;
-	__u8 per_atmid;
-	__u8 exc_access_id;
-	__u8 per_access_id;
-	__u8 op_access_id;
-	__u8 pad[3];
-};
-
-struct kvm_s390_prefix_info {
-	__u32 address;
-};
-
-struct kvm_s390_extcall_info {
-	__u16 code;
-};
-
-struct kvm_s390_emerg_info {
-	__u16 code;
-};
-
-struct kvm_s390_mchk_info {
-	__u64 cr14;
-	__u64 mcic;
-	__u64 failing_storage_address;
-	__u32 ext_damage_code;
-	__u32 pad;
-	__u8 fixed_logout[16];
-};
-
-struct kvm_s390_irq {
-	__u64 type;
-	union {
-		struct kvm_s390_io_info io;
-		struct kvm_s390_ext_info ext;
-		struct kvm_s390_pgm_info pgm;
-		struct kvm_s390_emerg_info emerg;
-		struct kvm_s390_extcall_info extcall;
-		struct kvm_s390_prefix_info prefix;
-		struct kvm_s390_mchk_info mchk;
-		char reserved[64];
-	} u;
-};
-
 /* for KVM_SET_GUEST_DEBUG */
 
 #define KVM_GUESTDBG_ENABLE		0x00000001
@@ -530,7 +459,6 @@ enum {
 	kvm_ioeventfd_flag_nr_pio,
 	kvm_ioeventfd_flag_nr_deassign,
 	kvm_ioeventfd_flag_nr_virtio_ccw_notify,
-	kvm_ioeventfd_flag_nr_fast_mmio,
 	kvm_ioeventfd_flag_nr_max,
 };
 
@@ -545,7 +473,7 @@ enum {
 struct kvm_ioeventfd {
 	__u64 datamatch;
 	__u64 addr;        /* legal pio/mmio address */
-	__u32 len;         /* 1, 2, 4, or 8 bytes; or 0 to ignore length */
+	__u32 len;         /* 1, 2, 4, or 8 bytes    */
 	__s32 fd;
 	__u32 flags;
 	__u8  pad[36];
@@ -752,14 +680,7 @@ struct kvm_ppc_smmu_info {
 #define KVM_CAP_SPAPR_MULTITCE 94
 #define KVM_CAP_EXT_EMUL_CPUID 95
 #define KVM_CAP_HYPERV_TIME 96
-#define KVM_CAP_IOAPIC_POLARITY_IGNORED 97
-#define KVM_CAP_ENABLE_CAP_VM 98
-#define KVM_CAP_S390_IRQCHIP 99
-#define KVM_CAP_IOEVENTFD_NO_LENGTH 100
-#define KVM_CAP_VM_ATTRIBUTES 101
 #define KVM_CAP_ARM_PSCI_0_2 102
-#define KVM_CAP_PPC_FIXUP_HCALL 103
-#define KVM_CAP_PPC_ENABLE_HCALL 104
 #define KVM_CAP_CHECK_EXTENSION_VM 105
 
 #ifdef KVM_CAP_IRQ_ROUTING
@@ -776,18 +697,9 @@ struct kvm_irq_routing_msi {
 	__u32 pad;
 };
 
-struct kvm_irq_routing_s390_adapter {
-	__u64 ind_addr;
-	__u64 summary_addr;
-	__u64 ind_offset;
-	__u32 summary_offset;
-	__u32 adapter_id;
-};
-
 /* gsi routing entry types */
 #define KVM_IRQ_ROUTING_IRQCHIP 1
 #define KVM_IRQ_ROUTING_MSI 2
-#define KVM_IRQ_ROUTING_S390_ADAPTER 3
 
 struct kvm_irq_routing_entry {
 	__u32 gsi;
@@ -797,7 +709,6 @@ struct kvm_irq_routing_entry {
 	union {
 		struct kvm_irq_routing_irqchip irqchip;
 		struct kvm_irq_routing_msi msi;
-		struct kvm_irq_routing_s390_adapter adapter;
 		__u32 pad[8];
 	} u;
 };
@@ -1116,10 +1027,6 @@ struct kvm_s390_ucas_mapping {
 /* Available with KVM_CAP_DEBUGREGS */
 #define KVM_GET_DEBUGREGS         _IOR(KVMIO,  0xa1, struct kvm_debugregs)
 #define KVM_SET_DEBUGREGS         _IOW(KVMIO,  0xa2, struct kvm_debugregs)
-/*
- * vcpu version available with KVM_ENABLE_CAP
- * vm version available with KVM_CAP_ENABLE_CAP_VM
- */
 #define KVM_ENABLE_CAP            _IOW(KVMIO,  0xa3, struct kvm_enable_cap)
 /* Available with KVM_CAP_XSAVE */
 #define KVM_GET_XSAVE		  _IOR(KVMIO,  0xa4, struct kvm_xsave)
diff --git a/original/uapi/linux/kvm_para.h b/original/uapi/linux/kvm_para.h
index bf6cd7d..2841f86 100644
--- a/original/uapi/linux/kvm_para.h
+++ b/original/uapi/linux/kvm_para.h
@@ -20,9 +20,6 @@
 #define KVM_HC_FEATURES			3
 #define KVM_HC_PPC_MAP_MAGIC_PAGE	4
 #define KVM_HC_KICK_CPU			5
-#define KVM_HC_MIPS_GET_CLOCK_FREQ	6
-#define KVM_HC_MIPS_EXIT_VM		7
-#define KVM_HC_MIPS_CONSOLE_OUTPUT	8
 
 /*
  * hypercalls use architecture specific
diff --git a/original/uapi/linux/l2tp.h b/original/uapi/linux/l2tp.h
index 21caa26..8adb681 100644
--- a/original/uapi/linux/l2tp.h
+++ b/original/uapi/linux/l2tp.h
@@ -124,8 +124,6 @@ enum {
 	L2TP_ATTR_STATS,		/* nested */
 	L2TP_ATTR_IP6_SADDR,		/* struct in6_addr */
 	L2TP_ATTR_IP6_DADDR,		/* struct in6_addr */
-	L2TP_ATTR_UDP_ZERO_CSUM6_TX,	/* u8 */
-	L2TP_ATTR_UDP_ZERO_CSUM6_RX,	/* u8 */
 	__L2TP_ATTR_MAX,
 };
 
diff --git a/original/uapi/linux/mxc_asrc.h b/original/uapi/linux/mxc_asrc.h
new file mode 100644
index 0000000..7a2b7df
--- /dev/null
+++ b/original/uapi/linux/mxc_asrc.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ *
+ * @file mxc_asrc.h
+ *
+ * @brief i.MX Asynchronous Sample Rate Converter
+ *
+ * @ingroup Audio
+ */
+
+#ifndef __MXC_ASRC_UAPI_H__
+#define __MXC_ASRC_UAPI_H__
+
+#define ASRC_IOC_MAGIC		'C'
+
+#define ASRC_REQ_PAIR		_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_CONVERT		_IOW(ASRC_IOC_MAGIC, 3, struct asrc_convert_buffer)
+#define ASRC_START_CONV		_IOW(ASRC_IOC_MAGIC, 4, enum asrc_pair_index)
+#define ASRC_STOP_CONV		_IOW(ASRC_IOC_MAGIC, 5, enum asrc_pair_index)
+#define ASRC_STATUS		_IOW(ASRC_IOC_MAGIC, 6, struct asrc_status_flags)
+#define ASRC_FLUSH		_IOW(ASRC_IOC_MAGIC, 7, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_INVALID_PAIR = -1,
+	ASRC_PAIR_A = 0,
+	ASRC_PAIR_B = 1,
+	ASRC_PAIR_C = 2,
+};
+
+#define ASRC_PAIR_MAX_NUM	(ASRC_PAIR_C + 1)
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SSI3_RX = 0x07,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_PAD = 0x06,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SSI3_TX = 0x0b,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SSI3_TX = 0x07,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_PAD = 0x06,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SSI3_RX = 0x0b,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_word_width {
+	ASRC_WIDTH_24_BIT = 0,
+	ASRC_WIDTH_16_BIT = 1,
+	ASRC_WIDTH_8_BIT = 2,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	enum asrc_word_width input_word_width;
+	enum asrc_word_width output_word_width;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_convert_buffer {
+	void *input_buffer_vaddr;
+	void *output_buffer_vaddr;
+	unsigned int input_buffer_length;
+	unsigned int output_buffer_length;
+};
+
+struct asrc_status_flags {
+	enum asrc_pair_index index;
+	unsigned int overload_error;
+};
+
+enum asrc_error_status {
+	ASRC_TASK_Q_OVERLOAD		= 0x01,
+	ASRC_OUTPUT_TASK_OVERLOAD	= 0x02,
+	ASRC_INPUT_TASK_OVERLOAD	= 0x04,
+	ASRC_OUTPUT_BUFFER_OVERFLOW	= 0x08,
+	ASRC_INPUT_BUFFER_UNDERRUN	= 0x10,
+};
+#endif/* __MXC_ASRC_UAPI_H__ */
diff --git a/original/uapi/linux/mxc_dcic.h b/original/uapi/linux/mxc_dcic.h
new file mode 100644
index 0000000..cbcacaa
--- /dev/null
+++ b/original/uapi/linux/mxc_dcic.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file uapi/linux/mxc_dcic.h
+ *
+ * @brief MXC DCIC private header file
+ *
+ * @ingroup MXC DCIC
+ */
+#ifndef __ASM_ARCH_MXC_DCIC_H__
+#define __ASM_ARCH_MXC_DCIC_H__
+
+#define DCIC_IOC_ALLOC_ROI_NUM	_IO('D', 10)
+#define DCIC_IOC_FREE_ROI_NUM	_IO('D', 11)
+#define DCIC_IOC_CONFIG_DCIC	_IO('D', 12)
+#define DCIC_IOC_CONFIG_ROI		_IO('D', 13)
+#define DCIC_IOC_GET_RESULT		_IO('D', 14)
+
+struct roi_params {
+	unsigned int roi_n;
+	unsigned int ref_sig;
+	unsigned int start_y;
+	unsigned int start_x;
+	unsigned int end_y;
+	unsigned int end_x;
+	char freeze;
+};
+
+#endif
diff --git a/original/uapi/linux/mxc_sim_interface.h b/original/uapi/linux/mxc_sim_interface.h
new file mode 100644
index 0000000..9ac3c02
--- /dev/null
+++ b/original/uapi/linux/mxc_sim_interface.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef UAPI_MXC_SIM_INTERFACE_H
+#define UAPI_MXC_SIM_INTERFACE_H
+
+#define SIM_ATR_LENGTH_MAX 32
+
+/* Raw ATR SIM_IOCTL_GET_ATR */
+typedef struct {
+	unsigned int size;/* length of ATR received */
+	unsigned char *atr_buffer;/* raw ATR string received */
+	int errval;/* The error vale reported to user space after completing ATR*/
+} sim_atr_t;
+
+/* ISO7816-3 protocols */
+#define SIM_PROTOCOL_T0  1
+#define SIM_PROTOCOL_T1  2
+
+/* Transfer types for SIM_IOCTL_XFER */
+#define SIM_XFER_TYPE_TPDU 1
+#define SIM_XFER_TYPE_PTS  2
+
+typedef struct {
+	unsigned int wwt;
+	unsigned int cwt;
+	unsigned int bwt;
+	unsigned int bgt;
+	unsigned int cgt;
+} sim_timing_t;
+
+/* Transfer data for SIM_IOCTL_XFER */
+typedef struct {
+	unsigned char *xmt_buffer;	/* transmit buffer pointer */
+	int xmt_length;/* transmit buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after completing transmitting*/
+} sim_xmt_t;
+
+typedef struct {
+	unsigned char *rcv_buffer;	/* receive buffer pointer */
+	int rcv_length;	/* receive buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after receiving*/
+} sim_rcv_t;
+
+typedef struct {
+	unsigned char di;
+	unsigned char fi;
+} sim_baud_t;
+
+/* Interface power states */
+#define SIM_POWER_OFF			(0)
+#define SIM_POWER_ON			(1)
+
+/* Return values for SIM_IOCTL_GET_PRESENSE */
+#define SIM_PRESENT_REMOVED		(0)
+#define SIM_PRESENT_DETECTED		(1)
+#define SIM_PRESENT_OPERATIONAL		(2)
+
+/* The error value */
+#define SIM_OK				(0)
+#define SIM_ERROR_CWT			(1 << 0)
+#define SIM_ERROR_BWT			(1 << 1)
+#define SIM_ERROR_PARITY		(1 << 2)
+#define SIM_ERROR_INVALID_TS		(1 << 3)
+#define SIM_ERROR_FRAME			(1 << 4)
+#define SIM_ERROR_ATR_TIMEROUT		(1 << 5)
+#define SIM_ERROR_NACK_THRESHOLD	(1 << 6)
+#define SIM_ERROR_BGT			(1 << 7)
+#define SIM_ERROR_ATR_DELAY		(1 << 8)
+
+/* Return values for SIM_IOCTL_GET_ERROR */
+#define SIM_E_ACCESS			(1)
+#define SIM_E_TPDUSHORT			(2)
+#define SIM_E_PTSEMPTY			(3)
+#define SIM_E_INVALIDXFERTYPE		(4)
+#define SIM_E_INVALIDXMTLENGTH		(5)
+#define SIM_E_INVALIDRCVLENGTH		(6)
+#define SIM_E_NACK			(7)
+#define SIM_E_TIMEOUT			(8)
+#define SIM_E_NOCARD			(9)
+#define SIM_E_PARAM_FI_INVALID		(10)
+#define SIM_E_PARAM_DI_INVALID		(11)
+#define SIM_E_PARAM_FBYD_WITHFRACTION	(12)
+#define SIM_E_PARAM_FBYD_NOTDIVBY8OR12	(13)
+#define SIM_E_PARAM_DIVISOR_RANGE	(14)
+#define SIM_E_MALLOC			(15)
+#define SIM_E_IRQ			(16)
+#define SIM_E_POWERED_ON		(17)
+#define SIM_E_POWERED_OFF		(18)
+
+/* ioctl encodings */
+#define SIM_IOCTL_BASE			(0xc0)
+#define SIM_IOCTL_GET_PRESENSE		_IOR(SIM_IOCTL_BASE, 1, int)
+#define SIM_IOCTL_GET_ATR		_IOR(SIM_IOCTL_BASE, 2, sim_atr_t)
+#define SIM_IOCTL_XMT			_IOR(SIM_IOCTL_BASE, 3, sim_xmt_t)
+#define SIM_IOCTL_RCV			_IOR(SIM_IOCTL_BASE, 4, sim_rcv_t)
+#define SIM_IOCTL_ACTIVATE		_IO(SIM_IOCTL_BASE, 5)
+#define SIM_IOCTL_DEACTIVATE		_IO(SIM_IOCTL_BASE, 6)
+#define SIM_IOCTL_WARM_RESET		_IO(SIM_IOCTL_BASE, 7)
+#define SIM_IOCTL_COLD_RESET		_IO(SIM_IOCTL_BASE, 8)
+#define SIM_IOCTL_CARD_LOCK		_IO(SIM_IOCTL_BASE, 9)
+#define SIM_IOCTL_CARD_EJECT		_IO(SIM_IOCTL_BASE, 10)
+#define SIM_IOCTL_SET_PROTOCOL		_IOR(SIM_IOCTL_BASE, 11, unsigned int)
+#define SIM_IOCTL_SET_TIMING		_IOR(SIM_IOCTL_BASE, 12, sim_timing_t)
+#define SIM_IOCTL_SET_BAUD		_IOR(SIM_IOCTL_BASE, 13, sim_baud_t)
+#define SIM_IOCTL_WAIT			_IOR(SIM_IOCTL_BASE, 14, unsigned int)
+
+#endif
diff --git a/original/uapi/linux/mxc_v4l2.h b/original/uapi/linux/mxc_v4l2.h
new file mode 100644
index 0000000..49345fe
--- /dev/null
+++ b/original/uapi/linux/mxc_v4l2.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file uapi/linux/mxc_v4l2.h
+ *
+ * @brief MXC V4L2 private header file
+ *
+ * @ingroup MXC V4L2
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+/*
+ * For IPUv1 and IPUv3, V4L2_CID_MXC_ROT means encoder ioctl ID.
+ * And V4L2_CID_MXC_VF_ROT is viewfinder ioctl ID only for IPUv1 and IPUv3.
+ */
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_MXC_VF_ROT		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_MXC_MOTION		(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_MXC_SWITCH_CAM		(V4L2_CID_PRIVATE_BASE + 6)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
diff --git a/original/uapi/linux/mxcfb.h b/original/uapi/linux/mxcfb.h
new file mode 100644
index 0000000..3a98409
--- /dev/null
+++ b/original/uapi/linux/mxcfb.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * @file uapi/linux/mxcfb.h
+ *
+ * @brief Global header file for the MXC frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_LOW_ACT	0x80000000
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+#define FB_ACCEL_TRIPLE_FLAG	0x00000000
+#define FB_ACCEL_DOUBLE_FLAG	0x00000001
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_loc_alpha {
+	int enable;
+	int alpha_in_pixel;
+	unsigned long alpha_phy_addr0;
+	unsigned long alpha_phy_addr1;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+struct mxcfb_gamma {
+	int enable;
+	int constk[16];
+	int slopek[16];
+};
+
+struct mxcfb_gpu_split_fmt {
+	struct fb_var_screeninfo var;
+	unsigned long offset;
+};
+
+struct mxcfb_rect {
+	__u32 top;
+	__u32 left;
+	__u32 width;
+	__u32 height;
+};
+
+#define GRAYSCALE_8BIT				0x1
+#define GRAYSCALE_8BIT_INVERTED			0x2
+#define GRAYSCALE_4BIT                          0x3
+#define GRAYSCALE_4BIT_INVERTED                 0x4
+
+#define AUTO_UPDATE_MODE_REGION_MODE		0
+#define AUTO_UPDATE_MODE_AUTOMATIC_MODE		1
+
+#define UPDATE_SCHEME_SNAPSHOT			0
+#define UPDATE_SCHEME_QUEUE			1
+#define UPDATE_SCHEME_QUEUE_AND_MERGE		2
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define WAVEFORM_MODE_GLR16			4
+#define WAVEFORM_MODE_GLD16			5
+#define WAVEFORM_MODE_AUTO			257
+
+#define TEMP_USE_AMBIENT			0x1000
+
+#define EPDC_FLAG_ENABLE_INVERSION		0x01
+#define EPDC_FLAG_FORCE_MONOCHROME		0x02
+#define EPDC_FLAG_USE_CMAP			0x04
+#define EPDC_FLAG_USE_ALT_BUFFER		0x100
+#define EPDC_FLAG_TEST_COLLISION		0x200
+#define EPDC_FLAG_GROUP_UPDATE			0x400
+#define EPDC_FLAG_USE_DITHERING_Y1		0x2000
+#define EPDC_FLAG_USE_DITHERING_Y4		0x4000
+#define EPDC_FLAG_USE_REGAL				0x8000
+
+enum mxcfb_dithering_mode {
+	EPDC_FLAG_USE_DITHERING_PASSTHROUGH = 0x0,
+	EPDC_FLAG_USE_DITHERING_FLOYD_STEINBERG,
+	EPDC_FLAG_USE_DITHERING_ATKINSON,
+	EPDC_FLAG_USE_DITHERING_ORDERED,
+	EPDC_FLAG_USE_DITHERING_QUANT_ONLY,
+	EPDC_FLAG_USE_DITHERING_MAX,
+};
+
+#define FB_POWERDOWN_DISABLE			-1
+
+struct mxcfb_alt_buffer_data {
+	__u32 phys_addr;
+	__u32 width;	/* width of entire buffer */
+	__u32 height;	/* height of entire buffer */
+	struct mxcfb_rect alt_update_region;	/* region within buffer to update */
+};
+
+struct mxcfb_update_data {
+	struct mxcfb_rect update_region;
+	__u32 waveform_mode;
+	__u32 update_mode;
+	__u32 update_marker;
+	int temp;
+	unsigned int flags;
+	int dither_mode;
+	int quant_bit;
+	struct mxcfb_alt_buffer_data alt_buffer_data;
+};
+
+struct mxcfb_update_marker_data {
+	__u32 update_marker;
+	__u32 collision_test;
+};
+
+/*
+ * Structure used to define waveform modes for driver
+ * Needed for driver to perform auto-waveform selection
+ */
+struct mxcfb_waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+/*
+ * Structure used to define a 5*3 matrix of parameters for
+ * setting IPU DP CSC module related to this framebuffer.
+ */
+struct mxcfb_csc_matrix {
+	int param[5][3];
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOWR('F', 0x24, struct mxcfb_pos)
+#define MXCFB_GET_FB_IPU_CHAN 	_IOR('F', 0x25, u_int32_t)
+#define MXCFB_SET_LOC_ALPHA     _IOWR('F', 0x26, struct mxcfb_loc_alpha)
+#define MXCFB_SET_LOC_ALP_BUF    _IOW('F', 0x27, unsigned long)
+#define MXCFB_SET_GAMMA	       _IOW('F', 0x28, struct mxcfb_gamma)
+#define MXCFB_GET_FB_IPU_DI 	_IOR('F', 0x29, u_int32_t)
+#define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
+#define MXCFB_GET_FB_BLANK     _IOR('F', 0x2B, u_int32_t)
+#define MXCFB_SET_DIFMT		_IOW('F', 0x2C, u_int32_t)
+#define MXCFB_CSC_UPDATE	_IOW('F', 0x2D, struct mxcfb_csc_matrix)
+#define MXCFB_SET_GPU_SPLIT_FMT	_IOW('F', 0x2F, struct mxcfb_gpu_split_fmt)
+#define MXCFB_SET_PREFETCH	_IOW('F', 0x30, int)
+#define MXCFB_GET_PREFETCH	_IOR('F', 0x31, int)
+
+/* IOCTLs for E-ink panel updates */
+#define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
+#define MXCFB_SET_TEMPERATURE		_IOW('F', 0x2C, int32_t)
+#define MXCFB_SET_AUTO_UPDATE_MODE	_IOW('F', 0x2D, __u32)
+#define MXCFB_SEND_UPDATE		_IOW('F', 0x2E, struct mxcfb_update_data)
+#define MXCFB_WAIT_FOR_UPDATE_COMPLETE	_IOWR('F', 0x2F, struct mxcfb_update_marker_data)
+#define MXCFB_SET_PWRDOWN_DELAY		_IOW('F', 0x30, int32_t)
+#define MXCFB_GET_PWRDOWN_DELAY		_IOR('F', 0x31, int32_t)
+#define MXCFB_SET_UPDATE_SCHEME		_IOW('F', 0x32, __u32)
+#define MXCFB_GET_WORK_BUFFER		_IOWR('F', 0x34, unsigned long)
+#define MXCFB_DISABLE_EPDC_ACCESS	_IO('F', 0x35)
+#define MXCFB_ENABLE_EPDC_ACCESS	_IO('F', 0x36)
+#endif
diff --git a/original/uapi/linux/neighbour.h b/original/uapi/linux/neighbour.h
index 4a1d7e9..d3ef583 100644
--- a/original/uapi/linux/neighbour.h
+++ b/original/uapi/linux/neighbour.h
@@ -24,7 +24,6 @@ enum {
 	NDA_PORT,
 	NDA_VNI,
 	NDA_IFINDEX,
-	NDA_MASTER,
 	__NDA_MAX
 };
 
diff --git a/original/uapi/linux/net_tstamp.h b/original/uapi/linux/net_tstamp.h
index ff35402..f53879c 100644
--- a/original/uapi/linux/net_tstamp.h
+++ b/original/uapi/linux/net_tstamp.h
@@ -20,13 +20,9 @@ enum {
 	SOF_TIMESTAMPING_SOFTWARE = (1<<4),
 	SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),
 	SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),
-	SOF_TIMESTAMPING_OPT_ID = (1<<7),
-	SOF_TIMESTAMPING_TX_SCHED = (1<<8),
-	SOF_TIMESTAMPING_TX_ACK = (1<<9),
-
-	SOF_TIMESTAMPING_LAST = SOF_TIMESTAMPING_TX_ACK,
-	SOF_TIMESTAMPING_MASK = (SOF_TIMESTAMPING_LAST - 1) |
-				 SOF_TIMESTAMPING_LAST
+	SOF_TIMESTAMPING_MASK =
+	(SOF_TIMESTAMPING_RAW_HARDWARE - 1) |
+	SOF_TIMESTAMPING_RAW_HARDWARE
 };
 
 /**
diff --git a/original/uapi/linux/netdevice.h b/original/uapi/linux/netdevice.h
index 5581854..6b9500b 100644
--- a/original/uapi/linux/netdevice.h
+++ b/original/uapi/linux/netdevice.h
@@ -37,12 +37,6 @@
 #define INIT_NETDEV_GROUP	0
 
 
-/* interface name assignment types (sysfs name_assign_type attribute) */
-#define NET_NAME_UNKNOWN	0	/* unknown origin (not exposed to userspace) */
-#define NET_NAME_ENUM		1	/* enumerated by kernel */
-#define NET_NAME_PREDICTABLE	2	/* predictably named by the kernel */
-#define NET_NAME_USER		3	/* provided by user-space */
-#define NET_NAME_RENAMED	4	/* renamed by user-space */
 
 /* Media selection options. */
 enum {
@@ -55,11 +49,5 @@ enum {
         IF_PORT_100BASEFX
 };
 
-/* hardware address assignment types */
-#define NET_ADDR_PERM		0	/* address is permanent (default) */
-#define NET_ADDR_RANDOM		1	/* address is generated randomly */
-#define NET_ADDR_STOLEN		2	/* address is stolen from other device */
-#define NET_ADDR_SET		3	/* address is set using
-					 * dev_set_mac_address() */
 
 #endif /* _UAPI_LINUX_NETDEVICE_H */
diff --git a/original/uapi/linux/netfilter/ipset/ip_set.h b/original/uapi/linux/netfilter/ipset/ip_set.h
index ca03119..25d3b2f 100644
--- a/original/uapi/linux/netfilter/ipset/ip_set.h
+++ b/original/uapi/linux/netfilter/ipset/ip_set.h
@@ -82,8 +82,6 @@ enum {
 	IPSET_ATTR_PROTO,	/* 7 */
 	IPSET_ATTR_CADT_FLAGS,	/* 8 */
 	IPSET_ATTR_CADT_LINENO = IPSET_ATTR_LINENO,	/* 9 */
-	IPSET_ATTR_MARK,	/* 10 */
-	IPSET_ATTR_MARKMASK,	/* 11 */
 	/* Reserve empty slots */
 	IPSET_ATTR_CADT_MAX = 16,
 	/* Create-only specific attributes */
@@ -115,9 +113,6 @@ enum {
 	IPSET_ATTR_BYTES,
 	IPSET_ATTR_PACKETS,
 	IPSET_ATTR_COMMENT,
-	IPSET_ATTR_SKBMARK,
-	IPSET_ATTR_SKBPRIO,
-	IPSET_ATTR_SKBQUEUE,
 	__IPSET_ATTR_ADT_MAX,
 };
 #define IPSET_ATTR_ADT_MAX	(__IPSET_ATTR_ADT_MAX - 1)
@@ -149,8 +144,6 @@ enum ipset_errno {
 	IPSET_ERR_IPADDR_IPV6,
 	IPSET_ERR_COUNTER,
 	IPSET_ERR_COMMENT,
-	IPSET_ERR_INVALID_MARKMASK,
-	IPSET_ERR_SKBINFO,
 
 	/* Type specific error codes */
 	IPSET_ERR_TYPE_SPECIFIC = 4352,
@@ -174,12 +167,6 @@ enum ipset_cmd_flags {
 	IPSET_FLAG_MATCH_COUNTERS = (1 << IPSET_FLAG_BIT_MATCH_COUNTERS),
 	IPSET_FLAG_BIT_RETURN_NOMATCH = 7,
 	IPSET_FLAG_RETURN_NOMATCH = (1 << IPSET_FLAG_BIT_RETURN_NOMATCH),
-	IPSET_FLAG_BIT_MAP_SKBMARK = 8,
-	IPSET_FLAG_MAP_SKBMARK = (1 << IPSET_FLAG_BIT_MAP_SKBMARK),
-	IPSET_FLAG_BIT_MAP_SKBPRIO = 9,
-	IPSET_FLAG_MAP_SKBPRIO = (1 << IPSET_FLAG_BIT_MAP_SKBPRIO),
-	IPSET_FLAG_BIT_MAP_SKBQUEUE = 10,
-	IPSET_FLAG_MAP_SKBQUEUE = (1 << IPSET_FLAG_BIT_MAP_SKBQUEUE),
 	IPSET_FLAG_CMD_MAX = 15,
 };
 
@@ -195,20 +182,9 @@ enum ipset_cadt_flags {
 	IPSET_FLAG_WITH_COUNTERS = (1 << IPSET_FLAG_BIT_WITH_COUNTERS),
 	IPSET_FLAG_BIT_WITH_COMMENT = 4,
 	IPSET_FLAG_WITH_COMMENT = (1 << IPSET_FLAG_BIT_WITH_COMMENT),
-	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
-	IPSET_FLAG_WITH_FORCEADD = (1 << IPSET_FLAG_BIT_WITH_FORCEADD),
-	IPSET_FLAG_BIT_WITH_SKBINFO = 6,
-	IPSET_FLAG_WITH_SKBINFO = (1 << IPSET_FLAG_BIT_WITH_SKBINFO),
 	IPSET_FLAG_CADT_MAX	= 15,
 };
 
-/* The flag bits which correspond to the non-extension create flags */
-enum ipset_create_flags {
-	IPSET_CREATE_FLAG_BIT_FORCEADD = 0,
-	IPSET_CREATE_FLAG_FORCEADD = (1 << IPSET_CREATE_FLAG_BIT_FORCEADD),
-	IPSET_CREATE_FLAG_BIT_MAX = 7,
-};
-
 /* Commands with settype-specific attributes */
 enum ipset_adt {
 	IPSET_ADD,
diff --git a/original/uapi/linux/netfilter/nf_nat.h b/original/uapi/linux/netfilter/nf_nat.h
index 0880781..1ad3659 100644
--- a/original/uapi/linux/netfilter/nf_nat.h
+++ b/original/uapi/linux/netfilter/nf_nat.h
@@ -13,11 +13,6 @@
 #define NF_NAT_RANGE_PROTO_RANDOM_ALL		\
 	(NF_NAT_RANGE_PROTO_RANDOM | NF_NAT_RANGE_PROTO_RANDOM_FULLY)
 
-#define NF_NAT_RANGE_MASK					\
-	(NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED |	\
-	 NF_NAT_RANGE_PROTO_RANDOM | NF_NAT_RANGE_PERSISTENT |	\
-	 NF_NAT_RANGE_PROTO_RANDOM_FULLY)
-
 struct nf_nat_ipv4_range {
 	unsigned int			flags;
 	__be32				min_ip;
diff --git a/original/uapi/linux/netfilter/nf_tables.h b/original/uapi/linux/netfilter/nf_tables.h
index f31fe7b..83c985a 100644
--- a/original/uapi/linux/netfilter/nf_tables.h
+++ b/original/uapi/linux/netfilter/nf_tables.h
@@ -1,8 +1,7 @@
 #ifndef _LINUX_NF_TABLES_H
 #define _LINUX_NF_TABLES_H
 
-#define NFT_CHAIN_MAXNAMELEN	32
-#define NFT_USERDATA_MAXLEN	256
+#define NFT_CHAIN_MAXNAMELEN 32
 
 enum nft_registers {
 	NFT_REG_VERDICT,
@@ -51,8 +50,6 @@ enum nft_verdicts {
  * @NFT_MSG_NEWSETELEM: create a new set element (enum nft_set_elem_attributes)
  * @NFT_MSG_GETSETELEM: get a set element (enum nft_set_elem_attributes)
  * @NFT_MSG_DELSETELEM: delete a set element (enum nft_set_elem_attributes)
- * @NFT_MSG_NEWGEN: announce a new generation, only for events (enum nft_gen_attributes)
- * @NFT_MSG_GETGEN: get the rule-set generation (enum nft_gen_attributes)
  */
 enum nf_tables_msg_types {
 	NFT_MSG_NEWTABLE,
@@ -70,8 +67,6 @@ enum nf_tables_msg_types {
 	NFT_MSG_NEWSETELEM,
 	NFT_MSG_GETSETELEM,
 	NFT_MSG_DELSETELEM,
-	NFT_MSG_NEWGEN,
-	NFT_MSG_GETGEN,
 	NFT_MSG_MAX,
 };
 
@@ -161,7 +156,6 @@ enum nft_chain_attributes {
  * @NFTA_RULE_EXPRESSIONS: list of expressions (NLA_NESTED: nft_expr_attributes)
  * @NFTA_RULE_COMPAT: compatibility specifications of the rule (NLA_NESTED: nft_rule_compat_attributes)
  * @NFTA_RULE_POSITION: numeric handle of the previous rule (NLA_U64)
- * @NFTA_RULE_USERDATA: user data (NLA_BINARY, NFT_USERDATA_MAXLEN)
  */
 enum nft_rule_attributes {
 	NFTA_RULE_UNSPEC,
@@ -171,7 +165,6 @@ enum nft_rule_attributes {
 	NFTA_RULE_EXPRESSIONS,
 	NFTA_RULE_COMPAT,
 	NFTA_RULE_POSITION,
-	NFTA_RULE_USERDATA,
 	__NFTA_RULE_MAX
 };
 #define NFTA_RULE_MAX		(__NFTA_RULE_MAX - 1)
@@ -216,29 +209,6 @@ enum nft_set_flags {
 };
 
 /**
- * enum nft_set_policies - set selection policy
- *
- * @NFT_SET_POL_PERFORMANCE: prefer high performance over low memory use
- * @NFT_SET_POL_MEMORY: prefer low memory use over high performance
- */
-enum nft_set_policies {
-	NFT_SET_POL_PERFORMANCE,
-	NFT_SET_POL_MEMORY,
-};
-
-/**
- * enum nft_set_desc_attributes - set element description
- *
- * @NFTA_SET_DESC_SIZE: number of elements in set (NLA_U32)
- */
-enum nft_set_desc_attributes {
-	NFTA_SET_DESC_UNSPEC,
-	NFTA_SET_DESC_SIZE,
-	__NFTA_SET_DESC_MAX
-};
-#define NFTA_SET_DESC_MAX	(__NFTA_SET_DESC_MAX - 1)
-
-/**
  * enum nft_set_attributes - nf_tables set netlink attributes
  *
  * @NFTA_SET_TABLE: table name (NLA_STRING)
@@ -248,9 +218,6 @@ enum nft_set_desc_attributes {
  * @NFTA_SET_KEY_LEN: key data length (NLA_U32)
  * @NFTA_SET_DATA_TYPE: mapping data type (NLA_U32)
  * @NFTA_SET_DATA_LEN: mapping data length (NLA_U32)
- * @NFTA_SET_POLICY: selection policy (NLA_U32)
- * @NFTA_SET_DESC: set description (NLA_NESTED)
- * @NFTA_SET_ID: uniquely identifies a set in a transaction (NLA_U32)
  */
 enum nft_set_attributes {
 	NFTA_SET_UNSPEC,
@@ -261,9 +228,6 @@ enum nft_set_attributes {
 	NFTA_SET_KEY_LEN,
 	NFTA_SET_DATA_TYPE,
 	NFTA_SET_DATA_LEN,
-	NFTA_SET_POLICY,
-	NFTA_SET_DESC,
-	NFTA_SET_ID,
 	__NFTA_SET_MAX
 };
 #define NFTA_SET_MAX		(__NFTA_SET_MAX - 1)
@@ -299,14 +263,12 @@ enum nft_set_elem_attributes {
  * @NFTA_SET_ELEM_LIST_TABLE: table of the set to be changed (NLA_STRING)
  * @NFTA_SET_ELEM_LIST_SET: name of the set to be changed (NLA_STRING)
  * @NFTA_SET_ELEM_LIST_ELEMENTS: list of set elements (NLA_NESTED: nft_set_elem_attributes)
- * @NFTA_SET_ELEM_LIST_SET_ID: uniquely identifies a set in a transaction (NLA_U32)
  */
 enum nft_set_elem_list_attributes {
 	NFTA_SET_ELEM_LIST_UNSPEC,
 	NFTA_SET_ELEM_LIST_TABLE,
 	NFTA_SET_ELEM_LIST_SET,
 	NFTA_SET_ELEM_LIST_ELEMENTS,
-	NFTA_SET_ELEM_LIST_SET_ID,
 	__NFTA_SET_ELEM_LIST_MAX
 };
 #define NFTA_SET_ELEM_LIST_MAX	(__NFTA_SET_ELEM_LIST_MAX - 1)
@@ -492,14 +454,12 @@ enum nft_cmp_attributes {
  * @NFTA_LOOKUP_SET: name of the set where to look for (NLA_STRING)
  * @NFTA_LOOKUP_SREG: source register of the data to look for (NLA_U32: nft_registers)
  * @NFTA_LOOKUP_DREG: destination register (NLA_U32: nft_registers)
- * @NFTA_LOOKUP_SET_ID: uniquely identifies a set in a transaction (NLA_U32)
  */
 enum nft_lookup_attributes {
 	NFTA_LOOKUP_UNSPEC,
 	NFTA_LOOKUP_SET,
 	NFTA_LOOKUP_SREG,
 	NFTA_LOOKUP_DREG,
-	NFTA_LOOKUP_SET_ID,
 	__NFTA_LOOKUP_MAX
 };
 #define NFTA_LOOKUP_MAX		(__NFTA_LOOKUP_MAX - 1)
@@ -573,12 +533,6 @@ enum nft_exthdr_attributes {
  * @NFT_META_SECMARK: packet secmark (skb->secmark)
  * @NFT_META_NFPROTO: netfilter protocol
  * @NFT_META_L4PROTO: layer 4 protocol number
- * @NFT_META_BRI_IIFNAME: packet input bridge interface name
- * @NFT_META_BRI_OIFNAME: packet output bridge interface name
- * @NFT_META_PKTTYPE: packet type (skb->pkt_type), special handling for loopback
- * @NFT_META_CPU: cpu id through smp_processor_id()
- * @NFT_META_IIFGROUP: packet input interface group
- * @NFT_META_OIFGROUP: packet output interface group
  */
 enum nft_meta_keys {
 	NFT_META_LEN,
@@ -598,12 +552,6 @@ enum nft_meta_keys {
 	NFT_META_SECMARK,
 	NFT_META_NFPROTO,
 	NFT_META_L4PROTO,
-	NFT_META_BRI_IIFNAME,
-	NFT_META_BRI_OIFNAME,
-	NFT_META_PKTTYPE,
-	NFT_META_CPU,
-	NFT_META_IIFGROUP,
-	NFT_META_OIFGROUP,
 };
 
 /**
@@ -653,7 +601,6 @@ enum nft_ct_keys {
 	NFT_CT_PROTOCOL,
 	NFT_CT_PROTO_SRC,
 	NFT_CT_PROTO_DST,
-	NFT_CT_LABELS,
 };
 
 /**
@@ -709,8 +656,6 @@ enum nft_counter_attributes {
  * @NFTA_LOG_PREFIX: prefix to prepend to log messages (NLA_STRING)
  * @NFTA_LOG_SNAPLEN: length of payload to include in netlink message (NLA_U32)
  * @NFTA_LOG_QTHRESHOLD: queue threshold (NLA_U32)
- * @NFTA_LOG_LEVEL: log level (NLA_U32)
- * @NFTA_LOG_FLAGS: logging flags (NLA_U32)
  */
 enum nft_log_attributes {
 	NFTA_LOG_UNSPEC,
@@ -718,8 +663,6 @@ enum nft_log_attributes {
 	NFTA_LOG_PREFIX,
 	NFTA_LOG_SNAPLEN,
 	NFTA_LOG_QTHRESHOLD,
-	NFTA_LOG_LEVEL,
-	NFTA_LOG_FLAGS,
 	__NFTA_LOG_MAX
 };
 #define NFTA_LOG_MAX		(__NFTA_LOG_MAX - 1)
@@ -749,32 +692,11 @@ enum nft_queue_attributes {
  *
  * @NFT_REJECT_ICMP_UNREACH: reject using ICMP unreachable
  * @NFT_REJECT_TCP_RST: reject using TCP RST
- * @NFT_REJECT_ICMPX_UNREACH: abstracted ICMP unreachable for bridge and inet
  */
 enum nft_reject_types {
 	NFT_REJECT_ICMP_UNREACH,
 	NFT_REJECT_TCP_RST,
-	NFT_REJECT_ICMPX_UNREACH,
-};
-
-/**
- * enum nft_reject_code - Generic reject codes for IPv4/IPv6
- *
- * @NFT_REJECT_ICMPX_NO_ROUTE: no route to host / network unreachable
- * @NFT_REJECT_ICMPX_PORT_UNREACH: port unreachable
- * @NFT_REJECT_ICMPX_HOST_UNREACH: host unreachable
- * @NFT_REJECT_ICMPX_ADMIN_PROHIBITED: administratively prohibited
- *
- * These codes are mapped to real ICMP and ICMPv6 codes.
- */
-enum nft_reject_inet_code {
-	NFT_REJECT_ICMPX_NO_ROUTE	= 0,
-	NFT_REJECT_ICMPX_PORT_UNREACH,
-	NFT_REJECT_ICMPX_HOST_UNREACH,
-	NFT_REJECT_ICMPX_ADMIN_PROHIBITED,
-	__NFT_REJECT_ICMPX_MAX
 };
-#define NFT_REJECT_ICMPX_MAX	(__NFT_REJECT_ICMPX_MAX - 1)
 
 /**
  * enum nft_reject_attributes - nf_tables reject expression netlink attributes
@@ -810,7 +732,6 @@ enum nft_nat_types {
  * @NFTA_NAT_REG_ADDR_MAX: source register of address range end (NLA_U32: nft_registers)
  * @NFTA_NAT_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
  * @NFTA_NAT_REG_PROTO_MAX: source register of proto range end (NLA_U32: nft_registers)
- * @NFTA_NAT_FLAGS: NAT flags (see NF_NAT_RANGE_* in linux/netfilter/nf_nat.h) (NLA_U32)
  */
 enum nft_nat_attributes {
 	NFTA_NAT_UNSPEC,
@@ -820,33 +741,8 @@ enum nft_nat_attributes {
 	NFTA_NAT_REG_ADDR_MAX,
 	NFTA_NAT_REG_PROTO_MIN,
 	NFTA_NAT_REG_PROTO_MAX,
-	NFTA_NAT_FLAGS,
 	__NFTA_NAT_MAX
 };
 #define NFTA_NAT_MAX		(__NFTA_NAT_MAX - 1)
 
-/**
- * enum nft_masq_attributes - nf_tables masquerade expression attributes
- *
- * @NFTA_MASQ_FLAGS: NAT flags (see NF_NAT_RANGE_* in linux/netfilter/nf_nat.h) (NLA_U32)
- */
-enum nft_masq_attributes {
-	NFTA_MASQ_UNSPEC,
-	NFTA_MASQ_FLAGS,
-	__NFTA_MASQ_MAX
-};
-#define NFTA_MASQ_MAX		(__NFTA_MASQ_MAX - 1)
-
-/**
- * enum nft_gen_attributes - nf_tables ruleset generation attributes
- *
- * @NFTA_GEN_ID: Ruleset generation ID (NLA_U32)
- */
-enum nft_gen_attributes {
-	NFTA_GEN_UNSPEC,
-	NFTA_GEN_ID,
-	__NFTA_GEN_MAX
-};
-#define NFTA_GEN_MAX		(__NFTA_GEN_MAX - 1)
-
 #endif /* _LINUX_NF_TABLES_H */
diff --git a/original/uapi/linux/netfilter/nfnetlink.h b/original/uapi/linux/netfilter/nfnetlink.h
index 354a7e5..596ddd4 100644
--- a/original/uapi/linux/netfilter/nfnetlink.h
+++ b/original/uapi/linux/netfilter/nfnetlink.h
@@ -20,8 +20,6 @@ enum nfnetlink_groups {
 #define NFNLGRP_CONNTRACK_EXP_DESTROY	NFNLGRP_CONNTRACK_EXP_DESTROY
 	NFNLGRP_NFTABLES,
 #define NFNLGRP_NFTABLES                NFNLGRP_NFTABLES
-	NFNLGRP_ACCT_QUOTA,
-#define NFNLGRP_ACCT_QUOTA		NFNLGRP_ACCT_QUOTA
 	__NFNLGRP_MAX,
 };
 #define NFNLGRP_MAX	(__NFNLGRP_MAX - 1)
diff --git a/original/uapi/linux/netfilter/nfnetlink_acct.h b/original/uapi/linux/netfilter/nfnetlink_acct.h
index f3e34db..c7b6269 100644
--- a/original/uapi/linux/netfilter/nfnetlink_acct.h
+++ b/original/uapi/linux/netfilter/nfnetlink_acct.h
@@ -10,35 +10,18 @@ enum nfnl_acct_msg_types {
 	NFNL_MSG_ACCT_GET,
 	NFNL_MSG_ACCT_GET_CTRZERO,
 	NFNL_MSG_ACCT_DEL,
-	NFNL_MSG_ACCT_OVERQUOTA,
 	NFNL_MSG_ACCT_MAX
 };
 
-enum nfnl_acct_flags {
-	NFACCT_F_QUOTA_PKTS	= (1 << 0),
-	NFACCT_F_QUOTA_BYTES	= (1 << 1),
-	NFACCT_F_OVERQUOTA	= (1 << 2), /* can't be set from userspace */
-};
-
 enum nfnl_acct_type {
 	NFACCT_UNSPEC,
 	NFACCT_NAME,
 	NFACCT_PKTS,
 	NFACCT_BYTES,
 	NFACCT_USE,
-	NFACCT_FLAGS,
-	NFACCT_QUOTA,
-	NFACCT_FILTER,
 	__NFACCT_MAX
 };
 #define NFACCT_MAX (__NFACCT_MAX - 1)
 
-enum nfnl_attr_filter_type {
-	NFACCT_FILTER_UNSPEC,
-	NFACCT_FILTER_MASK,
-	NFACCT_FILTER_VALUE,
-	__NFACCT_FILTER_MAX
-};
-#define NFACCT_FILTER_MAX (__NFACCT_FILTER_MAX - 1)
 
 #endif /* _UAPI_NFNL_ACCT_H_ */
diff --git a/original/uapi/linux/netfilter/xt_IDLETIMER.h b/original/uapi/linux/netfilter/xt_IDLETIMER.h
index 208ae93..faaa28b 100644
--- a/original/uapi/linux/netfilter/xt_IDLETIMER.h
+++ b/original/uapi/linux/netfilter/xt_IDLETIMER.h
@@ -4,6 +4,7 @@
  * Header file for Xtables timer target module.
  *
  * Copyright (C) 2004, 2010 Nokia Corporation
+ *
  * Written by Timo Teras <ext-timo.teras@nokia.com>
  *
  * Converted to x_tables and forward-ported to 2.6.34
@@ -32,12 +33,19 @@
 #include <linux/types.h>
 
 #define MAX_IDLETIMER_LABEL_SIZE 28
+#define NLMSG_MAX_SIZE 64
+
+#define NL_EVENT_TYPE_INACTIVE 0
+#define NL_EVENT_TYPE_ACTIVE 1
 
 struct idletimer_tg_info {
 	__u32 timeout;
 
 	char label[MAX_IDLETIMER_LABEL_SIZE];
 
+	/* Use netlink messages for notification in addition to sysfs */
+	__u8 send_nl_msg;
+
 	/* for kernel module internal use only */
 	struct idletimer_tg *timer __attribute__((aligned(8)));
 };
diff --git a/original/uapi/linux/netfilter/xt_bpf.h b/original/uapi/linux/netfilter/xt_bpf.h
index 1fad2c2..2ec9fbc 100644
--- a/original/uapi/linux/netfilter/xt_bpf.h
+++ b/original/uapi/linux/netfilter/xt_bpf.h
@@ -6,14 +6,14 @@
 
 #define XT_BPF_MAX_NUM_INSTR	64
 
-struct bpf_prog;
+struct sk_filter;
 
 struct xt_bpf_info {
 	__u16 bpf_program_num_elem;
 	struct sock_filter bpf_program[XT_BPF_MAX_NUM_INSTR];
 
 	/* only used in the kernel */
-	struct bpf_prog *filter __attribute__((aligned(8)));
+	struct sk_filter *filter __attribute__((aligned(8)));
 };
 
 #endif /*_XT_BPF_H */
diff --git a/original/uapi/linux/netfilter/xt_set.h b/original/uapi/linux/netfilter/xt_set.h
index d6a1df1..964d3d4 100644
--- a/original/uapi/linux/netfilter/xt_set.h
+++ b/original/uapi/linux/netfilter/xt_set.h
@@ -71,14 +71,4 @@ struct xt_set_info_match_v3 {
 	__u32 flags;
 };
 
-/* Revision 3 target */
-
-struct xt_set_info_target_v3 {
-	struct xt_set_info add_set;
-	struct xt_set_info del_set;
-	struct xt_set_info map_set;
-	__u32 flags;
-	__u32 timeout;
-};
-
 #endif /*_XT_SET_H*/
diff --git a/original/uapi/linux/netfilter/xt_socket.h b/original/uapi/linux/netfilter/xt_socket.h
index 6315e2a..55076a3 100644
--- a/original/uapi/linux/netfilter/xt_socket.h
+++ b/original/uapi/linux/netfilter/xt_socket.h
@@ -18,4 +18,9 @@ struct xt_socket_mtinfo2 {
 };
 #define XT_SOCKET_FLAGS_V2 (XT_SOCKET_TRANSPARENT | XT_SOCKET_NOWILDCARD)
 
+struct sock *xt_socket_get4_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+struct sock *xt_socket_get6_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+
 #endif /* _XT_SOCKET_H */
diff --git a/original/uapi/linux/netfilter_arp/arpt_mangle.h b/original/uapi/linux/netfilter_arp/arpt_mangle.h
index 8c2b16a..250f502 100644
--- a/original/uapi/linux/netfilter_arp/arpt_mangle.h
+++ b/original/uapi/linux/netfilter_arp/arpt_mangle.h
@@ -13,7 +13,7 @@ struct arpt_mangle
 	union {
 		struct in_addr tgt_ip;
 	} u_t;
-	__u8 flags;
+	u_int8_t flags;
 	int target;
 };
 
diff --git a/original/uapi/linux/nfc.h b/original/uapi/linux/nfc.h
index 9b19b44..6ad6cc0 100644
--- a/original/uapi/linux/nfc.h
+++ b/original/uapi/linux/nfc.h
@@ -150,8 +150,6 @@ enum nfc_commands {
  * @NFC_ATTR_SE_TYPE: Secure element type (UICC or EMBEDDED)
  * @NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS: Firmware download operation status
  * @NFC_ATTR_APDU: Secure element APDU
- * @NFC_ATTR_TARGET_ISO15693_DSFID: ISO 15693 Data Storage Format Identifier
- * @NFC_ATTR_TARGET_ISO15693_UID: ISO 15693 Unique Identifier
  */
 enum nfc_attrs {
 	NFC_ATTR_UNSPEC,
@@ -180,8 +178,6 @@ enum nfc_attrs {
 	NFC_ATTR_SE_AID,
 	NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS,
 	NFC_ATTR_SE_APDU,
-	NFC_ATTR_TARGET_ISO15693_DSFID,
-	NFC_ATTR_TARGET_ISO15693_UID,
 /* private: internal use only */
 	__NFC_ATTR_AFTER_LAST
 };
@@ -204,7 +200,6 @@ enum nfc_sdp_attr {
 #define NFC_SENSF_RES_MAXSIZE 18
 #define NFC_GB_MAXSIZE        48
 #define NFC_FIRMWARE_NAME_MAXSIZE 32
-#define NFC_ISO15693_UID_MAXSIZE 8
 
 /* NFC protocols */
 #define NFC_PROTO_JEWEL		1
@@ -213,9 +208,8 @@ enum nfc_sdp_attr {
 #define NFC_PROTO_ISO14443	4
 #define NFC_PROTO_NFC_DEP	5
 #define NFC_PROTO_ISO14443_B	6
-#define NFC_PROTO_ISO15693	7
 
-#define NFC_PROTO_MAX		8
+#define NFC_PROTO_MAX		7
 
 /* NFC communication modes */
 #define NFC_COMM_ACTIVE  0
@@ -233,7 +227,6 @@ enum nfc_sdp_attr {
 #define NFC_PROTO_ISO14443_MASK	  (1 << NFC_PROTO_ISO14443)
 #define NFC_PROTO_NFC_DEP_MASK	  (1 << NFC_PROTO_NFC_DEP)
 #define NFC_PROTO_ISO14443_B_MASK (1 << NFC_PROTO_ISO14443_B)
-#define NFC_PROTO_ISO15693_MASK	  (1 << NFC_PROTO_ISO15693)
 
 /* NFC Secure Elements */
 #define NFC_SE_UICC     0x1
@@ -273,19 +266,11 @@ struct sockaddr_nfc_llcp {
  * First byte is the adapter index
  * Second byte contains flags
  *  - 0x01 - Direction (0=RX, 1=TX)
- *  - 0x02-0x04 - Payload type (000=LLCP, 001=NCI, 010=HCI, 011=Digital,
- *                              100=Proprietary)
- *  - 0x05-0x80 - Reserved
+ *  - 0x02-0x80 - Reserved
  **/
-#define NFC_RAW_HEADER_SIZE	2
-#define NFC_DIRECTION_RX		0x00
-#define NFC_DIRECTION_TX		0x01
-
-#define RAW_PAYLOAD_LLCP 0
-#define RAW_PAYLOAD_NCI	1
-#define RAW_PAYLOAD_HCI	2
-#define RAW_PAYLOAD_DIGITAL	3
-#define RAW_PAYLOAD_PROPRIETARY	4
+#define NFC_LLCP_RAW_HEADER_SIZE	2
+#define NFC_LLCP_DIRECTION_RX		0x00
+#define NFC_LLCP_DIRECTION_TX		0x01
 
 /* socket option names */
 #define NFC_LLCP_RW		0
diff --git a/original/uapi/linux/nfsd/export.h b/original/uapi/linux/nfsd/export.h
index 584b6ef..cf47c31 100644
--- a/original/uapi/linux/nfsd/export.h
+++ b/original/uapi/linux/nfsd/export.h
@@ -28,8 +28,7 @@
 #define NFSEXP_ALLSQUASH	0x0008
 #define NFSEXP_ASYNC		0x0010
 #define NFSEXP_GATHERED_WRITES	0x0020
-#define NFSEXP_NOREADDIRPLUS    0x0040
-/* 80 100 currently unused */
+/* 40 80 100 currently unused */
 #define NFSEXP_NOHIDE		0x0200
 #define NFSEXP_NOSUBTREECHECK	0x0400
 #define	NFSEXP_NOAUTHNLM	0x0800		/* Don't authenticate NLM requests - just trust */
@@ -48,7 +47,7 @@
  */
 #define	NFSEXP_V4ROOT		0x10000
 /* All flags that we claim to support.  (Note we don't support NOACL.) */
-#define NFSEXP_ALLFLAGS		0x1FE7F
+#define NFSEXP_ALLFLAGS		0x17E3F
 
 /* The flags that may vary depending on security flavor: */
 #define NFSEXP_SECINFO_FLAGS	(NFSEXP_READONLY | NFSEXP_ROOTSQUASH \
diff --git a/original/uapi/linux/nfsd/nfsfh.h b/original/uapi/linux/nfsd/nfsfh.h
index 2039123..616e3b3 100644
--- a/original/uapi/linux/nfsd/nfsfh.h
+++ b/original/uapi/linux/nfsd/nfsfh.h
@@ -1,7 +1,13 @@
 /*
+ * include/linux/nfsd/nfsfh.h
+ *
  * This file describes the layout of the file handles as passed
  * over the wire.
  *
+ * Earlier versions of knfsd used to sign file handles using keyed MD5
+ * or SHA. I've removed this code, because it doesn't give you more
+ * security than blocking external access to port 2049 on your firewall.
+ *
  * Copyright (C) 1995, 1996, 1997 Olaf Kirch <okir@monad.swb.de>
  */
 
@@ -31,7 +37,7 @@ struct nfs_fhbase_old {
 };
 
 /*
- * This is the new flexible, extensible style NFSv2/v3/v4 file handle.
+ * This is the new flexible, extensible style NFSv2/v3 file handle.
  * by Neil Brown <neilb@cse.unsw.edu.au> - March 2000
  *
  * The file handle starts with a sequence of four-byte words.
@@ -41,7 +47,14 @@ struct nfs_fhbase_old {
  *
  * All four-byte values are in host-byte-order.
  *
- * The auth_type field is deprecated and must be set to 0.
+ * The auth_type field specifies how the filehandle can be authenticated
+ * This might allow a file to be confirmed to be in a writable part of a
+ * filetree without checking the path from it up to the root.
+ * Current values:
+ *     0  - No authentication.  fb_auth is 0 bytes long
+ * Possible future values:
+ *     1  - 4 bytes taken from MD5 hash of the remainer of the file handle
+ *          prefixed by a secret and with the important export flags.
  *
  * The fsid_type identifies how the filesystem (or export point) is
  *    encoded.
@@ -58,9 +71,14 @@ struct nfs_fhbase_old {
  *     7  - 8 byte inode number and 16 byte uuid
  *
  * The fileid_type identified how the file within the filesystem is encoded.
- *   The values for this field are filesystem specific, exccept that
- *   filesystems must not use the values '0' or '0xff'. 'See enum fid_type'
- *   in include/linux/exportfs.h for currently registered values.
+ * This is (will be) passed to, and set by, the underlying filesystem if it supports
+ * filehandle operations.  The filesystem must not use the value '0' or '0xff' and may
+ * only use the values 1 and 2 as defined below:
+ *  Current values:
+ *    0   - The root, or export point, of the filesystem.  fb_fileid is 0 bytes.
+ *    1   - 32bit inode number, 32 bit generation number.
+ *    2   - 32bit inode number, 32 bit generation number, 32 bit parent directory inode number.
+ *
  */
 struct nfs_fhbase_new {
 	__u8		fb_version;	/* == 1, even => nfs_fhbase_old */
@@ -96,9 +114,9 @@ struct knfsd_fh {
 #define	fh_fsid_type		fh_base.fh_new.fb_fsid_type
 #define	fh_auth_type		fh_base.fh_new.fb_auth_type
 #define	fh_fileid_type		fh_base.fh_new.fb_fileid_type
+#define	fh_auth			fh_base.fh_new.fb_auth
 #define	fh_fsid			fh_base.fh_new.fb_auth
 
-/* Do not use, provided for userspace compatiblity. */
-#define	fh_auth			fh_base.fh_new.fb_auth
+
 
 #endif /* _UAPI_LINUX_NFSD_FH_H */
diff --git a/original/uapi/linux/nl80211.h b/original/uapi/linux/nl80211.h
index 4b28dc0..91054fd 100644
--- a/original/uapi/linux/nl80211.h
+++ b/original/uapi/linux/nl80211.h
@@ -303,9 +303,8 @@
  *	passed, all channels allowed for the current regulatory domain
  *	are used.  Extra IEs can also be passed from the userspace by
  *	using the %NL80211_ATTR_IE attribute.
- * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if
- *	scheduled scan is not running. The caller may assume that as soon
- *	as the call returns, it is safe to start a new scheduled scan again.
+ * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan.  Returns -ENOENT
+ *	if scheduled scan is not running.
  * @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan
  *	results available.
  * @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has
@@ -419,18 +418,8 @@
  *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
  *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
  *	%NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
- *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
- *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT, %NL80211_ATTR_MAC_HINT, and
- *	%NL80211_ATTR_WIPHY_FREQ_HINT.
- *	If included, %NL80211_ATTR_MAC and %NL80211_ATTR_WIPHY_FREQ are
- *	restrictions on BSS selection, i.e., they effectively prevent roaming
- *	within the ESS. %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT
- *	can be included to provide a recommendation of the initial BSS while
- *	allowing the driver to roam to other BSSes within the ESS and also to
- *	ignore this recommendation if the indicated BSS is not ideal. Only one
- *	set of BSSID,frequency parameters is used (i.e., either the enforcing
- *	%NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict
- *	%NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT).
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE and
+ *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT.
  *	Background scan period can optionally be
  *	specified in %NL80211_ATTR_BG_SCAN_PERIOD,
  *	if not specified default background scan configuration
@@ -503,9 +492,6 @@
  *	TX status event pertaining to the TX request.
  *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
  *	management frames at CCK rate or not in 2GHz band.
- *	%NL80211_ATTR_CSA_C_OFFSETS_TX is an array of offsets to CSA
- *	counters which will be updated to the current value. This attribute
- *	is used during CSA period.
  * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
  *	command may be used with the corresponding cookie to cancel the wait
  *	time if it is known that it is no longer necessary.
@@ -722,22 +708,6 @@
  *	QoS mapping is relevant for IP packets, it is only valid during an
  *	association. This is cleared on disassociation and AP restart.
  *
- * @NL80211_CMD_ADD_TX_TS: Ask the kernel to add a traffic stream for the given
- *	%NL80211_ATTR_TSID and %NL80211_ATTR_MAC with %NL80211_ATTR_USER_PRIO
- *	and %NL80211_ATTR_ADMITTED_TIME parameters.
- *	Note that the action frame handshake with the AP shall be handled by
- *	userspace via the normal management RX/TX framework, this only sets
- *	up the TX TS in the driver/device.
- *	If the admitted time attribute is not added then the request just checks
- *	if a subsequent setup could be successful, the intent is to use this to
- *	avoid setting up a session with the AP when local restrictions would
- *	make that impossible. However, the subsequent "real" setup may still
- *	fail even if the check was successful.
- * @NL80211_CMD_DEL_TX_TS: Remove an existing TS with the %NL80211_ATTR_TSID
- *	and %NL80211_ATTR_MAC parameters. It isn't necessary to call this
- *	before removing a station entry entirely, or before disassociating
- *	or similar, cleanup will happen in the driver/device in this case.
- *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -909,9 +879,6 @@ enum nl80211_commands {
 
 	NL80211_CMD_SET_QOS_MAP,
 
-	NL80211_CMD_ADD_TX_TS,
-	NL80211_CMD_DEL_TX_TS,
-
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1547,10 +1514,10 @@ enum nl80211_commands {
  *	operation).
  * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
  *	for the time while performing a channel switch.
- * @NL80211_ATTR_CSA_C_OFF_BEACON: An array of offsets (u16) to the channel
- *	switch counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
- * @NL80211_ATTR_CSA_C_OFF_PRESP: An array of offsets (u16) to the channel
- *	switch counters in the probe response (%NL80211_ATTR_PROBE_RESP).
+ * @NL80211_ATTR_CSA_C_OFF_BEACON: Offset of the channel switch counter
+ *	field in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
+ * @NL80211_ATTR_CSA_C_OFF_PRESP: Offset of the channel switch counter
+ *	field in the probe response (%NL80211_ATTR_PROBE_RESP).
  *
  * @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32.
  *	As specified in the &enum nl80211_rxmgmt_flags.
@@ -1588,56 +1555,6 @@ enum nl80211_commands {
  *	data is in the format defined for the payload of the QoS Map Set element
  *	in IEEE Std 802.11-2012, 8.4.2.97.
  *
- * @NL80211_ATTR_MAC_HINT: MAC address recommendation as initial BSS
- * @NL80211_ATTR_WIPHY_FREQ_HINT: frequency of the recommended initial BSS
- *
- * @NL80211_ATTR_MAX_AP_ASSOC_STA: Device attribute that indicates how many
- *	associated stations are supported in AP mode (including P2P GO); u32.
- *	Since drivers may not have a fixed limit on the maximum number (e.g.,
- *	other concurrent operations may affect this), drivers are allowed to
- *	advertise values that cannot always be met. In such cases, an attempt
- *	to add a new station entry with @NL80211_CMD_NEW_STATION may fail.
- *
- * @NL80211_ATTR_CSA_C_OFFSETS_TX: An array of csa counter offsets (u16) which
- *	should be updated when the frame is transmitted.
- * @NL80211_ATTR_MAX_CSA_COUNTERS: U8 attribute used to advertise the maximum
- *	supported number of csa counters.
- *
- * @NL80211_ATTR_TDLS_PEER_CAPABILITY: flags for TDLS peer capabilities, u32.
- *	As specified in the &enum nl80211_tdls_peer_capability.
- *
- * @NL80211_ATTR_IFACE_SOCKET_OWNER: flag attribute, if set during interface
- *	creation then the new interface will be owned by the netlink socket
- *	that created it and will be destroyed when the socket is closed
- *
- * @NL80211_ATTR_TDLS_INITIATOR: flag attribute indicating the current end is
- *	the TDLS link initiator.
- *
- * @NL80211_ATTR_USE_RRM: flag for indicating whether the current connection
- *	shall support Radio Resource Measurements (11k). This attribute can be
- *	used with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests.
- *	User space applications are expected to use this flag only if the
- *	underlying device supports these minimal RRM features:
- *		%NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES,
- *		%NL80211_FEATURE_QUIET,
- *	If this flag is used, driver must add the Power Capabilities IE to the
- *	association request. In addition, it must also set the RRM capability
- *	flag in the association request's Capability Info field.
- *
- * @NL80211_ATTR_WIPHY_DYN_ACK: flag attribute used to enable ACK timeout
- *	estimation algorithm (dynack). In order to activate dynack
- *	%NL80211_FEATURE_ACKTO_ESTIMATION feature flag must be set by lower
- *	drivers to indicate dynack capability. Dynack is automatically disabled
- *	setting valid value for coverage class.
- *
- * @NL80211_ATTR_TSID: a TSID value (u8 attribute)
- * @NL80211_ATTR_USER_PRIO: user priority value (u8 attribute)
- * @NL80211_ATTR_ADMITTED_TIME: admitted time in units of 32 microseconds
- *	(per second) (u16 attribute)
- *
- * @NL80211_ATTR_SMPS_MODE: SMPS mode to use (ap mode). see
- *	&enum nl80211_smps_mode.
- *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
@@ -1966,30 +1883,6 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_QOS_MAP,
 
-	NL80211_ATTR_MAC_HINT,
-	NL80211_ATTR_WIPHY_FREQ_HINT,
-
-	NL80211_ATTR_MAX_AP_ASSOC_STA,
-
-	NL80211_ATTR_TDLS_PEER_CAPABILITY,
-
-	NL80211_ATTR_IFACE_SOCKET_OWNER,
-
-	NL80211_ATTR_CSA_C_OFFSETS_TX,
-	NL80211_ATTR_MAX_CSA_COUNTERS,
-
-	NL80211_ATTR_TDLS_INITIATOR,
-
-	NL80211_ATTR_USE_RRM,
-
-	NL80211_ATTR_WIPHY_DYN_ACK,
-
-	NL80211_ATTR_TSID,
-	NL80211_ATTR_USER_PRIO,
-	NL80211_ATTR_ADMITTED_TIME,
-
-	NL80211_ATTR_SMPS_MODE,
-
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -2258,8 +2151,6 @@ enum nl80211_sta_bss_param {
  *	Contains a nested array of signal strength attributes (u8, dBm)
  * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
  *	Same format as NL80211_STA_INFO_CHAIN_SIGNAL.
- * @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the
- *	802.11 header (u32, kbps)
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -2291,7 +2182,6 @@ enum nl80211_sta_info {
 	NL80211_STA_INFO_TX_BYTES64,
 	NL80211_STA_INFO_CHAIN_SIGNAL,
 	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
-	NL80211_STA_INFO_EXPECTED_THROUGHPUT,
 
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
@@ -2414,35 +2304,9 @@ enum nl80211_band_attr {
  * @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel
  *	using this channel as the primary or any of the secondary channels
  *	isn't possible
- * @NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
- * @NL80211_FREQUENCY_ATTR_INDOOR_ONLY: Only indoor use is permitted on this
- *	channel. A channel that has the INDOOR_ONLY attribute can only be
- *	used when there is a clear assessment that the device is operating in
- *	an indoor surroundings, i.e., it is connected to AC power (and not
- *	through portable DC inverters) or is under the control of a master
- *	that is acting as an AP and is connected to AC power.
- * @NL80211_FREQUENCY_ATTR_GO_CONCURRENT: GO operation is allowed on this
- *	channel if it's connected concurrently to a BSS on the same channel on
- *	the 2 GHz band or to a channel in the same UNII band (on the 5 GHz
- *	band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO on a
- *	channel that has the GO_CONCURRENT attribute set can be done when there
- *	is a clear assessment that the device is operating under the guidance of
- *	an authorized master, i.e., setting up a GO while the device is also
- *	connected to an AP with DFS and radar detection on the UNII band (it is
- *	up to user-space, i.e., wpa_supplicant to perform the required
- *	verifications)
- * @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed
- *	on this channel in current regulatory domain.
- * @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed
- *	on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
  *	currently defined
  * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
- *
- * See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122
- * for more information on the FCC description of the relaxations allowed
- * by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and
- * NL80211_FREQUENCY_ATTR_GO_CONCURRENT.
  */
 enum nl80211_frequency_attr {
 	__NL80211_FREQUENCY_ATTR_INVALID,
@@ -2458,11 +2322,6 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS,
 	NL80211_FREQUENCY_ATTR_NO_80MHZ,
 	NL80211_FREQUENCY_ATTR_NO_160MHZ,
-	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
-	NL80211_FREQUENCY_ATTR_INDOOR_ONLY,
-	NL80211_FREQUENCY_ATTR_GO_CONCURRENT,
-	NL80211_FREQUENCY_ATTR_NO_20MHZ,
-	NL80211_FREQUENCY_ATTR_NO_10MHZ,
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -2553,14 +2412,12 @@ enum nl80211_reg_type {
  * 	in KHz. This is not a center a frequency but an actual regulatory
  * 	band edge.
  * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
- *	frequency range, in KHz.
+ * 	frequency range, in KHz.
  * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
  * 	for a given frequency range. The value is in mBi (100 * dBi).
  * 	If you don't have one then don't send this.
  * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
  * 	a given frequency range. The value is in mBm (100 * dBm).
- * @NL80211_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
- *	If not present or 0 default CAC time will be used.
  * @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number
  *	currently defined
  * @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use
@@ -2576,8 +2433,6 @@ enum nl80211_reg_rule_attr {
 	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
 	NL80211_ATTR_POWER_RULE_MAX_EIRP,
 
-	NL80211_ATTR_DFS_CAC_TIME,
-
 	/* keep last */
 	__NL80211_REG_RULE_ATTR_AFTER_LAST,
 	NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
@@ -2587,15 +2442,9 @@ enum nl80211_reg_rule_attr {
  * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
  * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
  * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
- *	only report BSS with matching SSID.
+ * only report BSS with matching SSID.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a
- *	BSS in scan results. Filtering is turned off if not specified. Note that
- *	if this attribute is in a match set of its own, then it is treated as
- *	the default value for all matchsets with an SSID, rather than being a
- *	matchset of its own without an RSSI filter. This is due to problems with
- *	how this API was implemented in the past. Also, due to the same problem,
- *	the only way to create a matchset with only an RSSI filter (with this
- *	attribute) is if there's only a single matchset with the RSSI attribute.
+ *	BSS in scan results. Filtering is turned off if not specified.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
  *	attribute number currently defined
  * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
@@ -2628,9 +2477,6 @@ enum nl80211_sched_scan_match_attr {
  * @NL80211_RRF_NO_IR: no mechanisms that initiate radiation are allowed,
  * 	this includes probe requests or modes of operation that require
  * 	beaconing.
- * @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated
- *	base on contiguous rules and wider channels will be allowed to cross
- *	multiple contiguous/overlapping frequency ranges.
  */
 enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_OFDM		= 1<<0,
@@ -2642,7 +2488,6 @@ enum nl80211_reg_rule_flags {
 	NL80211_RRF_PTMP_ONLY		= 1<<6,
 	NL80211_RRF_NO_IR		= 1<<7,
 	__NL80211_RRF_NO_IBSS		= 1<<8,
-	NL80211_RRF_AUTO_BW		= 1<<11,
 };
 
 #define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
@@ -2681,13 +2526,10 @@ enum nl80211_dfs_regions {
  *	present has been registered with the wireless core that
  *	has listed NL80211_FEATURE_CELL_BASE_REG_HINTS as a
  *	supported feature.
- * @NL80211_USER_REG_HINT_INDOOR: a user sent an hint indicating that the
- *	platform is operating in an indoor environment.
  */
 enum nl80211_user_reg_hint_type {
 	NL80211_USER_REG_HINT_USER	= 0,
 	NL80211_USER_REG_HINT_CELL_BASE = 1,
-	NL80211_USER_REG_HINT_INDOOR    = 2,
 };
 
 /**
@@ -3109,20 +2951,14 @@ enum nl80211_bss_scan_width {
  * @NL80211_BSS_BSSID: BSSID of the BSS (6 octets)
  * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
  * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
- *	(if @NL80211_BSS_PRESP_DATA is present then this is known to be
- *	from a probe response, otherwise it may be from the same beacon
- *	that the NL80211_BSS_BEACON_TSF will be from)
  * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
  * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
  * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
  *	raw information elements from the probe response/beacon (bin);
- *	if the %NL80211_BSS_BEACON_IES attribute is present and the data is
- *	different then the IEs here are from a Probe Response frame; otherwise
- *	they are from a Beacon frame.
+ *	if the %NL80211_BSS_BEACON_IES attribute is present, the IEs here are
+ *	from a Probe Response frame; otherwise they are from a Beacon frame.
  *	However, if the driver does not indicate the source of the IEs, these
  *	IEs may be from either frame subtype.
- *	If present, the @NL80211_BSS_PRESP_DATA attribute indicates that the
- *	data here is known to be from a probe response, without any heuristics.
  * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
  *	in mBm (100 * dBm) (s32)
  * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
@@ -3134,10 +2970,6 @@ enum nl80211_bss_scan_width {
  *	yet been received
  * @NL80211_BSS_CHAN_WIDTH: channel width of the control channel
  *	(u32, enum nl80211_bss_scan_width)
- * @NL80211_BSS_BEACON_TSF: TSF of the last received beacon (u64)
- *	(not present if no beacon frame has been received yet)
- * @NL80211_BSS_PRESP_DATA: the data in @NL80211_BSS_INFORMATION_ELEMENTS and
- *	@NL80211_BSS_TSF is known to be from a probe response (flag attribute)
  * @__NL80211_BSS_AFTER_LAST: internal
  * @NL80211_BSS_MAX: highest BSS attribute
  */
@@ -3155,8 +2987,6 @@ enum nl80211_bss {
 	NL80211_BSS_SEEN_MS_AGO,
 	NL80211_BSS_BEACON_IES,
 	NL80211_BSS_CHAN_WIDTH,
-	NL80211_BSS_BEACON_TSF,
-	NL80211_BSS_PRESP_DATA,
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
@@ -3301,7 +3131,6 @@ enum nl80211_key_attributes {
  *	in an array of MCS numbers.
  * @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,
  *	see &struct nl80211_txrate_vht
- * @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi
  * @__NL80211_TXRATE_AFTER_LAST: internal
  * @NL80211_TXRATE_MAX: highest TX rate attribute
  */
@@ -3310,7 +3139,6 @@ enum nl80211_tx_rate_attributes {
 	NL80211_TXRATE_LEGACY,
 	NL80211_TXRATE_HT,
 	NL80211_TXRATE_VHT,
-	NL80211_TXRATE_GI,
 
 	/* keep last */
 	__NL80211_TXRATE_AFTER_LAST,
@@ -3328,12 +3156,6 @@ struct nl80211_txrate_vht {
 	__u16 mcs[NL80211_VHT_NSS_MAX];
 };
 
-enum nl80211_txrate_gi {
-	NL80211_TXRATE_DEFAULT_GI,
-	NL80211_TXRATE_FORCE_SGI,
-	NL80211_TXRATE_FORCE_LGI,
-};
-
 /**
  * enum nl80211_band - Frequency band
  * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
@@ -3773,8 +3595,6 @@ enum nl80211_iface_limit_attrs {
  *	different channels may be used within this group.
  * @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap
  *	of supported channel widths for radar detection.
- * @NL80211_IFACE_COMB_RADAR_DETECT_REGIONS: u32 attribute containing the bitmap
- *	of supported regulatory regions for radar detection.
  * @NUM_NL80211_IFACE_COMB: number of attributes
  * @MAX_NL80211_IFACE_COMB: highest attribute number
  *
@@ -3808,7 +3628,6 @@ enum nl80211_if_combination_attrs {
 	NL80211_IFACE_COMB_STA_AP_BI_MATCH,
 	NL80211_IFACE_COMB_NUM_CHANNELS,
 	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
-	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
 
 	/* keep last */
 	NUM_NL80211_IFACE_COMB,
@@ -3982,8 +3801,11 @@ enum nl80211_ap_sme_features {
  * @NL80211_FEATURE_CELL_BASE_REG_HINTS: This driver has been tested
  *	to work properly to suppport receiving regulatory hints from
  *	cellular base stations.
- * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: (no longer available, only
- *	here to reserve the value for API/ABI compatibility)
+ * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: If this is set, an active
+ *	P2P Device (%NL80211_IFTYPE_P2P_DEVICE) requires its own channel
+ *	in the interface combinations, even when it's only used for scan
+ *	and remain-on-channel. This could be due to, for example, the
+ *	remain-on-channel implementation requiring a channel context.
  * @NL80211_FEATURE_SAE: This driver supports simultaneous authentication of
  *	equals (SAE) with user space SME (NL80211_CMD_AUTHENTICATE) in station
  *	mode
@@ -4019,29 +3841,6 @@ enum nl80211_ap_sme_features {
  *	interface. An active monitor interface behaves like a normal monitor
  *	interface, but gets added to the driver. It ensures that incoming
  *	unicast packets directed at the configured interface address get ACKed.
- * @NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: This driver supports dynamic
- *	channel bandwidth change (e.g., HT 20 <-> 40 MHz channel) during the
- *	lifetime of a BSS.
- * @NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES: This device adds a DS Parameter
- *	Set IE to probe requests.
- * @NL80211_FEATURE_WFA_TPC_IE_IN_PROBES: This device adds a WFA TPC Report IE
- *	to probe requests.
- * @NL80211_FEATURE_QUIET: This device, in client mode, supports Quiet Period
- *	requests sent to it by an AP.
- * @NL80211_FEATURE_TX_POWER_INSERTION: This device is capable of inserting the
- *	current tx power value into the TPC Report IE in the spectrum
- *	management TPC Report action frame, and in the Radio Measurement Link
- *	Measurement Report action frame.
- * @NL80211_FEATURE_ACKTO_ESTIMATION: This driver supports dynamic ACK timeout
- *	estimation (dynack). %NL80211_ATTR_WIPHY_DYN_ACK flag attribute is used
- *	to enable dynack.
- * @NL80211_FEATURE_STATIC_SMPS: Device supports static spatial
- *	multiplexing powersave, ie. can turn off all but one chain
- *	even on HT connections that should be using more chains.
- * @NL80211_FEATURE_DYNAMIC_SMPS: Device supports dynamic spatial
- *	multiplexing powersave, ie. can turn off all but one chain
- *	and then wake the rest up as required after, for example,
- *	rts/cts handshake.
  */
 enum nl80211_feature_flags {
 	NL80211_FEATURE_SK_TX_STATUS			= 1 << 0,
@@ -4062,14 +3861,6 @@ enum nl80211_feature_flags {
 	NL80211_FEATURE_FULL_AP_CLIENT_STATE		= 1 << 15,
 	NL80211_FEATURE_USERSPACE_MPM			= 1 << 16,
 	NL80211_FEATURE_ACTIVE_MONITOR			= 1 << 17,
-	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE	= 1 << 18,
-	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES	= 1 << 19,
-	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES		= 1 << 20,
-	NL80211_FEATURE_QUIET				= 1 << 21,
-	NL80211_FEATURE_TX_POWER_INSERTION		= 1 << 22,
-	NL80211_FEATURE_ACKTO_ESTIMATION		= 1 << 23,
-	NL80211_FEATURE_STATIC_SMPS			= 1 << 24,
-	NL80211_FEATURE_DYNAMIC_SMPS			= 1 << 25,
 };
 
 /**
@@ -4144,25 +3935,6 @@ enum nl80211_acl_policy {
 };
 
 /**
- * enum nl80211_smps_mode - SMPS mode
- *
- * Requested SMPS mode (for AP mode)
- *
- * @NL80211_SMPS_OFF: SMPS off (use all antennas).
- * @NL80211_SMPS_STATIC: static SMPS (use a single antenna)
- * @NL80211_SMPS_DYNAMIC: dynamic smps (start with a single antenna and
- *	turn on other antennas after CTS/RTS).
- */
-enum nl80211_smps_mode {
-	NL80211_SMPS_OFF,
-	NL80211_SMPS_STATIC,
-	NL80211_SMPS_DYNAMIC,
-
-	__NL80211_SMPS_AFTER_LAST,
-	NL80211_SMPS_MAX = __NL80211_SMPS_AFTER_LAST - 1
-};
-
-/**
  * enum nl80211_radar_event - type of radar event for DFS operation
  *
  * Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace
@@ -4265,20 +4037,4 @@ struct nl80211_vendor_cmd_info {
 	__u32 subcmd;
 };
 
-/**
- * enum nl80211_tdls_peer_capability - TDLS peer flags.
- *
- * Used by tdls_mgmt() to determine which conditional elements need
- * to be added to TDLS Setup frames.
- *
- * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
- * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
- * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
- */
-enum nl80211_tdls_peer_capability {
-	NL80211_TDLS_PEER_HT = 1<<0,
-	NL80211_TDLS_PEER_VHT = 1<<1,
-	NL80211_TDLS_PEER_WMM = 1<<2,
-};
-
 #endif /* __LINUX_NL80211_H */
diff --git a/original/uapi/linux/nvme.h b/original/uapi/linux/nvme.h
index 29a7d86..e5ab622 100644
--- a/original/uapi/linux/nvme.h
+++ b/original/uapi/linux/nvme.h
@@ -1,6 +1,6 @@
 /*
  * Definitions for the NVM Express interface
- * Copyright (c) 2011-2014, Intel Corporation.
+ * Copyright (c) 2011-2013, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -10,6 +10,10 @@
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #ifndef _UAPI_LINUX_NVME_H
@@ -27,12 +31,7 @@ struct nvme_id_power_state {
 	__u8			read_lat;
 	__u8			write_tput;
 	__u8			write_lat;
-	__le16			idle_power;
-	__u8			idle_scale;
-	__u8			rsvd19;
-	__le16			active_power;
-	__u8			active_work_scale;
-	__u8			rsvd23[9];
+	__u8			rsvd16[16];
 };
 
 enum {
@@ -50,9 +49,7 @@ struct nvme_id_ctrl {
 	__u8			ieee[3];
 	__u8			mic;
 	__u8			mdts;
-	__u16			cntlid;
-	__u32			ver;
-	__u8			rsvd84[172];
+	__u8			rsvd78[178];
 	__le16			oacs;
 	__u8			acl;
 	__u8			aerl;
@@ -60,11 +57,7 @@ struct nvme_id_ctrl {
 	__u8			lpa;
 	__u8			elpe;
 	__u8			npss;
-	__u8			avscc;
-	__u8			apsta;
-	__le16			wctemp;
-	__le16			cctemp;
-	__u8			rsvd270[242];
+	__u8			rsvd264[248];
 	__u8			sqes;
 	__u8			cqes;
 	__u8			rsvd514[2];
@@ -75,12 +68,7 @@ struct nvme_id_ctrl {
 	__u8			vwc;
 	__le16			awun;
 	__le16			awupf;
-	__u8			nvscc;
-	__u8			rsvd531;
-	__le16			acwu;
-	__u8			rsvd534[2];
-	__le32			sgls;
-	__u8			rsvd540[1508];
+	__u8			rsvd530[1518];
 	struct nvme_id_power_state	psd[32];
 	__u8			vs[1024];
 };
@@ -89,7 +77,6 @@ enum {
 	NVME_CTRL_ONCS_COMPARE			= 1 << 0,
 	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE	= 1 << 1,
 	NVME_CTRL_ONCS_DSM			= 1 << 2,
-	NVME_CTRL_VWC_PRESENT			= 1 << 0,
 };
 
 struct nvme_lbaf {
@@ -108,15 +95,7 @@ struct nvme_id_ns {
 	__u8			mc;
 	__u8			dpc;
 	__u8			dps;
-	__u8			nmic;
-	__u8			rescap;
-	__u8			fpi;
-	__u8			rsvd33;
-	__le16			nawun;
-	__le16			nawupf;
-	__le16			nacwu;
-	__u8			rsvd40[80];
-	__u8			eui64[8];
+	__u8			rsvd30[98];
 	struct nvme_lbaf	lbaf[16];
 	__u8			rsvd192[192];
 	__u8			vs[3712];
@@ -147,10 +126,7 @@ struct nvme_smart_log {
 	__u8			unsafe_shutdowns[16];
 	__u8			media_errors[16];
 	__u8			num_err_log_entries[16];
-	__le32			warning_temp_time;
-	__le32			critical_comp_time;
-	__le16			temp_sensor[8];
-	__u8			rsvd216[296];
+	__u8			rsvd192[320];
 };
 
 enum {
@@ -306,10 +282,6 @@ enum {
 	NVME_FEAT_WRITE_ATOMIC	= 0x0a,
 	NVME_FEAT_ASYNC_EVENT	= 0x0b,
 	NVME_FEAT_SW_PROGRESS	= 0x0c,
-	NVME_LOG_ERROR		= 0x01,
-	NVME_LOG_SMART		= 0x02,
-	NVME_LOG_FW_SLOT	= 0x03,
-	NVME_LOG_RESERVATION	= 0x80,
 	NVME_FWACT_REPL		= (0 << 3),
 	NVME_FWACT_REPL_ACTV	= (1 << 3),
 	NVME_FWACT_ACTV		= (2 << 3),
@@ -462,7 +434,6 @@ enum {
 	NVME_SC_REFTAG_CHECK		= 0x284,
 	NVME_SC_COMPARE_FAILED		= 0x285,
 	NVME_SC_ACCESS_DENIED		= 0x286,
-	NVME_SC_DNR			= 0x4000,
 };
 
 struct nvme_completion {
diff --git a/original/uapi/linux/openvswitch.h b/original/uapi/linux/openvswitch.h
index 435eabc..970553c 100644
--- a/original/uapi/linux/openvswitch.h
+++ b/original/uapi/linux/openvswitch.h
@@ -118,9 +118,6 @@ struct ovs_vport_stats {
 /* Allow last Netlink attribute to be unaligned */
 #define OVS_DP_F_UNALIGNED	(1 << 0)
 
-/* Allow datapath to associate multiple Netlink PIDs to each vport */
-#define OVS_DP_F_VPORT_PIDS	(1 << 1)
-
 /* Fixed logical ports. */
 #define OVSP_LOCAL      ((__u32)0)
 
@@ -192,7 +189,6 @@ enum ovs_vport_type {
 	OVS_VPORT_TYPE_INTERNAL, /* network device implemented by datapath */
 	OVS_VPORT_TYPE_GRE,      /* GRE tunnel. */
 	OVS_VPORT_TYPE_VXLAN,	 /* VXLAN tunnel. */
-	OVS_VPORT_TYPE_GENEVE,	 /* Geneve tunnel. */
 	__OVS_VPORT_TYPE_MAX
 };
 
@@ -207,10 +203,9 @@ enum ovs_vport_type {
  * this is the name of the network device.  Maximum length %IFNAMSIZ-1 bytes
  * plus a null terminator.
  * @OVS_VPORT_ATTR_OPTIONS: Vport-specific configuration information.
- * @OVS_VPORT_ATTR_UPCALL_PID: The array of Netlink socket pids in userspace
- * among which OVS_PACKET_CMD_MISS upcalls will be distributed for packets
- * received on this port.  If this is a single-element array of value 0,
- * upcalls should not be sent.
+ * @OVS_VPORT_ATTR_UPCALL_PID: The Netlink socket in userspace that
+ * OVS_PACKET_CMD_MISS upcalls will be directed to for packets received on
+ * this port.  A value of zero indicates that upcalls should not be sent.
  * @OVS_VPORT_ATTR_STATS: A &struct ovs_vport_stats giving statistics for
  * packets sent or received through the vport.
  *
@@ -233,8 +228,7 @@ enum ovs_vport_attr {
 	OVS_VPORT_ATTR_TYPE,	/* u32 OVS_VPORT_TYPE_* constant. */
 	OVS_VPORT_ATTR_NAME,	/* string name, up to IFNAMSIZ bytes long */
 	OVS_VPORT_ATTR_OPTIONS, /* nested attributes, varies by vport type */
-	OVS_VPORT_ATTR_UPCALL_PID, /* array of u32 Netlink socket PIDs for */
-				/* receiving upcalls */
+	OVS_VPORT_ATTR_UPCALL_PID, /* u32 Netlink PID to receive upcalls */
 	OVS_VPORT_ATTR_STATS,	/* struct ovs_vport_stats */
 	__OVS_VPORT_ATTR_MAX
 };
@@ -290,12 +284,9 @@ enum ovs_key_attr {
 	OVS_KEY_ATTR_TUNNEL,    /* Nested set of ovs_tunnel attributes */
 	OVS_KEY_ATTR_SCTP,      /* struct ovs_key_sctp */
 	OVS_KEY_ATTR_TCP_FLAGS,	/* be16 TCP flags. */
-	OVS_KEY_ATTR_DP_HASH,      /* u32 hash value. Value 0 indicates the hash
-				   is not computed by the datapath. */
-	OVS_KEY_ATTR_RECIRC_ID, /* u32 recirc id */
 
 #ifdef __KERNEL__
-	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ovs_tunnel_info */
+	OVS_KEY_ATTR_IPV4_TUNNEL,  /* struct ovs_key_ipv4_tunnel */
 #endif
 	__OVS_KEY_ATTR_MAX
 };
@@ -310,8 +301,6 @@ enum ovs_tunnel_key_attr {
 	OVS_TUNNEL_KEY_ATTR_TTL,                /* u8 Tunnel IP TTL. */
 	OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT,      /* No argument, set DF. */
 	OVS_TUNNEL_KEY_ATTR_CSUM,               /* No argument. CSUM packet. */
-	OVS_TUNNEL_KEY_ATTR_OAM,                /* No argument. OAM frame.  */
-	OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,        /* Array of Geneve options. */
 	__OVS_TUNNEL_KEY_ATTR_MAX
 };
 
@@ -406,9 +395,7 @@ struct ovs_key_nd {
  * @OVS_FLOW_ATTR_ACTIONS: Nested %OVS_ACTION_ATTR_* attributes specifying
  * the actions to take for packets that match the key.  Always present in
  * notifications.  Required for %OVS_FLOW_CMD_NEW requests, optional for
- * %OVS_FLOW_CMD_SET requests.  An %OVS_FLOW_CMD_SET without
- * %OVS_FLOW_ATTR_ACTIONS will not modify the actions.  To clear the actions,
- * an %OVS_FLOW_ATTR_ACTIONS without any nested attributes must be given.
+ * %OVS_FLOW_CMD_SET requests.
  * @OVS_FLOW_ATTR_STATS: &struct ovs_flow_stats giving statistics for this
  * flow.  Present in notifications if the stats would be nonzero.  Ignored in
  * requests.
@@ -499,27 +486,6 @@ struct ovs_action_push_vlan {
 	__be16 vlan_tci;	/* 802.1Q TCI (VLAN ID and priority). */
 };
 
-/* Data path hash algorithm for computing Datapath hash.
- *
- * The algorithm type only specifies the fields in a flow
- * will be used as part of the hash. Each datapath is free
- * to use its own hash algorithm. The hash value will be
- * opaque to the user space daemon.
- */
-enum ovs_hash_alg {
-	OVS_HASH_ALG_L4,
-};
-
-/*
- * struct ovs_action_hash - %OVS_ACTION_ATTR_HASH action argument.
- * @hash_alg: Algorithm used to compute hash prior to recirculation.
- * @hash_basis: basis used for computing hash.
- */
-struct ovs_action_hash {
-	uint32_t  hash_alg;     /* One of ovs_hash_alg. */
-	uint32_t  hash_basis;
-};
-
 /**
  * enum ovs_action_attr - Action types.
  *
@@ -548,8 +514,6 @@ enum ovs_action_attr {
 	OVS_ACTION_ATTR_PUSH_VLAN,    /* struct ovs_action_push_vlan. */
 	OVS_ACTION_ATTR_POP_VLAN,     /* No argument. */
 	OVS_ACTION_ATTR_SAMPLE,       /* Nested OVS_SAMPLE_ATTR_*. */
-	OVS_ACTION_ATTR_RECIRC,       /* u32 recirc_id. */
-	OVS_ACTION_ATTR_HASH,	      /* struct ovs_action_hash. */
 	__OVS_ACTION_ATTR_MAX
 };
 
diff --git a/original/uapi/linux/pci_regs.h b/original/uapi/linux/pci_regs.h
index 4a1d0cc..30db069 100644
--- a/original/uapi/linux/pci_regs.h
+++ b/original/uapi/linux/pci_regs.h
@@ -552,7 +552,6 @@
 #define  PCI_EXP_RTCTL_PMEIE	0x0008	/* PME Interrupt Enable */
 #define  PCI_EXP_RTCTL_CRSSVE	0x0010	/* CRS Software Visibility Enable */
 #define PCI_EXP_RTCAP		30	/* Root Capabilities */
-#define  PCI_EXP_RTCAP_CRSVIS	0x0001	/* CRS Software Visibility capability */
 #define PCI_EXP_RTSTA		32	/* Root Status */
 #define PCI_EXP_RTSTA_PME	0x00010000 /* PME status */
 #define PCI_EXP_RTSTA_PENDING	0x00020000 /* PME pending */
@@ -631,7 +630,7 @@
 
 /* Advanced Error Reporting */
 #define PCI_ERR_UNCOR_STATUS	4	/* Uncorrectable Error Status */
-#define  PCI_ERR_UNC_UND	0x00000001	/* Undefined */
+#define  PCI_ERR_UNC_TRAIN	0x00000001	/* Training */
 #define  PCI_ERR_UNC_DLP	0x00000010	/* Data Link Protocol */
 #define  PCI_ERR_UNC_SURPDN	0x00000020	/* Surprise Down */
 #define  PCI_ERR_UNC_POISON_TLP	0x00001000	/* Poisoned TLP */
diff --git a/original/uapi/linux/perf_event.h b/original/uapi/linux/perf_event.h
index 9d84540..853bc1c 100644
--- a/original/uapi/linux/perf_event.h
+++ b/original/uapi/linux/perf_event.h
@@ -163,9 +163,8 @@ enum perf_branch_sample_type {
 	PERF_SAMPLE_BRANCH_ABORT_TX	= 1U << 7, /* transaction aborts */
 	PERF_SAMPLE_BRANCH_IN_TX	= 1U << 8, /* in transaction */
 	PERF_SAMPLE_BRANCH_NO_TX	= 1U << 9, /* not in transaction */
-	PERF_SAMPLE_BRANCH_COND		= 1U << 10, /* conditional branches */
 
-	PERF_SAMPLE_BRANCH_MAX		= 1U << 11, /* non-ABI */
+	PERF_SAMPLE_BRANCH_MAX		= 1U << 10, /* non-ABI */
 };
 
 #define PERF_SAMPLE_BRANCH_PLM_ALL \
@@ -302,8 +301,8 @@ struct perf_event_attr {
 				exclude_callchain_kernel : 1, /* exclude kernel callchains */
 				exclude_callchain_user   : 1, /* exclude user callchains */
 				mmap2          :  1, /* include mmap with inode data     */
-				comm_exec      :  1, /* flag comm events that are due to an exec */
-				__reserved_1   : 39;
+
+				__reserved_1   : 40;
 
 	union {
 		__u32		wakeup_events;	  /* wakeup every n events */
@@ -364,7 +363,7 @@ struct perf_event_mmap_page {
 	/*
 	 * Bits needed to read the hw events in user-space.
 	 *
-	 *   u32 seq, time_mult, time_shift, index, width;
+	 *   u32 seq, time_mult, time_shift, idx, width;
 	 *   u64 count, enabled, running;
 	 *   u64 cyc, time_offset;
 	 *   s64 pmc = 0;
@@ -383,11 +382,11 @@ struct perf_event_mmap_page {
 	 *       time_shift  = pc->time_shift;
 	 *     }
 	 *
-	 *     index = pc->index;
+	 *     idx = pc->index;
 	 *     count = pc->offset;
-	 *     if (pc->cap_user_rdpmc && index) {
+	 *     if (pc->cap_usr_rdpmc && idx) {
 	 *       width = pc->pmc_width;
-	 *       pmc = rdpmc(index - 1);
+	 *       pmc = rdpmc(idx - 1);
 	 *     }
 	 *
 	 *     barrier();
@@ -415,7 +414,7 @@ struct perf_event_mmap_page {
 	};
 
 	/*
-	 * If cap_user_rdpmc this field provides the bit-width of the value
+	 * If cap_usr_rdpmc this field provides the bit-width of the value
 	 * read using the rdpmc() or equivalent instruction. This can be used
 	 * to sign extend the result like:
 	 *
@@ -439,10 +438,10 @@ struct perf_event_mmap_page {
 	 *
 	 * Where time_offset,time_mult,time_shift and cyc are read in the
 	 * seqcount loop described above. This delta can then be added to
-	 * enabled and possible running (if index), improving the scaling:
+	 * enabled and possible running (if idx), improving the scaling:
 	 *
 	 *   enabled += delta;
-	 *   if (index)
+	 *   if (idx)
 	 *     running += delta;
 	 *
 	 *   quot = count / running;
@@ -502,12 +501,7 @@ struct perf_event_mmap_page {
 #define PERF_RECORD_MISC_GUEST_KERNEL		(4 << 0)
 #define PERF_RECORD_MISC_GUEST_USER		(5 << 0)
 
-/*
- * PERF_RECORD_MISC_MMAP_DATA and PERF_RECORD_MISC_COMM_EXEC are used on
- * different events so can reuse the same bit position.
- */
 #define PERF_RECORD_MISC_MMAP_DATA		(1 << 13)
-#define PERF_RECORD_MISC_COMM_EXEC		(1 << 13)
 /*
  * Indicates that the content of PERF_SAMPLE_IP points to
  * the actual instruction that triggered the event. See also
@@ -705,7 +699,6 @@ enum perf_event_type {
 	 *	u32				min;
 	 *	u64				ino;
 	 *	u64				ino_generation;
-	 *	u32				prot, flags;
 	 *	char				filename[];
 	 * 	struct sample_id		sample_id;
 	 * };
@@ -729,10 +722,10 @@ enum perf_callchain_context {
 	PERF_CONTEXT_MAX		= (__u64)-4095,
 };
 
-#define PERF_FLAG_FD_NO_GROUP		(1UL << 0)
-#define PERF_FLAG_FD_OUTPUT		(1UL << 1)
-#define PERF_FLAG_PID_CGROUP		(1UL << 2) /* pid=cgroup id, per-cpu mode only */
-#define PERF_FLAG_FD_CLOEXEC		(1UL << 3) /* O_CLOEXEC */
+#define PERF_FLAG_FD_NO_GROUP		(1U << 0)
+#define PERF_FLAG_FD_OUTPUT		(1U << 1)
+#define PERF_FLAG_PID_CGROUP		(1U << 2) /* pid=cgroup id, per-cpu mode only */
+#define PERF_FLAG_FD_CLOEXEC		(1U << 3) /* O_CLOEXEC */
 
 union perf_mem_data_src {
 	__u64 val;
diff --git a/original/uapi/linux/pfkeyv2.h b/original/uapi/linux/pfkeyv2.h
index ada7f01..0b80c80 100644
--- a/original/uapi/linux/pfkeyv2.h
+++ b/original/uapi/linux/pfkeyv2.h
@@ -235,18 +235,6 @@ struct sadb_x_kmaddress {
 } __attribute__((packed));
 /* sizeof(struct sadb_x_kmaddress) == 8 */
 
-/* To specify the SA dump filter */
-struct sadb_x_filter {
-	__u16	sadb_x_filter_len;
-	__u16	sadb_x_filter_exttype;
-	__u32	sadb_x_filter_saddr[4];
-	__u32	sadb_x_filter_daddr[4];
-	__u16	sadb_x_filter_family;
-	__u8	sadb_x_filter_splen;
-	__u8	sadb_x_filter_dplen;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_filter) == 40 */
-
 /* Message types */
 #define SADB_RESERVED		0
 #define SADB_GETSPI		1
@@ -370,8 +358,7 @@ struct sadb_x_filter {
 #define SADB_X_EXT_SEC_CTX		24
 /* Used with MIGRATE to pass @ to IKE for negotiation */
 #define SADB_X_EXT_KMADDRESS		25
-#define SADB_X_EXT_FILTER		26
-#define SADB_EXT_MAX			26
+#define SADB_EXT_MAX			25
 
 /* Identity Extension values */
 #define SADB_IDENTTYPE_RESERVED	0
diff --git a/original/uapi/linux/prctl.h b/original/uapi/linux/prctl.h
index 513df75..253856a 100644
--- a/original/uapi/linux/prctl.h
+++ b/original/uapi/linux/prctl.h
@@ -1,8 +1,6 @@
 #ifndef _LINUX_PRCTL_H
 #define _LINUX_PRCTL_H
 
-#include <linux/types.h>
-
 /* Values to pass as first argument to prctl() */
 
 #define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
@@ -121,31 +119,6 @@
 # define PR_SET_MM_ENV_END		11
 # define PR_SET_MM_AUXV			12
 # define PR_SET_MM_EXE_FILE		13
-# define PR_SET_MM_MAP			14
-# define PR_SET_MM_MAP_SIZE		15
-
-/*
- * This structure provides new memory descriptor
- * map which mostly modifies /proc/pid/stat[m]
- * output for a task. This mostly done in a
- * sake of checkpoint/restore functionality.
- */
-struct prctl_mm_map {
-	__u64	start_code;		/* code section bounds */
-	__u64	end_code;
-	__u64	start_data;		/* data section bounds */
-	__u64	end_data;
-	__u64	start_brk;		/* heap for brk() syscall */
-	__u64	brk;
-	__u64	start_stack;		/* stack starts at */
-	__u64	arg_start;		/* command line arguments bounds */
-	__u64	arg_end;
-	__u64	env_start;		/* environment variables bounds */
-	__u64	env_end;
-	__u64	*auxv;			/* auxiliary vector */
-	__u32	auxv_size;		/* vector size */
-	__u32	exe_fd;			/* /proc/$pid/exe link file */
-};
 
 /*
  * Set specific pid that is allowed to ptrace the current task.
@@ -176,7 +149,7 @@ struct prctl_mm_map {
 
 #define PR_GET_TID_ADDRESS	40
 
-#define PR_SET_THP_DISABLE	41
-#define PR_GET_THP_DISABLE	42
+#define PR_SET_VMA		0x53564d41
+# define PR_SET_VMA_ANON_NAME		0
 
 #endif /* _LINUX_PRCTL_H */
diff --git a/original/uapi/linux/pxp_device.h b/original/uapi/linux/pxp_device.h
new file mode 100644
index 0000000..fce89ce
--- /dev/null
+++ b/original/uapi/linux/pxp_device.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DEVICE
+#define _UAPI_PXP_DEVICE
+
+#include <linux/pxp_dma.h>
+
+struct pxp_chan_handle {
+	unsigned int handle;
+	int hist_status;
+};
+
+struct pxp_mem_desc {
+	unsigned int handle;
+	unsigned int size;
+	dma_addr_t phys_addr;
+	unsigned int virt_uaddr;		/* virtual user space address */
+	unsigned int mtype;
+};
+
+struct pxp_mem_flush {
+	unsigned int handle;
+	unsigned int type;
+};
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+#define PXP_IOC_FLUSH_PHYMEM   _IOR(PXP_IOC_MAGIC, 7, struct pxp_mem_flush)
+
+/* Memory types supported*/
+#define MEMORY_TYPE_UNCACHED 0x0
+#define MEMORY_TYPE_WC	     0x1
+#define MEMORY_TYPE_CACHED   0x2
+
+/* Cache flush operations */
+#define CACHE_CLEAN      0x1
+#define CACHE_INVALIDATE 0x2
+#define CACHE_FLUSH      0x4
+
+#endif
diff --git a/original/uapi/linux/pxp_dma.h b/original/uapi/linux/pxp_dma.h
new file mode 100644
index 0000000..6aa0139
--- /dev/null
+++ b/original/uapi/linux/pxp_dma.h
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DMA
+#define _UAPI_PXP_DMA
+
+#include <linux/posix_types.h>
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_VUY444  fourcc('V', 'U', 'Y', 'A')	/*!< 32 VUYA 8:8:8 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV21    fourcc('N', 'V', '2', '1')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV16    fourcc('N', 'V', '1', '6')	/* 12  Y/CbCr 4:2:2  */
+#define PXP_PIX_FMT_NV61    fourcc('N', 'V', '6', '1')	/* 12  Y/CbCr 4:2:2  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_GY04    fourcc('G', 'Y', '0', '4') /*!< 4  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE			0x0
+#define PXP_LUT_INVERT			0x1
+#define PXP_LUT_BLACK_WHITE		0x2
+#define PXP_LUT_USE_CMAP		0x4
+
+/* dithering modes enum */
+#define PXP_DITHER_PASS_THROUGH 0
+#define PXP_DITHER_FLOYD	1
+#define PXP_DITHER_ATKINSON	2
+#define PXP_DITHER_ORDERED	3
+#define PXP_DITHER_QUANT_ONLY	4
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+#define PXP_IOC_FILL_DATA    _IOWR(PXP_IOC_MAGIC, 7, struct pxp_mem_desc)
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+enum pxp_working_mode {
+	PXP_MODE_LEGACY			= 0x1,
+	PXP_MODE_STANDARD		= 0x2,
+	PXP_MODE_ADVANCED		= 0x4,
+};
+
+enum pxp_buffer_flag {
+	PXP_BUF_FLAG_WFE_A_FETCH0	= 0x0001,
+	PXP_BUF_FLAG_WFE_A_FETCH1	= 0x0002,
+	PXP_BUF_FLAG_WFE_A_STORE0	= 0x0004,
+	PXP_BUF_FLAG_WFE_A_STORE1	= 0x0008,
+	PXP_BUF_FLAG_WFE_B_FETCH0	= 0x0010,
+	PXP_BUF_FLAG_WFE_B_FETCH1	= 0x0020,
+	PXP_BUF_FLAG_WFE_B_STORE0	= 0x0040,
+	PXP_BUF_FLAG_WFE_B_STORE1	= 0x0080,
+	PXP_BUF_FLAG_DITHER_FETCH0	= 0x0100,
+	PXP_BUF_FLAG_DITHER_FETCH1	= 0x0200,
+	PXP_BUF_FLAG_DITHER_STORE0	= 0x0400,
+	PXP_BUF_FLAG_DITHER_STORE1	= 0x0800,
+};
+
+enum pxp_engine_ctrl {
+	PXP_ENABLE_ROTATE0		= 0x001,
+	PXP_ENABLE_ROTATE1		= 0x002,
+	PXP_ENABLE_LUT			= 0x004,
+	PXP_ENABLE_CSC2			= 0x008,
+	PXP_ENABLE_ALPHA_B		= 0x010,
+	PXP_ENABLE_INPUT_FETCH_SOTRE	= 0x020,
+	PXP_ENABLE_WFE_B		= 0x040,
+	PXP_ENABLE_WFE_A		= 0x080,
+	PXP_ENABLE_DITHER		= 0x100,
+	PXP_ENABLE_PS_AS_OUT		= 0x200,
+	PXP_ENABLE_COLLISION_DETECT     = 0x400,
+	PXP_ENABLE_HANDSHAKE		= 0x1000,
+	PXP_ENABLE_DITHER_BYPASS	= 0x2000,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+struct pxp_layer_param {
+	unsigned short left;
+	unsigned short top;
+	unsigned short width;
+	unsigned short height;
+	unsigned short stride; /* aka pitch */
+	unsigned int pixel_fmt;
+
+	unsigned int flag;
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	unsigned int color_key_enable;
+	unsigned int color_key;
+	bool global_alpha_enable;
+	/* global alpha is either override or multiply */
+	bool global_override;
+	unsigned char global_alpha;
+	bool alpha_invert;
+	bool local_alpha_enable;
+	int comp_mask;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_collision_info {
+	unsigned int pixel_cnt;
+	unsigned int rect_min_x;
+	unsigned int rect_min_y;
+	unsigned int rect_max_x;
+	unsigned int rect_max_y;
+	unsigned int victim_luts[2];
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int rot_pos;
+	int yuv;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	unsigned int bgcolor;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+	unsigned char *lut_map; /* 256 entries */
+	bool lut_map_updated; /* Map recently changed */
+	bool combine_enable;
+
+	/* the mode pxp's working against */
+	enum pxp_working_mode working_mode;
+	enum pxp_engine_ctrl engine_enable;
+
+	/* wfe */
+/*
+ * partial:
+ *         0 - full update
+ *         1 - partial update
+ * alpha_en:
+ *         0 - upd is {Y4[3:0],4'b0000} format
+ *         1 - upd is {Y4[3:0],3'b000,alpha} format
+ * reagl_en:
+ *         0 - use normal waveform algorithm
+ *         1 - enable reagl/-d waveform algorithm
+ * detection_only:
+ *         0 - write working buffer
+ *         1 - do no write working buffer, detection only
+ * lut:
+ *         valid value 0-63
+ *         set to the lut used for next update
+ */
+	bool partial_update;
+	bool alpha_en;
+	bool lut_update;
+	bool reagl_en;		/* enable reagl/-d */
+	bool reagl_d_en;	/* enable reagl or reagl-d */
+	bool detection_only;
+	int lut;
+	unsigned int lut_status_1;
+	unsigned int lut_status_2;
+
+	/* Dithering specific data */
+	int dither_mode;
+	unsigned int quant_bit;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[8];
+	struct pxp_layer_param out_param;
+	struct pxp_layer_param wfe_a_fetch_param[2];
+	struct pxp_layer_param wfe_a_store_param[2];
+	struct pxp_layer_param wfe_b_fetch_param[2];
+	struct pxp_layer_param wfe_b_store_param[2];
+	struct pxp_layer_param dither_fetch_param[2];
+	struct pxp_layer_param dither_store_param[2];
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int handle;
+};
+
+#endif
diff --git a/original/uapi/linux/raid/md_u.h b/original/uapi/linux/raid/md_u.h
index 74e7c60..4133e74 100644
--- a/original/uapi/linux/raid/md_u.h
+++ b/original/uapi/linux/raid/md_u.h
@@ -39,6 +39,7 @@
 #define RAID_VERSION		_IOR (MD_MAJOR, 0x10, mdu_version_t)
 #define GET_ARRAY_INFO		_IOR (MD_MAJOR, 0x11, mdu_array_info_t)
 #define GET_DISK_INFO		_IOR (MD_MAJOR, 0x12, mdu_disk_info_t)
+#define PRINT_RAID_DEBUG	_IO (MD_MAJOR, 0x13)
 #define RAID_AUTORUN		_IO (MD_MAJOR, 0x14)
 #define GET_BITMAP_FILE		_IOR (MD_MAJOR, 0x15, mdu_bitmap_file_t)
 
diff --git a/original/uapi/linux/random.h b/original/uapi/linux/random.h
index 3f93d16..fff3528 100644
--- a/original/uapi/linux/random.h
+++ b/original/uapi/linux/random.h
@@ -40,13 +40,4 @@ struct rand_pool_info {
 	__u32	buf[0];
 };
 
-/*
- * Flags for getrandom(2)
- *
- * GRND_NONBLOCK	Don't block and return EAGAIN instead
- * GRND_RANDOM		Use the /dev/random pool instead of /dev/urandom
- */
-#define GRND_NONBLOCK	0x0001
-#define GRND_RANDOM	0x0002
-
 #endif /* _UAPI_LINUX_RANDOM_H */
diff --git a/original/uapi/linux/rtnetlink.h b/original/uapi/linux/rtnetlink.h
index eb0f1a5..01757b7 100644
--- a/original/uapi/linux/rtnetlink.h
+++ b/original/uapi/linux/rtnetlink.h
@@ -297,6 +297,7 @@ enum rtattr_type_t {
 	RTA_TABLE,
 	RTA_MARK,
 	RTA_MFC_STATS,
+	RTA_UID,
 	__RTA_MAX
 };
 
diff --git a/original/uapi/linux/sched.h b/original/uapi/linux/sched.h
index b932be9..34f9d73 100644
--- a/original/uapi/linux/sched.h
+++ b/original/uapi/linux/sched.h
@@ -13,7 +13,7 @@
 #define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
 #define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
 #define CLONE_THREAD	0x00010000	/* Same thread group? */
-#define CLONE_NEWNS	0x00020000	/* New mount namespace group */
+#define CLONE_NEWNS	0x00020000	/* New namespace group? */
 #define CLONE_SYSVSEM	0x00040000	/* share system V SEM_UNDO semantics */
 #define CLONE_SETTLS	0x00080000	/* create a new TLS for the child */
 #define CLONE_PARENT_SETTID	0x00100000	/* set the TID in the parent */
diff --git a/original/uapi/linux/sctp.h b/original/uapi/linux/sctp.h
index ce70fe6..266022a 100644
--- a/original/uapi/linux/sctp.h
+++ b/original/uapi/linux/sctp.h
@@ -95,9 +95,6 @@ typedef __s32 sctp_assoc_t;
 #define SCTP_GET_ASSOC_ID_LIST	29	/* Read only */
 #define SCTP_AUTO_ASCONF       30
 #define SCTP_PEER_ADDR_THLDS	31
-#define SCTP_RECVRCVINFO	32
-#define SCTP_RECVNXTINFO	33
-#define SCTP_DEFAULT_SNDINFO	34
 
 /* Internal Socket Options. Some of the sctp library functions are
  * implemented using these socket options.
@@ -113,14 +110,8 @@ typedef __s32 sctp_assoc_t;
 #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
 #define SCTP_GET_ASSOC_STATS	112	/* Read only */
 
-/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
-/* On user space Linux, these live in <bits/socket.h> as an enum.  */
-enum sctp_msg_flags {
-	MSG_NOTIFICATION = 0x8000,
-#define MSG_NOTIFICATION MSG_NOTIFICATION
-};
-
-/* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
+/*
+ * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
  *
  *   This cmsghdr structure provides information for initializing new
  *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
@@ -130,6 +121,7 @@ enum sctp_msg_flags {
  *   cmsg_level    cmsg_type      cmsg_data[]
  *   ------------  ------------   ----------------------
  *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg
+ *
  */
 struct sctp_initmsg {
 	__u16 sinit_num_ostreams;
@@ -138,7 +130,8 @@ struct sctp_initmsg {
 	__u16 sinit_max_init_timeo;
 };
 
-/* 5.3.2 SCTP Header Information Structure (SCTP_SNDRCV)
+/*
+ * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)
  *
  *   This cmsghdr structure specifies SCTP options for sendmsg() and
  *   describes SCTP header information about a received message through
@@ -147,6 +140,7 @@ struct sctp_initmsg {
  *   cmsg_level    cmsg_type      cmsg_data[]
  *   ------------  ------------   ----------------------
  *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
+ *
  */
 struct sctp_sndrcvinfo {
 	__u16 sinfo_stream;
@@ -160,74 +154,19 @@ struct sctp_sndrcvinfo {
 	sctp_assoc_t sinfo_assoc_id;
 };
 
-/* 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
- *
- *   This cmsghdr structure specifies SCTP options for sendmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_SNDINFO   struct sctp_sndinfo
- */
-struct sctp_sndinfo {
-	__u16 snd_sid;
-	__u16 snd_flags;
-	__u32 snd_ppid;
-	__u32 snd_context;
-	sctp_assoc_t snd_assoc_id;
-};
-
-/* 5.3.5 SCTP Receive Information Structure (SCTP_RCVINFO)
- *
- *   This cmsghdr structure describes SCTP receive information
- *   about a received message through recvmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_RCVINFO   struct sctp_rcvinfo
- */
-struct sctp_rcvinfo {
-	__u16 rcv_sid;
-	__u16 rcv_ssn;
-	__u16 rcv_flags;
-	__u32 rcv_ppid;
-	__u32 rcv_tsn;
-	__u32 rcv_cumtsn;
-	__u32 rcv_context;
-	sctp_assoc_t rcv_assoc_id;
-};
-
-/* 5.3.6 SCTP Next Receive Information Structure (SCTP_NXTINFO)
- *
- *   This cmsghdr structure describes SCTP receive information
- *   of the next message that will be delivered through recvmsg()
- *   if this information is already available when delivering
- *   the current message.
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_NXTINFO   struct sctp_nxtinfo
- */
-struct sctp_nxtinfo {
-	__u16 nxt_sid;
-	__u16 nxt_flags;
-	__u32 nxt_ppid;
-	__u32 nxt_length;
-	sctp_assoc_t nxt_assoc_id;
-};
-
 /*
  *  sinfo_flags: 16 bits (unsigned integer)
  *
  *   This field may contain any of the following flags and is composed of
  *   a bitwise OR of these values.
  */
+
 enum sctp_sinfo_flags {
-	SCTP_UNORDERED		= (1 << 0), /* Send/receive message unordered. */
-	SCTP_ADDR_OVER		= (1 << 1), /* Override the primary destination. */
-	SCTP_ABORT		= (1 << 2), /* Send an ABORT message to the peer. */
-	SCTP_SACK_IMMEDIATELY	= (1 << 3), /* SACK should be sent without delay. */
-	SCTP_NOTIFICATION	= MSG_NOTIFICATION, /* Next message is not user msg but notification. */
-	SCTP_EOF		= MSG_FIN,  /* Initiate graceful shutdown process. */
+	SCTP_UNORDERED = 1,  /* Send/receive message unordered. */
+	SCTP_ADDR_OVER = 2,  /* Override the primary destination. */
+	SCTP_ABORT=4,        /* Send an ABORT message to the peer. */
+	SCTP_SACK_IMMEDIATELY = 8,	/* SACK should be sent without delay */
+	SCTP_EOF=MSG_FIN,    /* Initiate graceful shutdown process. */
 };
 
 typedef union {
@@ -238,16 +177,10 @@ typedef union {
 
 /* These are cmsg_types.  */
 typedef enum sctp_cmsg_type {
-	SCTP_INIT,		/* 5.2.1 SCTP Initiation Structure */
+	SCTP_INIT,              /* 5.2.1 SCTP Initiation Structure */
 #define SCTP_INIT	SCTP_INIT
-	SCTP_SNDRCV,		/* 5.2.2 SCTP Header Information Structure */
+	SCTP_SNDRCV,            /* 5.2.2 SCTP Header Information Structure */
 #define SCTP_SNDRCV	SCTP_SNDRCV
-	SCTP_SNDINFO,		/* 5.3.4 SCTP Send Information Structure */
-#define SCTP_SNDINFO	SCTP_SNDINFO
-	SCTP_RCVINFO,		/* 5.3.5 SCTP Receive Information Structure */
-#define SCTP_RCVINFO	SCTP_RCVINFO
-	SCTP_NXTINFO,		/* 5.3.6 SCTP Next Receive Information Structure */
-#define SCTP_NXTINFO	SCTP_NXTINFO
 } sctp_cmsg_t;
 
 /*
@@ -875,6 +808,13 @@ struct sctp_assoc_stats {
 	__u64		sas_ictrlchunks; /* Control chunks received */
 };
 
+/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
+/* On user space Linux, these live in <bits/socket.h> as an enum.  */
+enum sctp_msg_flags {
+	MSG_NOTIFICATION = 0x8000,
+#define MSG_NOTIFICATION MSG_NOTIFICATION
+};
+
 /*
  * 8.1 sctp_bindx()
  *
diff --git a/original/uapi/linux/seccomp.h b/original/uapi/linux/seccomp.h
index 0f238a4..ac2dc9f 100644
--- a/original/uapi/linux/seccomp.h
+++ b/original/uapi/linux/seccomp.h
@@ -10,13 +10,6 @@
 #define SECCOMP_MODE_STRICT	1 /* uses hard-coded filter. */
 #define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
 
-/* Valid operations for seccomp syscall. */
-#define SECCOMP_SET_MODE_STRICT	0
-#define SECCOMP_SET_MODE_FILTER	1
-
-/* Valid flags for SECCOMP_SET_MODE_FILTER */
-#define SECCOMP_FILTER_FLAG_TSYNC	1
-
 /*
  * All BPF programs must return a 32-bit value.
  * The bottom 16-bits are for optional return data.
diff --git a/original/uapi/linux/serial_core.h b/original/uapi/linux/serial_core.h
index 16ad852..b47dba2 100644
--- a/original/uapi/linux/serial_core.h
+++ b/original/uapi/linux/serial_core.h
@@ -211,7 +211,7 @@
 /* VIA VT8500 SoC */
 #define PORT_VT8500	97
 
-/* Cadence (Xilinx Zynq) UART */
+/* Xilinx PSS UART */
 #define PORT_XUARTPS	98
 
 /* Atheros AR933X SoC */
@@ -238,13 +238,4 @@
 /* Tilera TILE-Gx UART */
 #define PORT_TILEGX	106
 
-/* MEN 16z135 UART */
-#define PORT_MEN_Z135	107
-
-/* SC16IS74xx */
-#define PORT_SC16IS7XX   108
-
-/* MESON */
-#define PORT_MESON	109
-
 #endif /* _UAPILINUX_SERIAL_CORE_H */
diff --git a/original/uapi/linux/serial_reg.h b/original/uapi/linux/serial_reg.h
index df6c9ab..e632260 100644
--- a/original/uapi/linux/serial_reg.h
+++ b/original/uapi/linux/serial_reg.h
@@ -32,7 +32,7 @@
 
 #define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
-#define UART_IIR_ID		0x0e /* Mask for the interrupt ID */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
 #define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
 #define UART_IIR_RDI		0x04 /* Receiver data interrupt */
@@ -88,11 +88,6 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_FCR_R_TRIG_SHIFT		6
-#define UART_FCR_R_TRIG_BITS(x)		\
-	(((x) & UART_FCR_TRIGGER_MASK) >> UART_FCR_R_TRIG_SHIFT)
-#define UART_FCR_R_TRIG_MAX_STATE	4
-
 #define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
diff --git a/original/uapi/linux/serio.h b/original/uapi/linux/serio.h
index becdd78..9f53fa7 100644
--- a/original/uapi/linux/serio.h
+++ b/original/uapi/linux/serio.h
@@ -76,6 +76,5 @@
 #define SERIO_HAMPSHIRE	0x3b
 #define SERIO_PS2MULT	0x3c
 #define SERIO_TSC40	0x3d
-#define SERIO_WACOM_IV	0x3e
 
 #endif /* _UAPI_SERIO_H */
diff --git a/original/uapi/linux/shm.h b/original/uapi/linux/shm.h
index 1fbf24e..78b6941 100644
--- a/original/uapi/linux/shm.h
+++ b/original/uapi/linux/shm.h
@@ -8,20 +8,19 @@
 #endif
 
 /*
- * SHMMNI, SHMMAX and SHMALL are default upper limits which can be
- * modified by sysctl. The SHMMAX and SHMALL values have been chosen to
- * be as large possible without facilitating scenarios where userspace
- * causes overflows when adjusting the limits via operations of the form
- * "retrieve current limit; add X; update limit". It is therefore not
- * advised to make SHMMAX and SHMALL any larger. These limits are
- * suitable for both 32 and 64-bit systems.
+ * SHMMAX, SHMMNI and SHMALL are upper limits are defaults which can
+ * be increased by sysctl
  */
+
+#define SHMMAX 0x2000000		 /* max shared seg size (bytes) */
 #define SHMMIN 1			 /* min shared seg size (bytes) */
 #define SHMMNI 4096			 /* max num of segs system wide */
-#define SHMMAX (ULONG_MAX - (1UL << 24)) /* max shared seg size (bytes) */
-#define SHMALL (ULONG_MAX - (1UL << 24)) /* max shm system wide (pages) */
+#ifndef __KERNEL__
+#define SHMALL (SHMMAX/getpagesize()*(SHMMNI/16))
+#endif
 #define SHMSEG SHMMNI			 /* max shared segs per process */
 
+
 /* Obsolete, used only for backwards compatibility and libc5 compiles */
 struct shmid_ds {
 	struct ipc_perm		shm_perm;	/* operation perms */
diff --git a/original/uapi/linux/snmp.h b/original/uapi/linux/snmp.h
index df40137..bbaba22 100644
--- a/original/uapi/linux/snmp.h
+++ b/original/uapi/linux/snmp.h
@@ -252,7 +252,6 @@ enum
 	LINUX_MIB_TCPCHALLENGEACK,		/* TCPChallengeACK */
 	LINUX_MIB_TCPSYNCHALLENGE,		/* TCPSYNChallenge */
 	LINUX_MIB_TCPFASTOPENACTIVE,		/* TCPFastOpenActive */
-	LINUX_MIB_TCPFASTOPENACTIVEFAIL,	/* TCPFastOpenActiveFail */
 	LINUX_MIB_TCPFASTOPENPASSIVE,		/* TCPFastOpenPassive*/
 	LINUX_MIB_TCPFASTOPENPASSIVEFAIL,	/* TCPFastOpenPassiveFail */
 	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW,	/* TCPFastOpenListenOverflow */
@@ -260,11 +259,6 @@ enum
 	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES, /* TCPSpuriousRtxHostQueues */
 	LINUX_MIB_BUSYPOLLRXPACKETS,		/* BusyPollRxPackets */
 	LINUX_MIB_TCPAUTOCORKING,		/* TCPAutoCorking */
-	LINUX_MIB_TCPFROMZEROWINDOWADV,		/* TCPFromZeroWindowAdv */
-	LINUX_MIB_TCPTOZEROWINDOWADV,		/* TCPToZeroWindowAdv */
-	LINUX_MIB_TCPWANTZEROWINDOWADV,		/* TCPWantZeroWindowAdv */
-	LINUX_MIB_TCPSYNRETRANS,		/* TCPSynRetrans */
-	LINUX_MIB_TCPORIGDATASENT,		/* TCPOrigDataSent */
 	__LINUX_MIB_MAX
 };
 
diff --git a/original/uapi/linux/sockios.h b/original/uapi/linux/sockios.h
index e888b1a..623e9aa 100644
--- a/original/uapi/linux/sockios.h
+++ b/original/uapi/linux/sockios.h
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff --git a/original/uapi/linux/spi/spidev.h b/original/uapi/linux/spi/spidev.h
index dd5f21e..52d9ed0 100644
--- a/original/uapi/linux/spi/spidev.h
+++ b/original/uapi/linux/spi/spidev.h
@@ -42,10 +42,6 @@
 #define SPI_LOOP		0x20
 #define SPI_NO_CS		0x40
 #define SPI_READY		0x80
-#define SPI_TX_DUAL		0x100
-#define SPI_TX_QUAD		0x200
-#define SPI_RX_DUAL		0x400
-#define SPI_RX_QUAD		0x800
 
 /*---------------------------------------------------------------------------*/
 
@@ -96,9 +92,7 @@ struct spi_ioc_transfer {
 	__u16		delay_usecs;
 	__u8		bits_per_word;
 	__u8		cs_change;
-	__u8		tx_nbits;
-	__u8		rx_nbits;
-	__u16		pad;
+	__u32		pad;
 
 	/* If the contents of 'struct spi_ioc_transfer' ever change
 	 * incompatibly, then the ioctl number (currently 0) must change;
@@ -116,7 +110,7 @@ struct spi_ioc_transfer {
 #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
 
 
-/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) (limited to 8 bits) */
+/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) */
 #define SPI_IOC_RD_MODE			_IOR(SPI_IOC_MAGIC, 1, __u8)
 #define SPI_IOC_WR_MODE			_IOW(SPI_IOC_MAGIC, 1, __u8)
 
@@ -132,10 +126,6 @@ struct spi_ioc_transfer {
 #define SPI_IOC_RD_MAX_SPEED_HZ		_IOR(SPI_IOC_MAGIC, 4, __u32)
 #define SPI_IOC_WR_MAX_SPEED_HZ		_IOW(SPI_IOC_MAGIC, 4, __u32)
 
-/* Read / Write of the SPI mode field */
-#define SPI_IOC_RD_MODE32		_IOR(SPI_IOC_MAGIC, 5, __u32)
-#define SPI_IOC_WR_MODE32		_IOW(SPI_IOC_MAGIC, 5, __u32)
-
 
 
 #endif /* SPIDEV_H */
diff --git a/original/uapi/linux/sysctl.h b/original/uapi/linux/sysctl.h
index 43aaba1..6d67213 100644
--- a/original/uapi/linux/sysctl.h
+++ b/original/uapi/linux/sysctl.h
@@ -568,7 +568,6 @@ enum {
 	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
 	NET_IPV6_PROXY_NDP=23,
 	NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
-	NET_IPV6_ACCEPT_RA_FROM_LOCAL=26,
 	__NET_IPV6_MAX
 };
 
diff --git a/original/uapi/linux/tcp.h b/original/uapi/linux/tcp.h
index 3b97183..377f1e5 100644
--- a/original/uapi/linux/tcp.h
+++ b/original/uapi/linux/tcp.h
@@ -186,9 +186,6 @@ struct tcp_info {
 	__u32	tcpi_rcv_space;
 
 	__u32	tcpi_total_retrans;
-
-	__u64	tcpi_pacing_rate;
-	__u64	tcpi_max_pacing_rate;
 };
 
 /* for TCP_MD5SIG socket option */
diff --git a/original/uapi/linux/tcp_metrics.h b/original/uapi/linux/tcp_metrics.h
index 9353392..54a37b1 100644
--- a/original/uapi/linux/tcp_metrics.h
+++ b/original/uapi/linux/tcp_metrics.h
@@ -11,15 +11,12 @@
 #define TCP_METRICS_GENL_VERSION	0x1
 
 enum tcp_metric_index {
-	TCP_METRIC_RTT,		/* in ms units */
-	TCP_METRIC_RTTVAR,	/* in ms units */
+	TCP_METRIC_RTT,
+	TCP_METRIC_RTTVAR,
 	TCP_METRIC_SSTHRESH,
 	TCP_METRIC_CWND,
 	TCP_METRIC_REORDERING,
 
-	TCP_METRIC_RTT_US,	/* in usec units */
-	TCP_METRIC_RTTVAR_US,	/* in usec units */
-
 	/* Always last.  */
 	__TCP_METRIC_MAX,
 };
diff --git a/original/uapi/linux/tipc.h b/original/uapi/linux/tipc.h
index 6f71b9b..852373d 100644
--- a/original/uapi/linux/tipc.h
+++ b/original/uapi/linux/tipc.h
@@ -38,7 +38,6 @@
 #define _LINUX_TIPC_H_
 
 #include <linux/types.h>
-#include <linux/sockios.h>
 
 /*
  * TIPC addressing primitives
@@ -88,7 +87,6 @@ static inline unsigned int tipc_node(__u32 addr)
 
 #define TIPC_CFG_SRV		0	/* configuration service name type */
 #define TIPC_TOP_SRV		1	/* topology service name type */
-#define TIPC_LINK_STATE		2	/* link state name type */
 #define TIPC_RESERVED_TYPES	64	/* lowest user-publishable name type */
 
 /*
@@ -208,25 +206,4 @@ struct sockaddr_tipc {
 #define TIPC_NODE_RECVQ_DEPTH	131	/* Default: none (read only) */
 #define TIPC_SOCK_RECVQ_DEPTH	132	/* Default: none (read only) */
 
-/*
- * Maximum sizes of TIPC bearer-related names (including terminating NULL)
- * The string formatting for each name element is:
- * media: media
- * interface: media:interface name
- * link: Z.C.N:interface-Z.C.N:interface
- *
- */
-
-#define TIPC_MAX_MEDIA_NAME	16
-#define TIPC_MAX_IF_NAME	16
-#define TIPC_MAX_BEARER_NAME	32
-#define TIPC_MAX_LINK_NAME	60
-
-#define SIOCGETLINKNAME		SIOCPROTOPRIVATE
-
-struct tipc_sioc_ln_req {
-	__u32 peer;
-	__u32 bearer_id;
-	char linkname[TIPC_MAX_LINK_NAME];
-};
 #endif
diff --git a/original/uapi/linux/tipc_config.h b/original/uapi/linux/tipc_config.h
index 876d0a1..6b0bff0 100644
--- a/original/uapi/linux/tipc_config.h
+++ b/original/uapi/linux/tipc_config.h
@@ -39,7 +39,6 @@
 
 #include <linux/types.h>
 #include <linux/string.h>
-#include <linux/tipc.h>
 #include <asm/byteorder.h>
 
 #ifndef __KERNEL__
@@ -156,6 +155,15 @@
 #define TIPC_TLV_PORT_REF	26	/* 32-bit port reference */
 
 /*
+ * Maximum sizes of TIPC bearer-related names (including terminating NUL)
+ */
+
+#define TIPC_MAX_MEDIA_NAME	16	/* format = media */
+#define TIPC_MAX_IF_NAME	16	/* format = interface */
+#define TIPC_MAX_BEARER_NAME	32	/* format = media:interface */
+#define TIPC_MAX_LINK_NAME	60	/* format = Z.C.N:interface-Z.C.N:interface */
+
+/*
  * Link priority limits (min, default, max, media default)
  */
 
@@ -182,7 +190,7 @@
 
 #define TIPC_MIN_LINK_WIN 16
 #define TIPC_DEF_LINK_WIN 50
-#define TIPC_MAX_LINK_WIN 8191
+#define TIPC_MAX_LINK_WIN 150
 
 
 struct tipc_node_info {
diff --git a/original/uapi/linux/udp.h b/original/uapi/linux/udp.h
index 16574ea..e2bcfd7 100644
--- a/original/uapi/linux/udp.h
+++ b/original/uapi/linux/udp.h
@@ -29,8 +29,6 @@ struct udphdr {
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
 #define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
-#define UDP_NO_CHECK6_TX 101	/* Disable sending checksum for UDP6X */
-#define UDP_NO_CHECK6_RX 102	/* Disable accpeting checksum for UDP6 */
 
 /* UDP encapsulation types */
 #define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
diff --git a/original/uapi/linux/uhid.h b/original/uapi/linux/uhid.h
index aaa86d6..414b74b 100644
--- a/original/uapi/linux/uhid.h
+++ b/original/uapi/linux/uhid.h
@@ -21,49 +21,35 @@
 
 #include <linux/input.h>
 #include <linux/types.h>
-#include <linux/hid.h>
 
 enum uhid_event_type {
-	__UHID_LEGACY_CREATE,
+	UHID_CREATE,
 	UHID_DESTROY,
 	UHID_START,
 	UHID_STOP,
 	UHID_OPEN,
 	UHID_CLOSE,
 	UHID_OUTPUT,
-	__UHID_LEGACY_OUTPUT_EV,
-	__UHID_LEGACY_INPUT,
-	UHID_GET_REPORT,
-	UHID_GET_REPORT_REPLY,
-	UHID_CREATE2,
-	UHID_INPUT2,
-	UHID_SET_REPORT,
-	UHID_SET_REPORT_REPLY,
+	UHID_OUTPUT_EV,			/* obsolete! */
+	UHID_INPUT,
+	UHID_FEATURE,
+	UHID_FEATURE_ANSWER,
 };
 
-struct uhid_create2_req {
+struct uhid_create_req {
 	__u8 name[128];
 	__u8 phys[64];
 	__u8 uniq[64];
+	__u8 __user *rd_data;
 	__u16 rd_size;
+
 	__u16 bus;
 	__u32 vendor;
 	__u32 product;
 	__u32 version;
 	__u32 country;
-	__u8 rd_data[HID_MAX_DESCRIPTOR_SIZE];
 } __attribute__((__packed__));
 
-enum uhid_dev_flag {
-	UHID_DEV_NUMBERED_FEATURE_REPORTS			= (1ULL << 0),
-	UHID_DEV_NUMBERED_OUTPUT_REPORTS			= (1ULL << 1),
-	UHID_DEV_NUMBERED_INPUT_REPORTS				= (1ULL << 2),
-};
-
-struct uhid_start_req {
-	__u64 dev_flags;
-};
-
 #define UHID_DATA_MAX 4096
 
 enum uhid_report_type {
@@ -72,9 +58,9 @@ enum uhid_report_type {
 	UHID_INPUT_REPORT,
 };
 
-struct uhid_input2_req {
-	__u16 size;
+struct uhid_input_req {
 	__u8 data[UHID_DATA_MAX];
+	__u16 size;
 } __attribute__((__packed__));
 
 struct uhid_output_req {
@@ -83,83 +69,20 @@ struct uhid_output_req {
 	__u8 rtype;
 } __attribute__((__packed__));
 
-struct uhid_get_report_req {
-	__u32 id;
-	__u8 rnum;
-	__u8 rtype;
-} __attribute__((__packed__));
-
-struct uhid_get_report_reply_req {
-	__u32 id;
-	__u16 err;
-	__u16 size;
-	__u8 data[UHID_DATA_MAX];
-} __attribute__((__packed__));
-
-struct uhid_set_report_req {
-	__u32 id;
-	__u8 rnum;
-	__u8 rtype;
-	__u16 size;
-	__u8 data[UHID_DATA_MAX];
-} __attribute__((__packed__));
-
-struct uhid_set_report_reply_req {
-	__u32 id;
-	__u16 err;
-} __attribute__((__packed__));
-
-/*
- * Compat Layer
- * All these commands and requests are obsolete. You should avoid using them in
- * new code. We support them for backwards-compatibility, but you might not get
- * access to new feature in case you use them.
- */
-
-enum uhid_legacy_event_type {
-	UHID_CREATE			= __UHID_LEGACY_CREATE,
-	UHID_OUTPUT_EV			= __UHID_LEGACY_OUTPUT_EV,
-	UHID_INPUT			= __UHID_LEGACY_INPUT,
-	UHID_FEATURE			= UHID_GET_REPORT,
-	UHID_FEATURE_ANSWER		= UHID_GET_REPORT_REPLY,
-};
-
-/* Obsolete! Use UHID_CREATE2. */
-struct uhid_create_req {
-	__u8 name[128];
-	__u8 phys[64];
-	__u8 uniq[64];
-	__u8 __user *rd_data;
-	__u16 rd_size;
-
-	__u16 bus;
-	__u32 vendor;
-	__u32 product;
-	__u32 version;
-	__u32 country;
-} __attribute__((__packed__));
-
-/* Obsolete! Use UHID_INPUT2. */
-struct uhid_input_req {
-	__u8 data[UHID_DATA_MAX];
-	__u16 size;
-} __attribute__((__packed__));
-
-/* Obsolete! Kernel uses UHID_OUTPUT exclusively now. */
+/* Obsolete! Newer kernels will no longer send these events but instead convert
+ * it into raw output reports via UHID_OUTPUT. */
 struct uhid_output_ev_req {
 	__u16 type;
 	__u16 code;
 	__s32 value;
 } __attribute__((__packed__));
 
-/* Obsolete! Kernel uses ABI compatible UHID_GET_REPORT. */
 struct uhid_feature_req {
 	__u32 id;
 	__u8 rnum;
 	__u8 rtype;
 } __attribute__((__packed__));
 
-/* Obsolete! Use ABI compatible UHID_GET_REPORT_REPLY. */
 struct uhid_feature_answer_req {
 	__u32 id;
 	__u16 err;
@@ -167,15 +90,6 @@ struct uhid_feature_answer_req {
 	__u8 data[UHID_DATA_MAX];
 } __attribute__((__packed__));
 
-/*
- * UHID Events
- * All UHID events from and to the kernel are encoded as "struct uhid_event".
- * The "type" field contains a UHID_* type identifier. All payload depends on
- * that type and can be accessed via ev->u.XYZ accordingly.
- * If user-space writes short events, they're extended with 0s by the kernel. If
- * the kernel writes short events, user-space shall extend them with 0s.
- */
-
 struct uhid_event {
 	__u32 type;
 
@@ -185,14 +99,7 @@ struct uhid_event {
 		struct uhid_output_req output;
 		struct uhid_output_ev_req output_ev;
 		struct uhid_feature_req feature;
-		struct uhid_get_report_req get_report;
 		struct uhid_feature_answer_req feature_answer;
-		struct uhid_get_report_reply_req get_report_reply;
-		struct uhid_create2_req create2;
-		struct uhid_input2_req input2;
-		struct uhid_set_report_req set_report;
-		struct uhid_set_report_reply_req set_report_reply;
-		struct uhid_start_req start;
 	} u;
 } __attribute__((__packed__));
 
diff --git a/original/uapi/linux/uinput.h b/original/uapi/linux/uinput.h
index baeab83..fe46431 100644
--- a/original/uapi/linux/uinput.h
+++ b/original/uapi/linux/uinput.h
@@ -20,8 +20,6 @@
  * Author: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
  *
  * Changes/Revisions:
- *	0.4	01/09/2014 (Benjamin Tissoires <benjamin.tissoires@redhat.com>)
- *		- add UI_GET_SYSNAME ioctl
  *	0.3	24/05/2006 (Anssi Hannula <anssi.hannulagmail.com>)
  *		- update ff support for the changes in kernel interface
  *		- add UINPUT_VERSION
@@ -37,7 +35,7 @@
 #include <linux/types.h>
 #include <linux/input.h>
 
-#define UINPUT_VERSION		4
+#define UINPUT_VERSION		3
 
 
 struct uinput_ff_upload {
@@ -75,24 +73,6 @@ struct uinput_ff_erase {
 #define UI_BEGIN_FF_ERASE	_IOWR(UINPUT_IOCTL_BASE, 202, struct uinput_ff_erase)
 #define UI_END_FF_ERASE		_IOW(UINPUT_IOCTL_BASE, 203, struct uinput_ff_erase)
 
-/**
- * UI_GET_SYSNAME - get the sysfs name of the created uinput device
- *
- * @return the sysfs name of the created virtual input device.
- * The complete sysfs path is then /sys/devices/virtual/input/--NAME--
- * Usually, it is in the form "inputN"
- */
-#define UI_GET_SYSNAME(len)	_IOC(_IOC_READ, UINPUT_IOCTL_BASE, 300, len)
-
-/**
- * UI_GET_VERSION - Return version of uinput protocol
- *
- * This writes uinput protocol version implemented by the kernel into
- * the integer pointed to by the ioctl argument. The protocol version
- * is hard-coded in the kernel and is independent of the uinput device.
- */
-#define UI_GET_VERSION		_IOR(UINPUT_IOCTL_BASE, 301, unsigned int)
-
 /*
  * To write a force-feedback-capable driver, the upload_effect
  * and erase_effect callbacks in input_dev must be implemented.
diff --git a/original/uapi/linux/usb/cdc.h b/original/uapi/linux/usb/cdc.h
index b6a9cdd..f35aa0a 100644
--- a/original/uapi/linux/usb/cdc.h
+++ b/original/uapi/linux/usb/cdc.h
@@ -56,7 +56,6 @@
 #define USB_CDC_OBEX_TYPE		0x15
 #define USB_CDC_NCM_TYPE		0x1a
 #define USB_CDC_MBIM_TYPE		0x1b
-#define USB_CDC_MBIM_EXTENDED_TYPE	0x1c
 
 /* "Header Functional Descriptor" from CDC spec  5.2.3.1 */
 struct usb_cdc_header_desc {
@@ -206,17 +205,6 @@ struct usb_cdc_mbim_desc {
 	__u8    bmNetworkCapabilities;
 } __attribute__ ((packed));
 
-/* "MBIM Extended Functional Descriptor" from CDC MBIM spec 1.0 errata-1 */
-struct usb_cdc_mbim_extended_desc {
-	__u8	bLength;
-	__u8	bDescriptorType;
-	__u8	bDescriptorSubType;
-
-	__le16	bcdMBIMExtendedVersion;
-	__u8	bMaxOutstandingCommandMessages;
-	__le16	wMTU;
-} __attribute__ ((packed));
-
 /*-------------------------------------------------------------------------*/
 
 /*
diff --git a/original/uapi/linux/usb/ch9.h b/original/uapi/linux/usb/ch9.h
index aa33fd1..76a7f03 100644
--- a/original/uapi/linux/usb/ch9.h
+++ b/original/uapi/linux/usb/ch9.h
@@ -135,6 +135,8 @@
 #define	TEST_SE0_NAK	3
 #define	TEST_PACKET	4
 #define	TEST_FORCE_EN	5
+#define	TEST_OTG_SRP_REQD	6
+#define	TEST_OTG_HNP_REQD	7
 
 /*
  * New Feature Selectors as added by USB 3.0
@@ -674,9 +676,24 @@ struct usb_otg_descriptor {
 	__u8  bmAttributes;	/* support for HNP, SRP, etc */
 } __attribute__ ((packed));
 
+/* USB_DT_OTG (from OTG 2.0 supplement) */
+struct usb_otg20_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bmAttributes;	/* support for HNP, SRP, etc */
+	__le16 bcdOTG;		/* OTG and EH supplement release number
+				 * in binary-coded decimal (i.e. 2.0 is 0200H).
+				 * This field identifies the release of the
+				 * OTG and EH supplement with which the device
+				 * and its descriptors are compliant.
+				 */
+} __attribute__ ((packed));
+
 /* from usb_otg_descriptor.bmAttributes */
 #define USB_OTG_SRP		(1 << 0)
 #define USB_OTG_HNP		(1 << 1)	/* swap host/device roles */
+#define USB_OTG_ADP		(1 << 2)	/* support ADP */
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/original/uapi/linux/usb/functionfs.h b/original/uapi/linux/usb/functionfs.h
index 295ba29..f279394 100644
--- a/original/uapi/linux/usb/functionfs.h
+++ b/original/uapi/linux/usb/functionfs.h
@@ -10,17 +10,11 @@
 
 enum {
 	FUNCTIONFS_DESCRIPTORS_MAGIC = 1,
-	FUNCTIONFS_STRINGS_MAGIC = 2,
-	FUNCTIONFS_DESCRIPTORS_MAGIC_V2 = 3,
+	FUNCTIONFS_STRINGS_MAGIC     = 2
 };
 
-enum functionfs_flags {
-	FUNCTIONFS_HAS_FS_DESC = 1,
-	FUNCTIONFS_HAS_HS_DESC = 2,
-	FUNCTIONFS_HAS_SS_DESC = 4,
-	FUNCTIONFS_HAS_MS_OS_DESC = 8,
-	FUNCTIONFS_VIRTUAL_ADDR = 16,
-};
+
+#ifndef __KERNEL__
 
 /* Descriptor of an non-audio endpoint */
 struct usb_endpoint_descriptor_no_audio {
@@ -33,15 +27,10 @@ struct usb_endpoint_descriptor_no_audio {
 	__u8  bInterval;
 } __attribute__((packed));
 
-struct usb_functionfs_descs_head_v2 {
-	__le32 magic;
-	__le32 length;
-	__le32 flags;
-	/*
-	 * __le32 fs_count, hs_count, fs_count; must be included manually in
-	 * the structure taking flags into consideration.
-	 */
-} __attribute__((packed));
+
+/*
+ * All numbers must be in little endian order.
+ */
 
 /* Legacy format, deprecated as of 3.14. */
 struct usb_functionfs_descs_head {
@@ -51,125 +40,25 @@ struct usb_functionfs_descs_head {
 	__le32 hs_count;
 } __attribute__((packed, deprecated));
 
-/* MS OS Descriptor header */
-struct usb_os_desc_header {
-	__u8	interface;
-	__le32	dwLength;
-	__le16	bcdVersion;
-	__le16	wIndex;
-	union {
-		struct {
-			__u8	bCount;
-			__u8	Reserved;
-		};
-		__le16	wCount;
-	};
-} __attribute__((packed));
-
-struct usb_ext_compat_desc {
-	__u8	bFirstInterfaceNumber;
-	__u8	Reserved1;
-	__u8	CompatibleID[8];
-	__u8	SubCompatibleID[8];
-	__u8	Reserved2[6];
-};
-
-struct usb_ext_prop_desc {
-	__le32	dwSize;
-	__le32	dwPropertyDataType;
-	__le16	wPropertyNameLength;
-} __attribute__((packed));
-
-#ifndef __KERNEL__
-
 /*
  * Descriptors format:
  *
  * | off | name      | type         | description                          |
  * |-----+-----------+--------------+--------------------------------------|
- * |   0 | magic     | LE32         | FUNCTIONFS_DESCRIPTORS_MAGIC_V2      |
- * |   4 | length    | LE32         | length of the whole data chunk       |
- * |   8 | flags     | LE32         | combination of functionfs_flags      |
- * |     | fs_count  | LE32         | number of full-speed descriptors     |
- * |     | hs_count  | LE32         | number of high-speed descriptors     |
- * |     | ss_count  | LE32         | number of super-speed descriptors    |
- * |     | os_count  | LE32         | number of MS OS descriptors          |
- * |     | fs_descrs | Descriptor[] | list of full-speed descriptors       |
- * |     | hs_descrs | Descriptor[] | list of high-speed descriptors       |
- * |     | ss_descrs | Descriptor[] | list of super-speed descriptors      |
- * |     | os_descrs | OSDesc[]     | list of MS OS descriptors            |
- *
- * Depending on which flags are set, various fields may be missing in the
- * structure.  Any flags that are not recognised cause the whole block to be
- * rejected with -ENOSYS.
- *
- * Legacy descriptors format (deprecated as of 3.14):
- *
- * | off | name      | type         | description                          |
- * |-----+-----------+--------------+--------------------------------------|
- * |   0 | magic     | LE32         | FUNCTIONFS_DESCRIPTORS_MAGIC         |
+ * |   0 | magic     | LE32         | FUNCTIONFS_{FS,HS}_DESCRIPTORS_MAGIC |
  * |   4 | length    | LE32         | length of the whole data chunk       |
  * |   8 | fs_count  | LE32         | number of full-speed descriptors     |
  * |  12 | hs_count  | LE32         | number of high-speed descriptors     |
  * |  16 | fs_descrs | Descriptor[] | list of full-speed descriptors       |
  * |     | hs_descrs | Descriptor[] | list of high-speed descriptors       |
  *
- * All numbers must be in little endian order.
- *
- * Descriptor[] is an array of valid USB descriptors which have the following
- * format:
+ * descs are just valid USB descriptors and have the following format:
  *
  * | off | name            | type | description              |
  * |-----+-----------------+------+--------------------------|
  * |   0 | bLength         | U8   | length of the descriptor |
  * |   1 | bDescriptorType | U8   | descriptor type          |
  * |   2 | payload         |      | descriptor's payload     |
- *
- * OSDesc[] is an array of valid MS OS Feature Descriptors which have one of
- * the following formats:
- *
- * | off | name            | type | description              |
- * |-----+-----------------+------+--------------------------|
- * |   0 | inteface        | U8   | related interface number |
- * |   1 | dwLength        | U32  | length of the descriptor |
- * |   5 | bcdVersion      | U16  | currently supported: 1   |
- * |   7 | wIndex          | U16  | currently supported: 4   |
- * |   9 | bCount          | U8   | number of ext. compat.   |
- * |  10 | Reserved        | U8   | 0                        |
- * |  11 | ExtCompat[]     |      | list of ext. compat. d.  |
- *
- * | off | name            | type | description              |
- * |-----+-----------------+------+--------------------------|
- * |   0 | inteface        | U8   | related interface number |
- * |   1 | dwLength        | U32  | length of the descriptor |
- * |   5 | bcdVersion      | U16  | currently supported: 1   |
- * |   7 | wIndex          | U16  | currently supported: 5   |
- * |   9 | wCount          | U16  | number of ext. compat.   |
- * |  11 | ExtProp[]       |      | list of ext. prop. d.    |
- *
- * ExtCompat[] is an array of valid Extended Compatiblity descriptors
- * which have the following format:
- *
- * | off | name                  | type | description                         |
- * |-----+-----------------------+------+-------------------------------------|
- * |   0 | bFirstInterfaceNumber | U8   | index of the interface or of the 1st|
- * |     |                       |      | interface in an IAD group           |
- * |   1 | Reserved              | U8   | 0                                   |
- * |   2 | CompatibleID          | U8[8]| compatible ID string                |
- * |  10 | SubCompatibleID       | U8[8]| subcompatible ID string             |
- * |  18 | Reserved              | U8[6]| 0                                   |
- *
- * ExtProp[] is an array of valid Extended Properties descriptors
- * which have the following format:
- *
- * | off | name                  | type | description                         |
- * |-----+-----------------------+------+-------------------------------------|
- * |   0 | dwSize                | U32  | length of the descriptor            |
- * |   4 | dwPropertyDataType    | U32  | 1..7                                |
- * |   8 | wPropertyNameLength   | U16  | bPropertyName length (NL)           |
- * |  10 | bPropertyName         |U8[NL]| name of this property               |
- * |10+NL| dwPropertyDataLength  | U32  | bPropertyData length (DL)           |
- * |14+NL| bProperty             |U8[DL]| payload of this property            |
  */
 
 struct usb_functionfs_strings_head {
@@ -276,12 +165,6 @@ struct usb_functionfs_event {
  */
 #define	FUNCTIONFS_ENDPOINT_REVMAP	_IO('g', 129)
 
-/*
- * Returns endpoint descriptor. If function is not active returns -ENODEV.
- */
-#define	FUNCTIONFS_ENDPOINT_DESC	_IOR('g', 130, \
-					     struct usb_endpoint_descriptor)
-
 
 
 #endif /* _UAPI__LINUX_FUNCTIONFS_H__ */
diff --git a/original/uapi/linux/usbdevice_fs.h b/original/uapi/linux/usbdevice_fs.h
index abe5f4b..0c65e4b 100644
--- a/original/uapi/linux/usbdevice_fs.h
+++ b/original/uapi/linux/usbdevice_fs.h
@@ -102,10 +102,7 @@ struct usbdevfs_urb {
 	int buffer_length;
 	int actual_length;
 	int start_frame;
-	union {
-		int number_of_packets;	/* Only used for isoc urbs */
-		unsigned int stream_id;	/* Only used with bulk streams */
-	};
+	int number_of_packets;
 	int error_count;
 	unsigned int signr;	/* signal to be sent on completion,
 				  or 0 if none should be sent. */
@@ -147,11 +144,6 @@ struct usbdevfs_disconnect_claim {
 	char driver[USBDEVFS_MAXDRIVERNAME + 1];
 };
 
-struct usbdevfs_streams {
-	unsigned int num_streams; /* Not used by USBDEVFS_FREE_STREAMS */
-	unsigned int num_eps;
-	unsigned char eps[0];
-};
 
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
@@ -184,7 +176,5 @@ struct usbdevfs_streams {
 #define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
 #define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
-#define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
-#define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */
diff --git a/original/uapi/linux/v4l2-common.h b/original/uapi/linux/v4l2-common.h
index 2f6f8ca..4f0667e 100644
--- a/original/uapi/linux/v4l2-common.h
+++ b/original/uapi/linux/v4l2-common.h
@@ -29,8 +29,6 @@
 #ifndef __V4L2_COMMON__
 #define __V4L2_COMMON__
 
-#include <linux/types.h>
-
 /*
  *
  * Selection interface definitions
@@ -70,12 +68,4 @@
 #define V4L2_SUBDEV_SEL_FLAG_SIZE_LE	V4L2_SEL_FLAG_LE
 #define V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG V4L2_SEL_FLAG_KEEP_CONFIG
 
-struct v4l2_edid {
-	__u32 pad;
-	__u32 start_block;
-	__u32 blocks;
-	__u32 reserved[5];
-	__u8  *edid;
-};
-
 #endif /* __V4L2_COMMON__ */
diff --git a/original/uapi/linux/v4l2-controls.h b/original/uapi/linux/v4l2-controls.h
index 661f119..2cbe605 100644
--- a/original/uapi/linux/v4l2-controls.h
+++ b/original/uapi/linux/v4l2-controls.h
@@ -60,8 +60,6 @@
 #define V4L2_CTRL_CLASS_IMAGE_PROC	0x009f0000	/* Image processing controls */
 #define V4L2_CTRL_CLASS_DV		0x00a00000	/* Digital Video controls */
 #define V4L2_CTRL_CLASS_FM_RX		0x00a10000	/* FM Receiver controls */
-#define V4L2_CTRL_CLASS_RF_TUNER	0x00a20000	/* RF tuner controls */
-#define V4L2_CTRL_CLASS_DETECT		0x00a30000	/* Detection controls */
 
 /* User-class control IDs */
 
@@ -378,8 +376,6 @@ enum v4l2_mpeg_video_multi_slice_mode {
 #define V4L2_CID_MPEG_VIDEO_DEC_FRAME			(V4L2_CID_MPEG_BASE+224)
 #define V4L2_CID_MPEG_VIDEO_VBV_DELAY			(V4L2_CID_MPEG_BASE+225)
 #define V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER		(V4L2_CID_MPEG_BASE+226)
-#define V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE		(V4L2_CID_MPEG_BASE+227)
-#define V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE		(V4L2_CID_MPEG_BASE+228)
 
 #define V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP		(V4L2_CID_MPEG_BASE+300)
 #define V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP		(V4L2_CID_MPEG_BASE+301)
@@ -746,8 +742,6 @@ enum v4l2_auto_focus_range {
 	V4L2_AUTO_FOCUS_RANGE_INFINITY		= 3,
 };
 
-#define V4L2_CID_PAN_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+32)
-#define V4L2_CID_TILT_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+33)
 
 /* FM Modulator class control IDs */
 
@@ -759,15 +753,6 @@ enum v4l2_auto_focus_range {
 #define V4L2_CID_RDS_TX_PTY			(V4L2_CID_FM_TX_CLASS_BASE + 3)
 #define V4L2_CID_RDS_TX_PS_NAME			(V4L2_CID_FM_TX_CLASS_BASE + 5)
 #define V4L2_CID_RDS_TX_RADIO_TEXT		(V4L2_CID_FM_TX_CLASS_BASE + 6)
-#define V4L2_CID_RDS_TX_MONO_STEREO		(V4L2_CID_FM_TX_CLASS_BASE + 7)
-#define V4L2_CID_RDS_TX_ARTIFICIAL_HEAD		(V4L2_CID_FM_TX_CLASS_BASE + 8)
-#define V4L2_CID_RDS_TX_COMPRESSED		(V4L2_CID_FM_TX_CLASS_BASE + 9)
-#define V4L2_CID_RDS_TX_DYNAMIC_PTY		(V4L2_CID_FM_TX_CLASS_BASE + 10)
-#define V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT	(V4L2_CID_FM_TX_CLASS_BASE + 11)
-#define V4L2_CID_RDS_TX_TRAFFIC_PROGRAM		(V4L2_CID_FM_TX_CLASS_BASE + 12)
-#define V4L2_CID_RDS_TX_MUSIC_SPEECH		(V4L2_CID_FM_TX_CLASS_BASE + 13)
-#define V4L2_CID_RDS_TX_ALT_FREQS_ENABLE	(V4L2_CID_FM_TX_CLASS_BASE + 14)
-#define V4L2_CID_RDS_TX_ALT_FREQS		(V4L2_CID_FM_TX_CLASS_BASE + 15)
 
 #define V4L2_CID_AUDIO_LIMITER_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 64)
 #define V4L2_CID_AUDIO_LIMITER_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 65)
@@ -827,9 +812,6 @@ enum v4l2_flash_strobe_source {
 #define V4L2_FLASH_FAULT_SHORT_CIRCUIT		(1 << 3)
 #define V4L2_FLASH_FAULT_OVER_CURRENT		(1 << 4)
 #define V4L2_FLASH_FAULT_INDICATOR		(1 << 5)
-#define V4L2_FLASH_FAULT_UNDER_VOLTAGE		(1 << 6)
-#define V4L2_FLASH_FAULT_INPUT_VOLTAGE		(1 << 7)
-#define V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE	(1 << 8)
 
 #define V4L2_CID_FLASH_CHARGE			(V4L2_CID_FLASH_CLASS_BASE + 11)
 #define V4L2_CID_FLASH_READY			(V4L2_CID_FLASH_CLASS_BASE + 12)
@@ -867,10 +849,6 @@ enum v4l2_jpeg_chroma_subsampling {
 #define V4L2_CID_VBLANK				(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 1)
 #define V4L2_CID_HBLANK				(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 2)
 #define V4L2_CID_ANALOGUE_GAIN			(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 3)
-#define V4L2_CID_TEST_PATTERN_RED		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 4)
-#define V4L2_CID_TEST_PATTERN_GREENR		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 5)
-#define V4L2_CID_TEST_PATTERN_BLUE		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 6)
-#define V4L2_CID_TEST_PATTERN_GREENB		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 7)
 
 
 /* Image processing controls */
@@ -916,40 +894,5 @@ enum v4l2_deemphasis {
 };
 
 #define V4L2_CID_RDS_RECEPTION			(V4L2_CID_FM_RX_CLASS_BASE + 2)
-#define V4L2_CID_RDS_RX_PTY			(V4L2_CID_FM_RX_CLASS_BASE + 3)
-#define V4L2_CID_RDS_RX_PS_NAME			(V4L2_CID_FM_RX_CLASS_BASE + 4)
-#define V4L2_CID_RDS_RX_RADIO_TEXT		(V4L2_CID_FM_RX_CLASS_BASE + 5)
-#define V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT	(V4L2_CID_FM_RX_CLASS_BASE + 6)
-#define V4L2_CID_RDS_RX_TRAFFIC_PROGRAM		(V4L2_CID_FM_RX_CLASS_BASE + 7)
-#define V4L2_CID_RDS_RX_MUSIC_SPEECH		(V4L2_CID_FM_RX_CLASS_BASE + 8)
-
-#define V4L2_CID_RF_TUNER_CLASS_BASE		(V4L2_CTRL_CLASS_RF_TUNER | 0x900)
-#define V4L2_CID_RF_TUNER_CLASS			(V4L2_CTRL_CLASS_RF_TUNER | 1)
-
-#define V4L2_CID_RF_TUNER_BANDWIDTH_AUTO	(V4L2_CID_RF_TUNER_CLASS_BASE + 11)
-#define V4L2_CID_RF_TUNER_BANDWIDTH		(V4L2_CID_RF_TUNER_CLASS_BASE + 12)
-#define V4L2_CID_RF_TUNER_LNA_GAIN_AUTO		(V4L2_CID_RF_TUNER_CLASS_BASE + 41)
-#define V4L2_CID_RF_TUNER_LNA_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 42)
-#define V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO	(V4L2_CID_RF_TUNER_CLASS_BASE + 51)
-#define V4L2_CID_RF_TUNER_MIXER_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 52)
-#define V4L2_CID_RF_TUNER_IF_GAIN_AUTO		(V4L2_CID_RF_TUNER_CLASS_BASE + 61)
-#define V4L2_CID_RF_TUNER_IF_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 62)
-#define V4L2_CID_RF_TUNER_PLL_LOCK			(V4L2_CID_RF_TUNER_CLASS_BASE + 91)
-
-
-/*  Detection-class control IDs defined by V4L2 */
-#define V4L2_CID_DETECT_CLASS_BASE		(V4L2_CTRL_CLASS_DETECT | 0x900)
-#define V4L2_CID_DETECT_CLASS			(V4L2_CTRL_CLASS_DETECT | 1)
-
-#define V4L2_CID_DETECT_MD_MODE			(V4L2_CID_DETECT_CLASS_BASE + 1)
-enum v4l2_detect_md_mode {
-	V4L2_DETECT_MD_MODE_DISABLED		= 0,
-	V4L2_DETECT_MD_MODE_GLOBAL		= 1,
-	V4L2_DETECT_MD_MODE_THRESHOLD_GRID	= 2,
-	V4L2_DETECT_MD_MODE_REGION_GRID		= 3,
-};
-#define V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD	(V4L2_CID_DETECT_CLASS_BASE + 2)
-#define V4L2_CID_DETECT_MD_THRESHOLD_GRID	(V4L2_CID_DETECT_CLASS_BASE + 3)
-#define V4L2_CID_DETECT_MD_REGION_GRID		(V4L2_CID_DETECT_CLASS_BASE + 4)
 
 #endif
diff --git a/original/uapi/linux/v4l2-dv-timings.h b/original/uapi/linux/v4l2-dv-timings.h
index 6c8f159..be709fe 100644
--- a/original/uapi/linux/v4l2-dv-timings.h
+++ b/original/uapi/linux/v4l2-dv-timings.h
@@ -173,76 +173,6 @@
 		V4L2_DV_FL_CAN_REDUCE_FPS) \
 }
 
-#define V4L2_DV_BT_CEA_3840X2160P24 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 1276, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
-#define V4L2_DV_BT_CEA_3840X2160P25 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, 0) \
-}
-
-#define V4L2_DV_BT_CEA_3840X2160P30 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
-#define V4L2_DV_BT_CEA_3840X2160P50 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		594000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, 0) \
-}
-
-#define V4L2_DV_BT_CEA_3840X2160P60 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		594000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
-#define V4L2_DV_BT_CEA_4096X2160P24 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 1020, 88, 296, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
-#define V4L2_DV_BT_CEA_4096X2160P25 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, 0) \
-}
-
-#define V4L2_DV_BT_CEA_4096X2160P30 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		297000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
-#define V4L2_DV_BT_CEA_4096X2160P50 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		594000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, 0) \
-}
-
-#define V4L2_DV_BT_CEA_4096X2160P60 { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		594000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
-		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_CAN_REDUCE_FPS) \
-}
-
 
 /* VESA Discrete Monitor Timings as per version 1.0, revision 12 */
 
@@ -893,21 +823,4 @@
 		V4L2_DV_FL_REDUCED_BLANKING) \
 }
 
-/* 4K resolutions */
-#define V4L2_DV_BT_DMT_4096X2160P60_RB { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		556744000, 8, 32, 40, 48, 8, 6, 0, 0, 0, \
-		V4L2_DV_BT_STD_DMT | V4L2_DV_BT_STD_CVT, \
-		V4L2_DV_FL_REDUCED_BLANKING) \
-}
-
-#define V4L2_DV_BT_DMT_4096X2160P59_94_RB { \
-	.type = V4L2_DV_BT_656_1120, \
-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \
-		556188000, 8, 32, 40, 48, 8, 6, 0, 0, 0, \
-		V4L2_DV_BT_STD_DMT | V4L2_DV_BT_STD_CVT, \
-		V4L2_DV_FL_REDUCED_BLANKING) \
-}
-
 #endif
diff --git a/original/uapi/linux/v4l2-mediabus.h b/original/uapi/linux/v4l2-mediabus.h
index 1445e85..b5c3aab 100644
--- a/original/uapi/linux/v4l2-mediabus.h
+++ b/original/uapi/linux/v4l2-mediabus.h
@@ -52,7 +52,7 @@ enum v4l2_mbus_pixelcode {
 	V4L2_MBUS_FMT_RGB888_2X12_LE = 0x100c,
 	V4L2_MBUS_FMT_ARGB8888_1X32 = 0x100d,
 
-	/* YUV (including grey) - next is 0x2024 */
+	/* YUV (including grey) - next is 0x2018 */
 	V4L2_MBUS_FMT_Y8_1X8 = 0x2001,
 	V4L2_MBUS_FMT_UV8_1X8 = 0x2015,
 	V4L2_MBUS_FMT_UYVY8_1_5X8 = 0x2002,
@@ -64,8 +64,6 @@ enum v4l2_mbus_pixelcode {
 	V4L2_MBUS_FMT_YUYV8_2X8 = 0x2008,
 	V4L2_MBUS_FMT_YVYU8_2X8 = 0x2009,
 	V4L2_MBUS_FMT_Y10_1X10 = 0x200a,
-	V4L2_MBUS_FMT_UYVY10_2X10 = 0x2018,
-	V4L2_MBUS_FMT_VYUY10_2X10 = 0x2019,
 	V4L2_MBUS_FMT_YUYV10_2X10 = 0x200b,
 	V4L2_MBUS_FMT_YVYU10_2X10 = 0x200c,
 	V4L2_MBUS_FMT_Y12_1X12 = 0x2013,
@@ -74,20 +72,10 @@ enum v4l2_mbus_pixelcode {
 	V4L2_MBUS_FMT_YUYV8_1X16 = 0x2011,
 	V4L2_MBUS_FMT_YVYU8_1X16 = 0x2012,
 	V4L2_MBUS_FMT_YDYUYDYV8_1X16 = 0x2014,
-	V4L2_MBUS_FMT_UYVY10_1X20 = 0x201a,
-	V4L2_MBUS_FMT_VYUY10_1X20 = 0x201b,
 	V4L2_MBUS_FMT_YUYV10_1X20 = 0x200d,
 	V4L2_MBUS_FMT_YVYU10_1X20 = 0x200e,
 	V4L2_MBUS_FMT_YUV10_1X30 = 0x2016,
 	V4L2_MBUS_FMT_AYUV8_1X32 = 0x2017,
-	V4L2_MBUS_FMT_UYVY12_2X12 = 0x201c,
-	V4L2_MBUS_FMT_VYUY12_2X12 = 0x201d,
-	V4L2_MBUS_FMT_YUYV12_2X12 = 0x201e,
-	V4L2_MBUS_FMT_YVYU12_2X12 = 0x201f,
-	V4L2_MBUS_FMT_UYVY12_1X24 = 0x2020,
-	V4L2_MBUS_FMT_VYUY12_1X24 = 0x2021,
-	V4L2_MBUS_FMT_YUYV12_1X24 = 0x2022,
-	V4L2_MBUS_FMT_YVYU12_1X24 = 0x2023,
 
 	/* Bayer - next is 0x3019 */
 	V4L2_MBUS_FMT_SBGGR8_1X8 = 0x3001,
diff --git a/original/uapi/linux/v4l2-subdev.h b/original/uapi/linux/v4l2-subdev.h
index a619cdd..a33c4da 100644
--- a/original/uapi/linux/v4l2-subdev.h
+++ b/original/uapi/linux/v4l2-subdev.h
@@ -148,27 +148,33 @@ struct v4l2_subdev_selection {
 	__u32 reserved[8];
 };
 
-/* Backwards compatibility define --- to be removed */
-#define v4l2_subdev_edid v4l2_edid
+struct v4l2_subdev_edid {
+	__u32 pad;
+	__u32 start_block;
+	__u32 blocks;
+	__u32 reserved[5];
+	__u8 __user *edid;
+};
 
-#define VIDIOC_SUBDEV_G_FMT			_IOWR('V',  4, struct v4l2_subdev_format)
-#define VIDIOC_SUBDEV_S_FMT			_IOWR('V',  5, struct v4l2_subdev_format)
-#define VIDIOC_SUBDEV_G_FRAME_INTERVAL		_IOWR('V', 21, struct v4l2_subdev_frame_interval)
-#define VIDIOC_SUBDEV_S_FRAME_INTERVAL		_IOWR('V', 22, struct v4l2_subdev_frame_interval)
-#define VIDIOC_SUBDEV_ENUM_MBUS_CODE		_IOWR('V',  2, struct v4l2_subdev_mbus_code_enum)
-#define VIDIOC_SUBDEV_ENUM_FRAME_SIZE		_IOWR('V', 74, struct v4l2_subdev_frame_size_enum)
-#define VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL	_IOWR('V', 75, struct v4l2_subdev_frame_interval_enum)
-#define VIDIOC_SUBDEV_G_CROP			_IOWR('V', 59, struct v4l2_subdev_crop)
-#define VIDIOC_SUBDEV_S_CROP			_IOWR('V', 60, struct v4l2_subdev_crop)
-#define VIDIOC_SUBDEV_G_SELECTION		_IOWR('V', 61, struct v4l2_subdev_selection)
-#define VIDIOC_SUBDEV_S_SELECTION		_IOWR('V', 62, struct v4l2_subdev_selection)
-/* The following ioctls are identical to the ioctls in videodev2.h */
-#define VIDIOC_SUBDEV_G_EDID			_IOWR('V', 40, struct v4l2_edid)
-#define VIDIOC_SUBDEV_S_EDID			_IOWR('V', 41, struct v4l2_edid)
-#define VIDIOC_SUBDEV_S_DV_TIMINGS		_IOWR('V', 87, struct v4l2_dv_timings)
-#define VIDIOC_SUBDEV_G_DV_TIMINGS		_IOWR('V', 88, struct v4l2_dv_timings)
-#define VIDIOC_SUBDEV_ENUM_DV_TIMINGS		_IOWR('V', 98, struct v4l2_enum_dv_timings)
-#define VIDIOC_SUBDEV_QUERY_DV_TIMINGS		_IOR('V', 99, struct v4l2_dv_timings)
-#define VIDIOC_SUBDEV_DV_TIMINGS_CAP		_IOWR('V', 100, struct v4l2_dv_timings_cap)
+#define VIDIOC_SUBDEV_G_FMT	_IOWR('V',  4, struct v4l2_subdev_format)
+#define VIDIOC_SUBDEV_S_FMT	_IOWR('V',  5, struct v4l2_subdev_format)
+#define VIDIOC_SUBDEV_G_FRAME_INTERVAL \
+			_IOWR('V', 21, struct v4l2_subdev_frame_interval)
+#define VIDIOC_SUBDEV_S_FRAME_INTERVAL \
+			_IOWR('V', 22, struct v4l2_subdev_frame_interval)
+#define VIDIOC_SUBDEV_ENUM_MBUS_CODE \
+			_IOWR('V',  2, struct v4l2_subdev_mbus_code_enum)
+#define VIDIOC_SUBDEV_ENUM_FRAME_SIZE \
+			_IOWR('V', 74, struct v4l2_subdev_frame_size_enum)
+#define VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL \
+			_IOWR('V', 75, struct v4l2_subdev_frame_interval_enum)
+#define VIDIOC_SUBDEV_G_CROP	_IOWR('V', 59, struct v4l2_subdev_crop)
+#define VIDIOC_SUBDEV_S_CROP	_IOWR('V', 60, struct v4l2_subdev_crop)
+#define VIDIOC_SUBDEV_G_SELECTION \
+	_IOWR('V', 61, struct v4l2_subdev_selection)
+#define VIDIOC_SUBDEV_S_SELECTION \
+	_IOWR('V', 62, struct v4l2_subdev_selection)
+#define VIDIOC_SUBDEV_G_EDID	_IOWR('V', 40, struct v4l2_subdev_edid)
+#define VIDIOC_SUBDEV_S_EDID	_IOWR('V', 41, struct v4l2_subdev_edid)
 
 #endif
diff --git a/original/uapi/linux/version.h b/original/uapi/linux/version.h
index b8e4ed0..c0bf737 100644
--- a/original/uapi/linux/version.h
+++ b/original/uapi/linux/version.h
@@ -1,2 +1,2 @@
-#define LINUX_VERSION_CODE 201226
+#define LINUX_VERSION_CODE 200230
 #define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff --git a/original/uapi/linux/vfio.h b/original/uapi/linux/vfio.h
index 29715d2..0fd47f5 100644
--- a/original/uapi/linux/vfio.h
+++ b/original/uapi/linux/vfio.h
@@ -23,18 +23,6 @@
 
 #define VFIO_TYPE1_IOMMU		1
 #define VFIO_SPAPR_TCE_IOMMU		2
-#define VFIO_TYPE1v2_IOMMU		3
-/*
- * IOMMU enforces DMA cache coherence (ex. PCIe NoSnoop stripping).  This
- * capability is subject to change as groups are added or removed.
- */
-#define VFIO_DMA_CC_IOMMU		4
-
-/* Check if EEH is supported */
-#define VFIO_EEH			5
-
-/* Two-stage IOMMU */
-#define VFIO_TYPE1_NESTING_IOMMU	6	/* Implies v2 */
 
 /*
  * The IOCTL interface is designed for extensibility by embedding the
@@ -461,37 +449,6 @@ struct vfio_iommu_spapr_tce_info {
 
 #define VFIO_IOMMU_SPAPR_TCE_GET_INFO	_IO(VFIO_TYPE, VFIO_BASE + 12)
 
-/*
- * EEH PE operation struct provides ways to:
- * - enable/disable EEH functionality;
- * - unfreeze IO/DMA for frozen PE;
- * - read PE state;
- * - reset PE;
- * - configure PE.
- */
-struct vfio_eeh_pe_op {
-	__u32 argsz;
-	__u32 flags;
-	__u32 op;
-};
-
-#define VFIO_EEH_PE_DISABLE		0	/* Disable EEH functionality */
-#define VFIO_EEH_PE_ENABLE		1	/* Enable EEH functionality  */
-#define VFIO_EEH_PE_UNFREEZE_IO		2	/* Enable IO for frozen PE   */
-#define VFIO_EEH_PE_UNFREEZE_DMA	3	/* Enable DMA for frozen PE  */
-#define VFIO_EEH_PE_GET_STATE		4	/* PE state retrieval        */
-#define  VFIO_EEH_PE_STATE_NORMAL	0	/* PE in functional state    */
-#define  VFIO_EEH_PE_STATE_RESET	1	/* PE reset in progress      */
-#define  VFIO_EEH_PE_STATE_STOPPED	2	/* Stopped DMA and IO        */
-#define  VFIO_EEH_PE_STATE_STOPPED_DMA	4	/* Stopped DMA only          */
-#define  VFIO_EEH_PE_STATE_UNAVAIL	5	/* State unavailable         */
-#define VFIO_EEH_PE_RESET_DEACTIVATE	5	/* Deassert PE reset         */
-#define VFIO_EEH_PE_RESET_HOT		6	/* Assert hot reset          */
-#define VFIO_EEH_PE_RESET_FUNDAMENTAL	7	/* Assert fundamental reset  */
-#define VFIO_EEH_PE_CONFIGURE		8	/* PE configuration          */
-
-#define VFIO_EEH_PE_OP			_IO(VFIO_TYPE, VFIO_BASE + 21)
-
 /* ***************************************************************** */
 
 #endif /* _UAPIVFIO_H */
diff --git a/original/uapi/linux/videodev2.h b/original/uapi/linux/videodev2.h
index 1c2f84f..b3f83e9 100644
--- a/original/uapi/linux/videodev2.h
+++ b/original/uapi/linux/videodev2.h
@@ -79,7 +79,6 @@
 /*  Four-character-code (FOURCC) */
 #define v4l2_fourcc(a, b, c, d)\
 	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
-#define v4l2_fourcc_be(a, b, c, d)	(v4l2_fourcc(a, b, c, d) | (1 << 31))
 
 /*
  *	E N U M S
@@ -125,10 +124,6 @@ enum v4l2_field {
 	 (field) == V4L2_FIELD_INTERLACED_BT ||\
 	 (field) == V4L2_FIELD_SEQ_TB ||\
 	 (field) == V4L2_FIELD_SEQ_BT)
-#define V4L2_FIELD_HAS_T_OR_B(field)	\
-	((field) == V4L2_FIELD_BOTTOM ||\
-	 (field) == V4L2_FIELD_TOP ||\
-	 (field) == V4L2_FIELD_ALTERNATE)
 
 enum v4l2_buf_type {
 	V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
@@ -144,7 +139,6 @@ enum v4l2_buf_type {
 #endif
 	V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
 	V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE  = 10,
-	V4L2_BUF_TYPE_SDR_CAPTURE          = 11,
 	/* Deprecated, do not use */
 	V4L2_BUF_TYPE_PRIVATE              = 0x80,
 };
@@ -165,8 +159,6 @@ enum v4l2_tuner_type {
 	V4L2_TUNER_RADIO	     = 1,
 	V4L2_TUNER_ANALOG_TV	     = 2,
 	V4L2_TUNER_DIGITAL_TV	     = 3,
-	V4L2_TUNER_ADC               = 4,
-	V4L2_TUNER_RF                = 5,
 };
 
 enum v4l2_memory {
@@ -272,9 +264,6 @@ struct v4l2_capability {
 #define V4L2_CAP_RADIO			0x00040000  /* is a radio device */
 #define V4L2_CAP_MODULATOR		0x00080000  /* has a modulator */
 
-#define V4L2_CAP_SDR_CAPTURE		0x00100000  /* Is a SDR capture device */
-#define V4L2_CAP_EXT_PIX_FORMAT		0x00200000  /* Supports the extended pixel format */
-
 #define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
 #define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
 #define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */
@@ -293,7 +282,6 @@ struct v4l2_pix_format {
 	__u32          		sizeimage;
 	__u32			colorspace;	/* enum v4l2_colorspace */
 	__u32			priv;		/* private data, depends on pixelformat */
-	__u32			flags;		/* format flags (V4L2_PIX_FMT_FLAG_*) */
 };
 
 /*      Pixel format         FOURCC                          depth  Description  */
@@ -301,25 +289,15 @@ struct v4l2_pix_format {
 /* RGB formats */
 #define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
 #define V4L2_PIX_FMT_RGB444  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
-#define V4L2_PIX_FMT_ARGB444 v4l2_fourcc('A', 'R', '1', '2') /* 16  aaaarrrr ggggbbbb */
-#define V4L2_PIX_FMT_XRGB444 v4l2_fourcc('X', 'R', '1', '2') /* 16  xxxxrrrr ggggbbbb */
 #define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
-#define V4L2_PIX_FMT_ARGB555 v4l2_fourcc('A', 'R', '1', '5') /* 16  ARGB-1-5-5-5  */
-#define V4L2_PIX_FMT_XRGB555 v4l2_fourcc('X', 'R', '1', '5') /* 16  XRGB-1-5-5-5  */
 #define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
 #define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
-#define V4L2_PIX_FMT_ARGB555X v4l2_fourcc_be('A', 'R', '1', '5') /* 16  ARGB-5-5-5 BE */
-#define V4L2_PIX_FMT_XRGB555X v4l2_fourcc_be('X', 'R', '1', '5') /* 16  XRGB-5-5-5 BE */
 #define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */
 #define V4L2_PIX_FMT_BGR666  v4l2_fourcc('B', 'G', 'R', 'H') /* 18  BGR-6-6-6	  */
 #define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
 #define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
 #define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
-#define V4L2_PIX_FMT_ABGR32  v4l2_fourcc('A', 'R', '2', '4') /* 32  BGRA-8-8-8-8  */
-#define V4L2_PIX_FMT_XBGR32  v4l2_fourcc('X', 'R', '2', '4') /* 32  BGRX-8-8-8-8  */
 #define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
-#define V4L2_PIX_FMT_ARGB32  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
-#define V4L2_PIX_FMT_XRGB32  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */
 
 /* Grey formats */
 #define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
@@ -453,19 +431,6 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_SE401      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
 #define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
 
-/* SDR formats - used only for Software Defined Radio devices */
-#define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
-#define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
-#define V4L2_SDR_FMT_CS8          v4l2_fourcc('C', 'S', '0', '8') /* complex s8 */
-#define V4L2_SDR_FMT_CS14LE       v4l2_fourcc('C', 'S', '1', '4') /* complex s14le */
-#define V4L2_SDR_FMT_RU12LE       v4l2_fourcc('R', 'U', '1', '2') /* real u12le */
-
-/* priv field value to indicates that subsequent fields are valid. */
-#define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
-
-/* Flags */
-#define V4L2_PIX_FMT_FLAG_PREMUL_ALPHA	0x00000001
-
 /*
  *	F O R M A T   E N U M E R A T I O N
  */
@@ -675,6 +640,7 @@ struct v4l2_plane {
  * @length:	size in bytes of the buffer (NOT its payload) for single-plane
  *		buffers (when type != *_MPLANE); number of elements in the
  *		planes array for multi-plane buffers
+ * @input:	input number from which the video data has has been captured
  *
  * Contains data exchanged by application and driver using one of the Streaming
  * I/O methods.
@@ -703,36 +669,24 @@ struct v4l2_buffer {
 };
 
 /*  Flags for 'flags' field */
-/* Buffer is mapped (flag) */
-#define V4L2_BUF_FLAG_MAPPED			0x00000001
-/* Buffer is queued for processing */
-#define V4L2_BUF_FLAG_QUEUED			0x00000002
-/* Buffer is ready */
-#define V4L2_BUF_FLAG_DONE			0x00000004
-/* Image is a keyframe (I-frame) */
-#define V4L2_BUF_FLAG_KEYFRAME			0x00000008
-/* Image is a P-frame */
-#define V4L2_BUF_FLAG_PFRAME			0x00000010
-/* Image is a B-frame */
-#define V4L2_BUF_FLAG_BFRAME			0x00000020
+#define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
+#define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
+#define V4L2_BUF_FLAG_DONE	0x0004	/* Buffer is ready */
+#define V4L2_BUF_FLAG_KEYFRAME	0x0008	/* Image is a keyframe (I-frame) */
+#define V4L2_BUF_FLAG_PFRAME	0x0010	/* Image is a P-frame */
+#define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
 /* Buffer is ready, but the data contained within is corrupted. */
-#define V4L2_BUF_FLAG_ERROR			0x00000040
-/* timecode field is valid */
-#define V4L2_BUF_FLAG_TIMECODE			0x00000100
-/* Buffer is prepared for queuing */
-#define V4L2_BUF_FLAG_PREPARED			0x00000400
+#define V4L2_BUF_FLAG_ERROR	0x0040
+#define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
+#define V4L2_BUF_FLAG_PREPARED	0x0400	/* Buffer is prepared for queuing */
 /* Cache handling flags */
-#define V4L2_BUF_FLAG_NO_CACHE_INVALIDATE	0x00000800
-#define V4L2_BUF_FLAG_NO_CACHE_CLEAN		0x00001000
+#define V4L2_BUF_FLAG_NO_CACHE_INVALIDATE	0x0800
+#define V4L2_BUF_FLAG_NO_CACHE_CLEAN		0x1000
 /* Timestamp type */
-#define V4L2_BUF_FLAG_TIMESTAMP_MASK		0x0000e000
-#define V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN		0x00000000
-#define V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC	0x00002000
-#define V4L2_BUF_FLAG_TIMESTAMP_COPY		0x00004000
-/* Timestamp sources. */
-#define V4L2_BUF_FLAG_TSTAMP_SRC_MASK		0x00070000
-#define V4L2_BUF_FLAG_TSTAMP_SRC_EOF		0x00000000
-#define V4L2_BUF_FLAG_TSTAMP_SRC_SOE		0x00010000
+#define V4L2_BUF_FLAG_TIMESTAMP_MASK		0xe000
+#define V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN		0x0000
+#define V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC	0x2000
+#define V4L2_BUF_FLAG_TIMESTAMP_COPY		0x4000
 
 /**
  * struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
@@ -770,16 +724,7 @@ struct v4l2_framebuffer {
 /* FIXME: in theory we should pass something like PCI device + memory
  * region + offset instead of some physical address */
 	void                    *base;
-	struct {
-		__u32		width;
-		__u32		height;
-		__u32		pixelformat;
-		__u32		field;		/* enum v4l2_field */
-		__u32		bytesperline;	/* for padding, zero if unused */
-		__u32		sizeimage;
-		__u32		colorspace;	/* enum v4l2_colorspace */
-		__u32		priv;		/* reserved field, set to 0 */
-	} fmt;
+	struct v4l2_pix_format	fmt;
 };
 /*  Flags for the 'capability' field. Read only */
 #define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
@@ -1141,15 +1086,12 @@ struct v4l2_dv_timings {
 
 /** struct v4l2_enum_dv_timings - DV timings enumeration
  * @index:	enumeration index
- * @pad:	the pad number for which to enumerate timings (used with
- *		v4l-subdev nodes only)
  * @reserved:	must be zeroed
  * @timings:	the timings for the given index
  */
 struct v4l2_enum_dv_timings {
 	__u32 index;
-	__u32 pad;
-	__u32 reserved[2];
+	__u32 reserved[3];
 	struct v4l2_dv_timings timings;
 };
 
@@ -1187,14 +1129,11 @@ struct v4l2_bt_timings_cap {
 
 /** struct v4l2_dv_timings_cap - DV timings capabilities
  * @type:	the type of the timings (same as in struct v4l2_dv_timings)
- * @pad:	the pad number for which to query capabilities (used with
- *		v4l-subdev nodes only)
  * @bt:		the BT656/1120 timings capabilities
  */
 struct v4l2_dv_timings_cap {
 	__u32 type;
-	__u32 pad;
-	__u32 reserved[2];
+	__u32 reserved[3];
 	union {
 		struct v4l2_bt_timings_cap bt;
 		__u32 raw_data[32];
@@ -1288,11 +1227,7 @@ struct v4l2_ext_control {
 	union {
 		__s32 value;
 		__s64 value64;
-		char __user *string;
-		__u8 __user *p_u8;
-		__u16 __user *p_u16;
-		__u32 __user *p_u32;
-		void __user *ptr;
+		char *string;
 	};
 } __attribute__ ((packed));
 
@@ -1307,7 +1242,6 @@ struct v4l2_ext_controls {
 #define V4L2_CTRL_ID_MASK      	  (0x0fffffff)
 #define V4L2_CTRL_ID2CLASS(id)    ((id) & 0x0fff0000UL)
 #define V4L2_CTRL_DRIVER_PRIV(id) (((id) & 0xffff) >= 0x1000)
-#define V4L2_CTRL_MAX_DIMS	  (4)
 
 enum v4l2_ctrl_type {
 	V4L2_CTRL_TYPE_INTEGER	     = 1,
@@ -1318,13 +1252,7 @@ enum v4l2_ctrl_type {
 	V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
 	V4L2_CTRL_TYPE_STRING        = 7,
 	V4L2_CTRL_TYPE_BITMASK       = 8,
-	V4L2_CTRL_TYPE_INTEGER_MENU  = 9,
-
-	/* Compound types are >= 0x0100 */
-	V4L2_CTRL_COMPOUND_TYPES     = 0x0100,
-	V4L2_CTRL_TYPE_U8	     = 0x0100,
-	V4L2_CTRL_TYPE_U16	     = 0x0101,
-	V4L2_CTRL_TYPE_U32	     = 0x0102,
+	V4L2_CTRL_TYPE_INTEGER_MENU = 9,
 };
 
 /*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
@@ -1340,23 +1268,6 @@ struct v4l2_queryctrl {
 	__u32		     reserved[2];
 };
 
-/*  Used in the VIDIOC_QUERY_EXT_CTRL ioctl for querying extended controls */
-struct v4l2_query_ext_ctrl {
-	__u32		     id;
-	__u32		     type;
-	char		     name[32];
-	__s64		     minimum;
-	__s64		     maximum;
-	__u64		     step;
-	__s64		     default_value;
-	__u32                flags;
-	__u32                elem_size;
-	__u32                elems;
-	__u32                nr_of_dims;
-	__u32                dims[V4L2_CTRL_MAX_DIMS];
-	__u32		     reserved[32];
-};
-
 /*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
 struct v4l2_querymenu {
 	__u32		id;
@@ -1377,11 +1288,9 @@ struct v4l2_querymenu {
 #define V4L2_CTRL_FLAG_SLIDER 		0x0020
 #define V4L2_CTRL_FLAG_WRITE_ONLY 	0x0040
 #define V4L2_CTRL_FLAG_VOLATILE		0x0080
-#define V4L2_CTRL_FLAG_HAS_PAYLOAD	0x0100
 
-/*  Query flags, to be ORed with the control ID */
+/*  Query flag, to be ORed with the control ID */
 #define V4L2_CTRL_FLAG_NEXT_CTRL	0x80000000
-#define V4L2_CTRL_FLAG_NEXT_COMPOUND	0x40000000
 
 /*  User-class control IDs defined by V4L2 */
 #define V4L2_CID_MAX_CTRLS		1024
@@ -1430,7 +1339,6 @@ struct v4l2_modulator {
 #define V4L2_TUNER_CAP_RDS_CONTROLS	0x0200
 #define V4L2_TUNER_CAP_FREQ_BANDS	0x0400
 #define V4L2_TUNER_CAP_HWSEEK_PROG_LIM	0x0800
-#define V4L2_TUNER_CAP_1HZ		0x1000
 
 /*  Flags for the 'rxsubchans' field */
 #define V4L2_TUNER_SUB_MONO		0x0001
@@ -1647,12 +1555,6 @@ struct v4l2_vbi_format {
 #define V4L2_VBI_UNSYNC		(1 << 0)
 #define V4L2_VBI_INTERLACED	(1 << 1)
 
-/* ITU-R start lines for each field */
-#define V4L2_VBI_ITU_525_F1_START (1)
-#define V4L2_VBI_ITU_525_F2_START (264)
-#define V4L2_VBI_ITU_625_F1_START (1)
-#define V4L2_VBI_ITU_625_F2_START (314)
-
 /* Sliced VBI
  *
  *    This implements is a proposal V4L2 API to allow SLICED VBI
@@ -1776,7 +1678,6 @@ struct v4l2_plane_pix_format {
  * @colorspace:		enum v4l2_colorspace; supplemental to pixelformat
  * @plane_fmt:		per-plane information
  * @num_planes:		number of planes for this format
- * @flags:		format flags (V4L2_PIX_FMT_FLAG_*)
  */
 struct v4l2_pix_format_mplane {
 	__u32				width;
@@ -1787,19 +1688,7 @@ struct v4l2_pix_format_mplane {
 
 	struct v4l2_plane_pix_format	plane_fmt[VIDEO_MAX_PLANES];
 	__u8				num_planes;
-	__u8				flags;
-	__u8				reserved[10];
-} __attribute__ ((packed));
-
-/**
- * struct v4l2_sdr_format - SDR format definition
- * @pixelformat:	little endian four character code (fourcc)
- * @buffersize:		maximum size in bytes required for data
- */
-struct v4l2_sdr_format {
-	__u32				pixelformat;
-	__u32				buffersize;
-	__u8				reserved[24];
+	__u8				reserved[11];
 } __attribute__ ((packed));
 
 /**
@@ -1820,7 +1709,6 @@ struct v4l2_format {
 		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
 		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
 		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
-		struct v4l2_sdr_format		sdr;     /* V4L2_BUF_TYPE_SDR_CAPTURE */
 		__u8	raw_data[200];                   /* user-defined */
 	} fmt;
 };
@@ -1845,8 +1733,6 @@ struct v4l2_streamparm {
 #define V4L2_EVENT_EOS				2
 #define V4L2_EVENT_CTRL				3
 #define V4L2_EVENT_FRAME_SYNC			4
-#define V4L2_EVENT_SOURCE_CHANGE		5
-#define V4L2_EVENT_MOTION_DET			6
 #define V4L2_EVENT_PRIVATE_START		0x08000000
 
 /* Payload for V4L2_EVENT_VSYNC */
@@ -1878,35 +1764,12 @@ struct v4l2_event_frame_sync {
 	__u32 frame_sequence;
 };
 
-#define V4L2_EVENT_SRC_CH_RESOLUTION		(1 << 0)
-
-struct v4l2_event_src_change {
-	__u32 changes;
-};
-
-#define V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ	(1 << 0)
-
-/**
- * struct v4l2_event_motion_det - motion detection event
- * @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the
- *                     frame_sequence field is valid.
- * @frame_sequence:    the frame sequence number associated with this event.
- * @region_mask:       which regions detected motion.
- */
-struct v4l2_event_motion_det {
-	__u32 flags;
-	__u32 frame_sequence;
-	__u32 region_mask;
-};
-
 struct v4l2_event {
 	__u32				type;
 	union {
 		struct v4l2_event_vsync		vsync;
 		struct v4l2_event_ctrl		ctrl;
 		struct v4l2_event_frame_sync	frame_sync;
-		struct v4l2_event_src_change	src_change;
-		struct v4l2_event_motion_det	motion_det;
 		__u8				data[64];
 	} u;
 	__u32				pending;
@@ -1936,13 +1799,11 @@ struct v4l2_event_subscription {
 /* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */
 
 #define V4L2_CHIP_MATCH_BRIDGE      0  /* Match against chip ID on the bridge (0 for the bridge) */
-#define V4L2_CHIP_MATCH_SUBDEV      4  /* Match against subdev index */
-
-/* The following four defines are no longer in use */
 #define V4L2_CHIP_MATCH_HOST V4L2_CHIP_MATCH_BRIDGE
 #define V4L2_CHIP_MATCH_I2C_DRIVER  1  /* Match against I2C driver name */
 #define V4L2_CHIP_MATCH_I2C_ADDR    2  /* Match against I2C 7-bit address */
 #define V4L2_CHIP_MATCH_AC97        3  /* Match against ancillary AC97 chip */
+#define V4L2_CHIP_MATCH_SUBDEV      4  /* Match against subdev index */
 
 struct v4l2_dbg_match {
 	__u32 type; /* Match type */
@@ -1959,6 +1820,13 @@ struct v4l2_dbg_register {
 	__u64 val;
 } __attribute__ ((packed));
 
+/* VIDIOC_DBG_G_CHIP_IDENT */
+struct v4l2_dbg_chip_ident {
+	struct v4l2_dbg_match match;
+	__u32 ident;       /* chip identifier as specified in <media/v4l2-chip-ident.h> */
+	__u32 revision;    /* chip revision, chip specific */
+} __attribute__ ((packed));
+
 #define V4L2_CHIP_FL_READABLE (1 << 0)
 #define V4L2_CHIP_FL_WRITABLE (1 << 1)
 
@@ -2022,8 +1890,6 @@ struct v4l2_create_buffers {
 #define VIDIOC_QUERYMENU	_IOWR('V', 37, struct v4l2_querymenu)
 #define VIDIOC_G_INPUT		 _IOR('V', 38, int)
 #define VIDIOC_S_INPUT		_IOWR('V', 39, int)
-#define VIDIOC_G_EDID		_IOWR('V', 40, struct v4l2_edid)
-#define VIDIOC_S_EDID		_IOWR('V', 41, struct v4l2_edid)
 #define VIDIOC_G_OUTPUT		 _IOR('V', 46, int)
 #define VIDIOC_S_OUTPUT		_IOWR('V', 47, int)
 #define VIDIOC_ENUMOUTPUT	_IOWR('V', 48, struct v4l2_output)
@@ -2061,6 +1927,12 @@ struct v4l2_create_buffers {
 #define	VIDIOC_DBG_S_REGISTER 	 _IOW('V', 79, struct v4l2_dbg_register)
 #define	VIDIOC_DBG_G_REGISTER 	_IOWR('V', 80, struct v4l2_dbg_register)
 
+/* Experimental, meant for debugging, testing and internal use.
+   Never use this ioctl in applications!
+   Note: this ioctl is deprecated in favor of VIDIOC_DBG_G_CHIP_INFO and
+   will go away in the future. */
+#define VIDIOC_DBG_G_CHIP_IDENT _IOWR('V', 81, struct v4l2_dbg_chip_ident)
+
 #define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
 
 #define	VIDIOC_S_DV_TIMINGS	_IOWR('V', 87, struct v4l2_dv_timings)
@@ -2097,8 +1969,6 @@ struct v4l2_create_buffers {
    Never use these in applications! */
 #define VIDIOC_DBG_G_CHIP_INFO  _IOWR('V', 102, struct v4l2_dbg_chip_info)
 
-#define VIDIOC_QUERY_EXT_CTRL	_IOWR('V', 103, struct v4l2_query_ext_ctrl)
-
 /* Reminder: when adding new ioctls please add support for them to
    drivers/media/video/v4l2-compat-ioctl32.c as well! */
 
diff --git a/original/uapi/linux/virtio_blk.h b/original/uapi/linux/virtio_blk.h
index 9ad67b2..6d8e61c 100644
--- a/original/uapi/linux/virtio_blk.h
+++ b/original/uapi/linux/virtio_blk.h
@@ -40,7 +40,6 @@
 #define VIRTIO_BLK_F_WCE	9	/* Writeback mode enabled after reset */
 #define VIRTIO_BLK_F_TOPOLOGY	10	/* Topology information is available */
 #define VIRTIO_BLK_F_CONFIG_WCE	11	/* Writeback mode available in config */
-#define VIRTIO_BLK_F_MQ		12	/* support more than one vq */
 
 #ifndef __KERNEL__
 /* Old (deprecated) name for VIRTIO_BLK_F_WCE. */
@@ -78,10 +77,6 @@ struct virtio_blk_config {
 
 	/* writeback mode (if VIRTIO_BLK_F_CONFIG_WCE) */
 	__u8 wce;
-	__u8 unused;
-
-	/* number of vqs, only available when VIRTIO_BLK_F_MQ is set */
-	__u16 num_queues;
 } __attribute__((packed));
 
 /*
diff --git a/original/uapi/linux/xfrm.h b/original/uapi/linux/xfrm.h
index 02d5125..a8cd6a4 100644
--- a/original/uapi/linux/xfrm.h
+++ b/original/uapi/linux/xfrm.h
@@ -298,8 +298,6 @@ enum xfrm_attr_type_t {
 	XFRMA_TFCPAD,		/* __u32 */
 	XFRMA_REPLAY_ESN_VAL,	/* struct xfrm_replay_esn */
 	XFRMA_SA_EXTRA_FLAGS,	/* __u32 */
-	XFRMA_PROTO,		/* __u8 */
-	XFRMA_ADDRESS_FILTER,	/* struct xfrm_address_filter */
 	__XFRMA_MAX
 
 #define XFRMA_MAX (__XFRMA_MAX - 1)
@@ -328,8 +326,6 @@ enum xfrm_spdattr_type_t {
 	XFRMA_SPD_UNSPEC,
 	XFRMA_SPD_INFO,
 	XFRMA_SPD_HINFO,
-	XFRMA_SPD_IPV4_HTHRESH,
-	XFRMA_SPD_IPV6_HTHRESH,
 	__XFRMA_SPD_MAX
 
 #define XFRMA_SPD_MAX (__XFRMA_SPD_MAX - 1)
@@ -349,11 +345,6 @@ struct xfrmu_spdhinfo {
 	__u32 spdhmcnt;
 };
 
-struct xfrmu_spdhthresh {
-	__u8 lbits;
-	__u8 rbits;
-};
-
 struct xfrm_usersa_info {
 	struct xfrm_selector		sel;
 	struct xfrm_id			id;
@@ -483,14 +474,6 @@ struct xfrm_user_mapping {
 	__be16				new_sport;
 };
 
-struct xfrm_address_filter {
-	xfrm_address_t			saddr;
-	xfrm_address_t			daddr;
-	__u16				family;
-	__u8				splen;
-	__u8				dplen;
-};
-
 #ifndef __KERNEL__
 /* backwards compatibility for userspace */
 #define XFRMGRP_ACQUIRE		1
diff --git a/original/uapi/mtd/mtd-abi.h b/original/uapi/mtd/mtd-abi.h
index 763bb69..e272ea0 100644
--- a/original/uapi/mtd/mtd-abi.h
+++ b/original/uapi/mtd/mtd-abi.h
@@ -109,7 +109,6 @@ struct mtd_write_req {
 #define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
 #define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
 #define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
-#define MTD_CAP_NVRAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
 
 /* Obsolete ECC byte placement modes (used with obsolete MEMGETOOBSEL) */
 #define MTD_NANDECC_OFF		0	// Switch off ECC (Not recommended)
diff --git a/original/uapi/mtd/ubi-user.h b/original/uapi/mtd/ubi-user.h
index 1927b0d..723c324 100644
--- a/original/uapi/mtd/ubi-user.h
+++ b/original/uapi/mtd/ubi-user.h
@@ -134,16 +134,6 @@
  * used. A pointer to a &struct ubi_set_vol_prop_req object is expected to be
  * passed. The object describes which property should be set, and to which value
  * it should be set.
- *
- * Block devices on UBI volumes
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * To create a R/O block device on top of an UBI volume the %UBI_IOCVOLCRBLK
- * should be used. A pointer to a &struct ubi_blkcreate_req object is expected
- * to be passed, which is not used and reserved for future usage.
- *
- * Conversely, to remove a block device the %UBI_IOCVOLRMBLK should be used,
- * which takes no arguments.
  */
 
 /*
@@ -201,10 +191,6 @@
 /* Set an UBI volume property */
 #define UBI_IOCSETVOLPROP _IOW(UBI_VOL_IOC_MAGIC, 6, \
 			       struct ubi_set_vol_prop_req)
-/* Create a R/O block device on top of an UBI volume */
-#define UBI_IOCVOLCRBLK _IOW(UBI_VOL_IOC_MAGIC, 7, struct ubi_blkcreate_req)
-/* Remove the R/O block device */
-#define UBI_IOCVOLRMBLK _IO(UBI_VOL_IOC_MAGIC, 8)
 
 /* Maximum MTD device name length supported by UBI */
 #define MAX_UBI_MTD_NAME_LEN 127
@@ -434,12 +420,4 @@ struct ubi_set_vol_prop_req {
 	__u64 value;
 }  __packed;
 
-/**
- * struct ubi_blkcreate_req - a data structure used in block creation requests.
- * @padding: reserved for future, not used, has to be zeroed
- */
-struct ubi_blkcreate_req {
-	__s8  padding[128];
-}  __packed;
-
 #endif /* __UBI_USER_H__ */
diff --git a/original/uapi/rdma/ib_user_mad.h b/original/uapi/rdma/ib_user_mad.h
index 09f809f..d6fce1c 100644
--- a/original/uapi/rdma/ib_user_mad.h
+++ b/original/uapi/rdma/ib_user_mad.h
@@ -191,45 +191,6 @@ struct ib_user_mad_reg_req {
 	__u8	rmpp_version;
 };
 
-/**
- * ib_user_mad_reg_req2 - MAD registration request
- *
- * @id                 - Set by the _kernel_; used by userspace to identify the
- *                       registered agent in future requests.
- * @qpn                - Queue pair number; must be 0 or 1.
- * @mgmt_class         - Indicates which management class of MADs should be
- *                       receive by the caller.  This field is only required if
- *                       the user wishes to receive unsolicited MADs, otherwise
- *                       it should be 0.
- * @mgmt_class_version - Indicates which version of MADs for the given
- *                       management class to receive.
- * @res                - Ignored.
- * @flags              - additional registration flags; Must be in the set of
- *                       flags defined in IB_USER_MAD_REG_FLAGS_CAP
- * @method_mask        - The caller wishes to receive unsolicited MADs for the
- *                       methods whose bit(s) is(are) set.
- * @oui                - Indicates IEEE OUI to use when mgmt_class is a vendor
- *                       class in the range from 0x30 to 0x4f. Otherwise not
- *                       used.
- * @rmpp_version       - If set, indicates the RMPP version to use.
- */
-enum {
-	IB_USER_MAD_USER_RMPP = (1 << 0),
-};
-#define IB_USER_MAD_REG_FLAGS_CAP (IB_USER_MAD_USER_RMPP)
-struct ib_user_mad_reg_req2 {
-	__u32	id;
-	__u32	qpn;
-	__u8	mgmt_class;
-	__u8	mgmt_class_version;
-	__u16   res;
-	__u32   flags;
-	__u64   method_mask[2];
-	__u32   oui;
-	__u8	rmpp_version;
-	__u8	reserved[3];
-};
-
 #define IB_IOCTL_MAGIC		0x1b
 
 #define IB_USER_MAD_REGISTER_AGENT	_IOWR(IB_IOCTL_MAGIC, 1, \
@@ -239,7 +200,4 @@ struct ib_user_mad_reg_req2 {
 
 #define IB_USER_MAD_ENABLE_PKEY		_IO(IB_IOCTL_MAGIC, 3)
 
-#define IB_USER_MAD_REGISTER_AGENT2     _IOWR(IB_IOCTL_MAGIC, 4, \
-					      struct ib_user_mad_reg_req2)
-
 #endif /* IB_USER_MAD_H */
diff --git a/original/uapi/rdma/ib_user_verbs.h b/original/uapi/rdma/ib_user_verbs.h
index 26daf55..cbfdd4c 100644
--- a/original/uapi/rdma/ib_user_verbs.h
+++ b/original/uapi/rdma/ib_user_verbs.h
@@ -276,22 +276,6 @@ struct ib_uverbs_reg_mr_resp {
 	__u32 rkey;
 };
 
-struct ib_uverbs_rereg_mr {
-	__u64 response;
-	__u32 mr_handle;
-	__u32 flags;
-	__u64 start;
-	__u64 length;
-	__u64 hca_va;
-	__u32 pd_handle;
-	__u32 access_flags;
-};
-
-struct ib_uverbs_rereg_mr_resp {
-	__u32 lkey;
-	__u32 rkey;
-};
-
 struct ib_uverbs_dereg_mr {
 	__u32 mr_handle;
 };
diff --git a/original/uapi/rdma/rdma_netlink.h b/original/uapi/rdma/rdma_netlink.h
index de69170..8297285 100644
--- a/original/uapi/rdma/rdma_netlink.h
+++ b/original/uapi/rdma/rdma_netlink.h
@@ -4,16 +4,7 @@
 #include <linux/types.h>
 
 enum {
-	RDMA_NL_RDMA_CM = 1,
-	RDMA_NL_NES,
-	RDMA_NL_C4IW,
-	RDMA_NL_NUM_CLIENTS
-};
-
-enum {
-	RDMA_NL_GROUP_CM = 1,
-	RDMA_NL_GROUP_IWPM,
-	RDMA_NL_NUM_GROUPS
+	RDMA_NL_RDMA_CM = 1
 };
 
 #define RDMA_NL_GET_CLIENT(type) ((type & (((1 << 6) - 1) << 10)) >> 10)
@@ -31,18 +22,6 @@ enum {
 	RDMA_NL_RDMA_CM_NUM_ATTR,
 };
 
-/* iwarp port mapper op-codes */
-enum {
-	RDMA_NL_IWPM_REG_PID = 0,
-	RDMA_NL_IWPM_ADD_MAPPING,
-	RDMA_NL_IWPM_QUERY_MAPPING,
-	RDMA_NL_IWPM_REMOVE_MAPPING,
-	RDMA_NL_IWPM_HANDLE_ERR,
-	RDMA_NL_IWPM_MAPINFO,
-	RDMA_NL_IWPM_MAPINFO_NUM,
-	RDMA_NL_IWPM_NUM_OPS
-};
-
 struct rdma_cm_id_stats {
 	__u32	qp_num;
 	__u32	bound_dev_if;
@@ -54,78 +33,5 @@ struct rdma_cm_id_stats {
 	__u8	qp_type;
 };
 
-enum {
-	IWPM_NLA_REG_PID_UNSPEC = 0,
-	IWPM_NLA_REG_PID_SEQ,
-	IWPM_NLA_REG_IF_NAME,
-	IWPM_NLA_REG_IBDEV_NAME,
-	IWPM_NLA_REG_ULIB_NAME,
-	IWPM_NLA_REG_PID_MAX
-};
-
-enum {
-	IWPM_NLA_RREG_PID_UNSPEC = 0,
-	IWPM_NLA_RREG_PID_SEQ,
-	IWPM_NLA_RREG_IBDEV_NAME,
-	IWPM_NLA_RREG_ULIB_NAME,
-	IWPM_NLA_RREG_ULIB_VER,
-	IWPM_NLA_RREG_PID_ERR,
-	IWPM_NLA_RREG_PID_MAX
-
-};
-
-enum {
-	IWPM_NLA_MANAGE_MAPPING_UNSPEC = 0,
-	IWPM_NLA_MANAGE_MAPPING_SEQ,
-	IWPM_NLA_MANAGE_ADDR,
-	IWPM_NLA_MANAGE_MAPPED_LOC_ADDR,
-	IWPM_NLA_RMANAGE_MAPPING_ERR,
-	IWPM_NLA_RMANAGE_MAPPING_MAX
-};
-
-#define IWPM_NLA_MANAGE_MAPPING_MAX 3
-#define IWPM_NLA_QUERY_MAPPING_MAX  4
-#define IWPM_NLA_MAPINFO_SEND_MAX   3
-
-enum {
-	IWPM_NLA_QUERY_MAPPING_UNSPEC = 0,
-	IWPM_NLA_QUERY_MAPPING_SEQ,
-	IWPM_NLA_QUERY_LOCAL_ADDR,
-	IWPM_NLA_QUERY_REMOTE_ADDR,
-	IWPM_NLA_RQUERY_MAPPED_LOC_ADDR,
-	IWPM_NLA_RQUERY_MAPPED_REM_ADDR,
-	IWPM_NLA_RQUERY_MAPPING_ERR,
-	IWPM_NLA_RQUERY_MAPPING_MAX
-};
-
-enum {
-	IWPM_NLA_MAPINFO_REQ_UNSPEC = 0,
-	IWPM_NLA_MAPINFO_ULIB_NAME,
-	IWPM_NLA_MAPINFO_ULIB_VER,
-	IWPM_NLA_MAPINFO_REQ_MAX
-};
-
-enum {
-	IWPM_NLA_MAPINFO_UNSPEC = 0,
-	IWPM_NLA_MAPINFO_LOCAL_ADDR,
-	IWPM_NLA_MAPINFO_MAPPED_ADDR,
-	IWPM_NLA_MAPINFO_MAX
-};
-
-enum {
-	IWPM_NLA_MAPINFO_NUM_UNSPEC = 0,
-	IWPM_NLA_MAPINFO_SEQ,
-	IWPM_NLA_MAPINFO_SEND_NUM,
-	IWPM_NLA_MAPINFO_ACK_NUM,
-	IWPM_NLA_MAPINFO_NUM_MAX
-};
-
-enum {
-	IWPM_NLA_ERR_UNSPEC = 0,
-	IWPM_NLA_ERR_SEQ,
-	IWPM_NLA_ERR_CODE,
-	IWPM_NLA_ERR_MAX
-};
-
 
 #endif /* _UAPI_RDMA_NETLINK_H */
diff --git a/original/uapi/sound/asound.h b/original/uapi/sound/asound.h
index 941d32f..9fc6219 100644
--- a/original/uapi/sound/asound.h
+++ b/original/uapi/sound/asound.h
@@ -94,11 +94,9 @@ enum {
 	SNDRV_HWDEP_IFACE_HDA,		/* HD-audio */
 	SNDRV_HWDEP_IFACE_USB_STREAM,	/* direct access to usb stream */
 	SNDRV_HWDEP_IFACE_FW_DICE,	/* TC DICE FireWire device */
-	SNDRV_HWDEP_IFACE_FW_FIREWORKS,	/* Echo Audio Fireworks based device */
-	SNDRV_HWDEP_IFACE_FW_BEBOB,	/* BridgeCo BeBoB based device */
 
 	/* Don't forget to change the following: */
-	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_FW_BEBOB
+	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_FW_DICE
 };
 
 struct snd_hwdep_info {
@@ -139,7 +137,7 @@ struct snd_hwdep_dsp_image {
  *                                                                           *
  *****************************************************************************/
 
-#define SNDRV_PCM_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 12)
+#define SNDRV_PCM_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 11)
 
 typedef unsigned long snd_pcm_uframes_t;
 typedef signed long snd_pcm_sframes_t;
@@ -219,10 +217,7 @@ typedef int __bitwise snd_pcm_format_t;
 #define	SNDRV_PCM_FORMAT_G723_40_1B	((__force snd_pcm_format_t) 47) /* 1 sample in 1 byte */
 #define	SNDRV_PCM_FORMAT_DSD_U8		((__force snd_pcm_format_t) 48) /* DSD, 1-byte samples DSD (x8) */
 #define	SNDRV_PCM_FORMAT_DSD_U16_LE	((__force snd_pcm_format_t) 49) /* DSD, 2-byte samples DSD (x16), little endian */
-#define	SNDRV_PCM_FORMAT_DSD_U32_LE	((__force snd_pcm_format_t) 50) /* DSD, 4-byte samples DSD (x32), little endian */
-#define	SNDRV_PCM_FORMAT_DSD_U16_BE	((__force snd_pcm_format_t) 51) /* DSD, 2-byte samples DSD (x16), big endian */
-#define	SNDRV_PCM_FORMAT_DSD_U32_BE	((__force snd_pcm_format_t) 52) /* DSD, 4-byte samples DSD (x32), big endian */
-#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_DSD_U32_BE
+#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_DSD_U16_LE
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define	SNDRV_PCM_FORMAT_S16		SNDRV_PCM_FORMAT_S16_LE
@@ -394,9 +389,7 @@ struct snd_pcm_sw_params {
 	snd_pcm_uframes_t silence_threshold;	/* min distance from noise for silence filling */
 	snd_pcm_uframes_t silence_size;		/* silence block size */
 	snd_pcm_uframes_t boundary;		/* pointers wrap point */
-	unsigned int proto;			/* protocol version */
-	unsigned int tstamp_type;		/* timestamp type (req. proto >= 2.0.12) */
-	unsigned char reserved[56];		/* reserved for future */
+	unsigned char reserved[64];		/* reserved for future */
 };
 
 struct snd_pcm_channel_info {
@@ -467,8 +460,7 @@ struct snd_xfern {
 enum {
 	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,	/* gettimeofday equivalent */
 	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,	/* posix_clock_monotonic equivalent */
-	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,    /* monotonic_raw (no NTP) */
-	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,
+	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
 };
 
 /* channel positions */
diff --git a/original/uapi/sound/compress_offload.h b/original/uapi/sound/compress_offload.h
index 1964026..21eed48 100644
--- a/original/uapi/sound/compress_offload.h
+++ b/original/uapi/sound/compress_offload.h
@@ -39,7 +39,7 @@
 struct snd_compressed_buffer {
 	__u32 fragment_size;
 	__u32 fragments;
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * struct snd_compr_params: compressed stream params
@@ -51,7 +51,7 @@ struct snd_compr_params {
 	struct snd_compressed_buffer buffer;
 	struct snd_codec codec;
 	__u8 no_wake_mode;
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * struct snd_compr_tstamp: timestamp descriptor
@@ -70,7 +70,7 @@ struct snd_compr_tstamp {
 	__u32 pcm_frames;
 	__u32 pcm_io_frames;
 	__u32 sampling_rate;
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * struct snd_compr_avail: avail descriptor
@@ -80,7 +80,7 @@ struct snd_compr_tstamp {
 struct snd_compr_avail {
 	__u64 avail;
 	struct snd_compr_tstamp tstamp;
-} __attribute__((packed, aligned(4)));
+} __attribute__((packed));
 
 enum snd_compr_direction {
 	SND_COMPRESS_PLAYBACK = 0,
@@ -107,7 +107,7 @@ struct snd_compr_caps {
 	__u32 max_fragments;
 	__u32 codecs[MAX_NUM_CODECS];
 	__u32 reserved[11];
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * struct snd_compr_codec_caps: query capability of codec
@@ -119,7 +119,7 @@ struct snd_compr_codec_caps {
 	__u32 codec;
 	__u32 num_descriptors;
 	struct snd_codec_desc descriptor[MAX_NUM_CODEC_DESCRIPTORS];
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * @SNDRV_COMPRESS_ENCODER_PADDING: no of samples appended by the encoder at the
@@ -140,7 +140,7 @@ enum {
 struct snd_compr_metadata {
 	 __u32 key;
 	 __u32 value[8];
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * compress path ioctl definitions
diff --git a/original/uapi/sound/compress_params.h b/original/uapi/sound/compress_params.h
index d9bd9ca..165e705 100644
--- a/original/uapi/sound/compress_params.h
+++ b/original/uapi/sound/compress_params.h
@@ -268,7 +268,7 @@ struct snd_enc_vorbis {
 	__u32 max_bit_rate;
 	__u32 min_bit_rate;
 	__u32 downmix;
-} __attribute__((packed, aligned(4)));
+};
 
 
 /**
@@ -284,7 +284,7 @@ struct snd_enc_real {
 	__u32 quant_bits;
 	__u32 start_region;
 	__u32 num_regions;
-} __attribute__((packed, aligned(4)));
+};
 
 /**
  * struct snd_enc_flac
@@ -308,12 +308,12 @@ struct snd_enc_real {
 struct snd_enc_flac {
 	__u32 num;
 	__u32 gain;
-} __attribute__((packed, aligned(4)));
+};
 
 struct snd_enc_generic {
 	__u32 bw;	/* encoder bandwidth */
 	__s32 reserved[15];
-} __attribute__((packed, aligned(4)));
+};
 
 union snd_codec_options {
 	struct snd_enc_wma wma;
@@ -321,7 +321,7 @@ union snd_codec_options {
 	struct snd_enc_real real;
 	struct snd_enc_flac flac;
 	struct snd_enc_generic generic;
-} __attribute__((packed, aligned(4)));
+};
 
 /** struct snd_codec_desc - description of codec capabilities
  * @max_ch: Maximum number of audio channels
@@ -358,7 +358,7 @@ struct snd_codec_desc {
 	__u32 formats;
 	__u32 min_buffer;
 	__u32 reserved[15];
-} __attribute__((packed, aligned(4)));
+};
 
 /** struct snd_codec
  * @id: Identifies the supported audio encoder/decoder.
@@ -399,6 +399,6 @@ struct snd_codec {
 	__u32 align;
 	union snd_codec_options options;
 	__u32 reserved[3];
-} __attribute__((packed, aligned(4)));
+};
 
 #endif
diff --git a/original/uapi/sound/firewire.h b/original/uapi/sound/firewire.h
index af4bd13..59f5961 100644
--- a/original/uapi/sound/firewire.h
+++ b/original/uapi/sound/firewire.h
@@ -2,13 +2,11 @@
 #define _UAPI_SOUND_FIREWIRE_H_INCLUDED
 
 #include <linux/ioctl.h>
-#include <linux/types.h>
 
 /* events can be read() from the hwdep device */
 
 #define SNDRV_FIREWIRE_EVENT_LOCK_STATUS	0x000010cc
 #define SNDRV_FIREWIRE_EVENT_DICE_NOTIFICATION	0xd1ce004e
-#define SNDRV_FIREWIRE_EVENT_EFW_RESPONSE	0x4e617475
 
 struct snd_firewire_event_common {
 	unsigned int type; /* SNDRV_FIREWIRE_EVENT_xxx */
@@ -24,27 +22,10 @@ struct snd_firewire_event_dice_notification {
 	unsigned int notification; /* DICE-specific bits */
 };
 
-#define SND_EFW_TRANSACTION_USER_SEQNUM_MAX	((__u32)((__u16)~0) - 1)
-/* each field should be in big endian */
-struct snd_efw_transaction {
-	__be32 length;
-	__be32 version;
-	__be32 seqnum;
-	__be32 category;
-	__be32 command;
-	__be32 status;
-	__be32 params[0];
-};
-struct snd_firewire_event_efw_response {
-	unsigned int type;
-	__be32 response[0];	/* some responses */
-};
-
 union snd_firewire_event {
 	struct snd_firewire_event_common            common;
 	struct snd_firewire_event_lock_status       lock_status;
 	struct snd_firewire_event_dice_notification dice_notification;
-	struct snd_firewire_event_efw_response      efw_response;
 };
 
 
@@ -53,9 +34,7 @@ union snd_firewire_event {
 #define SNDRV_FIREWIRE_IOCTL_UNLOCK    _IO('H', 0xfa)
 
 #define SNDRV_FIREWIRE_TYPE_DICE	1
-#define SNDRV_FIREWIRE_TYPE_FIREWORKS	2
-#define SNDRV_FIREWIRE_TYPE_BEBOB	3
-/* AV/C, RME, MOTU, ... */
+/* Fireworks, AV/C, RME, MOTU, ... */
 
 struct snd_firewire_get_info {
 	unsigned int type; /* SNDRV_FIREWIRE_TYPE_xxx */
diff --git a/original/uapi/video/adf.h b/original/uapi/video/adf.h
index c5d2e62..b703bf9 100644
--- a/original/uapi/video/adf.h
+++ b/original/uapi/video/adf.h
@@ -83,7 +83,7 @@ struct adf_event {
  */
 struct adf_vsync_event {
 	struct adf_event base;
-	__aligned_u64 timestamp;
+	__u64 timestamp;
 };
 
 /**
@@ -119,12 +119,12 @@ struct adf_buffer_config {
 	__u32 h;
 	__u32 format;
 
-	__s32 fd[ADF_MAX_PLANES];
+	__s64 fd[ADF_MAX_PLANES];
 	__u32 offset[ADF_MAX_PLANES];
 	__u32 pitch[ADF_MAX_PLANES];
 	__u8 n_planes;
 
-	__s32 acquire_fence;
+	__s64 acquire_fence;
 };
 #define ADF_MAX_BUFFERS (4096 / sizeof(struct adf_buffer_config))
 
@@ -150,7 +150,7 @@ struct adf_post_config {
 	size_t custom_data_size;
 	void __user *custom_data;
 
-	__s32 complete_fence;
+	__s64 complete_fence;
 };
 #define ADF_MAX_INTERFACES (4096 / sizeof(__u32))
 
@@ -180,7 +180,7 @@ struct adf_simple_buffer_alloc {
 	__u16 h;
 	__u32 format;
 
-	__s32 fd;
+	__s64 fd;
 	__u32 offset;
 	__u32 pitch;
 };
@@ -195,7 +195,7 @@ struct adf_simple_buffer_alloc {
  */
 struct adf_simple_post_config {
 	struct adf_buffer_config buf;
-	__s32 complete_fence;
+	__s64 complete_fence;
 };
 
 /**
-- 
1.8.0

