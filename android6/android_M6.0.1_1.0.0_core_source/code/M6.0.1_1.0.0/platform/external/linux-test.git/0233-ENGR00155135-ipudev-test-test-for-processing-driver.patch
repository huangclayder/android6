From 46a5cb5a0a23f5d23d630eb4935e2460bd955a3a Mon Sep 17 00:00:00 2001
From: Jason Chen <b02280@freescale.com>
Date: Mon, 22 Aug 2011 10:54:20 +0800
Subject: [PATCH 233/505] ENGR00155135 ipudev test: test for processing driver

IPU's IC/IRT/VDI modules provide resizing/CSC/combination/de-interlacing
support, this patch make all these features into one processing driver.
A struct ipu_task is the interface between user and this driver, user just
need fill his task struct and queue it through ioctl, then wait ipu hardware
finish its job (now only support BLOCKING operation, not support NO_BLOCK
operation).
Pls refer to inlcude/linux/ipu.h for structure information and unit test
for usage.

This patch is for unit test changes.

Signed-off-by: Jason Chen <b02280@freescale.com>
---
 test/mxc_ipudev_test/Makefile           |    6 +-
 test/mxc_ipudev_test/ipudev_config_file |   74 +-
 test/mxc_ipudev_test/mxc_ipudev_test.c  |  593 ++++++---
 test/mxc_ipudev_test/mxc_ipudev_test.h  |   26 +-
 test/mxc_ipudev_test/test_pattern.c     | 2014 -------------------------------
 test/mxc_ipudev_test/utils.c            |  317 ++++-
 6 files changed, 737 insertions(+), 2293 deletions(-)
 delete mode 100644 test/mxc_ipudev_test/test_pattern.c

diff --git a/test/mxc_ipudev_test/Makefile b/test/mxc_ipudev_test/Makefile
index 12c7889..813393f 100644
--- a/test/mxc_ipudev_test/Makefile
+++ b/test/mxc_ipudev_test/Makefile
@@ -1,8 +1,8 @@
 # list of platforms which want this test case
-INCLUDE_LIST:=IMX31_3STACK IMX35_3STACK IMX37_3STACK IMX51 IMX53
+INCLUDE_LIST:=IMX51 IMX53 IMX6Q
 
-SRCS = mxc_ipudev_test.c utils.c test_pattern.c
-CFLAGS += -lipu -lIpuScreenLayer -lm -lrt
+SRCS = mxc_ipudev_test.c utils.c
+CFLAGS += -lm -lrt
 
 ifeq ($(PLATFORM),$(findstring $(PLATFORM),$(INCLUDE_LIST)))
 OBJS = $(OBJDIR)/mxc_ipudev_test.out
diff --git a/test/mxc_ipudev_test/ipudev_config_file b/test/mxc_ipudev_test/ipudev_config_file
index d6fe358..6541b13 100644
--- a/test/mxc_ipudev_test/ipudev_config_file
+++ b/test/mxc_ipudev_test/ipudev_config_file
@@ -27,22 +27,35 @@
 #	IPU_ROTATE_90_RIGHT_HFLIP = 6,
 #	IPU_ROTATE_90_LEFT = 7,
 #
-# mode ref:
-# 	TASK_ENC = 0x1
-# 	TASK_VF = 0x2
-# 	TASK_PP = 0x4
-# 	TASK_VDI_VF = 0x8
-# 	NORMAL_MODE = 0x10
-# 	STREAM_MODE = 0x20
+# priority ref:
+#	IPU_TASK_PRIORITY_NORMAL = 0
+#	IPU_TASK_PRIORITY_HIGH = 1
 #
-# video de-interlace motion ref:
+# task_id ref:
+#	IPU_TASK_ID_ANY	= 0
+#	IPU_TASK_ID_VF	= 1
+#	IPU_TASK_ID_PP	= 2
+#
+# timeout: ms
+#
+# de-interlace motion ref:
 #	MEDIUM_MOTION = 0
 #	LOW_MOTION = 1
 #	HIGH_MOTION = 2
 #
+# overlay alpha mode ref:
+#	IPU_ALPHA_MODE_GLOBAL =	0
+#	IPU_ALPHA_MODE_LOCAL  =	1
+#
+
+#### priority
+priority=0
+
+#### task_id
+task_id=0
 
-#### mode
-mode=0x24
+#### timeout
+timeout=1000
 
 #### operation frame count
 fcount=50
@@ -57,20 +70,45 @@ in_fmt=I420
 #input crop
 in_posx=0
 in_posy=0
-in_win_w=0
-in_win_h=0
-#input motion(video de-interlace)
+in_crop_w=0
+in_crop_h=0
+#deinterlace
+deinterlace_en=0
 motion_sel=0
 
+#### overlay
+overlay_en=0
+ov_width=320
+ov_height=240
+ov_fmt=I420
+#overlay crop
+ov_posx=0
+ov_posy=0
+ov_crop_w=0
+ov_crop_h=0
+#overlay alpha
+alpha_mode=0
+alpha_value=0
+#overlay colorkey
+colorkey_en=0
+colorkey_value=0x555555
+
 #### output
 out_width=1024
 out_height=768
 out_fmt=UYVY
 out_rot=0
-#output to framebuffer
-out_to_fb=1
-out_fb_num=2
+#output crop
 out_posx=0
 out_posy=0
-#output to file
-out_filename=output.dat
+out_crop_w=0
+out_crop_h=0
+
+#output target
+out_to_fb=1
+#if out_to_fb == 1, then out_filename ref to fb
+#	ipu0 1st display overlay:	ipu0-1st-ovfb
+#	ipu0 2nd display:		ipu0-2nd-fb
+#	ipu1 1st display overlay:	ipu1-1st-ovfb
+#	ipu1 2nd display:		ipu1-2nd-fb
+out_filename=ipu0-1st-ovfb
diff --git a/test/mxc_ipudev_test/mxc_ipudev_test.c b/test/mxc_ipudev_test/mxc_ipudev_test.c
index 432e540..7f916f7 100644
--- a/test/mxc_ipudev_test/mxc_ipudev_test.c
+++ b/test/mxc_ipudev_test/mxc_ipudev_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  */
 
@@ -21,130 +21,154 @@
  */
 
 #include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <unistd.h>
 #include <fcntl.h>
+#include <stdlib.h>
 #include <stdint.h>
+#include <unistd.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <linux/mxcfb.h>
 #include "mxc_ipudev_test.h"
 
+#define FB_BUFS 3
 int ctrl_c_rev = 0;
-
 void ctrl_c_handler(int signum, siginfo_t *info, void *myact)
 {
 	ctrl_c_rev = 1;
 }
 
-void output_to_file_cb(void * arg, int index)
-{
-	ipu_test_handle_t * test_handle = (ipu_test_handle_t *)arg;
-
-	if (test_handle->file_out)
-		if(fwrite(test_handle->ipu_handle->outbuf_start[index], 1,
-				test_handle->ipu_handle->ofr_size,
-				test_handle->file_out) < test_handle->ipu_handle->ofr_size) {
-			printf("Can not write enough data into output file!\n");
-		}
-}
-
-int process_cmdline(int argc, char **argv, ipu_test_handle_t * test_handle)
+int process_cmdline(int argc, char **argv, ipu_test_handle_t *test_handle)
 {
 	int i;
+	struct ipu_task *t = &test_handle->task;
 
 	if (argc == 1)
 		return -1;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-C") == 0) {
+	for (i = 1; i < argc; i++)
+		if (strcmp(argv[i], "-C") == 0)
 			parse_config_file(argv[++i], test_handle);
-		} else if (strcmp(argv[i], "-P") == 0) {
-			test_handle->test_pattern = atoi(argv[++i]);
-		} else if (strcmp(argv[i], "-bw") == 0) {
-			test_handle->block_width = atoi(argv[++i]);
-			if (test_handle->block_width < 16)
-				test_handle->block_width = 16;
-		} else if (strcmp(argv[i], "-Q") == 0)
-			test_handle->query_task = 1;
-		else if (strcmp(argv[i], "-K") == 0) {
-			test_handle->kill_task = 1;
-			test_handle->kill_task_idx = atoi(argv[++i]);
-		}
-	}
-
-	if (test_handle->test_pattern)
-		return 0;
-	if (test_handle->query_task || test_handle->kill_task)
-		return 0;
 
-	if ((test_handle->input.width == 0) || (test_handle->input.height == 0) ||
-			(test_handle->output.width == 0) ||
-			(test_handle->output.height == 0)
+	if ((t->input.width == 0) || (t->input.height == 0) ||
+			(t->output.width == 0) ||
+			(t->output.height == 0)
 			|| (test_handle->fcount < 1))
 		return -1;
 
 	return 0;
 }
 
-int query_ipu_task(void)
+static unsigned int fmt_to_bpp(unsigned int pixelformat)
 {
-	int i;
-	ipu_lib_ctl_task_t task;
-
-	for (i = 0; i< MAX_TASK_NUM; i++) {
-		task.index = i;
-		mxc_ipu_lib_task_control(IPU_CTL_TASK_QUERY, (void *)(&task), NULL);
-		if (task.task_pid) {
-			printf("\ntask %d:\n", i);
-			printf("\tpid: %d\n", task.task_pid);
-			printf("\tmode:\n");
-			if (task.task_mode & IC_ENC)
-				printf("\t\tIC_ENC\n");
-			if (task.task_mode & IC_VF)
-				printf("\t\tIC_VF\n");
-			if (task.task_mode & IC_PP)
-				printf("\t\tIC_PP\n");
-			if (task.task_mode & ROT_ENC)
-				printf("\t\tROT_ENC\n");
-			if (task.task_mode & ROT_VF)
-				printf("\t\tROT_VF\n");
-			if (task.task_mode & ROT_PP)
-				printf("\t\tROT_PP\n");
-			if (task.task_mode & VDI_IC_VF)
-				printf("\t\tVDI_IC_VF\n");
-		}
-	}
-
-	return 0;
+        unsigned int bpp;
+
+        switch (pixelformat)
+        {
+                case IPU_PIX_FMT_RGB565:
+                /*interleaved 422*/
+                case IPU_PIX_FMT_YUYV:
+                case IPU_PIX_FMT_UYVY:
+                /*non-interleaved 422*/
+                case IPU_PIX_FMT_YUV422P:
+                case IPU_PIX_FMT_YVU422P:
+                        bpp = 16;
+                        break;
+                case IPU_PIX_FMT_BGR24:
+                case IPU_PIX_FMT_RGB24:
+                case IPU_PIX_FMT_YUV444:
+                        bpp = 24;
+                        break;
+                case IPU_PIX_FMT_BGR32:
+                case IPU_PIX_FMT_BGRA32:
+                case IPU_PIX_FMT_RGB32:
+                case IPU_PIX_FMT_RGBA32:
+                case IPU_PIX_FMT_ABGR32:
+                        bpp = 32;
+                        break;
+                /*non-interleaved 420*/
+                case IPU_PIX_FMT_YUV420P:
+                case IPU_PIX_FMT_YVU420P:
+                case IPU_PIX_FMT_YUV420P2:
+                case IPU_PIX_FMT_NV12:
+                        bpp = 12;
+                        break;
+                default:
+                        bpp = 8;
+                        break;
+        }
+        return bpp;
 }
 
-int kill_ipu_task(int index)
+static void dump_ipu_task(struct ipu_task *t)
 {
-	ipu_lib_ctl_task_t task;
-
-	task.index = index;
-	mxc_ipu_lib_task_control(IPU_CTL_TASK_KILL, (void *)(&task), NULL);
-
-	return 0;
+	printf("====== ipu task ======\n");
+	printf("input:\n");
+	printf("\tforamt: 0x%x\n", t->input.format);
+	printf("\twidth: %d\n", t->input.width);
+	printf("\theight: %d\n", t->input.height);
+	printf("\tcrop.w = %d\n", t->input.crop.w);
+	printf("\tcrop.h = %d\n", t->input.crop.h);
+	printf("\tcrop.pos.x = %d\n", t->input.crop.pos.x);
+	printf("\tcrop.pos.y = %d\n", t->input.crop.pos.y);
+	if (t->input.deinterlace.enable) {
+		printf("deinterlace enabled with:\n");
+		if (t->input.deinterlace.motion != HIGH_MOTION)
+			printf("\tlow/medium motion\n");
+		else
+			printf("\thigh motion\n");
+	}
+	printf("output:\n");
+	printf("\tforamt: 0x%x\n", t->output.format);
+	printf("\twidth: %d\n", t->output.width);
+	printf("\theight: %d\n", t->output.height);
+	printf("\troate: %d\n", t->output.rotate);
+	printf("\tcrop.w = %d\n", t->output.crop.w);
+	printf("\tcrop.h = %d\n", t->output.crop.h);
+	printf("\tcrop.pos.x = %d\n", t->output.crop.pos.x);
+	printf("\tcrop.pos.y = %d\n", t->output.crop.pos.y);
+	if (t->overlay_en) {
+		printf("overlay:\n");
+		printf("\tforamt: 0x%x\n", t->overlay.format);
+		printf("\twidth: %d\n", t->overlay.width);
+		printf("\theight: %d\n", t->overlay.height);
+		printf("\tcrop.w = %d\n", t->overlay.crop.w);
+		printf("\tcrop.h = %d\n", t->overlay.crop.h);
+		printf("\tcrop.pos.x = %d\n", t->overlay.crop.pos.x);
+		printf("\tcrop.pos.y = %d\n", t->overlay.crop.pos.y);
+		if (t->overlay.alpha.mode == IPU_ALPHA_MODE_LOCAL)
+			printf("combine with local alpha\n");
+		else
+			printf("combine with global alpha %d\n", t->overlay.alpha.gvalue);
+		if (t->overlay.colorkey.enable)
+			printf("colorkey enabled with 0x%x\n", t->overlay.colorkey.value);
+	}
 }
 
 int main(int argc, char *argv[])
 {
-	int ret = 0, next_update_idx = 0, done_cnt = 0, first_time = 1;
-	int done_loop = 0, total_cnt = 0;
-	ipu_lib_handle_t ipu_handle;
 	ipu_test_handle_t test_handle;
-	FILE * file_in = NULL;
+	struct ipu_task *t = &test_handle.task;
+	int ret = 0, done_cnt = 0;
+	int done_loop = 0, total_cnt = 0;
 	struct sigaction act;
+	FILE * file_in = NULL;
+	FILE * file_out = NULL;
 	struct timeval begin, end;
 	int sec, usec, run_time = 0;
-
-	memset(&ipu_handle, 0, sizeof(ipu_lib_handle_t));
-	memset(&test_handle, 0, sizeof(ipu_test_handle_t));
-	test_handle.ipu_handle = &ipu_handle;
-	test_handle.mode = OP_NORMAL_MODE;
-	test_handle.block_width = 80;
+	int fd_ipu = 0, fd_fb = 0;
+	int isize = 0, ovsize = 0;
+	int alpsize = 0, osize = 0;
+	void *inbuf = NULL, *vdibuf = NULL;
+	void *ovbuf = NULL, *alpbuf = NULL;
+	void *outbuf = NULL;
+	dma_addr_t outpaddr[FB_BUFS];
+	struct fb_var_screeninfo fb_var;
+	struct fb_fix_screeninfo fb_fix;
+	int blank;
 
 	/*for ctrl-c*/
 	sigemptyset(&act.sa_mask);
@@ -153,127 +177,270 @@ int main(int argc, char *argv[])
 
 	if((ret = sigaction(SIGINT, &act, NULL)) < 0) {
 		printf("install sigal error\n");
-		goto done;
+		return ret;
 	}
 
+	memset(&test_handle, 0, sizeof(ipu_test_handle_t));
+
 	if (process_cmdline(argc, argv, &test_handle) < 0) {
 		printf("\nMXC IPU device Test\n\n" \
-				"Usage: %s\n" \
-				"-C <config file>\n" \
-				"-P <test pattern>\n" \
-				"[-bw <block width for pattern 3>]\n" \
-				"<input raw file>\n\n" \
-				"Query ipu task runing:\n" \
-				"-Q\n\n" \
-				"Kill ipu task:\n" \
-				"-K <task_index>\n", argv[0]);
-		printf("\ntest pattern:\n" \
-			"1: video pattern with user define dma buffer queue, one full-screen output\n" \
-			"2: hopping block screen save\n" \
-			"3: color bar + hopping block\n" \
-			"4: color bar IC global alpha overlay\n" \
-			"5: color bar IC separate local alpha overlay\n" \
-			"6: color bar IC local alpha within pixel overlay\n" \
-			"7: ipu dma copy test\n" \
-			"8: 2 screen layer test using IC global alpha blending\n" \
-			"9: 3 screen layer test using IC global alpha blending\n" \
-			"10: 2 screen layer test using IC local alpha blending with alpha value in separate buffer\n" \
-			"11: 3 screen layer test using IC local alpha blending with alpha value in separate buffer\n" \
-			"12: 2 screen layer test using IC local alpha blending with alpha value in pixel\n" \
-			"13: 3 screen layer test using IC local alpha blending with alpha value in pixel\n" \
-			"14: 2 screen layer test IPC ProcessA + ProcessB with globla alpha blending\n" \
-			"15: 2 screen layer test IPC ProcessA + ProcessB with local alpha blending\n" \
-			"16: 3 screen layer test IPC ProcessA(first_layer + sencond_layer) + ProcessB(third_layer) with globla alpha blending\n" \
-			"17: 3 screen layer test IPC ProcessA(first_layer + sencond_layer) + ProcessB(third_layer) with local alpha blending\n" \
-			"18: 3 screen layer test IPC ProcessA(first_layer) ProcessB(sencond_layer) ProcessC(third_layer) with local alpha blending\n" \
-			"19: 2 screen layer test IPC ProcessA(first_layer) ProcessB(sencond_layer) with local alpha blending plus tv copy\n\n");
+			"Usage: %s -C <config file> <input raw file>\n",
+			argv[0]);
 		return -1;
 	}
 
-	system("echo 0,0 > /sys/class/graphics/fb0/pan");
+	file_in = fopen(argv[argc-1], "rb");
+	if (file_in == NULL){
+		printf("there is no such file for reading %s\n", argv[argc-1]);
+		ret = -1;
+		goto err0;
+	}
 
-	if (test_handle.test_pattern) {
-		ret = run_test_pattern(test_handle.test_pattern, &test_handle);
-		system("echo 0,0 > /sys/class/graphics/fb0/pan");
-		return ret;
-	} else if (argc < 4) {
-		if (test_handle.query_task)
-			return query_ipu_task();
-		else if (test_handle.kill_task)
-			return kill_ipu_task(test_handle.kill_task_idx);
-		else {
-			printf("Pls set input file\n");
-			return -1;
-		}
+	fd_ipu = open("/dev/mxc_ipu", O_RDWR, 0);
+	if (fd_ipu < 0) {
+		printf("open ipu dev fail\n");
+		ret = -1;
+		goto err1;
+	}
+
+	isize = t->input.paddr =
+		t->input.width * t->input.height
+		* fmt_to_bpp(t->input.format)/8;
+	ret = ioctl(fd_ipu, IPU_ALLOC, &t->input.paddr);
+	if (ret < 0) {
+		printf("ioctl IPU_ALLOC fail\n");
+		goto err2;
+	}
+	inbuf = mmap(0, isize, PROT_READ | PROT_WRITE,
+		MAP_SHARED, fd_ipu, t->input.paddr);
+	if (!inbuf) {
+		printf("mmap fail\n");
+		ret = -1;
+		goto err3;
 	}
 
-	if (test_handle.mode & OP_STREAM_MODE) {
-		if (test_handle.fcount == 1) {
-			test_handle.mode &= ~(OP_STREAM_MODE);
-			test_handle.mode |= OP_NORMAL_MODE;
+	if (t->input.deinterlace.enable &&
+		(t->input.deinterlace.motion != HIGH_MOTION)) {
+		t->input.paddr_n = isize;
+		ret = ioctl(fd_ipu, IPU_ALLOC, &t->input.paddr_n);
+		if (ret < 0) {
+			printf("ioctl IPU_ALLOC fail\n");
+			goto err4;
+		}
+		vdibuf = mmap(0, isize, PROT_READ | PROT_WRITE,
+				MAP_SHARED, fd_ipu, t->input.paddr_n);
+		if (!vdibuf) {
+			printf("mmap fail\n");
+			ret = -1;
+			goto err5;
 		}
 	}
 
-	file_in = fopen(argv[argc-1], "rb");
-	if (file_in == NULL){
-		printf("there is no such file for reading %s\n", argv[argc-1]);
-		return -1;
+	if (t->overlay_en) {
+		ovsize = t->overlay.paddr =
+			t->overlay.width * t->overlay.height
+			* fmt_to_bpp(t->overlay.format)/8;
+		ret = ioctl(fd_ipu, IPU_ALLOC, &t->overlay.paddr);
+		if (ret < 0) {
+			printf("ioctl IPU_ALLOC fail\n");
+			goto err6;
+		}
+		ovbuf = mmap(0, ovsize, PROT_READ | PROT_WRITE,
+				MAP_SHARED, fd_ipu, t->overlay.paddr);
+		if (!ovbuf) {
+			printf("mmap fail\n");
+			ret = -1;
+			goto err7;
+		}
+
+		/*fill overlay buffer with dedicated data*/
+		memset(ovbuf, 0x00, ovsize/4);
+		memset(ovbuf+ovsize/4, 0x55, ovsize/4);
+		memset(ovbuf+ovsize/2, 0xaa, ovsize/4);
+		memset(ovbuf+ovsize*3/4, 0xff, ovsize/4);
+
+		if (t->overlay.alpha.mode == IPU_ALPHA_MODE_LOCAL) {
+			alpsize = t->overlay.alpha.loc_alp_paddr =
+				t->overlay.width * t->overlay.height;
+			ret = ioctl(fd_ipu, IPU_ALLOC, &t->overlay.alpha.loc_alp_paddr);
+			if (ret < 0) {
+				printf("ioctl IPU_ALLOC fail\n");
+				goto err8;
+			}
+			alpbuf = mmap(0, alpsize, PROT_READ | PROT_WRITE,
+					MAP_SHARED, fd_ipu, t->overlay.alpha.loc_alp_paddr);
+			if (!alpbuf) {
+				printf("mmap fail\n");
+				ret = -1;
+				goto err9;
+			}
+
+			/*fill loc alpha buffer with dedicated data*/
+			memset(alpbuf, 0x00, alpsize/4);
+			memset(alpbuf+alpsize/4, 0x55, alpsize/4);
+			memset(alpbuf+alpsize/2, 0xaa, alpsize/4);
+			memset(alpbuf+alpsize*3/4, 0xff, alpsize/4);
+		}
 	}
 
-	if (test_handle.outfile && !test_handle.output.show_to_fb)
-		test_handle.file_out = fopen(test_handle.outfile, "wb");
+	if (test_handle.show_to_fb) {
+		int found = 0, i;
+		char fb_dev[] = "/dev/fb0";
+		char fb_name[16];
+
+		if (!strcmp(test_handle.outfile, "ipu0-1st-ovfb"))
+			memcpy(fb_name, "DISP3 FG", 9);
+		if (!strcmp(test_handle.outfile, "ipu0-2nd-fb"))
+			memcpy(fb_name, "DISP3 BG - DI1", 15);
+		if (!strcmp(test_handle.outfile, "ipu1-1st-ovfb"))
+			memcpy(fb_name, "DISP4 FG", 9);
+		if (!strcmp(test_handle.outfile, "ipu1-2nd-fb"))
+			memcpy(fb_name, "DISP4 BG - DI1", 15);
+
+		for (i=0; i<5; i++) {
+			fb_dev[7] = '0';
+			fb_dev[7] += i;
+			fd_fb = open(fb_dev, O_RDWR, 0);
+			if (fd_fb > 0) {
+				ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
+				if (!strcmp(fb_fix.id, fb_name)) {
+					printf("found fb dev %s\n", fb_dev);
+					found = 1;
+					break;
+				} else
+					close(fd_fb);
+			}
+		}
 
-	ret = mxc_ipu_lib_task_init(&(test_handle.input), NULL, &(test_handle.output),
-			test_handle.mode, test_handle.ipu_handle);
-	if (ret < 0) {
-		printf("mxc_ipu_lib_task_init failed!\n");
-		goto done;
+		if (!found) {
+			printf("can not find fb dev %s\n", fb_name);
+			ret = -1;
+			goto err10;
+		}
+
+		ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var);
+		fb_var.xres = t->output.width;
+		fb_var.xres_virtual = fb_var.xres;
+		fb_var.yres = t->output.height;
+		fb_var.yres_virtual = fb_var.yres * FB_BUFS;
+		fb_var.activate |= FB_ACTIVATE_FORCE;
+		fb_var.nonstd = t->output.format;
+		fb_var.bits_per_pixel = fmt_to_bpp(t->output.format);
+
+		ret = ioctl(fd_fb, FBIOPUT_VSCREENINFO, &fb_var);
+		if (ret < 0) {
+			printf("fb ioctl FBIOPUT_VSCREENINFO fail\n");
+			goto err11;
+		}
+		ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var);
+		ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
+
+		for (i=0; i<FB_BUFS; i++)
+			outpaddr[i] = fb_fix.smem_start +
+				i * fb_var.yres * fb_fix.line_length;
+
+		blank = FB_BLANK_UNBLANK;
+		ioctl(fd_fb, FBIOBLANK, blank);
+	} else {
+		osize = t->output.paddr =
+			t->output.width * t->output.height
+			* fmt_to_bpp(t->output.format)/8;
+		ret = ioctl(fd_ipu, IPU_ALLOC, &t->output.paddr);
+		if (ret < 0) {
+			printf("ioctl IPU_ALLOC fail\n");
+			goto err10;
+		}
+		outbuf = mmap(0, osize, PROT_READ | PROT_WRITE,
+				MAP_SHARED, fd_ipu, t->output.paddr);
+		if (!outbuf) {
+			printf("mmap fail\n");
+			ret = -1;
+			goto err11;
+		}
+
+		file_out = fopen(test_handle.outfile, "wb");
+		if (file_out == NULL) {
+			printf("can not open output file %s\n", test_handle.outfile);
+			ret = -1;
+			goto err12;
+		}
 	}
 
 again:
+	ret = ioctl(fd_ipu, IPU_CHECK_TASK, t);
+	if (ret != IPU_CHECK_OK) {
+		if (ret > IPU_CHECK_ERR_MIN) {
+			if (ret == IPU_CHECK_ERR_SPLIT_INPUTW_OVER) {
+				t->input.crop.w -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_INPUTH_OVER) {
+				t->input.crop.h -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER) {
+				t->output.crop.w -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER) {
+				t->output.crop.h -= 8;
+				goto again;
+			}
+			ret = -1;
+			printf("ipu task check fail\n");
+			goto err13;
+		}
+	}
+	dump_ipu_task(t);
+
+task_begin:
+	if (t->input.deinterlace.enable &&
+		(t->input.deinterlace.motion != HIGH_MOTION))
+		if (fread(vdibuf, 1, isize, file_in) < isize) {
+			ret = -1;
+			printf("Can not read enough data from input file\n");
+			goto err13;
+		}
+
 	while((done_cnt < test_handle.fcount) && (ctrl_c_rev == 0)) {
 		gettimeofday(&begin, NULL);
-		if (fread(test_handle.ipu_handle->inbuf_start[next_update_idx], 1, test_handle.ipu_handle->ifr_size, file_in)
-				< test_handle.ipu_handle->ifr_size) {
+
+		if (t->input.deinterlace.enable &&
+			(t->input.deinterlace.motion != HIGH_MOTION)) {
+			memcpy(inbuf, vdibuf, isize);
+			ret = fread(vdibuf, 1, isize, file_in);
+		} else
+			ret = fread(inbuf, 1, isize, file_in);
+		if (ret < isize) {
 			ret = -1;
-			printf("Can not read enough data from input file!\n");
+			printf("Can not read enough data from input file\n");
 			break;
 		}
-		if (first_time && (test_handle.mode == (TASK_VDI_VF_MODE | OP_NORMAL_MODE)) && (test_handle.input.motion_sel != HIGH_MOTION)) {
-			if (fread(test_handle.ipu_handle->inbuf_start[1], 1, test_handle.ipu_handle->ifr_size, file_in)
-					< test_handle.ipu_handle->ifr_size) {
-				ret = -1;
-				printf("Can not read enough data from input file!\n");
+
+		if (test_handle.show_to_fb)
+			t->output.paddr = outpaddr[done_cnt % FB_BUFS];
+
+		ret = ioctl(fd_ipu, IPU_QUEUE_TASK, t);
+		if (ret < 0) {
+			printf("ioct IPU_QUEUE_TASK fail\n");
+			break;
+		}
+
+		if (test_handle.show_to_fb) {
+			fb_var.yoffset = (done_cnt % FB_BUFS) * fb_var.yres;
+			ret = ioctl(fd_fb, FBIOPAN_DISPLAY, &fb_var);
+			if (ret < 0) {
+				printf("fb ioct FBIOPAN_DISPLAY fail\n");
 				break;
 			}
-			first_time = 0;
-			done_cnt++;
-			total_cnt++;
-		}
-		if (first_time && (test_handle.mode & OP_STREAM_MODE)) {
-			if (fread(test_handle.ipu_handle->inbuf_start[1], 1, test_handle.ipu_handle->ifr_size, file_in)
-					< test_handle.ipu_handle->ifr_size) {
+		} else {
+			ret = fwrite(outbuf, 1, osize, file_out);
+			if (ret < osize) {
 				ret = -1;
-				printf("Can not read enough data from input file!\n");
+				printf("Can not write enough data into output file\n");
 				break;
 			}
-			if ((test_handle.mode & TASK_VDI_VF_MODE) && (test_handle.input.motion_sel != HIGH_MOTION)) {
-				if (fread(test_handle.ipu_handle->inbuf_start[2], 1, test_handle.ipu_handle->ifr_size, file_in)
-						< test_handle.ipu_handle->ifr_size) {
-					ret = -1;
-					printf("Can not read enough data from input file!\n");
-					break;
-				}
-				done_cnt++;
-				total_cnt++;
-			}
-			first_time = 0;
-			done_cnt++;
-			total_cnt++;
 		}
-		next_update_idx = mxc_ipu_lib_task_buf_update(test_handle.ipu_handle, 0, 0, 0, output_to_file_cb, &test_handle);
-		if (next_update_idx < 0)
-			break;
 		done_cnt++;
 		total_cnt++;
 
@@ -288,23 +455,63 @@ again:
 		run_time += (sec * 1000000) + usec;
 	}
 
-	done_loop++;
-	if ((done_loop < test_handle.loop_cnt) && (ctrl_c_rev == 0)) {
-		done_cnt = 0;
-		fseek(file_in, 0L, SEEK_SET);
-		goto again;
+	if (ret >= 0) {
+		done_loop++;
+		if ((done_loop < test_handle.loop_cnt) && (ctrl_c_rev == 0)) {
+			done_cnt = 0;
+			fseek(file_in, 0L, SEEK_SET);
+			goto task_begin;
+		}
 	}
 
-	printf("total frame count %d avg frame time %d us, fps %f\n", total_cnt, run_time/total_cnt, total_cnt/(run_time/1000000.0));
-
-	mxc_ipu_lib_task_uninit(test_handle.ipu_handle);
-
-done:
-	fclose(file_in);
-	if (test_handle.file_out)
-		fclose(test_handle.file_out);
-
-	system("echo 0,0 > /sys/class/graphics/fb0/pan");
+	printf("total frame count %d avg frame time %d us, fps %f\n",
+			total_cnt, run_time/total_cnt, total_cnt/(run_time/1000000.0));
 
+err13:
+	if (fd_fb) {
+		blank = FB_BLANK_POWERDOWN;
+		ioctl(fd_fb, FBIOBLANK, blank);
+	}
+	if (file_out)
+		fclose(file_out);
+err12:
+	if (outbuf)
+		munmap(outbuf, osize);
+err11:
+	if (fd_fb)
+		close(fd_fb);
+	if (t->output.paddr)
+		ioctl(fd_ipu, IPU_FREE, &t->output.paddr);
+err10:
+	if (alpbuf)
+		munmap(alpbuf, alpsize);
+err9:
+	if (t->overlay.alpha.loc_alp_paddr)
+		ioctl(fd_ipu, IPU_FREE, &t->overlay.alpha.loc_alp_paddr);
+err8:
+	if (ovbuf)
+		munmap(ovbuf, ovsize);
+err7:
+	if (t->overlay.paddr)
+		ioctl(fd_ipu, IPU_FREE, &t->overlay.paddr);
+err6:
+	if (vdibuf)
+		munmap(vdibuf, isize);
+err5:
+	if (t->input.paddr_n)
+		ioctl(fd_ipu, IPU_FREE, &t->input.paddr_n);
+err4:
+	if (inbuf)
+		munmap(inbuf, isize);
+err3:
+	if (t->input.paddr)
+		ioctl(fd_ipu, IPU_FREE, &t->input.paddr);
+err2:
+	if (fd_ipu)
+		close(fd_ipu);
+err1:
+	if (file_in)
+		fclose(file_in);
+err0:
 	return ret;
 }
diff --git a/test/mxc_ipudev_test/mxc_ipudev_test.h b/test/mxc_ipudev_test/mxc_ipudev_test.h
index 882d185..6ccfbcf 100644
--- a/test/mxc_ipudev_test/mxc_ipudev_test.h
+++ b/test/mxc_ipudev_test/mxc_ipudev_test.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  */
 
@@ -23,35 +23,15 @@
 #define __MXC_IPUDEV_TEST_H__
 
 #include <linux/ipu.h>
-#include <linux/videodev.h>
-#include "mxc_ipu_hl_lib.h"
 
 typedef struct {
-	ipu_lib_handle_t * ipu_handle;
+	struct ipu_task task;
 	int fcount;
 	int loop_cnt;
-	int mode;
-	int test_pattern;
-	int block_width;
-	int query_task;
-	int kill_task;
-	int kill_task_idx;
+	int show_to_fb;
 	char outfile[128];
-	FILE * file_out;
-	ipu_lib_input_param_t input;
-	ipu_lib_output_param_t output;
 } ipu_test_handle_t;
 
-enum {
-	NO_OV = 0x00,
-	IC_GLB_ALP_OV = 0x01,
-	IC_LOC_SEP_ALP_OV = 0x02,
-	IC_LOC_PIX_ALP_OV = 0x04,
-	DP_LOC_SEP_ALP_OV = 0x08,
-	COPY_TV = 0x10,
-};
-
 extern int parse_config_file(char *file_name, ipu_test_handle_t *test_handle);
-int run_test_pattern(int pattern, ipu_test_handle_t * test_handle);
 
 #endif
diff --git a/test/mxc_ipudev_test/test_pattern.c b/test/mxc_ipudev_test/test_pattern.c
deleted file mode 100644
index c968548..0000000
--- a/test/mxc_ipudev_test/test_pattern.c
+++ /dev/null
@@ -1,2014 +0,0 @@
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- */
-
-/*
- * The code contained herein is licensed under the GNU Lesser General
- * Public License.  You may obtain a copy of the GNU Lesser General
- * Public License Version 2.1 or later at the following locations:
- *
- * http://www.opensource.org/licenses/lgpl-license.html
- * http://www.gnu.org/copyleft/lgpl.html
- */
-
-/*!
- * @file test_pattern.c
- *
- * @brief IPU device lib test pattern implementation
- *
- * @ingroup IPU
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <string.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <time.h>
-#include <errno.h>
-#include <pthread.h>
-#include <math.h>
-#include <semaphore.h>
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <linux/mxcfb.h>
-#include "mxc_ipudev_test.h"
-#ifndef BUILD_FOR_ANDROID
-#include "ScreenLayer.h"
-#endif
-
-/*
-       Y = R *  .299 + G *  .587 + B *  .114;
-       U = R * -.169 + G * -.332 + B *  .500 + 128.;
-       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
-
-#define red(x) (((x & 0xE0) >> 5) * 0x24)
-#define green(x) (((x & 0x1C) >> 2) * 0x24)
-#define blue(x) ((x & 0x3) * 0x55)
-#define y(rgb) ((red(rgb)*299L + green(rgb)*587L + blue(rgb)*114L) / 1000)
-#define u(rgb) ((((blue(rgb)*500L) - (red(rgb)*169L) - (green(rgb)*332L)) / 1000))
-#define v(rgb) (((red(rgb)*500L - green(rgb)*419L - blue(rgb)*81L) / 1000))
-#define BUF_CNT		5
-
-extern int ctrl_c_rev;
-
-static int get_system_rev(unsigned int * system_rev)
-{
-        FILE *fp;
-        char buf[1024];
-        int nread;
-        char *tmp, *rev;
-        int ret = -1;
-
-        fp = fopen("/proc/cpuinfo", "r");
-        if (fp == NULL) {
-                printf("Open /proc/cpuinfo failed!\n");
-                return ret;
-        }
-
-        nread = fread(buf, 1, sizeof(buf), fp);
-        fclose(fp);
-        if ((nread == 0) || (nread == sizeof(buf))) {
-                fclose(fp);
-                return ret;
-        }
-
-        buf[nread] = '\0';
-
-        tmp = strstr(buf, "Revision");
-        if (tmp != NULL) {
-                rev = index(tmp, ':');
-                if (rev != NULL) {
-                        rev++;
-                        *system_rev = strtoul(rev, NULL, 16);
-                        ret = 0;
-                }
-        }
-
-        return ret;
-}
-
-void gen_fill_pattern(char * buf, int in_width, int in_height)
-{
-	int y_size = in_width * in_height;
-	int h_step = in_height / 16;
-	int w_step = in_width / 16;
-	int h, w;
-	uint32_t y_color = 0;
-	int32_t u_color = 0;
-	int32_t v_color = 0;
-	uint32_t rgb = 0;
-	static int32_t alpha = 0;
-	static int inc_alpha = 1;
-
-	for (h = 0; h < in_height; h++) {
-		int32_t rgb_temp = rgb;
-
-		for (w = 0; w < in_width; w++) {
-			if (w % w_step == 0) {
-				y_color = y(rgb_temp);
-				y_color = (y_color * alpha) / 255;
-
-				u_color = u(rgb_temp);
-				u_color = (u_color * alpha) / 255;
-				u_color += 128;
-
-				v_color = v(rgb_temp);
-				v_color = (v_color * alpha) / 255;
-				v_color += 128;
-
-				rgb_temp++;
-				if (rgb_temp > 255)
-					rgb_temp = 0;
-			}
-			buf[(h*in_width) + w] = y_color;
-			if (!(h & 0x1) && !(w & 0x1)) {
-				buf[y_size + (((h*in_width)/4) + (w/2)) ] = u_color;
-				buf[y_size + y_size/4 + (((h*in_width)/4) + (w/2))] = v_color;
-			}
-		}
-		if ((h > 0) && (h % h_step == 0)) {
-			rgb += 16;
-			if (rgb > 255)
-				rgb = 0;
-		}
-
-	}
-	if (inc_alpha) {
-		alpha+=4;
-		if (alpha >= 255) {
-			inc_alpha = 0;
-		}
-	} else {
-		alpha-=4;
-		if (alpha <= 0) {
-			inc_alpha = 1;
-		}
-	}
-}
-
-void gen_fill_alpha_in_separate_buffer(void * alpha_buf, int alpha_size,
-				       char alpha)
-{
-	memset(alpha_buf, alpha, alpha_size);
-}
-
-void fill_alpha_buffer(char *alpha_buf, int left, int top,
-		       int right, int bottom, int disp_w, char alpha_val)
-{
-	char *pPointAlphaValue;
-	int x, y;
-
-	for (y = top; y < bottom; y++) {
-		for (x = left; x < right; x++) {
-			pPointAlphaValue = (char *)(alpha_buf +
-					    disp_w * y + x);
-			*pPointAlphaValue = alpha_val;
-		}
-	}
-}
-
-void gen_fill_alpha_in_pixel(void * buf, unsigned int pixel_format,
-			     int buf_size, char alpha)
-{
-	int i;
-	char* p_alpha;
-
-	if (pixel_format == v4l2_fourcc('R', 'G', 'B', 'A') ||
-	    pixel_format == v4l2_fourcc('B', 'G', 'R', 'A')) {
-		for (i = 0; i < buf_size; i++) {
-			if (i % 4 == 3) {
-				p_alpha = (char *)(buf + i);
-				*p_alpha = alpha;
-			}
-		}
-	} else if (pixel_format == v4l2_fourcc('A', 'B', 'G', 'R')) {
-		for (i = 0; i < buf_size; i++) {
-			if (i % 4 == 0) {
-				p_alpha = (char *)(buf + i);
-				*p_alpha = alpha;
-			}
-		}
-	} else {
-		printf("Unsupported pixel format with alpha value!\n");
-	}
-}
-
-void gen_fill_alpha_in_pixel_for_point(void * buf, unsigned int pixel_format,
-			     int sl_width, int x, int y, char alpha)
-{
-	unsigned char* p_alpha;
-
-	if (pixel_format == v4l2_fourcc('R', 'G', 'B', 'A') ||
-	    pixel_format == v4l2_fourcc('B', 'G', 'R', 'A')) {
-		p_alpha = (unsigned char *)(buf + 4*sl_width*y + 4*x + 3);
-	} else if (pixel_format == v4l2_fourcc('A', 'B', 'G', 'R')) {
-		p_alpha = (unsigned char *)(buf + 4*sl_width*y + 4*x);
-	} else {
-		printf("Unsupported pixel format with alpha value!\n");
-		return;
-	}
-	*p_alpha = alpha;
-}
-
-int foreground_fb(void)
-{
-	int fd_fb;
-	struct fb_fix_screeninfo fb_fix;
-
-	fd_fb = open("/dev/fb2", O_RDWR, 0);
-	ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
-	if (strcmp(fb_fix.id, "DISP3 FG") == 0) {
-		close(fd_fb);
-		return 2;
-	}
-
-	fd_fb = open("/dev/fb1", O_RDWR, 0);
-	ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
-	if (strcmp(fb_fix.id, "DISP3 FG") == 0) {
-		close(fd_fb);
-		return 1;
-	}
-
-	return 0;
-}
-
-int dc_fb(void)
-{
-	int fd_fb;
-	struct fb_fix_screeninfo fb_fix;
-
-	fd_fb = open("/dev/fb0", O_RDWR, 0);
-	ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
-	if (strcmp(fb_fix.id, "DISP3 BG - DI1") == 0) {
-		close(fd_fb);
-		return 0;
-	}
-
-	fd_fb = open("/dev/fb1", O_RDWR, 0);
-	ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix);
-	if (strcmp(fb_fix.id, "DISP3 BG - DI1") == 0) {
-		close(fd_fb);
-		return 1;
-	}
-
-	return -1;
-}
-
-int fd_fb_alloc = 0;
-
-int dma_memory_alloc(int size, int cnt, dma_addr_t paddr[], void * vaddr[])
-{
-	int i, ret = 0;
-
-	if ((fd_fb_alloc = open("/dev/fb0", O_RDWR, 0)) < 0) {
-		printf("Unable to open /dev/fb0\n");
-		ret = -1;
-		goto done;
-	}
-
-	for (i=0;i<cnt;i++) {
-		/*alloc mem from DMA zone*/
-		/*input as request mem size */
-		paddr[i] = size;
-		if ( ioctl(fd_fb_alloc, FBIO_ALLOC, &(paddr[i])) < 0) {
-			printf("Unable alloc mem from /dev/fb0\n");
-			close(fd_fb_alloc);
-			if ((fd_fb_alloc = open("/dev/fb1", O_RDWR, 0)) < 0) {
-				printf("Unable to open /dev/fb1\n");
-				if ((fd_fb_alloc = open("/dev/fb2", O_RDWR, 0)) < 0) {
-					printf("Unable to open /dev/fb2\n");
-					ret = -1;
-					goto done;
-				} else if ( ioctl(fd_fb_alloc, FBIO_ALLOC, &(paddr[i])) < 0) {
-					printf("Unable alloc mem from /dev/fb2\n");
-					ret = -1;
-					goto done;
-				}
-			} else if ( ioctl(fd_fb_alloc, FBIO_ALLOC, &(paddr[i])) < 0) {
-				printf("Unable alloc mem from /dev/fb1\n");
-				close(fd_fb_alloc);
-				if ((fd_fb_alloc = open("/dev/fb2", O_RDWR, 0)) < 0) {
-					printf("Unable to open /dev/fb2\n");
-					ret = -1;
-					goto done;
-				} else if ( ioctl(fd_fb_alloc, FBIO_ALLOC, &(paddr[i])) < 0) {
-					printf("Unable alloc mem from /dev/fb2\n");
-					ret = -1;
-					goto done;
-				}
-			}
-		}
-
-		vaddr[i] = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED,
-				fd_fb_alloc, paddr[i]);
-		if (vaddr[i] == MAP_FAILED) {
-			printf("mmap failed!\n");
-			ret = -1;
-			goto done;
-		}
-	}
-done:
-	return ret;
-}
-
-void dma_memory_free(int size, int cnt, dma_addr_t paddr[], void * vaddr[])
-{
-	int i;
-
-	for (i=0;i<cnt;i++) {
-		if (vaddr[i])
-			munmap(vaddr[i], size);
-		if (paddr[i])
-			ioctl(fd_fb_alloc, FBIO_FREE, &(paddr[i]));
-	}
-}
-
-int copy_test(ipu_test_handle_t * test_handle)
-{
-	int ret = 0, fd_fb = 0, screen_size;
-	struct fb_var_screeninfo fb_var;
-	struct fb_fix_screeninfo fb_fix;
-	void * fake_fb[1];
-	int fake_fb_paddr[1], done_cnt = 0;
-
-	if ((fd_fb = open("/dev/fb0", O_RDWR, 0)) < 0) {
-		printf("Unable to open /dev/fb0\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-		printf("Get FB var info failed!\n");
-		ret = -1;
-		goto done;
-	}
-	if ( ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix) < 0) {
-		printf("Get FB fix info failed!\n");
-		ret = -1;
-		goto done;
-	}
-	screen_size = fb_var.yres * fb_fix.line_length;
-	ret = dma_memory_alloc(screen_size, 1, fake_fb_paddr, fake_fb);
-	if ( ret < 0) {
-		printf("dma_memory_alloc failed\n");
-		goto done;
-	}
-
-	test_handle->mode = OP_NORMAL_MODE | TASK_PP_MODE;
-	test_handle->fcount = 10;
-	test_handle->input.width = fb_var.xres;
-	test_handle->input.height = fb_var.yres;
-	test_handle->output.width = fb_var.xres;
-	test_handle->output.height = fb_var.yres;
-	if (fb_var.bits_per_pixel == 24) {
-		test_handle->output.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-		test_handle->input.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-	} else {
-		test_handle->output.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-		test_handle->input.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-	}
-	test_handle->input.user_def_paddr[0] = fake_fb_paddr[0];
-	test_handle->output.user_def_paddr[0] = fb_fix.smem_start;
-
-	ret = mxc_ipu_lib_task_init(&(test_handle->input), NULL, &(test_handle->output),
-				test_handle->mode, test_handle->ipu_handle);
-	if (ret < 0) {
-		printf("mxc_ipu_lib_task_init failed!\n");
-		goto err;
-	}
-
-	while((done_cnt < test_handle->fcount) && (ctrl_c_rev == 0)) {
-		static int j = 0;
-		if ((j % 3) == 0)
-			memset(fake_fb[0], 0, screen_size);
-		if ((j % 3) == 1)
-			memset(fake_fb[0], 0x80, screen_size);
-		if ((j % 3) == 2)
-			memset(fake_fb[0], 0xff, screen_size);
-		j++;
-		if (mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, 0, 0, 0, NULL, NULL) < 0)
-			break;
-		done_cnt++;
-		sleep(1);
-	}
-
-	mxc_ipu_lib_task_uninit(test_handle->ipu_handle);
-
-err:
-	dma_memory_free(screen_size, 1, fake_fb_paddr, fake_fb);
-done:
-	return ret;
-}
-
-int color_bar(int overlay, ipu_test_handle_t * test_handle)
-{
-	int ret = 0, fd_fb = 0, size = 0, i, k = 0, done_cnt = 0, fcount = 0;
-	void * buf[BUF_CNT] = {0}, * fb[3];
-	void * ov_fake_fb = 0, * ov_alpha_fake_fb = 0;
-	int ov_fake_fb_paddr = 0, ov_alpha_fake_fb_paddr = 0;
-	int paddr[BUF_CNT] = {0};
-	struct fb_var_screeninfo fb_var;
-	struct fb_fix_screeninfo fb_fix;
-	struct mxcfb_gbl_alpha g_alpha;
-	unsigned int system_rev = 0, ipu_version;
-	ipu_lib_overlay_param_t ov;
-	int screen_size, ov_fake_fb_size = 0, ov_alpha_fake_fb_size = 0;
-
-	get_system_rev(&system_rev);
-	if (((system_rev & 0xff000) == 0x37000) ||
-		(((system_rev & 0xff000) == 0x51000)) ||
-		(((system_rev & 0xff000) == 0x53000)))
-		ipu_version = 3;
-	else
-		ipu_version = 1;
-
-	if (ipu_version == 1) {
-		printf("ipuv1 can not support dispaly 2 output together!\n");
-		printf("because ipuv1 ENC channel can not be linked to disp channel!\n");
-		ret = -1;
-		goto done;
-	}
-	if ((ipu_version == 1) && overlay) {
-		printf("currently ipuv1 would not support overlay!\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ((fd_fb = open("/dev/fb0", O_RDWR, 0)) < 0) {
-		printf("Unable to open /dev/fb0\n");
-		ret = -1;
-		goto done;
-	}
-
-	g_alpha.alpha = 128;
-	g_alpha.enable = 1;
-	if (ioctl(fd_fb, MXCFB_SET_GBL_ALPHA, &g_alpha) < 0) {
-		printf("Set global alpha failed\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-		printf("Get FB var info failed!\n");
-		ret = -1;
-		goto done;
-	}
-	if ( ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix) < 0) {
-		printf("Get FB fix info failed!\n");
-		ret = -1;
-		goto done;
-	}
-
-	if(fb_var.yres_virtual != 3*fb_var.yres)
-	{
-		fb_var.yres_virtual = 3*fb_var.yres;
-		if ( ioctl(fd_fb, FBIOPUT_VSCREENINFO, &fb_var) < 0) {
-			printf("Get FB var info failed!\n");
-			ret = -1;
-			goto done;
-		}
-	}
-
-	screen_size = fb_var.yres * fb_fix.line_length;
-	fb[0] = mmap(NULL, 3 * screen_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-			fd_fb, 0);
-	if (fb[0] == MAP_FAILED) {
-		printf("fb buf0 mmap failed, errno %d!\n", errno);
-		ret = -1;
-		goto done;
-	}
-	/* ipu use fb base+screen_size as buf0 */
-	fb[1] = (void *)((char *)fb[0]);
-	fb[0] = (void *)((char *)fb[1] + screen_size);
-	fb[2] = (void *)((char *)fb[1] + 2*screen_size);
-
-	/* use I420 input format as fix*/
-	test_handle->mode = OP_STREAM_MODE;
-	test_handle->fcount = fcount = 511;
-	test_handle->input.width = 320;
-	test_handle->input.height = 240;
-	test_handle->input.fmt = v4l2_fourcc('I', '4', '2', '0');
-	if (fb_var.bits_per_pixel == 24)
-		test_handle->output.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-	else
-		test_handle->output.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-	test_handle->output.show_to_fb = 1;
-	test_handle->output.fb_disp.fb_num = 0;
-	/* ipuv1 only support display on PP & VF task mode */
-	if (ipu_version == 1)
-		test_handle->mode |= TASK_PP_MODE;
-	test_handle->output.rot = 3;
-	if (overlay){
-		/* overlay case -- fake fb+overlay show to fb0*/
-		ov.width = fb_var.xres;
-		ov.height = fb_var.yres;
-		if (fb_var.bits_per_pixel == 24)
-			ov.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-		else
-			ov.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-
-		if (overlay == IC_LOC_SEP_ALP_OV) {
-			ov.ov_crop_win.pos.x = fb_var.xres/4;
-			ov.ov_crop_win.pos.y = fb_var.yres/4;
-			ov.ov_crop_win.win_w = fb_var.xres/2;
-			ov.ov_crop_win.win_h = fb_var.yres/2;
-			ov.local_alpha_en = 1;
-			ov.global_alpha_en = 0;
-			ov_fake_fb_size = screen_size;
-			ov_alpha_fake_fb_size = ov.width * ov.height;
-
-			test_handle->output.width = fb_var.xres/2;
-			test_handle->output.height = fb_var.yres/2;
-			test_handle->output.fb_disp.pos.x = fb_var.xres/4;
-			test_handle->output.fb_disp.pos.y = fb_var.yres/4;
-		} else if (overlay == IC_GLB_ALP_OV) {
-			ov.ov_crop_win.pos.x = fb_var.xres/4;
-			ov.ov_crop_win.pos.y = fb_var.yres/4;
-			ov.ov_crop_win.win_w = fb_var.xres/2;
-			ov.ov_crop_win.win_h = fb_var.yres/2;
-			ov.local_alpha_en = 0;
-			ov.global_alpha_en = 1;
-			ov_fake_fb_size = screen_size;
-
-			test_handle->output.width = fb_var.xres/2;
-			test_handle->output.height = fb_var.yres/2;
-			test_handle->output.fb_disp.pos.x = fb_var.xres/4;
-			test_handle->output.fb_disp.pos.y = fb_var.yres/4;
-		} else if (overlay == IC_LOC_PIX_ALP_OV) {
-			ov.fmt = v4l2_fourcc('R', 'G', 'B', 'A');
-			ov.ov_crop_win.pos.x = 0;
-			ov.ov_crop_win.pos.y = 0;
-			ov.ov_crop_win.win_w = fb_var.xres;
-			ov.ov_crop_win.win_h = fb_var.yres;
-			ov.global_alpha_en = 0;
-			ov.local_alpha_en = 0;
-			ov_fake_fb_size = ov.width * ov.height * 4;
-
-			/*
-			 * RGB32A is not the pixel format of FB0(RGB565),
-			 * so we cannot do memory copy from graphic plane to
-			 * FB0. We choose to set graphic plane and video plane
-			 * to be the same resolution with FB0.
-			 */
-			test_handle->output.width = fb_var.xres;
-			test_handle->output.height = fb_var.yres;
-			test_handle->output.fb_disp.pos.x = 0;
-			test_handle->output.fb_disp.pos.y = 0;
-		}
-		ov.key_color_en = 0;
-		ov.alpha = 128;
-		ov.key_color = 0x808080;
-	} else {
-		/* one output case -- full screen */
-		test_handle->output.width = fb_var.xres;
-		test_handle->output.height = fb_var.yres;
-	}
-
-	/*allocate dma buffers from fb dev*/
-	size = test_handle->input.width * test_handle->input.height * 3/2;
-	ret = dma_memory_alloc(size, BUF_CNT, paddr, buf);
-	if ( ret < 0) {
-		printf("dma_memory_alloc failed\n");
-		goto done;
-	}
-
-	if (overlay) {
-		ov_fake_fb_paddr = ov_fake_fb_size;
-		if ( ioctl(fd_fb, FBIO_ALLOC, &(ov_fake_fb_paddr)) < 0) {
-			printf("Unable alloc mem from /dev/fb0\n");
-			ret = -1;
-			goto done;
-		}
-		ov_fake_fb = mmap(NULL, ov_fake_fb_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-				fd_fb, ov_fake_fb_paddr);
-		if (ov_fake_fb == MAP_FAILED) {
-			printf("mmap failed!\n");
-			ret = -1;
-			goto done;
-		}
-		ov.user_def_paddr[0] = ov_fake_fb_paddr;
-		ov.user_def_paddr[1] = ov.user_def_paddr[0];
-
-		if (overlay == IC_LOC_SEP_ALP_OV) {
-			ov_alpha_fake_fb_paddr = ov_alpha_fake_fb_size;
-			if (ioctl(fd_fb, FBIO_ALLOC,
-				  &(ov_alpha_fake_fb_paddr)) < 0) {
-				printf("Unable alloc mem from /dev/fb0\n");
-				ret = -1;
-				goto done;
-			}
-			ov_alpha_fake_fb = mmap(NULL, ov_alpha_fake_fb_size,
-						PROT_READ | PROT_WRITE,
-						MAP_SHARED,
-						fd_fb,
-						ov_alpha_fake_fb_paddr);
-			if (ov_alpha_fake_fb == MAP_FAILED) {
-				printf("mmap failed!\n");
-				ret = -1;
-				goto done;
-			}
-			ov.user_def_alpha_paddr[0] = ov_alpha_fake_fb_paddr;
-			ov.user_def_alpha_paddr[1] = ov_alpha_fake_fb_paddr;
-		}
-	}
-
-	/* we are using stream mode and we set dma addr by ourselves*/
-	test_handle->input.user_def_paddr[0] = paddr[0];
-	test_handle->input.user_def_paddr[1] = paddr[1];
-	gen_fill_pattern(buf[0], test_handle->input.width, test_handle->input.height);
-	gen_fill_pattern(buf[1], test_handle->input.width, test_handle->input.height);
-	done_cnt = i = 1;
-
-	if (overlay)
-		ret = mxc_ipu_lib_task_init(&(test_handle->input), &ov, &(test_handle->output),
-				test_handle->mode, test_handle->ipu_handle);
-	else
-		ret = mxc_ipu_lib_task_init(&(test_handle->input), NULL, &(test_handle->output),
-				test_handle->mode, test_handle->ipu_handle);
-	if (ret < 0) {
-		printf("mxc_ipu_lib_task_init failed!\n");
-		goto done;
-	}
-
-	while((done_cnt < test_handle->fcount) && (ctrl_c_rev == 0)) {
-		if (overlay) {
-			if (overlay == IC_GLB_ALP_OV) {
-				if (done_cnt % 50 == 0) {
-					static int j = 0;
-					if ((j % 3) == 0)
-						memset(ov_fake_fb, 0,
-						       ov_fake_fb_size);
-					if ((j % 3) == 1)
-						memset(ov_fake_fb, 0x80,
-						       ov_fake_fb_size);
-					if ((j % 3) == 2)
-						memset(ov_fake_fb, 0xff,
-						       ov_fake_fb_size);
-					j++;
-				}
-				/* fb show sequence should be 0->1->2->0 */
-				memcpy(fb[done_cnt%3], ov_fake_fb,
-				       ov_fake_fb_size);
-				if (mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, paddr[i], ov_fake_fb_paddr, 0, NULL, NULL) < 0)
-					break;
-			} else if (overlay == IC_LOC_PIX_ALP_OV) {
-				if (done_cnt == 1) {
-					/* RGBA32 red */
-					/* 2 planes */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 0)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x80, 1);
-					}
-				} else if (done_cnt == 1*fcount/9) {
-					/* video plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-					}
-				} else if (done_cnt == 2*fcount/9) {
-					/* graphic plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-					}
-				} else if (done_cnt == fcount/3) {
-					/* RGBA32 green */
-					/* 2 planes */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 1)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x80, 1);
-					}
-				} else if (done_cnt == 4*fcount/9) {
-					/* video plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-					}
-				} else if (done_cnt == 5*fcount/9) {
-					/* graphic plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-					}
-				} else if (done_cnt == 2*fcount/3) {
-					/* RGBA32 blue */
-					/* 2 planes */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 2)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x80, 1);
-					}
-				} else if (done_cnt == 7*fcount/9) {
-					/* video plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-					}
-				} else if (done_cnt == 8*fcount/9) {
-					/* graphic plane */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 4 == 3)
-							memset(ov_fake_fb + k,
-							       0xFF, 1);
-					}
-				}
-				if (mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, paddr[i], ov_fake_fb_paddr, 0, NULL, NULL) < 0)
-					break;
-			} else if (overlay == IC_LOC_SEP_ALP_OV) {
-				if (done_cnt == 1) {
-					/* RGB565 red */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 2 == 1)
-							memset(ov_fake_fb + k,
-							       0xF8, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-					}
-					/* 2 planes */
-					memset(ov_alpha_fake_fb, 0x80,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 1*fcount/9) {
-					/* video plane */
-					memset(ov_alpha_fake_fb, 0x00,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 2*fcount/9) {
-					/* graphic plane */
-					memset(ov_alpha_fake_fb, 0xFF,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == fcount/3) {
-					/* RGB565 green */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 2 == 1)
-							memset(ov_fake_fb + k,
-							       0x07, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0xE0, 1);
-					}
-					/* 2 planes */
-					memset(ov_alpha_fake_fb, 0x80,
-					       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 4*fcount/9) {
-					/* video plane */
-					memset(ov_alpha_fake_fb, 0x00,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 5*fcount/9) {
-					/* graphic plane */
-					memset(ov_alpha_fake_fb, 0xFF,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 2*fcount/3) {
-					/* RGB565 blue */
-					for (k = 0; k < ov_fake_fb_size; k++) {
-						if (k % 2 == 0)
-							memset(ov_fake_fb + k,
-							       0x1F, 1);
-						else
-							memset(ov_fake_fb + k,
-							       0x00, 1);
-					}
-					/* 2 planes */
-					memset(ov_alpha_fake_fb, 0x80,
-					       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 7*fcount/9) {
-					/* video plane */
-					memset(ov_alpha_fake_fb, 0x00,
-				      	       ov_alpha_fake_fb_size);
-				} else if (done_cnt == 8*fcount/9) {
-					/* graphic plane */
-					memset(ov_alpha_fake_fb, 0xFF,
-				      	       ov_alpha_fake_fb_size);
-				}
-				memcpy(fb[done_cnt%3], ov_fake_fb,
-				       ov_fake_fb_size);
-				if (mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, paddr[i], ov_fake_fb_paddr, ov_alpha_fake_fb_paddr, NULL, NULL) < 0)
-					break;
-			}
-		} else {
-			if (mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, paddr[i], 0, 0, NULL, NULL) < 0)
-				break;
-		}
-
-		i++;
-		if (i == BUF_CNT)
-			i = 0;
-		done_cnt++;
-		gen_fill_pattern(buf[i], test_handle->input.width, test_handle->input.height);
-		/* make the input framerate < 60Hz*/
-		usleep(15000);
-	}
-
-	mxc_ipu_lib_task_uninit(test_handle->ipu_handle);
-
-done:
-	dma_memory_free(size, BUF_CNT, paddr, buf);
-	if (fd_fb)
-		close(fd_fb);
-
-	return ret;
-}
-
-int update_block_pos(int *x, int *y, int angle_start, int block_width,
-	int limit_w, int limit_h, int fd_fb)
-{
-	static int angle = 0;
-	static double steps = 0.0;
-	struct mxcfb_pos pos;
-	int need_change = 0;
-	double ra;
-	double nx, ny;
-
-	if (angle == 0)
-		angle = angle_start;
-	steps += 0.1;
-	ra = ((double)angle)*3.1415926/180.0;
-	nx = *x + steps*cos(ra);
-	ny = *y + steps*sin(ra);
-	if (nx < 0) {
-		if (ny < *y) /* x+, y-*/
-			angle = 360 - angle_start;
-		else /* x+, y+ */
-			angle = angle_start;
-		need_change = 1;
-	} else if (nx > (limit_w - block_width)) {
-		if (ny < *y) /* x-, y-*/
-			angle = 180 + angle_start;
-		else /* x-, y+ */
-			angle = 180 - angle_start;
-		need_change = 1;
-	} else if (ny < 0) {
-		if (nx < *x) /* x-, y+*/
-			angle = 180 - angle_start;
-		else /* x+, y+ */
-			angle = angle_start;
-		need_change = 1;
-	} else if (ny > (limit_h - block_width)) {
-		if (nx < *x) /* x-, y-*/
-			angle = 180 + angle_start;
-		else /* x+, y- */
-			angle = 360 - angle_start;
-		need_change = 1;
-	}
-
-	if (need_change) {
-		steps = 0.0;
-		ra = ((double)angle)*3.1415926/180.0;
-		nx = *x;
-		ny = *y;
-		//printf("change angle to %d\n", angle);
-		//printf("pos %d, %d\n", *x, *y);
-	}
-
-	pos.x = nx;
-	pos.y = ny;
-	ioctl(fd_fb, MXCFB_SET_OVERLAY_POS, &pos);
-	*x = nx;
-	*y = ny;
-
-	return need_change;
-}
-
-/*
- * This call-back function provide one method to update
- * framebuffer by pan_display.
- */
-void hop_block_output_cb(void * arg, int index)
-{
-	int fd_fb = *((int *)arg);
-	struct fb_var_screeninfo fb_var;
-
-	ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var);
-	/* for buf index 0, its phyaddr is fb buf1*/
-	/* for buf index 1, its phyaddr is fb buf0*/
-	/* for buf index 2, its phyaddr is fb buf2*/
-	if (index == 0)
-		fb_var.yoffset = fb_var.yres;
-	else if (index == 1)
-		fb_var.yoffset = 0;
-	else
-		fb_var.yoffset = 2 * fb_var.yres;
-
-	ioctl(fd_fb, FBIOPAN_DISPLAY, &fb_var);
-}
-
-int hop_block(ipu_test_handle_t * test_handle)
-{
-	int ret = 0, x = 0, y = 0, fd_fb = 0, next_update_idx = 0;
-	int lcd_w, lcd_h;
-	int blank;
-	char random_color;
-	int start_angle, screen_size;
-	void * buf;
-	struct mxcfb_pos pos;
-	struct fb_var_screeninfo fb_var;
-	struct fb_fix_screeninfo fb_fix;
-
-	/* clear background fb, get the lcd frame info */
-	if ((fd_fb = open("/dev/fb0", O_RDWR, 0)) < 0) {
-		printf("Unable to open /dev/fb0\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix) < 0) {
-		printf("Get FB fix info failed!\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-		printf("Get FB var info failed!\n");
-		ret = -1;
-		goto done;
-	}
-	lcd_w = fb_var.xres;
-	lcd_h = fb_var.yres;
-	screen_size = fb_var.yres_virtual * fb_fix.line_length;
-
-	buf = mmap(NULL, screen_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-			fd_fb, 0);
-	if (buf == MAP_FAILED) {
-		printf("mmap failed!\n");
-		ret = -1;
-		goto done;
-	}
-	memset(buf, 0, screen_size);
-	close(fd_fb);
-
-	/* display hop block to overlay */
-	if (foreground_fb() == 2) {
-		if ((fd_fb = open("/dev/fb2", O_RDWR, 0)) < 0) {
-			printf("Unable to open /dev/fb2\n");
-			ret = -1;
-			goto done;
-		}
-	} else {
-		if ((fd_fb = open("/dev/fb1", O_RDWR, 0)) < 0) {
-			printf("Unable to open /dev/fb1\n");
-			ret = -1;
-			goto done;
-		}
-	}
-
-	fb_var.xres = test_handle->block_width
-			- test_handle->block_width%8;
-	fb_var.xres_virtual = fb_var.xres;
-	fb_var.yres = test_handle->block_width;
-	fb_var.yres_virtual = fb_var.yres * 3;
-	if ( ioctl(fd_fb, FBIOPUT_VSCREENINFO, &fb_var) < 0) {
-		printf("Set FB var info failed!\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix) < 0) {
-		printf("Get FB fix info failed!\n");
-		ret = -1;
-		goto done;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-		printf("Get FB var info failed!\n");
-		ret = -1;
-		goto done;
-	}
-	blank = FB_BLANK_UNBLANK;
-	if ( ioctl(fd_fb, FBIOBLANK, blank) < 0) {
-		printf("UNBLANK FB failed!\n");
-		ret = -1;
-		goto done;
-	}
-
-	test_handle->mode = OP_STREAM_MODE;
-	test_handle->input.width = 400;
-	test_handle->input.height = 400;
-	test_handle->input.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-	test_handle->output.width = test_handle->block_width
-					- test_handle->block_width%8;
-	test_handle->output.height = test_handle->block_width;
-	if (fb_var.bits_per_pixel == 24)
-		test_handle->output.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-	else
-		test_handle->output.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-	test_handle->output.show_to_fb = 0;
-	screen_size = fb_var.yres * fb_fix.line_length;
-	test_handle->output.user_def_paddr[0] = fb_fix.smem_start + screen_size;
-	test_handle->output.user_def_paddr[1] = fb_fix.smem_start;
-	test_handle->output.user_def_paddr[2] = fb_fix.smem_start + 2*screen_size;
-
-	ret = mxc_ipu_lib_task_init(&(test_handle->input), NULL, &(test_handle->output),
-			test_handle->mode, test_handle->ipu_handle);
-	if (ret < 0) {
-		printf("mxc_ipu_lib_task_init failed!\n");
-		goto done;
-	}
-
-	srand((unsigned int)time(0));
-	random_color = (char)(rand()%255);
-	/* for stream mode, fill two input frame to prepare */
-	memset(test_handle->ipu_handle->inbuf_start[0], random_color, test_handle->ipu_handle->ifr_size);
-	memset(test_handle->ipu_handle->inbuf_start[1], random_color, test_handle->ipu_handle->ifr_size);
-	start_angle = rand()%90;
-	if (start_angle == 90) start_angle = 89;
-	if (start_angle == 0) start_angle = 1;
-	printf("Start angle is %d\n", start_angle);
-
-	/* start first frame */
-	if((next_update_idx = mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, 0, 0, 0, hop_block_output_cb, &fd_fb)) < 0)
-		goto err;
-
-	while(ctrl_c_rev == 0) {
-		usleep(100000);
-		/* update frame if only hop block hit the LCD frame */
-		if(update_block_pos(&x, &y, start_angle, test_handle->block_width, lcd_w, lcd_h, fd_fb)) {
-			random_color = (char)(rand()%255);
-			memset(test_handle->ipu_handle->inbuf_start[next_update_idx], random_color,
-					test_handle->ipu_handle->ifr_size);
-			if((next_update_idx = mxc_ipu_lib_task_buf_update(test_handle->ipu_handle, 0, 0, 0, hop_block_output_cb, &fd_fb)) < 0)
-				break;
-		}
-	}
-
-	/* ipu need reset position to 0,0 */
-	pos.x = 0;
-	pos.y = 0;
-	ioctl(fd_fb, MXCFB_SET_OVERLAY_POS, &pos);
-
-	blank = FB_BLANK_POWERDOWN;
-	if ( ioctl(fd_fb, FBIOBLANK, blank) < 0) {
-		printf("POWERDOWN FB failed!\n");
-		ret = -1;
-		goto done;
-	}
-err:
-	mxc_ipu_lib_task_uninit(test_handle->ipu_handle);
-
-done:
-	if (fd_fb)
-		close(fd_fb);
-	return ret;
-}
-
-void * thread_func_color_bar(void *arg)
-{
-	int ret;
-	ipu_test_handle_t test_handle;
-	ipu_lib_handle_t ipu_handle;
-
-	memset(&ipu_handle, 0, sizeof(ipu_lib_handle_t));
-	memset(&test_handle, 0, sizeof(ipu_test_handle_t));
-
-	test_handle.ipu_handle = &ipu_handle;
-	ret = color_bar(NO_OV, &test_handle);
-
-	pthread_exit((void*)ret);
-
-	return NULL;
-}
-
-void * thread_func_hop_block(void *arg)
-{
-	int ret;
-
-	ret = hop_block((ipu_test_handle_t *)arg);
-
-	pthread_exit((void*)ret);
-
-	return NULL;
-}
-
-#ifndef BUILD_FOR_ANDROID
-#define PRIMARYFBDEV	"/dev/fb0"
-#define OVERLAYFBDEV	"/dev/fb2"
-#define	BUFCNT_1ST	1
-#define BUFCNT_2ND	3
-#define BUFCNT_3TH	5
-#define FRM_CNT		511
-/* variables for semaphore */
-sem_t *         semIDUnit;
-const char*     semNameUnit="IPU_SL_unit_test";
-
-/* Vittual address of shared memory in current process */
-int * vshmUnitTest =NULL;
-
-int getFBInfor(int * pfbWidth, int * pfbHeight, int * pfbBPP )
-{
-	int ret, fd_fb;
-	struct fb_var_screeninfo fb_var;
-	struct fb_fix_screeninfo fb_fix;
-
-	ret = 0;
-	/* get fb info */
-	if ((fd_fb = open(PRIMARYFBDEV, O_RDWR, 0)) < 0) {
-		printf("Unable to open /dev/fb0\n");
-		ret = -1;
-		goto getFBInfor_err1;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_FSCREENINFO, &fb_fix) < 0) {
-		printf("Get FB fix info failed!\n");
-		ret = -1;
-		goto getFBInfor_err2;
-	}
-
-	if ( ioctl(fd_fb, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-		printf("Get FB var info failed!\n");
-		ret = -1;
-		goto getFBInfor_err2;
-	}
-	*pfbWidth	= fb_var.xres;
-	*pfbHeight	= fb_var.yres;
-	*pfbBPP		= fb_var.bits_per_pixel;
-getFBInfor_err2:
-	close(fd_fb);
-getFBInfor_err1:
-	return ret;
-}
-void * first_layer_thread_func(void *arg)
-{
-	int i, ret;
-	ScreenLayer first_layer;
-	int fb_width, fb_height, fb_bpp;
-	int op_type = NO_OV;
-
-	if(arg)
-		op_type = *((int *)arg);
-
-	ret = getFBInfor(&fb_width, &fb_height, &fb_bpp);
-	if(ret == -1)
-	{
-		printf("Can not get fb information. \n");
-		goto err;
-	}
-
-	memset(&first_layer, 0, sizeof(ScreenLayer));
-	if (fb_bpp == 24)
-		first_layer.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-	else
-		first_layer.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-
-	if (op_type & COPY_TV)
-		first_layer.fmt = v4l2_fourcc('U', 'Y', 'V', 'Y');
-
-	memcpy(first_layer.fbdev, PRIMARYFBDEV, strlen(PRIMARYFBDEV)+1);
-	first_layer.pPrimary = NULL;
-	if ((ret = CreateScreenLayer(&first_layer, BUFCNT_1ST))
-		!= E_RET_SUCCESS) {
-		printf("CreateScreenLayer first layer err %d\n", ret);
-		goto err;
-	}
-
-	i = 0;
-	while (i < 50 && !ctrl_c_rev) {
-		if (i % 3 == 0)
-			memset(first_layer.bufVaddr[0], 0x0, first_layer.bufSize);
-		else if (i % 3 == 1)
-			memset(first_layer.bufVaddr[0], 0x80, first_layer.bufSize);
-		else if (i % 3 == 2)
-			memset(first_layer.bufVaddr[0], 0xff, first_layer.bufSize);
-		i++;
-		if (op_type & DP_LOC_SEP_ALP_OV) {
-			if ((ret = UpdateScreenLayer(&first_layer)) != E_RET_SUCCESS) {
-				printf("UpdateScreenLayer err %d\n",ret);
-				goto err1;
-			}
-		} else {
-			sem_wait(semIDUnit);
-			if (!vshmUnitTest[1] && !vshmUnitTest[2]) {
-				if ((ret = UpdateScreenLayer(&first_layer)) != E_RET_SUCCESS) {
-					printf("UpdateScreenLayer err %d\n",ret);
-					goto err1;
-				}
-			}
-			sem_post(semIDUnit);
-		}
-		sleep(2);
-	}
-err1:
-	while(vshmUnitTest[1] || vshmUnitTest[2])sleep(1);
-	DestoryScreenLayer(&first_layer);
-err:
-	printf("First layer has been destroyed! \n");
-	return NULL;
-}
-
-void * second_layer_thread_func(void *arg)
-{
-	ScreenLayer second_layer;
-	LoadParam param;
-	LoadParam sec_param;
-	dma_addr_t paddr_2nd[BUFCNT_2ND];
-	void * buf_2nd[BUFCNT_2ND];
-	MethodAlphaData alpha_data;
-	MethodColorKeyData colorkey_data;
-	int buf_size, alpha_buf_size, x, y, i, ret, op_type = *((int *)arg);
-	int SL_width, SL_height;
-	char alpha_val;
-	int fb_width, fb_height, fb_bpp;
-	int show_time = 0;
-	int load_time = 0;
-	int update_time = 0;
-	int bufcnt = BUFCNT_2ND;
-
-	ret = getFBInfor(&fb_width, &fb_height, &fb_bpp);
-	if(ret == -1)
-	{
-		printf("Can not get fb information. \n");
-		goto err;
-	}
-
-	memset(&second_layer, 0, sizeof(ScreenLayer));
-
-	i=100;
-	while(i)
-	{
-		i--;
-		second_layer.pPrimary = GetPrimarySLHandle(PRIMARYFBDEV);
-		if(second_layer.pPrimary == NULL)
-			usleep(200*1000);
-		else
-			break;
-	}
-	if(i==0)
-	{
-		printf("Should create primary layer firstly. \n");
-		ret = -1;
-		goto err;
-	}
-
-	alpha_buf_size = 0;
-	memset(&alpha_data, 0, sizeof(MethodAlphaData));
-	memset(&colorkey_data, 0, sizeof(MethodColorKeyData));
-	second_layer.screenRect.left = 0;
-	second_layer.screenRect.top = 0;
-	second_layer.screenRect.right = fb_width;
-	second_layer.screenRect.bottom = fb_height;
-	SL_width = second_layer.screenRect.right - second_layer.screenRect.left;
-	SL_height = second_layer.screenRect.bottom - second_layer.screenRect.top;
-	if (op_type & IC_LOC_PIX_ALP_OV)
-		second_layer.fmt = v4l2_fourcc('R', 'G', 'B', 'A');
-	else if (op_type & COPY_TV) /* for better performance */
-		second_layer.fmt = v4l2_fourcc('U', 'Y', 'V', 'Y');
-	else
-		second_layer.fmt = v4l2_fourcc('B', 'G', 'R', '3');
-	if (op_type & IC_LOC_SEP_ALP_OV)
-		second_layer.supportSepLocalAlpha = 1;
-	if ((ret = CreateScreenLayer(&second_layer, bufcnt))
-		!= E_RET_SUCCESS) {
-		printf("CreateScreenLayer second layer err %d\n", ret);
-		goto err;
-	}
-	/* set alpha and key color */
-	if (op_type & IC_GLB_ALP_OV) {
-		alpha_data.globalAlphaEnable = 1;
-		alpha_data.alpha = 255;
-	} else if (op_type & IC_LOC_SEP_ALP_OV)
-		alpha_data.sepLocalAlphaEnable = 1;
-	colorkey_data.enable = 0;
-	colorkey_data.keyColor = 0;
-	if ((ret = SetScreenLayer(&second_layer, E_SET_ALPHA, &alpha_data))
-		!= E_RET_SUCCESS) {
-		printf("SetScreenLayer E_SET_ALPHA for second layer err %d\n", ret);
-		goto err1;
-	}
-	if ((ret = SetScreenLayer(&second_layer, E_SET_COLORKEY, &colorkey_data))
-		!= E_RET_SUCCESS) {
-		printf("SetScreenLayer E_SET_COLORKEY for second layer err %d\n", ret);
-		goto err1;
-	}
-
-	if (op_type & COPY_TV) {
-		MethodTvoutData tvout;
-		tvout.tvMode = TVOUT_NTSC;
-		tvout.lcd2tvRotation = 0;
-		if ((ret = SetScreenLayer(&second_layer, E_COPY_TVOUT, &tvout))
-				!= E_RET_SUCCESS) {
-			printf("SetScreenLayer E_ENABLE_TVTOU for second layer err %d\n", ret);
-			goto err1;
-		}
-	}
-
-	param.srcWidth = 320;
-	param.srcHeight = 240;
-	param.srcFmt = v4l2_fourcc('I', '4', '2', '0');
-	param.srcRect.left = 0;
-	param.srcRect.top = 0;
-	param.srcRect.right = 320;
-	param.srcRect.bottom = 240;
-	param.destRect.left = 0;
-	param.destRect.top = 0;
-	param.destRect.right = second_layer.screenRect.right - second_layer.screenRect.left;
-	param.destRect.bottom = second_layer.screenRect.bottom - second_layer.screenRect.top;
-	param.destRot = 0;
-
-	/* just add third layer to this screenlayer to show the performance*/
-	if (op_type & COPY_TV){
-		sec_param.srcWidth = 320;
-		sec_param.srcHeight = 240;
-		sec_param.srcFmt = v4l2_fourcc('I', '4', '2', '0');
-		sec_param.srcRect.left = 0;
-		sec_param.srcRect.top = 0;
-		sec_param.srcRect.right = 320;
-		sec_param.srcRect.bottom = 240;
-		sec_param.destRect.left = (second_layer.screenRect.right - second_layer.screenRect.left)/2;
-		sec_param.destRect.top = 0;
-		sec_param.destRect.right = second_layer.screenRect.right - second_layer.screenRect.left;
-		sec_param.destRect.bottom = (second_layer.screenRect.bottom - second_layer.screenRect.top)/2;
-		sec_param.destRot = 0;
-	}
-
-	buf_size = param.srcWidth * param.srcHeight * 3/2;
-	if (op_type & IC_LOC_SEP_ALP_OV)
-		alpha_buf_size = SL_width * SL_height;
-	ret = dma_memory_alloc(buf_size, bufcnt, paddr_2nd, buf_2nd);
-	if ( ret < 0) {
-		printf("dma_memory_alloc failed\n");
-		goto err1;
-	}
-
-	for (i=0;i<FRM_CNT;i++) {
-		struct timeval frame_begin,frame_end;
-		struct timeval load_begin,load_end;
-		struct timeval update_begin,update_end;
-                int sec, usec;
-
-		if (ctrl_c_rev)
-			break;
-
-		param.srcPaddr = paddr_2nd[i%bufcnt];
-		gen_fill_pattern(buf_2nd[i%bufcnt], param.srcWidth, param.srcHeight);
-
-		gettimeofday(&frame_begin, NULL);
-		gettimeofday(&load_begin, NULL);
-
-		if ((ret = LoadScreenLayer(&second_layer, &param, i%bufcnt)) != E_RET_SUCCESS) {
-			printf("LoadScreenLayer err %d\n", ret);
-			goto err2;
-		}
-
-		if (op_type & COPY_TV){
-			sec_param.srcPaddr = paddr_2nd[i%bufcnt];
-			if ((ret = LoadScreenLayer(&second_layer, &sec_param, i%bufcnt)) != E_RET_SUCCESS) {
-				printf("LoadScreenLayer sec err %d\n", ret);
-				goto err2;
-			}
-		}
-		gettimeofday(&load_end, NULL);
-
-		sec = load_end.tv_sec - load_begin.tv_sec;
-		usec = load_end.tv_usec - load_begin.tv_usec;
-
-		if (usec < 0) {
-			sec--;
-			usec = usec + 1000000;
-		}
-		load_time += (sec * 1000000) + usec;
-
-		gettimeofday(&frame_end, NULL);
-
-                sec = frame_end.tv_sec - frame_begin.tv_sec;
-                usec = frame_end.tv_usec - frame_begin.tv_usec;
-
-                if (usec < 0) {
-                        sec--;
-                        usec = usec + 1000000;
-                }
-                show_time += (sec * 1000000) + usec;
-
-		/* Fill local alpha buffer */
-		if (op_type & IC_LOC_SEP_ALP_OV) {
-			gen_fill_alpha_in_separate_buffer(second_layer.bufAlphaVaddr[i%bufcnt], alpha_buf_size, 0x80);
-			if (i < FRM_CNT/3) {
-				alpha_val = 0x80;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						LoadAlphaPoint(&second_layer, x, y, alpha_val, i%bufcnt);
-			} else if (i < 2*FRM_CNT/3) {
-				alpha_val = 0x00;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						LoadAlphaPoint(&second_layer, x, y, alpha_val, i%bufcnt);
-			} else if (i < FRM_CNT) {
-				alpha_val = 0xFF;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						LoadAlphaPoint(&second_layer, x, y, alpha_val, i%bufcnt);
-			}
-		}
-		/* Change local alpha value in pixel */
-		else if (op_type & IC_LOC_PIX_ALP_OV) {
-			gen_fill_alpha_in_pixel(second_layer.bufVaddr[i%bufcnt], second_layer.fmt, second_layer.bufSize, 0x80);
-			if (i < FRM_CNT/3) {
-				alpha_val = 0x80;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(second_layer.bufVaddr[i%bufcnt], second_layer.fmt, SL_width, x, y, alpha_val);
-			} else if (i < 2*FRM_CNT/3) {
-				alpha_val = 0x00;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(second_layer.bufVaddr[i%bufcnt], second_layer.fmt, SL_width, x, y, alpha_val);
-			} else if (i < FRM_CNT) {
-				alpha_val = 0xFF;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(second_layer.bufVaddr[i%bufcnt], second_layer.fmt, SL_width, x, y, alpha_val);
-			}
-		}
-
-		gettimeofday(&frame_begin, NULL);
-		gettimeofday(&update_begin, NULL);
-
-		if ((ret = FlipScreenLayerBuf(&second_layer, i%bufcnt)) != E_RET_SUCCESS) {
-			printf("FlipScreenLayerBuf err %d\n", ret);
-			goto err2;
-		}
-
-		sem_wait(semIDUnit);
-		if (!vshmUnitTest[2]) {
-			if ((ret = UpdateScreenLayer(&second_layer)) != E_RET_SUCCESS) {
-				printf("UpdateScreenLayer err %d\n",ret);
-				goto err2;
-			}
-		}
-		sem_post(semIDUnit);
-
-		gettimeofday(&update_end, NULL);
-
-		sec = update_end.tv_sec - update_begin.tv_sec;
-		usec = update_end.tv_usec - update_begin.tv_usec;
-
-		if (usec < 0) {
-			sec--;
-			usec = usec + 1000000;
-		}
-		update_time += (sec * 1000000) + usec;
-
-		gettimeofday(&frame_end, NULL);
-
-                sec = frame_end.tv_sec - frame_begin.tv_sec;
-                usec = frame_end.tv_usec - frame_begin.tv_usec;
-
-                if (usec < 0) {
-                        sec--;
-                        usec = usec + 1000000;
-                }
-                show_time += (sec * 1000000) + usec;
-	}
-
-	printf("2nd layer load avg frame time %d us\n", load_time/i);
-	printf("2nd layer update avg frame time %d us\n", update_time/i);
-	printf("2nd layer avg frame time %d us\n", show_time/i);
-
-err2:
-	dma_memory_free(buf_size, bufcnt, paddr_2nd, buf_2nd);
-err1:
-	DestoryScreenLayer(&second_layer);
-err:
-	sem_wait(semIDUnit);
-	vshmUnitTest[1] = 0;
-	sem_post(semIDUnit);
-	printf("Second layer has been destroyed! \n");
-	return NULL;
-}
-
-void * third_layer_thread_func(void *arg)
-{
-	ScreenLayer third_layer;
-	LoadParam param;
-	dma_addr_t paddr_3th[BUFCNT_3TH];
-	void * buf_3th[BUFCNT_3TH];
-	MethodAlphaData alpha_data;
-	MethodColorKeyData colorkey_data;
-	int buf_size, alpha_buf_size, i, ret, x, y, op_type = *((int *)arg);
-	int SL_width, SL_height;
-	char alpha_val;
-	int fb_width, fb_height, fb_bpp;
-	int show_time = 0;
-
-	ret = getFBInfor(&fb_width, &fb_height, &fb_bpp);
-	if(ret == -1)
-	{
-		printf("Can not get fb information. \n");
-		goto err;
-	}
-
-	alpha_buf_size = 0;
-	memset(&third_layer, 0, sizeof(ScreenLayer));
-	memset(&alpha_data, 0, sizeof(MethodAlphaData));
-	memset(&colorkey_data, 0, sizeof(MethodColorKeyData));
-	third_layer.screenRect.left = fb_width*1/4;
-	third_layer.screenRect.top = fb_height*1/4;
-	third_layer.screenRect.right = fb_width*3/4;
-	third_layer.screenRect.bottom = fb_height*3/4;
-	SL_width = third_layer.screenRect.right - third_layer.screenRect.left;
-	SL_height = third_layer.screenRect.bottom - third_layer.screenRect.top;
-	if (op_type & IC_LOC_PIX_ALP_OV)
-		third_layer.fmt = v4l2_fourcc('R', 'G', 'B', 'A');
-	else
-		third_layer.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-	i=100;
-	while(i)
-	{
-		i--;
-		third_layer.pPrimary = GetPrimarySLHandle(PRIMARYFBDEV);
-		if(third_layer.pPrimary == NULL)
-			usleep(20*1000);
-		else
-			break;
-	}
-	if(i==0)
-		printf("Should create primary layer firstly. \n");
-	if (op_type & IC_LOC_SEP_ALP_OV)
-		third_layer.supportSepLocalAlpha = 1;
-	if ((ret = CreateScreenLayer(&third_layer, BUFCNT_3TH))
-		!= E_RET_SUCCESS) {
-		printf("CreateScreenLayer third layer err %d\n", ret);
-		goto err;
-	}
-	/* set alpha and key color */
-	if (op_type & IC_GLB_ALP_OV) {
-		alpha_data.globalAlphaEnable = 1;
-		alpha_data.alpha = 255;
-	} else if (op_type & IC_LOC_SEP_ALP_OV)
-		alpha_data.sepLocalAlphaEnable = 1;
-	colorkey_data.enable = 0;
-	colorkey_data.keyColor = 0;
-	if ((ret = SetScreenLayer(&third_layer, E_SET_ALPHA, &alpha_data))
-		!= E_RET_SUCCESS) {
-		printf("SetScreenLayer E_SET_ALPHA for third layer err %d\n", ret);
-		goto err1;
-	}
-	if ((ret = SetScreenLayer(&third_layer, E_SET_COLORKEY, &colorkey_data))
-		!= E_RET_SUCCESS) {
-		printf("SetScreenLayer E_SET_COLORKEY for third layer err %d\n", ret);
-		goto err1;
-	}
-
-	param.srcWidth = 320;
-	param.srcHeight = 240;
-	param.srcFmt = v4l2_fourcc('I', '4', '2', '0');
-	param.srcRect.left = 0;
-	param.srcRect.top = 0;
-	param.srcRect.right = 320;
-	param.srcRect.bottom = 240;
-	param.destRect.left = 0;
-	param.destRect.top = 0;
-	param.destRect.right = third_layer.screenRect.right - third_layer.screenRect.left;
-	param.destRect.bottom = third_layer.screenRect.bottom - third_layer.screenRect.top;
-	param.destRot = 0;
-	buf_size = param.srcWidth * param.srcHeight * 3/2;
-	if (op_type & IC_LOC_SEP_ALP_OV)
-		alpha_buf_size = SL_width * SL_height;
-	ret = dma_memory_alloc(buf_size, BUFCNT_3TH, paddr_3th, buf_3th);
-	if ( ret < 0) {
-		printf("dma_memory_alloc failed\n");
-		goto err1;
-	}
-
-	for (i=0;i<FRM_CNT;i++) {
-		struct timeval frame_begin,frame_end;
-                int sec, usec;
-
-		if (ctrl_c_rev)
-			break;
-
-		param.srcPaddr = paddr_3th[i%BUFCNT_3TH];
-		gen_fill_pattern(buf_3th[i%BUFCNT_3TH], param.srcWidth, param.srcHeight);
-
-		gettimeofday(&frame_begin, NULL);
-
-		if ((ret = LoadScreenLayer(&third_layer, &param, i%BUFCNT_3TH)) != E_RET_SUCCESS) {
-			printf("LoadScreenLayer err %d\n", ret);
-			goto err2;
-		}
-
-		gettimeofday(&frame_end, NULL);
-
-                sec = frame_end.tv_sec - frame_begin.tv_sec;
-                usec = frame_end.tv_usec - frame_begin.tv_usec;
-
-                if (usec < 0) {
-                        sec--;
-                        usec = usec + 1000000;
-                }
-                show_time += (sec * 1000000) + usec;
-
-		/* Fill local alpha buffer */
-		if (op_type & IC_LOC_SEP_ALP_OV) {
-			if(i < FRM_CNT/3)
-				gen_fill_alpha_in_separate_buffer(third_layer.bufAlphaVaddr[i%BUFCNT_3TH], alpha_buf_size, 0x80);
-			else if(i < 2*FRM_CNT/3)
-				gen_fill_alpha_in_separate_buffer(third_layer.bufAlphaVaddr[i%BUFCNT_3TH], alpha_buf_size, 0x00);
-			else if(i < FRM_CNT)
-				gen_fill_alpha_in_separate_buffer(third_layer.bufAlphaVaddr[i%BUFCNT_3TH], alpha_buf_size, 0xFF);
-		}
-		/* Change local alpha value in pixel */
-		else if (op_type & IC_LOC_PIX_ALP_OV) {
-			gen_fill_alpha_in_pixel(third_layer.bufVaddr[i%BUFCNT_3TH], third_layer.fmt, third_layer.bufSize, 0x80);
-			if (i < FRM_CNT/3) {
-				alpha_val = 0x80;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(third_layer.bufVaddr[i%BUFCNT_3TH], third_layer.fmt, SL_width, x, y, alpha_val);
-			} else if (i < 2*FRM_CNT/3) {
-				alpha_val = 0x00;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(third_layer.bufVaddr[i%BUFCNT_3TH], third_layer.fmt, SL_width, x, y, alpha_val);
-			} else if (i < FRM_CNT) {
-				alpha_val = 0xFF;
-				for (x=SL_width/4; x<3*SL_width/4; x++)
-					for (y=SL_height/4; y<3*SL_height/4; y++)
-						gen_fill_alpha_in_pixel_for_point(third_layer.bufVaddr[i%BUFCNT_3TH], third_layer.fmt, SL_width, x, y, alpha_val);
-			}
-		}
-
-		gettimeofday(&frame_begin, NULL);
-
-		if ((ret = FlipScreenLayerBuf(&third_layer, i%BUFCNT_3TH)) != E_RET_SUCCESS) {
-			printf("FlipScreenLayerBuf err %d\n", ret);
-			goto err2;
-		}
-
-		if ((ret = UpdateScreenLayer(&third_layer)) != E_RET_SUCCESS) {
-			printf("UpdateScreenLayer err %d\n",ret);
-			goto err2;
-		}
-
-		gettimeofday(&frame_end, NULL);
-
-                sec = frame_end.tv_sec - frame_begin.tv_sec;
-                usec = frame_end.tv_usec - frame_begin.tv_usec;
-
-                if (usec < 0) {
-                        sec--;
-                        usec = usec + 1000000;
-                }
-                show_time += (sec * 1000000) + usec;
-
-                /* screenlayer should not update fast than lcd refresh rate*/
-                usleep(10000);
-	}
-
-	printf("3rd layer avg frame time %d us\n", show_time/i);
-
-err2:
-	dma_memory_free(buf_size, BUFCNT_3TH, paddr_3th, buf_3th);
-err1:
-	DestoryScreenLayer(&third_layer);
-err:
-	sem_wait(semIDUnit);
-	vshmUnitTest[2] = 0;
-	sem_post(semIDUnit);
-	printf("Third layer has been destroyed! \n");
-	return NULL;
-}
-
-int screenlayer_test(int three_layer, int op_type)
-{
-	pthread_t first_layer_thread;
-	pthread_t second_layer_thread;
-	pthread_t third_layer_thread;
-	int ret;
-        int shmIDUnit;
-        struct stat shmStat;
-        char shmNameUnit[32]="shm_name_unit_test";
-
-        ret = 0;
-        semIDUnit = sem_open(semNameUnit, O_CREAT, 0666, 1);
-        if(SEM_FAILED == semIDUnit){
-                printf("can not open the semaphore for SL IPC Unit test!\n");
-                ret = -1;
-                goto done;
-        }
-
-        shmIDUnit = shm_open(shmNameUnit, O_RDWR|O_CREAT, 0666);
-        if(shmIDUnit == -1){
-                printf("can not open the shared memory for SL IPC Unit test!\n");
-                ret = -1;
-                sem_close(semIDUnit);
-                goto done;
-        }
-        /* Get special size shm */
-        ftruncate(shmIDUnit,3 * sizeof(int));
-        /* Connect to the shm */
-        fstat(shmIDUnit, &shmStat);
-
-        if(vshmUnitTest == NULL)
-                vshmUnitTest = (int *)mmap(NULL,shmStat.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,shmIDUnit,0);
-
-        if(vshmUnitTest == MAP_FAILED || vshmUnitTest ==NULL)
-        {
-                ret = -1;
-                sem_close(semIDUnit);
-                shm_unlink(shmNameUnit);
-                goto done;
-        }
-	memset(vshmUnitTest, 0, 3 *sizeof(int));
-
-	/* create first layer */
-	printf("Display to primary layer!\n");
-	pthread_create(&first_layer_thread, NULL, first_layer_thread_func, NULL);
-
-	/* create second layer */
-	printf("Add second layer!\n");
-	vshmUnitTest[1] = 1;
-	pthread_create(&second_layer_thread, NULL, second_layer_thread_func, &op_type);
-
-	if (three_layer) {
-		/* create third layer */
-		printf("Add third layer!\n");
-		vshmUnitTest[2] = 1;
-		pthread_create(&third_layer_thread, NULL, third_layer_thread_func, &op_type);
-	}
-
-	while(!ctrl_c_rev)usleep(100000);
-
-	if (three_layer)
-		pthread_join(third_layer_thread, NULL);
-	pthread_join(second_layer_thread, NULL);
-	pthread_join(first_layer_thread, NULL);
-
-	sem_unlink(semNameUnit);
-	shm_unlink(shmNameUnit);
-done:
-	return ret;
-}
-/*
-**	ProcessA: First_layer & second_layer
-**	ProcessB: Third_layer
-*/
-int screenlayer_test_ipc(int process_num, int three_layer, int op_type)
-{
-	pthread_t first_layer_thread;
-	pthread_t second_layer_thread;
-	pthread_t third_layer_thread;
-	int ret;
-	int shmIDUnit;
-	struct stat shmStat;
-	char shmNameUnit[32]="shm_name_unit_test";
-
-	ret = 0;
-	semIDUnit = sem_open(semNameUnit, O_CREAT, 0666, 1);
-	if(SEM_FAILED == semIDUnit){
-                printf("can not open the semaphore for SL IPC Unit test!\n");
-                ret = -1;
-                goto done;
-        }
-
-	shmIDUnit = shm_open(shmNameUnit, O_RDWR|O_CREAT, 0666);
-        if(shmIDUnit == -1){
-                printf("can not open the shared memory for SL IPC Unit test!\n");
-                ret = -1;
-                sem_close(semIDUnit);
-                goto done;
-        }
-        /* Get special size shm */
-        ftruncate(shmIDUnit,3 * sizeof(int));
-        /* Connect to the shm */
-        fstat(shmIDUnit, &shmStat);
-
-        if(vshmUnitTest == NULL)
-		vshmUnitTest = (int *)mmap(NULL,shmStat.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,shmIDUnit,0);
-
-	if(vshmUnitTest == MAP_FAILED || vshmUnitTest ==NULL)
-	{
-		ret = -1;
-		sem_close(semIDUnit);
-		shm_unlink(shmNameUnit);
-		goto done;
-	}
-	memset(vshmUnitTest, 0, 3 *sizeof(int));
-	vshmUnitTest[1] = 1;
-
-	/* Two process cases*/
-	if(process_num == 2)
-	{
-		if(three_layer) vshmUnitTest[2]  = 1;
-		/* Process A */
-		if(fork() != 0)
-		{
-			/* create first layer */
-			printf("Display to primary layer!\n");
-			pthread_create(&first_layer_thread, NULL, first_layer_thread_func, &op_type);
-
-			if(three_layer)
-			{
-				/* create second layer */
-				sleep(2);
-				printf("Add second layer!\n");
-				pthread_create(&second_layer_thread, NULL, second_layer_thread_func, &op_type);
-				pthread_join(second_layer_thread, NULL);
-			}
-
-			pthread_join(first_layer_thread, NULL);
-			sem_unlink(semNameUnit);
-			shm_unlink(shmNameUnit);
-			printf("SL IPC: Process A has been exited. \n");
-			exit(0);
-		}else{
-			/* Process B */
-			sleep(2);
-			if(three_layer)
-			{
-				/* create third layer */
-				printf("Add third layer!\n");
-				pthread_create(&third_layer_thread, NULL, third_layer_thread_func, &op_type);
-				pthread_join(third_layer_thread, NULL);
-			} else
-			{
-				/* create second layer */
-		                printf("Add second layer(two layers case)!\n");
-                        	pthread_create(&second_layer_thread, NULL, second_layer_thread_func, &op_type);
-		                pthread_join(second_layer_thread, NULL);
-			}
-			printf("SL IPC: Process B has been exited. \n");
-		}
-		sem_unlink(semNameUnit);
-		shm_unlink(shmNameUnit);
-		exit(0);
-	}else if(process_num ==3)
-	{
-		vshmUnitTest[2]  = 1;
-		/* Process A */
-                if(fork()!=0)
-                {
-                        /* create first layer */
-                        printf("Display to primary layer!\n");
-                        pthread_create(&first_layer_thread, NULL, first_layer_thread_func, NULL);
-                        pthread_join(first_layer_thread, NULL);
-                        sem_unlink(semNameUnit);
-                        shm_unlink(shmNameUnit);
-                        printf("SL IPC: Process A has been exited. \n");
-                        exit(0);
-                }else{
-			/* Process B */
-			if(fork()==0)
-			{
-                                /* create second layer */
-				sleep(2);
-                                printf("Add second layer!\n");
-                                pthread_create(&second_layer_thread, NULL, second_layer_thread_func, &op_type);
-				pthread_join(second_layer_thread, NULL);
-				sem_unlink(semNameUnit);
-	                        shm_unlink(shmNameUnit);
-        	                printf("SL IPC: Process B has been exited. \n");
-                	        exit(0);
-			}
-			else
-			{
-				/* Process C */
-				/* create third layer */
-				sleep(2);
-				printf("Add third layer!\n");
-				pthread_create(&third_layer_thread, NULL, third_layer_thread_func, &op_type);
-				pthread_join(third_layer_thread, NULL);
-				sem_unlink(semNameUnit);
-	                        shm_unlink(shmNameUnit);
-        	                printf("SL IPC: Process C has been exited. \n");
-                	        exit(0);
-			}
-
-		}
-	}
-
-done:
-	return ret;
-}
-#endif
-
-int run_test_pattern(int pattern, ipu_test_handle_t * test_handle)
-{
-	if (pattern == 1) {
-		printf("Color bar test with full-screen:\n");
-		return color_bar(NO_OV, test_handle);
-	}
-	if (pattern == 2) {
-		printf("Hopping block test:\n");
-		return hop_block(test_handle);
-	}
-	if (pattern == 3) {
-		int ret=0;
-		int ret1=0;
-		int ret2=0;
-		pthread_t thread1;
-		pthread_t thread2;
-
-		printf("Hopping block + color bar thread test:\n");
-
-		pthread_create(&thread2, NULL, thread_func_hop_block, test_handle);
-		pthread_create(&thread1, NULL, thread_func_color_bar, NULL);
-
-		sleep(1);
-		pthread_join(thread1, (void*)(&ret1));
-		pthread_join(thread2, (void*)(&ret2));
-		printf("Hopping block + color bar threads has joied:\n");
-		if(ret1==0 && ret2==0)
-			ret = 0;
-		else
-			ret = -1;
-		return ret;
-	}
-	if (pattern == 4) {
-		printf("Color bar IC global alpha overlay test:\n");
-		return color_bar(IC_GLB_ALP_OV, test_handle);
-	}
-	if (pattern == 5) {
-		printf("Color bar IC separate local alpha overlay test:\n");
-		return color_bar(IC_LOC_SEP_ALP_OV, test_handle);
-	}
-	if (pattern == 6) {
-		printf("Color bar IC local alpha within pixel overlay test:\n");
-		return color_bar(IC_LOC_PIX_ALP_OV, test_handle);
-	}
-	if (pattern == 7) {
-		printf("Copy test:\n");
-		return copy_test(test_handle);
-	}
-#ifndef BUILD_FOR_ANDROID
-	if (pattern == 8) {
-		printf("Screen layer with 2 layers test using IC global alpha blending:\n");
-		return screenlayer_test(0, IC_GLB_ALP_OV);
-	}
-	if (pattern == 9) {
-		printf("Screen layer with 3 layers test using IC global alpha blending:\n");
-		return screenlayer_test(1, IC_GLB_ALP_OV);
-	}
-	if (pattern == 10) {
-		printf("Screen layer with 2 layers test using IC local alpha blending with alpha value in separate buffer:\n");
-		return screenlayer_test(0, IC_LOC_SEP_ALP_OV);
-	}
-	if (pattern == 11) {
-		printf("Screen layer with 3 layers test using IC local alpha blending with alpha value in separate buffer:\n");
-		return screenlayer_test(1, IC_LOC_SEP_ALP_OV);
- 	}
-	if (pattern == 12) {
-		printf("Screen layer with 2 layers test using IC local alpha blending with alpha value in pixel:\n");
-		return screenlayer_test(0, IC_LOC_PIX_ALP_OV);
-	}
-	if (pattern == 13) {
-		printf("Screen layer with 3 layers test using IC local alpha blending with alpha value in pixel:\n");
-		return screenlayer_test(1, IC_LOC_PIX_ALP_OV);
- 	}
-	if (pattern == 14){
-		printf("Screen layer IPC(global alpha): ProcessA(first_layer ) ProcessB(second_layer):\n");
-		return screenlayer_test_ipc(2, 0, IC_GLB_ALP_OV);
-	}
-	if (pattern == 15){
-		printf("Screen layer IPC(local alpha): ProcessA(first_layer ) ProcessB(second_layer):\n");
-		return screenlayer_test_ipc(2, 0, IC_LOC_SEP_ALP_OV);
-	}
-	if (pattern == 16){
-		printf("Screen layer IPC(global alpha): ProcessA(first_layer + second_layer) ProcessB(third_layer):\n");
-		return screenlayer_test_ipc(2, 1, IC_GLB_ALP_OV);
-	}
-	if (pattern == 17){
-		printf("Screen layer IPC(local alpha): ProcessA(first_layer + second_layer) ProcessB(third_layer):\n");
-		return screenlayer_test_ipc(2, 1, IC_LOC_SEP_ALP_OV);
-	}
-	if (pattern == 18){
-		printf("Screen layer IPC(local alpha): ProcessA(first_layer) ProcessB(second_layer) ProcessC(third_layer):\n");
-		return screenlayer_test_ipc(3, 1, IC_LOC_SEP_ALP_OV);
-	}
-	if (pattern == 19){
-		printf("[No mandatory test]Screen layer IPC(local alpha + tvout): ProcessA(first_layer) ProcessB(second_layer):\n");
-		return screenlayer_test_ipc(2, 0, IC_LOC_SEP_ALP_OV | COPY_TV);
-	}
-#endif
-
-	printf("No such test pattern %d\n", pattern);
-	return -1;
-}
diff --git a/test/mxc_ipudev_test/utils.c b/test/mxc_ipudev_test/utils.c
index e4d96ae..3c8e11e 100644
--- a/test/mxc_ipudev_test/utils.c
+++ b/test/mxc_ipudev_test/utils.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  */
 
@@ -51,17 +51,44 @@ char * skip_unwanted(char *ptr)
 
 int parse_options(char *buf, ipu_test_handle_t *test_handle)
 {
+	struct ipu_task *t = &test_handle->task;
 	char *str;
 
 	/* general */
-	str = strstr(buf, "mode");
+	str = strstr(buf, "priority");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->mode = strtol(str, NULL, 16);
-				printf("mode\t\t= 0x%x\n", test_handle->mode);
+				t->priority = strtol(str, NULL, 10);
+				printf("priority\t= %d\n", t->priority);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "task_id");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->task_id = strtol(str, NULL, 10);
+				printf("task_id\t\t= %d\n", t->task_id);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "timeout");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->timeout = strtol(str, NULL, 10);
+				printf("timeout\t\t= %d\n", t->timeout);
 			}
 			return 0;
 		}
@@ -100,8 +127,8 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.width = strtol(str, NULL, 10);
-				printf("in_width\t= %d\n", test_handle->input.width);
+				t->input.width = strtol(str, NULL, 10);
+				printf("in_width\t= %d\n", t->input.width);
 			}
 			return 0;
 		}
@@ -113,8 +140,8 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.height = strtol(str, NULL, 10);
-				printf("in_height\t= %d\n", test_handle->input.height);
+				t->input.height = strtol(str, NULL, 10);
+				printf("in_height\t= %d\n", t->input.height);
 			}
 			return 0;
 		}
@@ -126,7 +153,7 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.fmt =
+				t->input.format =
 					v4l2_fourcc(str[0], str[1], str[2], str[3]);
 				printf("in_fmt\t\t= %s\n", str);
 			}
@@ -140,10 +167,10 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.input_crop_win.pos.x =
+				t->input.crop.pos.x =
 					strtol(str, NULL, 10);
 				printf("in_posx\t\t= %d\n",
-					test_handle->input.input_crop_win.pos.x);
+					t->input.crop.pos.x);
 			}
 			return 0;
 		}
@@ -155,40 +182,55 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.input_crop_win.pos.y =
+				t->input.crop.pos.y =
 					strtol(str, NULL, 10);
 				printf("in_posy\t\t= %d\n",
-					test_handle->input.input_crop_win.pos.y);
+					t->input.crop.pos.y);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "in_win_w");
+	str = strstr(buf, "in_crop_w");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.input_crop_win.win_w =
+				t->input.crop.w =
 					strtol(str, NULL, 10);
-				printf("in_win_w\t= %d\n",
-					test_handle->input.input_crop_win.win_w);
+				printf("in_crop_w\t= %d\n",
+					t->input.crop.w);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "in_win_h");
+	str = strstr(buf, "in_crop_h");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.input_crop_win.win_h =
+				t->input.crop.h =
 					strtol(str, NULL, 10);
-				printf("in_win_h\t= %d\n",
-					test_handle->input.input_crop_win.win_h);
+				printf("in_crop_h\t= %d\n",
+					t->input.crop.h);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "deinterlace_en");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->input.deinterlace.enable =
+					strtol(str, NULL, 10);
+				printf("deinterlace_en\t= %d\n",
+					t->input.deinterlace.enable);
 			}
 			return 0;
 		}
@@ -200,10 +242,184 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->input.motion_sel =
+				t->input.deinterlace.motion =
 					strtol(str, NULL, 10);
 				printf("motion_sel\t= %d\n",
-					test_handle->input.motion_sel);
+					t->input.deinterlace.motion);
+			}
+			return 0;
+		}
+	}
+
+	/* overlay */
+	str = strstr(buf, "overlay_en");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay_en = strtol(str, NULL, 10);
+				printf("overlay_en\t= %d\n", t->overlay_en);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_width");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.width = strtol(str, NULL, 10);
+				printf("ov_width\t= %d\n", t->overlay.width);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_height");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.height = strtol(str, NULL, 10);
+				printf("ov_height\t= %d\n", t->overlay.height);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_fmt");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.format =
+					v4l2_fourcc(str[0], str[1], str[2], str[3]);
+				printf("ov_fmt\t\t= %s\n", str);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_posx");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.crop.pos.x =
+					strtol(str, NULL, 10);
+				printf("ov_posx\t\t= %d\n",
+					t->overlay.crop.pos.x);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_posy");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.crop.pos.y =
+					strtol(str, NULL, 10);
+				printf("ov_posy\t\t= %d\n",
+					t->overlay.crop.pos.y);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_crop_w");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.crop.w =
+					strtol(str, NULL, 10);
+				printf("ov_crop_w\t= %d\n",
+					t->overlay.crop.w);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "ov_crop_h");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.crop.h =
+					strtol(str, NULL, 10);
+				printf("ov_crop_h\t= %d\n",
+					t->overlay.crop.h);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "alpha_mode");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.alpha.mode =
+					strtol(str, NULL, 10);
+				printf("alpha_mode\t= %d\n",
+					t->overlay.alpha.mode);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "alpha_value");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.alpha.gvalue =
+					strtol(str, NULL, 10);
+				printf("alpha_value\t= %d\n",
+					t->overlay.alpha.gvalue);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "colorkey_en");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.colorkey.enable =
+					strtol(str, NULL, 10);
+				printf("colorkey_en\t= %d\n",
+					t->overlay.colorkey.enable);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "colorkey_value");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->overlay.colorkey.value =
+					strtol(str, NULL, 16);
+				printf("colorkey_value\t= 0x%x\n",
+					t->overlay.colorkey.value);
 			}
 			return 0;
 		}
@@ -216,8 +432,8 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.width = strtol(str, NULL, 10);
-				printf("out_width\t= %d\n", test_handle->output.width);
+				t->output.width = strtol(str, NULL, 10);
+				printf("out_width\t= %d\n", t->output.width);
 			}
 			return 0;
 		}
@@ -229,8 +445,8 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.height = strtol(str, NULL, 10);
-				printf("out_height\t= %d\n", test_handle->output.height);
+				t->output.height = strtol(str, NULL, 10);
+				printf("out_height\t= %d\n", t->output.height);
 			}
 			return 0;
 		}
@@ -242,7 +458,7 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.fmt =
+				t->output.format =
 					v4l2_fourcc(str[0], str[1], str[2], str[3]);
 				printf("out_fmt\t\t= %s\n", str);
 			}
@@ -256,60 +472,77 @@ int parse_options(char *buf, ipu_test_handle_t *test_handle)
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.rot = strtol(str, NULL, 10);
-				printf("out_rot\t\t= %d\n", test_handle->output.rot);
+				t->output.rotate = strtol(str, NULL, 10);
+				printf("out_rot\t\t= %d\n", t->output.rotate);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "out_to_fb");
+	str = strstr(buf, "out_posx");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.show_to_fb = strtol(str, NULL, 10);
-				printf("out_to_fb\t= %d\n", test_handle->output.show_to_fb);
+				t->output.crop.pos.x = strtol(str, NULL, 10);
+				printf("out_posx\t= %d\n", t->output.crop.pos.x);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "out_fb_num");
+	str = strstr(buf, "out_posy");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.fb_disp.fb_num = strtol(str, NULL, 10);
-				printf("out_fb_num\t= %d\n", test_handle->output.fb_disp.fb_num);
+				t->output.crop.pos.y = strtol(str, NULL, 10);
+				printf("out_posy\t= %d\n", t->output.crop.pos.y);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "out_posx");
+	str = strstr(buf, "out_crop_w");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.fb_disp.pos.x = strtol(str, NULL, 10);
-				printf("out_posx\t= %d\n", test_handle->output.fb_disp.pos.x);
+				t->output.crop.w =
+					strtol(str, NULL, 10);
+				printf("out_crop_w\t= %d\n",
+					t->output.crop.w);
 			}
 			return 0;
 		}
 	}
 
-	str = strstr(buf, "out_posy");
+	str = strstr(buf, "out_crop_h");
+	if (str != NULL) {
+		str = index(buf, '=');
+		if (str != NULL) {
+			str++;
+			if (*str != '\0') {
+				t->output.crop.h =
+					strtol(str, NULL, 10);
+				printf("out_crop_h\t= %d\n",
+					t->output.crop.h);
+			}
+			return 0;
+		}
+	}
+
+	str = strstr(buf, "out_to_fb");
 	if (str != NULL) {
 		str = index(buf, '=');
 		if (str != NULL) {
 			str++;
 			if (*str != '\0') {
-				test_handle->output.fb_disp.pos.y = strtol(str, NULL, 10);
-				printf("out_posy\t= %d\n", test_handle->output.fb_disp.pos.y);
+				test_handle->show_to_fb = strtol(str, NULL, 10);
+				printf("out_to_fb\t= %d\n", test_handle->show_to_fb);
 			}
 			return 0;
 		}
-- 
1.8.0

