From 830947a0d8317ed6292c8521e707a1ece9ded808 Mon Sep 17 00:00:00 2001
From: Fugang Duan <b38611@freescale.com>
Date: Mon, 12 Oct 2015 11:14:44 +0800
Subject: [PATCH 502/505] MLK-11688 ar3k: remove the ar3k test tool

Remove the ar3k hciattach test tools since bluez4.x and bluez5.x all
support ar3k/st/broadcom BT and others more BT vendors.

Signed-off-by: Fugang Duan <B38611@freescale.com>
---
 test/ar3k_bt/Makefile             |   29 -
 test/ar3k_bt/ar3k-bt-start.sh     |    6 -
 test/ar3k_bt/hciattach-ar3k.bin   |  Bin 95745 -> 0 bytes
 test/ar3k_bt/hciattach.8          |  155 ----
 test/ar3k_bt/hciattach.c          | 1623 -------------------------------------
 test/ar3k_bt/hciattach.h          |   59 --
 test/ar3k_bt/hciattach_ath3k.c    | 1053 ------------------------
 test/ar3k_bt/hciattach_qualcomm.c |  275 -------
 test/ar3k_bt/hciattach_st.c       |  278 -------
 test/ar3k_bt/hciattach_ti.c       |  529 ------------
 test/ar3k_bt/hciattach_tialt.c    |  244 ------
 11 files changed, 4251 deletions(-)
 delete mode 100755 test/ar3k_bt/Makefile
 delete mode 100644 test/ar3k_bt/ar3k-bt-start.sh
 delete mode 100755 test/ar3k_bt/hciattach-ar3k.bin
 delete mode 100644 test/ar3k_bt/hciattach.8
 delete mode 100755 test/ar3k_bt/hciattach.c
 delete mode 100755 test/ar3k_bt/hciattach.h
 delete mode 100644 test/ar3k_bt/hciattach_ath3k.c
 delete mode 100644 test/ar3k_bt/hciattach_qualcomm.c
 delete mode 100755 test/ar3k_bt/hciattach_st.c
 delete mode 100755 test/ar3k_bt/hciattach_ti.c
 delete mode 100755 test/ar3k_bt/hciattach_tialt.c

diff --git a/test/ar3k_bt/Makefile b/test/ar3k_bt/Makefile
deleted file mode 100755
index 92e2901..0000000
--- a/test/ar3k_bt/Makefile
+++ /dev/null
@@ -1,29 +0,0 @@
-# Makefile for atheros BT hciattach app
-#
-# This package is for atheros ar3k bt chip, you can use the binary,
-# also provide the modified source code, if you need rebuild the tool
-# please rebuild, it need the rootfs and bluez source & lib path
-EXCLUDE_LIST:= IMX21ADS IMX27ADS IMX31ADS IMX32ADS IMX37_3STACK IMX25_3STACK
-
-INC += -I$(LINUXPATH)/include
-
-ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
-OBJS = $(OBJDIR)/hciattach-ar3k.bin $(OBJDIR)/ar3k-bt-start.sh
-else
-OBJS =
-endif
-
-# If you want to compile the source code, please reference follow make file.
-# this is default off by here.
-# it will be compile on your target envroioment.(eg, ubuntu).
-all: $(OBJS)
-
-CFLAGS +=  -lbluetooth
-
-$(OBJDIR)/hciattach-ar3k.bin :
-	$(CC)  ${INC} -Wall -lbluetooth -g hciattach_ath3k.c  hciattach.c  hciattach_qualcomm.c  hciattach_st.c  hciattach_tialt.c  hciattach_ti.c -o hciattach-ar3k.bin
-
-clean:
-	rm -f *.o hciattach-ar3k.bin
-
-include ../make.rules
diff --git a/test/ar3k_bt/ar3k-bt-start.sh b/test/ar3k_bt/ar3k-bt-start.sh
deleted file mode 100644
index 82e0c3a..0000000
--- a/test/ar3k_bt/ar3k-bt-start.sh
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/bin/sh
-
-sudo pkill -9 hciattach-ar3k.bin
-sudo su -c "echo 1 > /sys/class/rfkill/rfkill0/state"
-sudo chmod 777 /dev/ttymxc2
-sudo /unit_tests/hciattach-ar3k.bin -n ttymxc2 ath3k 3000000 flow sleep &
diff --git a/test/ar3k_bt/hciattach-ar3k.bin b/test/ar3k_bt/hciattach-ar3k.bin
deleted file mode 100755
index cf1922f937a48dd8332e872a92e2e6537d934402..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 95745
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

diff --git a/test/ar3k_bt/hciattach.8 b/test/ar3k_bt/hciattach.8
deleted file mode 100644
index e0e2730..0000000
--- a/test/ar3k_bt/hciattach.8
+++ /dev/null
@@ -1,155 +0,0 @@
-.TH HCIATTACH 8 "Jan 22 2002" BlueZ "Linux System Administration"
-.SH NAME
-hciattach \- attach serial devices via UART HCI to BlueZ stack
-.SH SYNOPSIS
-.B hciattach
-.RB [\| \-b \|]
-.RB [\| \-n \|]
-.RB [\| \-p \|]
-.RB [\| \-t
-.IR timeout \|]
-.RB [\| \-s
-.IR speed \|]
-.RB [\| \-l \|]
-.RB [\| \-r \|]
-.I tty
-.IR type \||\| id
-.I speed
-.I flow
-.I bdaddr
-.SH DESCRIPTION
-.LP
-Hciattach is used to attach a serial UART to the Bluetooth stack as HCI
-transport interface.
-.SH OPTIONS
-.TP
-.B \-b
-Send break.
-.TP
-.B \-n
-Don't detach from controlling terminal.
-.TP
-.B \-p
-Print the PID when detaching.
-.TP
-.BI \-t " timeout"
-Specify an initialization timeout.  (Default is 5 seconds.)
-.TP
-.BI \-s " speed"
-Specify an initial speed instead of the hardware default.
-.TP
-.B \-l
-List all available configurations.
-.TP
-.B \-r
-Set the HCI device into raw mode (the kernel and bluetoothd will ignore it).
-.TP
-.I tty
-This specifies the serial device to attach. A leading
-.B /dev
-can be omitted. Examples:
-.B /dev/ttyS1
-.B ttyS2
-.TP
-.IR type \||\| id
-The
-.I type
-or
-.I id
-of the Bluetooth device that is to be attached, i.e. vendor or other device
-specific identifier. Currently supported types are
-.RS
-.TP
-.B type
-.B description
-.TP
-.B any
-Unspecified HCI_UART interface, no vendor specific options
-.TP
-.B ericsson
-Ericsson based modules
-.TP
-.B digi
-Digianswer based cards
-.TP
-.B xircom
-Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter
-.TP
-.B csr
-CSR Casira serial adapter or BrainBoxes serial dongle (BL642)
-.TP
-.B bboxes
-BrainBoxes PCMCIA card (BL620)
-.TP
-.B swave
-Silicon Wave kits
-.TP
-.B bcsp
-Serial adapters using CSR chips with BCSP serial protocol
-.TP
-.B ath3k
-Atheros AR300x based serial Bluetooth device
-.RE
-
-Supported IDs are (manufacturer id, product id)
-.RS
-.TP
-.B 0x0105, 0x080a
-Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter
-.TP
-.B 0x0160, 0x0002
-BrainBoxes PCMCIA card (BL620)
-.RE
-
-.TP
-.I speed
-The
-.I speed
-specifies the UART speed to use. Baudrates higher than 115.200bps require
-vendor specific initializations that are not implemented for all types of
-devices. In general the following speeds are supported:
-
-.B 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600
-
-Supported vendor devices are automatically initialised to their respective
-best settings.
-.TP
-.I flow
-If the keyword
-.I flow
-is appended to the list of options then hardware flow control is forced on
-the serial link (
-.B CRTSCTS
-). All above mentioned device types have
-.B flow
-set by default. To force no flow control use
-.B noflow
-instead.
-.TP
-.I sleep
-Enables hardware specific power management feature. If
-.I sleep
-is appended to the list of options then this feature is enabled. To disable
-this feature use
-.B nosleep
-instead.
-All above mentioned device types have
-.B nosleep
-set by default.
-
-Note: This option will only be valid for hardware which support
-hardware specific power management enable option from host.
-.TP
-.I bdaddr
-The
-.I bdaddr
-specifies the Bluetooth Address to use.  Some devices (like the STLC2500)
-do not store the Bluetooth address in hardware memory.  Instead it must
-be uploaded during the initialization process.  If this argument
-is specified, then the address will be used to initialize the device.
-Otherwise, a default address will be used.
-
-.SH AUTHORS
-Written by Maxim Krasnyansky <maxk@qualcomm.com>
-.PP
-Manual page by Nils Faerber <nils@kernelconcepts.de>
diff --git a/test/ar3k_bt/hciattach.c b/test/ar3k_bt/hciattach.c
deleted file mode 100755
index 26bc235..0000000
--- a/test/ar3k_bt/hciattach.c
+++ /dev/null
@@ -1,1623 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2000-2001  Qualcomm Incorporated
- *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
- *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include <syslog.h>
-#include <termios.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/poll.h>
-#include <sys/param.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/uio.h>
-
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/hci_lib.h>
-
-#include "hciattach.h"
-
-#ifdef NEED_PPOLL
-#include "ppoll.h"
-#endif
-
-struct uart_t {
-	char *type;
-	int  m_id;
-	int  p_id;
-	int  proto;
-	int  init_speed;
-	int  speed;
-	int  flags;
-	int  pm;
-	char *bdaddr;
-	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
-	int  (*post) (int fd, struct uart_t *u, struct termios *ti);
-};
-
-#define FLOW_CTL	0x0001
-#define ENABLE_PM	1
-#define DISABLE_PM	0
-
-static volatile sig_atomic_t __io_canceled = 0;
-
-static void sig_hup(int sig)
-{
-}
-
-static void sig_term(int sig)
-{
-	__io_canceled = 1;
-}
-
-static void sig_alarm(int sig)
-{
-	fprintf(stderr, "Initialization timed out.\n");
-	exit(1);
-}
-
-static int uart_speed(int s)
-{
-	switch (s) {
-	case 9600:
-		return B9600;
-	case 19200:
-		return B19200;
-	case 38400:
-		return B38400;
-	case 57600:
-		return B57600;
-	case 115200:
-		return B115200;
-	case 230400:
-		return B230400;
-	case 460800:
-		return B460800;
-	case 500000:
-		return B500000;
-	case 576000:
-		return B576000;
-	case 921600:
-		return B921600;
-	case 1000000:
-		return B1000000;
-	case 1152000:
-		return B1152000;
-	case 1500000:
-		return B1500000;
-	case 2000000:
-		return B2000000;
-#ifdef B2500000
-	case 2500000:
-		return B2500000;
-#endif
-#ifdef B3000000
-	case 3000000:
-		return B3000000;
-#endif
-#ifdef B3500000
-	case 3500000:
-		return B3500000;
-#endif
-#ifdef B4000000
-	case 4000000:
-		return B4000000;
-#endif
-	default:
-		return B57600;
-	}
-}
-
-int set_speed(int fd, struct termios *ti, int speed)
-{
-	if (cfsetospeed(ti, uart_speed(speed)) < 0)
-		return -errno;
-
-	if (cfsetispeed(ti, uart_speed(speed)) < 0)
-		return -errno;
-
-	if (tcsetattr(fd, TCSANOW, ti) < 0)
-		return -errno;
-
-	return 0;
-}
-
-/*
- * Read an HCI event from the given file descriptor.
- */
-int read_hci_event(int fd, unsigned char* buf, int size)
-{
-	int remain, r;
-	int count = 0;
-
-	if (size <= 0)
-		return -1;
-
-	/* The first byte identifies the packet type. For HCI event packets, it
-	 * should be 0x04, so we read until we get to the 0x04. */
-	while (1) {
-		r = read(fd, buf, 1);
-		if (r <= 0)
-			return -1;
-		if (buf[0] == 0x04)
-			break;
-	}
-	count++;
-
-	/* The next two bytes are the event code and parameter total length. */
-	while (count < 3) {
-		r = read(fd, buf + count, 3 - count);
-		if (r <= 0)
-			return -1;
-		count += r;
-	}
-
-	/* Now we read the parameters. */
-	if (buf[2] < (size - 3))
-		remain = buf[2];
-	else
-		remain = size - 3;
-
-	while ((count - 3) < remain) {
-		r = read(fd, buf + count, remain - (count - 3));
-		if (r <= 0)
-			return -1;
-		count += r;
-	}
-
-	return count;
-}
-
-/*
- * Ericsson specific initialization
- */
-static int ericsson(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[5];
-
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x09;
-	cmd[2] = 0xfc;
-	cmd[3] = 0x01;
-
-	switch (u->speed) {
-	case 57600:
-		cmd[4] = 0x03;
-		break;
-	case 115200:
-		cmd[4] = 0x02;
-		break;
-	case 230400:
-		cmd[4] = 0x01;
-		break;
-	case 460800:
-		cmd[4] = 0x00;
-		break;
-	case 921600:
-		cmd[4] = 0x20;
-		break;
-	case 2000000:
-		cmd[4] = 0x25;
-		break;
-	case 3000000:
-		cmd[4] = 0x27;
-		break;
-	case 4000000:
-		cmd[4] = 0x2B;
-		break;
-	default:
-		cmd[4] = 0x03;
-		u->speed = 57600;
-		fprintf(stderr, "Invalid speed requested, using %d bps instead\n", u->speed);
-		break;
-	}
-
-	/* Send initialization command */
-	if (write(fd, cmd, 5) != 5) {
-		perror("Failed to write init command");
-		return -1;
-	}
-
-	nanosleep(&tm, NULL);
-	return 0;
-}
-
-/*
- * Digianswer specific initialization
- */
-static int digi(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[5];
-
-	/* DigiAnswer set baud rate command */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x07;
-	cmd[2] = 0xfc;
-	cmd[3] = 0x01;
-
-	switch (u->speed) {
-	case 57600:
-		cmd[4] = 0x08;
-		break;
-	case 115200:
-		cmd[4] = 0x09;
-		break;
-	default:
-		cmd[4] = 0x09;
-		u->speed = 115200;
-		break;
-	}
-
-	/* Send initialization command */
-	if (write(fd, cmd, 5) != 5) {
-		perror("Failed to write init command");
-		return -1;
-	}
-
-	nanosleep(&tm, NULL);
-	return 0;
-}
-
-static int texas(int fd, struct uart_t *u, struct termios *ti)
-{
-	return texas_init(fd, ti);
-}
-
-static int texas2(int fd, struct uart_t *u, struct termios *ti)
-{
-	return texas_post(fd, ti);
-}
-
-static int texasalt(int fd, struct uart_t *u, struct termios *ti)
-{
-	return texasalt_init(fd, u->speed, ti);
-}
-
-static int ath3k_ps(int fd, struct uart_t *u, struct termios *ti)
-{
-	return ath3k_init(fd, u->speed, u->init_speed, u->bdaddr, ti);
-}
-
-static int ath3k_pm(int fd, struct uart_t *u, struct termios *ti)
-{
-	return ath3k_post(fd, u->pm);
-}
-
-static int qualcomm(int fd, struct uart_t *u, struct termios *ti)
-{
-	return qualcomm_init(fd, u->speed, ti, u->bdaddr);
-}
-
-static int read_check(int fd, void *buf, int count)
-{
-	int res;
-
-	do {
-		res = read(fd, buf, count);
-		if (res != -1) {
-			buf += res;
-			count -= res;
-		}
-	} while (count && (errno == 0 || errno == EINTR));
-
-	if (count)
-		return -1;
-
-	return 0;
-}
-
-/*
- * BCSP specific initialization
- */
-static int serial_fd;
-static int bcsp_max_retries = 10;
-
-static void bcsp_tshy_sig_alarm(int sig)
-{
-	unsigned char bcsp_sync_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xda,0xdc,0xed,0xed,0xc0};
-	int len;
-	static int retries = 0;
-
-	if (retries < bcsp_max_retries) {
-		retries++;
-		len = write(serial_fd, &bcsp_sync_pkt, 10);
-		alarm(1);
-		return;
-	}
-
-	tcflush(serial_fd, TCIOFLUSH);
-	fprintf(stderr, "BCSP initialization timed out\n");
-	exit(1);
-}
-
-static void bcsp_tconf_sig_alarm(int sig)
-{
-	unsigned char bcsp_conf_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xad,0xef,0xac,0xed,0xc0};
-	int len;
-	static int retries = 0;
-
-	if (retries < bcsp_max_retries){
-		retries++;
-		len = write(serial_fd, &bcsp_conf_pkt, 10);
-		alarm(1);
-		return;
-	}
-
-	tcflush(serial_fd, TCIOFLUSH);
-	fprintf(stderr, "BCSP initialization timed out\n");
-	exit(1);
-}
-
-static int bcsp(int fd, struct uart_t *u, struct termios *ti)
-{
-	unsigned char byte, bcsph[4], bcspp[4],
-		bcsp_sync_resp_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xac,0xaf,0xef,0xee,0xc0},
-		bcsp_conf_resp_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xde,0xad,0xd0,0xd0,0xc0},
-		bcspsync[4]     = {0xda, 0xdc, 0xed, 0xed},
-		bcspsyncresp[4] = {0xac,0xaf,0xef,0xee},
-		bcspconf[4]     = {0xad,0xef,0xac,0xed},
-		bcspconfresp[4] = {0xde,0xad,0xd0,0xd0};
-	struct sigaction sa;
-	int len;
-
-	if (set_speed(fd, ti, u->speed) < 0) {
-		perror("Can't set default baud rate");
-		return -1;
-	}
-
-	ti->c_cflag |= PARENB;
-	ti->c_cflag &= ~(PARODD);
-
-	if (tcsetattr(fd, TCSANOW, ti) < 0) {
-		perror("Can't set port settings");
-		return -1;
-	}
-
-	alarm(0);
-
-	serial_fd = fd;
-	memset(&sa, 0, sizeof(sa));
-	sa.sa_flags = SA_NOCLDSTOP;
-	sa.sa_handler = bcsp_tshy_sig_alarm;
-	sigaction(SIGALRM, &sa, NULL);
-
-	/* State = shy */
-
-	bcsp_tshy_sig_alarm(0);
-	while (1) {
-		do {
-			if (read_check(fd, &byte, 1) == -1){
-				perror("Failed to read");
-				return -1;
-			}
-		} while (byte != 0xC0);
-
-		do {
-			if ( read_check(fd, &bcsph[0], 1) == -1){
-				perror("Failed to read");
-				return -1;
-			}
-		} while (bcsph[0] == 0xC0);
-
-		if ( read_check(fd, &bcsph[1], 3) == -1){
-			perror("Failed to read");
-			return -1;
-		}
-
-		if (((bcsph[0] + bcsph[1] + bcsph[2]) & 0xFF) != (unsigned char)~bcsph[3])
-			continue;
-		if (bcsph[1] != 0x41 || bcsph[2] != 0x00)
-			continue;
-
-		if (read_check(fd, &bcspp, 4) == -1){
-			perror("Failed to read");
-			return -1;
-		}
-
-		if (!memcmp(bcspp, bcspsync, 4)) {
-			len = write(fd, &bcsp_sync_resp_pkt,10);
-		} else if (!memcmp(bcspp, bcspsyncresp, 4))
-			break;
-	}
-
-	/* State = curious */
-
-	alarm(0);
-	sa.sa_handler = bcsp_tconf_sig_alarm;
-	sigaction(SIGALRM, &sa, NULL);
-	alarm(1);
-
-	while (1) {
-		do {
-			if (read_check(fd, &byte, 1) == -1){
-				perror("Failed to read");
-				return -1;
-			}
-		} while (byte != 0xC0);
-
-		do {
-			if (read_check(fd, &bcsph[0], 1) == -1){
-				perror("Failed to read");
-				return -1;
-			}
-		} while (bcsph[0] == 0xC0);
-
-		if (read_check(fd, &bcsph[1], 3) == -1){
-			perror("Failed to read");
-			return -1;
-		}
-
-		if (((bcsph[0] + bcsph[1] + bcsph[2]) & 0xFF) != (unsigned char)~bcsph[3])
-			continue;
-
-		if (bcsph[1] != 0x41 || bcsph[2] != 0x00)
-			continue;
-
-		if (read_check(fd, &bcspp, 4) == -1){
-			perror("Failed to read");
-			return -1;
-		}
-
-		if (!memcmp(bcspp, bcspsync, 4))
-			len = write(fd, &bcsp_sync_resp_pkt, 10);
-		else if (!memcmp(bcspp, bcspconf, 4))
-			len = write(fd, &bcsp_conf_resp_pkt, 10);
-		else if (!memcmp(bcspp, bcspconfresp,  4))
-			break;
-	}
-
-	/* State = garrulous */
-
-	return 0;
-}
-
-/*
- * CSR specific initialization
- * Inspired strongly by code in OpenBT and experimentations with Brainboxes
- * Pcmcia card.
- * Jean Tourrilhes <jt@hpl.hp.com> - 14.11.01
- */
-static int csr(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = {0, 10000000};	/* 10ms - be generous */
-	unsigned char cmd[30];		/* Command */
-	unsigned char resp[30];		/* Response */
-	int  clen = 0;		/* Command len */
-	static int csr_seq = 0;	/* Sequence number of command */
-	int  divisor;
-
-	/* It seems that if we set the CSR UART speed straight away, it
-	 * won't work, the CSR UART gets into a state where we can't talk
-	 * to it anymore.
-	 * On the other hand, doing a read before setting the CSR speed
-	 * seems to be ok.
-	 * Therefore, the strategy is to read the build ID (useful for
-	 * debugging) and only then set the CSR UART speed. Doing like
-	 * this is more complex but at least it works ;-)
-	 * The CSR UART control may be slow to wake up or something because
-	 * every time I read its speed, its bogus...
-	 * Jean II */
-
-	/* Try to read the build ID of the CSR chip */
-	clen = 5 + (5 + 6) * 2;
-	/* HCI header */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x00;		/* CSR command */
-	cmd[2] = 0xfc;		/* MANUFACTURER_SPEC */
-	cmd[3] = 1 + (5 + 6) * 2;	/* len */
-	/* CSR MSG header */
-	cmd[4] = 0xC2;		/* first+last+channel=BCC */
-	/* CSR BCC header */
-	cmd[5] = 0x00;		/* type = GET-REQ */
-	cmd[6] = 0x00;		/* - msB */
-	cmd[7] = 5 + 4;		/* len */
-	cmd[8] = 0x00;		/* - msB */
-	cmd[9] = csr_seq & 0xFF;/* seq num */
-	cmd[10] = (csr_seq >> 8) & 0xFF;	/* - msB */
-	csr_seq++;
-	cmd[11] = 0x19;		/* var_id = CSR_CMD_BUILD_ID */
-	cmd[12] = 0x28;		/* - msB */
-	cmd[13] = 0x00;		/* status = STATUS_OK */
-	cmd[14] = 0x00;		/* - msB */
-	/* CSR BCC payload */
-	memset(cmd + 15, 0, 6 * 2);
-
-	/* Send command */
-	do {
-		if (write(fd, cmd, clen) != clen) {
-			perror("Failed to write init command (GET_BUILD_ID)");
-			return -1;
-		}
-
-		/* Read reply. */
-		if (read_hci_event(fd, resp, 100) < 0) {
-			perror("Failed to read init response (GET_BUILD_ID)");
-			return -1;
-		}
-
-	/* Event code 0xFF is for vendor-specific events, which is
-	 * what we're looking for. */
-	} while (resp[1] != 0xFF);
-
-#ifdef CSR_DEBUG
-	{
-	char temp[512];
-	int i;
-	for (i=0; i < rlen; i++)
-		sprintf(temp + (i*3), "-%02X", resp[i]);
-	fprintf(stderr, "Reading CSR build ID %d [%s]\n", rlen, temp + 1);
-	// In theory, it should look like :
-	// 04-FF-13-FF-01-00-09-00-00-00-19-28-00-00-73-00-00-00-00-00-00-00
-	}
-#endif
-	/* Display that to user */
-	fprintf(stderr, "CSR build ID 0x%02X-0x%02X\n",
-		resp[15] & 0xFF, resp[14] & 0xFF);
-
-	/* Try to read the current speed of the CSR chip */
-	clen = 5 + (5 + 4)*2;
-	/* -- HCI header */
-	cmd[3] = 1 + (5 + 4)*2;	/* len */
-	/* -- CSR BCC header -- */
-	cmd[9] = csr_seq & 0xFF;	/* seq num */
-	cmd[10] = (csr_seq >> 8) & 0xFF;	/* - msB */
-	csr_seq++;
-	cmd[11] = 0x02;		/* var_id = CONFIG_UART */
-	cmd[12] = 0x68;		/* - msB */
-
-#ifdef CSR_DEBUG
-	/* Send command */
-	do {
-		if (write(fd, cmd, clen) != clen) {
-			perror("Failed to write init command (GET_BUILD_ID)");
-			return -1;
-		}
-
-		/* Read reply. */
-		if (read_hci_event(fd, resp, 100) < 0) {
-			perror("Failed to read init response (GET_BUILD_ID)");
-			return -1;
-		}
-
-	/* Event code 0xFF is for vendor-specific events, which is
-	 * what we're looking for. */
-	} while (resp[1] != 0xFF);
-
-	{
-	char temp[512];
-	int i;
-	for (i=0; i < rlen; i++)
-		sprintf(temp + (i*3), "-%02X", resp[i]);
-	fprintf(stderr, "Reading CSR UART speed %d [%s]\n", rlen, temp+1);
-	}
-#endif
-
-	if (u->speed > 1500000) {
-		fprintf(stderr, "Speed %d too high. Remaining at %d baud\n",
-			u->speed, u->init_speed);
-		u->speed = u->init_speed;
-	} else if (u->speed != 57600 && uart_speed(u->speed) == B57600) {
-		/* Unknown speed. Why oh why can't we just pass an int to the kernel? */
-		fprintf(stderr, "Speed %d unrecognised. Remaining at %d baud\n",
-			u->speed, u->init_speed);
-		u->speed = u->init_speed;
-	}
-	if (u->speed == u->init_speed)
-		return 0;
-
-	/* Now, create the command that will set the UART speed */
-	/* CSR BCC header */
-	cmd[5] = 0x02;			/* type = SET-REQ */
-	cmd[6] = 0x00;			/* - msB */
-	cmd[9] = csr_seq & 0xFF;	/* seq num */
-	cmd[10] = (csr_seq >> 8) & 0xFF;/* - msB */
-	csr_seq++;
-
-	divisor = (u->speed*64+7812)/15625;
-
-	/* No parity, one stop bit -> divisor |= 0x0000; */
-	cmd[15] = (divisor) & 0xFF;		/* divider */
-	cmd[16] = (divisor >> 8) & 0xFF;	/* - msB */
-	/* The rest of the payload will be 0x00 */
-
-#ifdef CSR_DEBUG
-	{
-	char temp[512];
-	int i;
-	for(i = 0; i < clen; i++)
-		sprintf(temp + (i*3), "-%02X", cmd[i]);
-	fprintf(stderr, "Writing CSR UART speed %d [%s]\n", clen, temp + 1);
-	// In theory, it should look like :
-	// 01-00-FC-13-C2-02-00-09-00-03-00-02-68-00-00-BF-0E-00-00-00-00-00-00
-	// 01-00-FC-13-C2-02-00-09-00-01-00-02-68-00-00-D8-01-00-00-00-00-00-00
-	}
-#endif
-
-	/* Send the command to set the CSR UART speed */
-	if (write(fd, cmd, clen) != clen) {
-		perror("Failed to write init command (SET_UART_SPEED)");
-		return -1;
-	}
-
-	nanosleep(&tm, NULL);
-	return 0;
-}
-
-/*
- * Atheros AR3xxx specific initialization code with power management disabled.
- * Suraj Sumangala <Suraj@Atheros.com>
- */
-static int ar3kpost(int fd, struct uart_t *u, struct termios *ti)
-{
-	int dev_id, dd;
-	struct timespec tm = {0, 50000};
-	int status = 0;
-
-	ATH_INFO("");
-
-	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
-	if (dev_id < 0) {
-		perror("cannot get device id");
-		return -1;
-	}
-	ATH_INFO("ioctl(fd, HCIUARTGETDEVICE, 0)");
-
-	dd = hci_open_dev(dev_id);
-	if (dd < 0) {
-		perror("HCI device open failed");
-		return -1;
-	}
-	ATH_INFO("hci_open_dev");
-
-	sleep(2);
-
-	/* send vendor specific command with Sleep feature disabled */
-	hci_send_cmd(dd, OGF_VENDOR_CMD, 0x04, 1, &status);
-	ATH_INFO("Send vendor specific command with Sleep feature disabled");
-
-	nanosleep(&tm, NULL);
-	hci_close_dev(dd);
-
-	return 0;
-
-}
-/*
- * Atheros AR3xxx specific initialization post callback
- *  with power management enabled
- * Suraj Sumangala <Suraj@Atheros.com>
- */
-static int ar3kpmpost(int fd, struct uart_t *u, struct termios *ti)
-{
-	int dev_id, dd;
-	struct timespec tm = {0, 50000};
-	int status = 1;
-
-	ATH_INFO("");
-
-	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
-	if (dev_id < 0) {
-		perror("cannot get device id");
-		return -1;
-	}
-	ATH_INFO("ioctl(fd, HCIUARTGETDEVICE, 0)");
-
-	dd = hci_open_dev(dev_id);
-	if (dd < 0) {
-		perror("HCI device open failed");
-		return -1;
-	}
-	ATH_INFO("hci_open_dev");
-
-	sleep(2);
-
-	/* send vendor specific command with Sleep feature Enabled */
-	if (hci_send_cmd(dd, OGF_VENDOR_CMD, 0x04, 1, &status) < 0)
-		perror("sleep enable command not sent");
-
-	ATH_INFO("Send vendor specific command with Sleep feature Enabled");
-
-	nanosleep(&tm, NULL);
-	hci_close_dev(dd);
-
-	return 0;
-}
-/*
- * Atheros AR3xxx specific initialization
- * Suraj Sumangala <Suraj@Atheros.com>
- */
-static int ar3kinit(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = { 0, 500000 };
-	unsigned char cmd[14], rsp[100];
-	int r;
-	int baud;
-
-	ATH_INFO("");
-
-	/* Download PS and patch */
-	r = ath_ps_download(fd);
-	if (r < 0) {
-		perror("Failed to Download configuration");
-		return -1;
-	}
-	ATH_INFO("Download PS and patch");
-
-	/* Write BDADDR if user has provided any */
-	if (u->bdaddr != NULL) {
-		/* Set BD_ADDR */
-		memset(cmd, 0, sizeof(cmd));
-		memset(rsp, 0, sizeof(rsp));
-		cmd[0] = HCI_COMMAND_PKT;
-		cmd[1] = 0x0B;
-		cmd[2] = 0xfc;
-		cmd[3] = 0x0A;
-		cmd[4] = 0x01;
-		cmd[5] = 0x01;
-		cmd[6] = 0x00;
-		cmd[7] = 0x06;
-		str2ba(u->bdaddr, (bdaddr_t *) (cmd + 8));
-
-		/* Send command */
-		if (write(fd, cmd, 14) != 14) {
-			fprintf(stderr, "Failed to write BD_ADDR command\n");
-			return -1;
-		}
-
-		/* Read reply */
-		if (read_hci_event(fd, rsp, 10) < 0) {
-			fprintf(stderr, "Failed to set BD_ADDR\n");
-			return -1;
-		}
-		ATH_INFO("Write BDADDR");
-	}
-
-	/* Send HCI Reset to write the configuration */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x03;
-	cmd[2] = 0x0c;
-	cmd[3] = 0x00;
-	/* Send reset command */
-	r = write(fd, cmd, 4);
-
-	if (r != 4)
-		return -1;
-
-	nanosleep(&tm, NULL);
-	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
-		return -1;
-	ATH_INFO("Send HCI Reset");
-
-	/* Set baud rate command,
-	 * set controller baud rate to user specified value */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x0C;
-	cmd[2] = 0xfc;
-	cmd[3] = 0x02;
-	baud = u->speed/100;
-	cmd[4] = (char)baud;
-	cmd[5] = (char)(baud >> 8);
-
-	if (write(fd, cmd, 6) != 6) {
-		perror("Failed to write init command");
-		return -1;
-	}
-
-	/* Wait for the command complete event for Baud rate change Command */
-	nanosleep(&tm, NULL);
-	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
-		return -1;
-	ATH_INFO("Set baud rate command");
-
-	return 0;
-}
-/*
- * Silicon Wave specific initialization
- * Thomas Moser <thomas.moser@tmoser.ch>
- */
-static int swave(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = { 0, 500000 };
-	char cmd[10], rsp[100];
-	int r;
-
-	// Silicon Wave set baud rate command
-	// see HCI Vendor Specific Interface from Silicon Wave
-	// first send a "param access set" command to set the
-	// appropriate data fields in RAM. Then send a "HCI Reset
-	// Subcommand", e.g. "soft reset" to make the changes effective.
-
-	cmd[0] = HCI_COMMAND_PKT;	// it's a command packet
-	cmd[1] = 0x0B;			// OCF 0x0B	= param access set
-	cmd[2] = 0xfc;			// OGF bx111111 = vendor specific
-	cmd[3] = 0x06;			// 6 bytes of data following
-	cmd[4] = 0x01;			// param sub command
-	cmd[5] = 0x11;			// tag 17 = 0x11 = HCI Transport Params
-	cmd[6] = 0x03;			// length of the parameter following
-	cmd[7] = 0x01;			// HCI Transport flow control enable
-	cmd[8] = 0x01;			// HCI Transport Type = UART
-
-	switch (u->speed) {
-	case 19200:
-		cmd[9] = 0x03;
-		break;
-	case 38400:
-		cmd[9] = 0x02;
-		break;
-	case 57600:
-		cmd[9] = 0x01;
-		break;
-	case 115200:
-		cmd[9] = 0x00;
-		break;
-	default:
-		u->speed = 115200;
-		cmd[9] = 0x00;
-		break;
-	}
-
-	/* Send initialization command */
-	if (write(fd, cmd, 10) != 10) {
-		perror("Failed to write init command");
-		return -1;
-	}
-
-	// We should wait for a "GET Event" to confirm the success of
-	// the baud rate setting. Wait some time before reading. Better:
-	// read with timeout, parse data
-	// until correct answer, else error handling ... todo ...
-
-	nanosleep(&tm, NULL);
-
-	r = read(fd, rsp, sizeof(rsp));
-	if (r > 0) {
-		// guess it's okay, but we should parse the reply. But since
-		// I don't react on an error anyway ... todo
-		// Response packet format:
-		//  04	Event
-		//  FF	Vendor specific
-		//  07	Parameter length
-		//  0B	Subcommand
-		//  01	Setevent
-		//  11	Tag specifying HCI Transport Layer Parameter
-		//  03	length
-		//  01	flow on
-		//  01 	Hci Transport type = Uart
-		//  xx	Baud rate set (see above)
-	} else {
-		// ups, got error.
-		return -1;
-	}
-
-	// we probably got the reply. Now we must send the "soft reset"
-	// which is standard HCI RESET.
-
-	cmd[0] = HCI_COMMAND_PKT;	// it's a command packet
-	cmd[1] = 0x03;
-	cmd[2] = 0x0c;
-	cmd[3] = 0x00;
-
-	/* Send reset command */
-	if (write(fd, cmd, 4) != 4) {
-		perror("Can't write Silicon Wave reset cmd.");
-		return -1;
-	}
-
-	nanosleep(&tm, NULL);
-
-	// now the uart baud rate on the silicon wave module is set and effective.
-	// change our own baud rate as well. Then there is a reset event comming in
- 	// on the *new* baud rate. This is *undocumented*! The packet looks like this:
-	// 04 FF 01 0B (which would make that a confirmation of 0x0B = "Param
-	// subcommand class". So: change to new baud rate, read with timeout, parse
-	// data, error handling. BTW: all param access in Silicon Wave is done this way.
-	// Maybe this code would belong in a seperate file, or at least code reuse...
-
-	return 0;
-}
-
-/*
- * ST Microelectronics specific initialization
- * Marcel Holtmann <marcel@holtmann.org>
- */
-static int st(int fd, struct uart_t *u, struct termios *ti)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[5];
-
-	/* ST Microelectronics set baud rate command */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x46;			// OCF = Hci_Cmd_ST_Set_Uart_Baud_Rate
-	cmd[2] = 0xfc;			// OGF = Vendor specific
-	cmd[3] = 0x01;
-
-	switch (u->speed) {
-	case 9600:
-		cmd[4] = 0x09;
-		break;
-	case 19200:
-		cmd[4] = 0x0b;
-		break;
-	case 38400:
-		cmd[4] = 0x0d;
-		break;
-	case 57600:
-		cmd[4] = 0x0e;
-		break;
-	case 115200:
-		cmd[4] = 0x10;
-		break;
-	case 230400:
-		cmd[4] = 0x12;
-		break;
-	case 460800:
-		cmd[4] = 0x13;
-		break;
-	case 921600:
-		cmd[4] = 0x14;
-		break;
-	default:
-		cmd[4] = 0x10;
-		u->speed = 115200;
-		break;
-	}
-
-	/* Send initialization command */
-	if (write(fd, cmd, 5) != 5) {
-		perror("Failed to write init command");
-		return -1;
-	}
-
-	nanosleep(&tm, NULL);
-	return 0;
-}
-
-static int stlc2500(int fd, struct uart_t *u, struct termios *ti)
-{
-	bdaddr_t bdaddr;
-	unsigned char resp[10];
-	int n;
-	int rvalue;
-
-	/* STLC2500 has an ericsson core */
-	rvalue = ericsson(fd, u, ti);
-	if (rvalue != 0)
-		return rvalue;
-
-#ifdef STLC2500_DEBUG
-	fprintf(stderr, "Setting speed\n");
-#endif
-	if (set_speed(fd, ti, u->speed) < 0) {
-		perror("Can't set baud rate");
-		return -1;
-	}
-
-#ifdef STLC2500_DEBUG
-	fprintf(stderr, "Speed set...\n");
-#endif
-
-	/* Read reply */
-	if ((n = read_hci_event(fd, resp, 10)) < 0) {
-		fprintf(stderr, "Failed to set baud rate on chip\n");
-		return -1;
-	}
-
-#ifdef STLC2500_DEBUG
-	for (i = 0; i < n; i++) {
-		fprintf(stderr, "resp[%d] = %02x\n", i, resp[i]);
-	}
-#endif
-
-	str2ba(u->bdaddr, &bdaddr);
-	return stlc2500_init(fd, &bdaddr);
-}
-
-static int bgb2xx(int fd, struct uart_t *u, struct termios *ti)
-{
-	bdaddr_t bdaddr;
-
-	str2ba(u->bdaddr, &bdaddr);
-
-	return bgb2xx_init(fd, &bdaddr);
-}
-
-/*
- * Broadcom specific initialization
- * Extracted from Jungo openrg
- */
-static int bcm2035(int fd, struct uart_t *u, struct termios *ti)
-{
-	int n;
-	unsigned char cmd[30], resp[30];
-
-	/* Reset the BT Chip */
-	memset(cmd, 0, sizeof(cmd));
-	memset(resp, 0, sizeof(resp));
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x03;
-	cmd[2] = 0x0c;
-	cmd[3] = 0x00;
-
-	/* Send command */
-	if (write(fd, cmd, 4) != 4) {
-		fprintf(stderr, "Failed to write reset command\n");
-		return -1;
-	}
-
-	/* Read reply */
-	if ((n = read_hci_event(fd, resp, 4)) < 0) {
-		fprintf(stderr, "Failed to reset chip\n");
-		return -1;
-	}
-
-	if (u->bdaddr != NULL) {
-		/* Set BD_ADDR */
-		memset(cmd, 0, sizeof(cmd));
-		memset(resp, 0, sizeof(resp));
-		cmd[0] = HCI_COMMAND_PKT;
-		cmd[1] = 0x01;
-		cmd[2] = 0xfc;
-		cmd[3] = 0x06;
-		str2ba(u->bdaddr, (bdaddr_t *) (cmd + 4));
-
-		/* Send command */
-		if (write(fd, cmd, 10) != 10) {
-			fprintf(stderr, "Failed to write BD_ADDR command\n");
-			return -1;
-		}
-
-		/* Read reply */
-		if ((n = read_hci_event(fd, resp, 10)) < 0) {
-			fprintf(stderr, "Failed to set BD_ADDR\n");
-			return -1;
-		}
-	}
-
-	/* Read the local version info */
-	memset(cmd, 0, sizeof(cmd));
-	memset(resp, 0, sizeof(resp));
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x01;
-	cmd[2] = 0x10;
-	cmd[3] = 0x00;
-
-	/* Send command */
-	if (write(fd, cmd, 4) != 4) {
-		fprintf(stderr, "Failed to write \"read local version\" "
-			"command\n");
-		return -1;
-	}
-
-	/* Read reply */
-	if ((n = read_hci_event(fd, resp, 4)) < 0) {
-		fprintf(stderr, "Failed to read local version\n");
-		return -1;
-	}
-
-	/* Read the local supported commands info */
-	memset(cmd, 0, sizeof(cmd));
-	memset(resp, 0, sizeof(resp));
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x02;
-	cmd[2] = 0x10;
-	cmd[3] = 0x00;
-
-	/* Send command */
-	if (write(fd, cmd, 4) != 4) {
-		fprintf(stderr, "Failed to write \"read local supported "
-						"commands\" command\n");
-		return -1;
-	}
-
-	/* Read reply */
-	if ((n = read_hci_event(fd, resp, 4)) < 0) {
-		fprintf(stderr, "Failed to read local supported commands\n");
-		return -1;
-	}
-
-	/* Set the baud rate */
-	memset(cmd, 0, sizeof(cmd));
-	memset(resp, 0, sizeof(resp));
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x18;
-	cmd[2] = 0xfc;
-	cmd[3] = 0x02;
-	switch (u->speed) {
-	case 57600:
-		cmd[4] = 0x00;
-		cmd[5] = 0xe6;
-		break;
-	case 230400:
-		cmd[4] = 0x22;
-		cmd[5] = 0xfa;
-		break;
-	case 460800:
-		cmd[4] = 0x22;
-		cmd[5] = 0xfd;
-		break;
-	case 921600:
-		cmd[4] = 0x55;
-		cmd[5] = 0xff;
-		break;
-	default:
-		/* Default is 115200 */
-		cmd[4] = 0x00;
-		cmd[5] = 0xf3;
-		break;
-	}
-	fprintf(stderr, "Baud rate parameters: DHBR=0x%2x,DLBR=0x%2x\n",
-		cmd[4], cmd[5]);
-
-	/* Send command */
-	if (write(fd, cmd, 6) != 6) {
-		fprintf(stderr, "Failed to write \"set baud rate\" command\n");
-		return -1;
-	}
-
-	if ((n = read_hci_event(fd, resp, 6)) < 0) {
-		fprintf(stderr, "Failed to set baud rate\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-struct uart_t uart[] = {
-	{ "any",        0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, NULL     },
-
-	{ "ericsson",   0x0000, 0x0000, HCI_UART_H4,   57600,  115200,
-				FLOW_CTL, DISABLE_PM, NULL, ericsson },
-
-	{ "digi",       0x0000, 0x0000, HCI_UART_H4,   9600,   115200,
-				FLOW_CTL, DISABLE_PM, NULL, digi     },
-
-	{ "bcsp",       0x0000, 0x0000, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter */
-	{ "xircom",     0x0105, 0x080a, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM,  NULL, NULL     },
-
-	/* CSR Casira serial adapter or BrainBoxes serial dongle (BL642) */
-	{ "csr",        0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, csr      },
-
-	/* BrainBoxes PCMCIA card (BL620) */
-	{ "bboxes",     0x0160, 0x0002, HCI_UART_H4,   115200, 460800,
-				FLOW_CTL, DISABLE_PM, NULL, csr      },
-
-	/* Silicon Wave kits */
-	{ "swave",      0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, swave    },
-
-	/* Texas Instruments Bluelink (BRF) modules */
-	{ "texas",      0x0000, 0x0000, HCI_UART_LL,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, texas,    texas2 },
-
-	{ "texasalt",   0x0000, 0x0000, HCI_UART_LL,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, texasalt, NULL   },
-
-	/* ST Microelectronics minikits based on STLC2410/STLC2415 */
-	{ "st",         0x0000, 0x0000, HCI_UART_H4,    57600, 115200,
-				FLOW_CTL, DISABLE_PM,  NULL, st       },
-
-	/* ST Microelectronics minikits based on STLC2500 */
-	{ "stlc2500",   0x0000, 0x0000, HCI_UART_H4, 115200, 115200,
-			FLOW_CTL, DISABLE_PM, "00:80:E1:00:AB:BA", stlc2500 },
-
-	/* Philips generic Ericsson IP core based */
-	{ "philips",    0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, NULL     },
-
-	/* Philips BGB2xx Module */
-	{ "bgb2xx",    0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-			FLOW_CTL, DISABLE_PM, "BD:B2:10:00:AB:BA", bgb2xx },
-
-	/* Sphinx Electronics PICO Card */
-	{ "picocard",   0x025e, 0x1000, HCI_UART_H4, 115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, NULL     },
-
-	/* Inventel BlueBird Module */
-	{ "inventel",   0x0000, 0x0000, HCI_UART_H4, 115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, NULL     },
-
-	/* COM One Platinium Bluetooth PC Card */
-	{ "comone",     0xffff, 0x0101, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM,  NULL, bcsp     },
-
-	/* TDK Bluetooth PC Card and IBM Bluetooth PC Card II */
-	{ "tdk",        0x0105, 0x4254, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* Socket Bluetooth CF Card (Rev G) */
-	{ "socket",     0x0104, 0x0096, HCI_UART_BCSP, 230400, 230400,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* 3Com Bluetooth Card (Version 3.0) */
-	{ "3com",       0x0101, 0x0041, HCI_UART_H4,   115200, 115200,
-				FLOW_CTL, DISABLE_PM, NULL, csr      },
-
-	/* AmbiCom BT2000C Bluetooth PC/CF Card */
-	{ "bt2000c",    0x022d, 0x2000, HCI_UART_H4,    57600, 460800,
-				FLOW_CTL, DISABLE_PM, NULL, csr      },
-
-	/* Zoom Bluetooth PCMCIA Card */
-	{ "zoom",       0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* Sitecom CN-504 PCMCIA Card */
-	{ "sitecom",    0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* Billionton PCBTC1 PCMCIA Card */
-	{ "billionton", 0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200,
-				0, DISABLE_PM, NULL, bcsp     },
-
-	/* Broadcom BCM2035 */
-	{ "bcm2035",    0x0A5C, 0x2035, HCI_UART_H4,   115200, 460800,
-				FLOW_CTL, DISABLE_PM, NULL, bcm2035  },
-
-	{ "ath3k",    0x0000, 0x0000, HCI_UART_ATH3K, 115200, 115200,
-			FLOW_CTL, DISABLE_PM, NULL, ath3k_ps, ath3k_pm  },
-
-	/* QUALCOMM BTS */
-	{ "qualcomm",   0x0000, 0x0000, HCI_UART_H4,   115200, 115200,
-			FLOW_CTL, DISABLE_PM, NULL, qualcomm, NULL },
-
-	{ NULL, 0 }
-};
-
-static struct uart_t * get_by_id(int m_id, int p_id)
-{
-	int i;
-	for (i = 0; uart[i].type; i++) {
-		if (uart[i].m_id == m_id && uart[i].p_id == p_id)
-			return &uart[i];
-	}
-	return NULL;
-}
-
-static struct uart_t * get_by_type(char *type)
-{
-	int i;
-	for (i = 0; uart[i].type; i++) {
-		if (!strcmp(uart[i].type, type))
-			return &uart[i];
-	}
-	return NULL;
-}
-
-/* Initialize UART driver */
-static int init_uart(char *dev, struct uart_t *u, int send_break, int raw)
-{
-	struct termios ti;
-	int fd, i;
-	unsigned long flags = 0;
-
-	if (raw)
-		flags |= 1 << HCI_UART_RAW_DEVICE;
-
-	fd = open(dev, O_RDWR | O_NOCTTY);
-	if (fd < 0) {
-		perror("Can't open serial port");
-		return -1;
-	}
-	ATH_INFO("Serial port is opened");
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (tcgetattr(fd, &ti) < 0) {
-		perror("Can't get port settings");
-		return -1;
-	}
-	ATH_INFO("Port settings is gotten");
-
-	cfmakeraw(&ti);
-
-	ti.c_cflag |= CLOCAL;
-	if (u->flags & FLOW_CTL)
-		ti.c_cflag |= CRTSCTS;
-	else
-		ti.c_cflag &= ~CRTSCTS;
-
-	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
-		perror("Can't set port settings");
-		return -1;
-	}
-	ATH_INFO("Port settings is set");
-
-	/* Set initial baudrate */
-	if (set_speed(fd, &ti, u->init_speed) < 0) {
-		perror("Can't set initial baud rate");
-		return -1;
-	}
-	ATH_INFO("Initial baud rate is set");
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (send_break) {
-		tcsendbreak(fd, 0);
-		usleep(500000);
-	}
-	ATH_INFO("Break is sent");
-
-	if (u->init && u->init(fd, u, &ti) < 0)
-		return -1;
-	ATH_INFO("u->init is loaded");
-
-	tcflush(fd, TCIOFLUSH);
-
-	/* Set actual baudrate */
-	if (set_speed(fd, &ti, u->speed) < 0) {
-		perror("Can't set baud rate");
-		return -1;
-	}
-	ATH_INFO("Actual baud rate is set");
-
-	/* Set TTY to N_HCI line discipline */
-	i = N_HCI;
-	if (ioctl(fd, TIOCSETD, &i) < 0) {
-		perror("Can't set line discipline");
-		return -1;
-	}
-	ATH_INFO("Line discipline is set");
-
-	if (flags && ioctl(fd, HCIUARTSETFLAGS, flags) < 0) {
-		perror("Can't set UART flags");
-		return -1;
-	}
-
-	if (ioctl(fd, HCIUARTSETPROTO, u->proto) < 0) {
-		perror("Can't set device");
-		return -1;
-	}
-	ATH_INFO("Ioctl device is set");
-
-	if (u->post && u->post(fd, u, &ti) < 0)
-		return -1;
-	ATH_INFO("u->post is loaded");
-
-	return fd;
-}
-
-static void usage(void)
-{
-	printf("hciattach - HCI UART driver initialization utility\n");
-	printf("Usage:\n");
-	printf("\thciattach [-n] [-p] [-b] [-r] [-t timeout] [-s initial_speed] <tty> <type | id> [speed] [flow|noflow] [bdaddr]\n");
-	printf("\thciattach -l\n");
-}
-
-int main(int argc, char *argv[])
-{
-	struct uart_t *u = NULL;
-	int detach, printpid, raw, opt, i, n, ld, err;
-	int to = 10;
-	int init_speed = 0;
-	int send_break = 0;
-	pid_t pid;
-	struct sigaction sa;
-	struct pollfd p;
-	sigset_t sigs;
-	char dev[PATH_MAX];
-
-	detach = 1;
-	printpid = 0;
-	raw = 0;
-
-	while ((opt=getopt(argc, argv, "bnpt:s:lr")) != EOF) {
-		switch(opt) {
-		case 'b':
-			send_break = 1;
-			break;
-
-		case 'n':
-			detach = 0;
-			break;
-
-		case 'p':
-			printpid = 1;
-			break;
-
-		case 't':
-			to = atoi(optarg);
-			break;
-
-		case 's':
-			init_speed = atoi(optarg);
-			break;
-
-		case 'l':
-			for (i = 0; uart[i].type; i++) {
-				printf("%-10s0x%04x,0x%04x\n", uart[i].type,
-							uart[i].m_id, uart[i].p_id);
-			}
-			exit(0);
-
-		case 'r':
-			raw = 1;
-			break;
-
-		default:
-			usage();
-			exit(1);
-		}
-	}
-
-	n = argc - optind;
-	if (n < 2) {
-		usage();
-		exit(1);
-	}
-
-	for (n = 0; optind < argc; n++, optind++) {
-		char *opt;
-
-		opt = argv[optind];
-
-		switch(n) {
-		case 0:
-			dev[0] = 0;
-			if (!strchr(opt, '/'))
-				strcpy(dev, "/dev/");
-			strcat(dev, opt);
-			break;
-
-		case 1:
-			if (strchr(argv[optind], ',')) {
-				int m_id, p_id;
-				sscanf(argv[optind], "%x,%x", &m_id, &p_id);
-				u = get_by_id(m_id, p_id);
-			} else {
-				u = get_by_type(opt);
-			}
-
-			if (!u) {
-				fprintf(stderr, "Unknown device type or id\n");
-				exit(1);
-			}
-
-			break;
-
-		case 2:
-			u->speed = atoi(argv[optind]);
-			break;
-
-		case 3:
-			if (!strcmp("flow", argv[optind]))
-				u->flags |=  FLOW_CTL;
-			else
-				u->flags &= ~FLOW_CTL;
-			break;
-
-		case 4:
-			if (!strcmp("sleep", argv[optind]))
-				u->pm = ENABLE_PM;
-			else
-				u->pm = DISABLE_PM;
-			break;
-
-		case 5:
-			u->bdaddr = argv[optind];
-			break;
-		}
-	}
-
-	if (!u) {
-		fprintf(stderr, "Unknown device type or id\n");
-		exit(1);
-	}
-
-	/* If user specified a initial speed, use that instead of
-	   the hardware's default */
-	if (init_speed)
-		u->init_speed = init_speed;
-
-	memset(&sa, 0, sizeof(sa));
-	sa.sa_flags   = SA_NOCLDSTOP;
-	sa.sa_handler = sig_alarm;
-	sigaction(SIGALRM, &sa, NULL);
-
-	/* 10 seconds should be enough for initialization */
-	alarm(to);
-	bcsp_max_retries = to;
-
-	n = init_uart(dev, u, send_break, raw);
-	if (n < 0) {
-		perror("Can't initialize device");
-		exit(1);
-	}
-
-	printf("Device setup complete\n");
-
-	alarm(0);
-
-	memset(&sa, 0, sizeof(sa));
-	sa.sa_flags   = SA_NOCLDSTOP;
-	sa.sa_handler = SIG_IGN;
-	sigaction(SIGCHLD, &sa, NULL);
-	sigaction(SIGPIPE, &sa, NULL);
-
-	sa.sa_handler = sig_term;
-	sigaction(SIGTERM, &sa, NULL);
-	sigaction(SIGINT,  &sa, NULL);
-
-	sa.sa_handler = sig_hup;
-	sigaction(SIGHUP, &sa, NULL);
-
-	if (detach) {
-		if ((pid = fork())) {
-			if (printpid)
-				printf("%d\n", pid);
-			return 0;
-		}
-
-		for (i = 0; i < 20; i++)
-			if (i != n)
-				close(i);
-	}
-
-	p.fd = n;
-	p.events = POLLERR | POLLHUP;
-
-	sigfillset(&sigs);
-	sigdelset(&sigs, SIGCHLD);
-	sigdelset(&sigs, SIGPIPE);
-	sigdelset(&sigs, SIGTERM);
-	sigdelset(&sigs, SIGINT);
-	sigdelset(&sigs, SIGHUP);
-
-	while (!__io_canceled) {
-		p.revents = 0;
-		err = ppoll(&p, 1, NULL, &sigs);
-		if (err < 0 && errno == EINTR)
-			continue;
-		if (err)
-			break;
-	}
-
-	/* Restore TTY line discipline */
-	ld = N_TTY;
-	if (ioctl(n, TIOCSETD, &ld) < 0) {
-		perror("Can't restore line discipline");
-		exit(1);
-	}
-
-	return 0;
-}
diff --git a/test/ar3k_bt/hciattach.h b/test/ar3k_bt/hciattach.h
deleted file mode 100755
index 2ad48ff..0000000
--- a/test/ar3k_bt/hciattach.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#include <termios.h>
-
-#define ATH_DBG(fmt, arg...)  fprintf(stderr, "[ATH_DBG] (%s) <%s>: " fmt "\n" , __FILE__ , __func__ , ## arg)
-#define ATH_INFO(fmt, arg...)  fprintf(stderr, "[ATH_INFO] (%s) <%s>: " fmt "\n" , __FILE__ , __func__ , ## arg)
-
-#ifndef N_HCI
-#define N_HCI	15
-#endif
-
-#define HCIUARTSETPROTO		_IOW('U', 200, int)
-#define HCIUARTGETPROTO		_IOR('U', 201, int)
-#define HCIUARTGETDEVICE	_IOR('U', 202, int)
-#define HCIUARTSETFLAGS		_IOW('U', 203, int)
-#define HCIUARTGETFLAGS		_IOR('U', 204, int)
-
-#define HCI_UART_H4	0
-#define HCI_UART_BCSP	1
-#define HCI_UART_3WIRE	2
-#define HCI_UART_H4DS	3
-#define HCI_UART_LL	4
-#define HCI_UART_ATH3K  5
-
-#define HCI_UART_RAW_DEVICE	0
-
-int read_hci_event(int fd, unsigned char* buf, int size);
-int set_speed(int fd, struct termios *ti, int speed);
-
-int texas_init(int fd, struct termios *ti);
-int texas_post(int fd, struct termios *ti);
-int texasalt_init(int fd, int speed, struct termios *ti);
-int stlc2500_init(int fd, bdaddr_t *bdaddr);
-int bgb2xx_init(int dd, bdaddr_t *bdaddr);
-int ath3k_init(int fd, int speed, int init_speed, char *bdaddr,
-						struct termios *ti);
-int ath3k_post(int fd, int pm);
-int qualcomm_init(int fd, int speed, struct termios *ti, const char *bdaddr);
diff --git a/test/ar3k_bt/hciattach_ath3k.c b/test/ar3k_bt/hciattach_ath3k.c
deleted file mode 100644
index 9285f69..0000000
--- a/test/ar3k_bt/hciattach_ath3k.c
+++ /dev/null
@@ -1,1053 +0,0 @@
-/*
- *  Copyright (c) 2009-2010 Atheros Communications Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/ioctl.h>
-
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/hci_lib.h>
-
-#include "hciattach.h"
-
-#define TRUE    1
-#define FALSE   0
-
-#ifdef ANDROID_OS
-#define FW_PATH                         "/system/lib/firmware/ar3k/"
-#else
-#define FW_PATH                         "/lib/firmware/ar3k/"
-#endif
-
-struct ps_cfg_entry {
-	uint32_t id;
-	uint32_t len;
-	uint8_t *data;
-};
-
-struct ps_entry_type {
-	unsigned char type;
-	unsigned char array;
-};
-
-#define MAX_TAGS              50
-#define PS_HDR_LEN            4
-#define HCI_VENDOR_CMD_OGF    0x3F
-#define HCI_PS_CMD_OCF        0x0B
-
-struct ps_cfg_entry ps_list[MAX_TAGS];
-
-static void load_hci_ps_hdr(uint8_t *cmd, uint8_t ps_op, int len, int index)
-{
-	hci_command_hdr *ch = (void *)cmd;
-
-	ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-						HCI_PS_CMD_OCF));
-	ch->plen = len + PS_HDR_LEN;
-	cmd += HCI_COMMAND_HDR_SIZE;
-
-	cmd[0] = ps_op;
-	cmd[1] = index;
-	cmd[2] = index >> 8;
-	cmd[3] = len;
-}
-
-#define PS_EVENT_LEN 100
-
-/*
- * Send HCI command and wait for command complete event.
- * The event buffer has to be freed by the caller.
- */
-static int send_hci_cmd_sync(int dev, uint8_t *cmd, int len, uint8_t **event)
-{
-	int err;
-	uint8_t *hci_event;
-	uint8_t pkt_type = HCI_COMMAND_PKT;
-
-	if (len == 0)
-		return len;
-
-	if (write(dev, &pkt_type, 1) != 1)
-		return -EILSEQ;
-	if (write(dev, (unsigned char *)cmd, len) != len)
-		return -EILSEQ;
-
-	hci_event = (uint8_t *)malloc(PS_EVENT_LEN);
-	if (!hci_event)
-		return -ENOMEM;
-
-	err = read_hci_event(dev, (unsigned char *)hci_event, PS_EVENT_LEN);
-	if (err > 0) {
-		*event = hci_event;
-	} else {
-		free(hci_event);
-		return -EILSEQ;
-	}
-
-	return len;
-}
-
-#define HCI_EV_SUCCESS        0x00
-
-static int read_ps_event(uint8_t *event, uint16_t ocf)
-{
-	hci_event_hdr *eh;
-	uint16_t opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF, ocf));
-
-	event++;
-
-	eh = (void *)event;
-	event += HCI_EVENT_HDR_SIZE;
-
-	if (eh->evt == EVT_CMD_COMPLETE) {
-		evt_cmd_complete *cc = (void *)event;
-
-		event += EVT_CMD_COMPLETE_SIZE;
-
-		if (cc->opcode == opcode && event[0] == HCI_EV_SUCCESS)
-			return 0;
-		else
-			return -EILSEQ;
-	}
-
-	return -EILSEQ;
-}
-
-static int write_cmd(int fd, uint8_t *buffer, int len)
-{
-	uint8_t *event;
-	int err;
-
-	err = send_hci_cmd_sync(fd, buffer, len, &event);
-	if (err < 0)
-		return err;
-
-	err = read_ps_event(event, HCI_PS_CMD_OCF);
-	if (event)
-		free(event);
-
-	return err;
-}
-
-#define PS_WRITE           1
-#define PS_RESET           2
-#define WRITE_PATCH        8
-#define ENABLE_PATCH       11
-
-#define HCI_PS_CMD_HDR_LEN 7
-
-#define PS_RESET_PARAM_LEN 6
-#define HCI_MAX_CMD_SIZE   260
-#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
-
-#define PS_ID_MASK         0xFF
-
-/* Sends PS commands using vendor specficic HCI commands */
-static int write_ps_cmd(int fd, uint8_t opcode, uint32_t ps_param)
-{
-	uint8_t cmd[HCI_MAX_CMD_SIZE];
-	uint32_t i;
-
-	switch (opcode) {
-	case ENABLE_PATCH:
-		load_hci_ps_hdr(cmd, opcode, 0, 0x00);
-
-		if (write_cmd(fd, cmd, HCI_PS_CMD_HDR_LEN) < 0)
-			return -EILSEQ;
-		break;
-
-	case PS_RESET:
-		load_hci_ps_hdr(cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
-
-		cmd[7] = 0x00;
-		cmd[PS_RESET_CMD_LEN - 2] = ps_param & PS_ID_MASK;
-		cmd[PS_RESET_CMD_LEN - 1] = (ps_param >> 8) & PS_ID_MASK;
-
-		if (write_cmd(fd, cmd, PS_RESET_CMD_LEN) < 0)
-			return -EILSEQ;
-		break;
-
-	case PS_WRITE:
-		for (i = 0; i < ps_param; i++) {
-			load_hci_ps_hdr(cmd, opcode, ps_list[i].len,
-							ps_list[i].id);
-
-			memcpy(&cmd[HCI_PS_CMD_HDR_LEN], ps_list[i].data,
-							ps_list[i].len);
-
-			if (write_cmd(fd, cmd, ps_list[i].len +
-						HCI_PS_CMD_HDR_LEN) < 0)
-				return -EILSEQ;
-		}
-		break;
-	}
-
-	return 0;
-}
-
-#define __is_delim(ch) ((ch) == ':')
-#define MAX_PREAMBLE_LEN 4
-
-/* Parse PS entry preamble of format [X:X] for main type and subtype */
-static int get_ps_type(char *ptr, int index, char *type, char *sub_type)
-{
-	int i;
-	int delim = FALSE;
-
-	if (index > MAX_PREAMBLE_LEN)
-		return -EILSEQ;
-
-	for (i = 1; i < index; i++) {
-		if (__is_delim(ptr[i])) {
-			delim = TRUE;
-			continue;
-		}
-
-		if (isalpha(ptr[i])) {
-			if (delim == FALSE)
-				(*type) = toupper(ptr[i]);
-			else
-				(*sub_type) = toupper(ptr[i]);
-		}
-	}
-
-	return 0;
-}
-
-#define ARRAY   'A'
-#define STRING  'S'
-#define DECIMAL 'D'
-#define BINARY  'B'
-
-#define PS_HEX           0
-#define PS_DEC           1
-
-static int get_input_format(char *buf, struct ps_entry_type *format)
-{
-	char *ptr = NULL;
-	char type = '\0';
-	char sub_type = '\0';
-
-	format->type = PS_HEX;
-	format->array = TRUE;
-
-	if (strstr(buf, "[") != buf)
-		return 0;
-
-	ptr = strstr(buf, "]");
-	if (!ptr)
-		return -EILSEQ;
-
-	if (get_ps_type(buf, ptr - buf, &type, &sub_type) < 0)
-		return -EILSEQ;
-
-	/* Check is data type is of array */
-	if (type == ARRAY || sub_type == ARRAY)
-		format->array = TRUE;
-
-	if (type == STRING || sub_type == STRING)
-		format->array = FALSE;
-
-	if (type == DECIMAL || type == BINARY)
-		format->type = PS_DEC;
-	else
-		format->type = PS_HEX;
-
-	return 0;
-}
-
-#define UNDEFINED 0xFFFF
-
-static unsigned int read_data_in_section(char *buf, struct ps_entry_type type)
-{
-	char *ptr = buf;
-
-	if (!buf)
-		return UNDEFINED;
-
-	if (buf == strstr(buf, "[")) {
-		ptr = strstr(buf, "]");
-		if (!ptr)
-			return UNDEFINED;
-
-		ptr++;
-	}
-
-	if (type.type == PS_HEX && type.array != TRUE)
-		return strtol(ptr, NULL, 16);
-
-	return UNDEFINED;
-}
-
-struct tag_info {
-	unsigned section;
-	unsigned line_count;
-	unsigned char_cnt;
-	unsigned byte_count;
-};
-
-static inline int update_char_count(const char *buf)
-{
-	char *end_ptr;
-
-	if (strstr(buf, "[") == buf) {
-		end_ptr = strstr(buf, "]");
-		if (!end_ptr)
-			return 0;
-		else
-			return (end_ptr - buf) + 1;
-	}
-
-	return 0;
-}
-
-/* Read PS entries as string, convert and add to Hex array */
-static void update_tag_data(struct ps_cfg_entry *tag,
-				struct tag_info *info, const char *ptr)
-{
-	char buf[3];
-
-	buf[2] = '\0';
-
-	strncpy(buf, &ptr[info->char_cnt], 2);
-	tag->data[info->byte_count] = strtol(buf, NULL, 16);
-	info->char_cnt += 3;
-	info->byte_count++;
-
-	strncpy(buf, &ptr[info->char_cnt], 2);
-	tag->data[info->byte_count] = strtol(buf, NULL, 16);
-	info->char_cnt += 3;
-	info->byte_count++;
-}
-
-#define PS_UNDEF   0
-#define PS_ID      1
-#define PS_LEN     2
-#define PS_DATA    3
-
-#define PS_MAX_LEN         500
-#define LINE_SIZE_MAX      (PS_MAX_LEN * 2)
-#define ENTRY_PER_LINE     16
-
-#define __check_comment(buf) (((buf)[0] == '/') && ((buf)[1] == '/'))
-#define __skip_space(str)      while (*(str) == ' ') ((str)++)
-
-static int ath_parse_ps(FILE *stream)
-{
-	char buf[LINE_SIZE_MAX + 1];
-	char *ptr;
-	uint8_t tag_cnt = 0;
-	int16_t byte_count = 0;
-	struct ps_entry_type format;
-	struct tag_info status = { 0, 0, 0, 0 };
-
-	do {
-		int read_count;
-		struct ps_cfg_entry *tag;
-
-		ptr = fgets(buf, LINE_SIZE_MAX, stream);
-		if (!ptr)
-			break;
-
-		__skip_space(ptr);
-		if (__check_comment(ptr))
-			continue;
-
-		/* Lines with a '#' will be followed by new PS entry */
-		if (ptr == strstr(ptr, "#")) {
-			if (status.section != PS_UNDEF) {
-				return -EILSEQ;
-			} else {
-				status.section = PS_ID;
-				continue;
-			}
-		}
-
-		tag = &ps_list[tag_cnt];
-
-		switch (status.section) {
-		case PS_ID:
-			if (get_input_format(ptr, &format) < 0)
-				return -EILSEQ;
-
-			tag->id = read_data_in_section(ptr, format);
-			status.section = PS_LEN;
-			break;
-
-		case PS_LEN:
-			if (get_input_format(ptr, &format) < 0)
-				return -EILSEQ;
-
-			byte_count = read_data_in_section(ptr, format);
-			if (byte_count > PS_MAX_LEN)
-				return -EILSEQ;
-
-			tag->len = byte_count;
-			tag->data = (uint8_t *)malloc(byte_count);
-
-			status.section = PS_DATA;
-			status.line_count = 0;
-			break;
-
-		case PS_DATA:
-			if (status.line_count == 0)
-				if (get_input_format(ptr, &format) < 0)
-					return -EILSEQ;
-
-			__skip_space(ptr);
-
-			status.char_cnt = update_char_count(ptr);
-
-			read_count = (byte_count > ENTRY_PER_LINE) ?
-					ENTRY_PER_LINE : byte_count;
-
-			if (format.type == PS_HEX && format.array == TRUE) {
-				while (read_count > 0) {
-					update_tag_data(tag, &status, ptr);
-					read_count -= 2;
-				}
-
-				if (byte_count > ENTRY_PER_LINE)
-					byte_count -= ENTRY_PER_LINE;
-				else
-					byte_count = 0;
-			}
-
-			status.line_count++;
-
-			if (byte_count == 0)
-				memset(&status, 0x00, sizeof(struct tag_info));
-
-			if (status.section == PS_UNDEF)
-				tag_cnt++;
-
-			if (tag_cnt == MAX_TAGS)
-				return -EILSEQ;
-			break;
-		}
-	} while (ptr);
-
-	return tag_cnt;
-}
-
-#define MAX_PATCH_CMD 244
-struct patch_entry {
-	int16_t len;
-	uint8_t data[MAX_PATCH_CMD];
-};
-
-#define SET_PATCH_RAM_ID	0x0D
-#define SET_PATCH_RAM_CMD_SIZE	11
-#define ADDRESS_LEN		4
-static int set_patch_ram(int dev, char *patch_loc, int len)
-{
-	int err;
-	uint8_t cmd[20];
-	int i, j;
-	char loc_byte[3];
-	uint8_t *event;
-	uint8_t *loc_ptr = &cmd[7];
-
-	if (!patch_loc)
-		return -1;
-
-	loc_byte[2] = '\0';
-
-	load_hci_ps_hdr(cmd, SET_PATCH_RAM_ID, ADDRESS_LEN, 0);
-
-	for (i = 0, j = 3; i < 4; i++, j--) {
-		loc_byte[0] = patch_loc[0];
-		loc_byte[1] = patch_loc[1];
-		loc_ptr[j] = strtol(loc_byte, NULL, 16);
-		patch_loc += 2;
-	}
-
-	err = send_hci_cmd_sync(dev, cmd, SET_PATCH_RAM_CMD_SIZE, &event);
-	if (err < 0)
-		return err;
-
-	err = read_ps_event(event, HCI_PS_CMD_OCF);
-
-	if (event)
-		free(event);
-
-	return err;
-}
-
-#define PATCH_LOC_KEY    "DA:"
-#define PATCH_LOC_STRING_LEN    8
-static int ps_patch_download(int fd, FILE *stream)
-{
-	char byte[3];
-	char ptr[MAX_PATCH_CMD + 1];
-	int byte_cnt;
-	int patch_count = 0;
-	char patch_loc[PATCH_LOC_STRING_LEN + 1];
-
-	byte[2] = '\0';
-
-	while (fgets(ptr, MAX_PATCH_CMD, stream)) {
-		if (strlen(ptr) <= 1)
-			continue;
-		else if (strstr(ptr, PATCH_LOC_KEY) == ptr) {
-			strncpy(patch_loc, &ptr[sizeof(PATCH_LOC_KEY) - 1],
-							PATCH_LOC_STRING_LEN);
-			if (set_patch_ram(fd, patch_loc, sizeof(patch_loc)) < 0)
-				return -1;
-		} else if (isxdigit(ptr[0]))
-			break;
-		else
-			return -1;
-	}
-
-	byte_cnt = strtol(ptr, NULL, 16);
-
-	while (byte_cnt > 0) {
-		int i;
-		uint8_t cmd[HCI_MAX_CMD_SIZE];
-		struct patch_entry patch;
-
-		if (byte_cnt > MAX_PATCH_CMD)
-			patch.len = MAX_PATCH_CMD;
-		else
-			patch.len = byte_cnt;
-
-		for (i = 0; i < patch.len; i++) {
-			if (!fgets(byte, 3, stream))
-				return -1;
-
-			patch.data[i] = strtoul(byte, NULL, 16);
-		}
-
-		load_hci_ps_hdr(cmd, WRITE_PATCH, patch.len, patch_count);
-		memcpy(&cmd[HCI_PS_CMD_HDR_LEN], patch.data, patch.len);
-
-		if (write_cmd(fd, cmd, patch.len + HCI_PS_CMD_HDR_LEN) < 0)
-			return -1;
-
-		patch_count++;
-		byte_cnt = byte_cnt - MAX_PATCH_CMD;
-	}
-
-	if (write_ps_cmd(fd, ENABLE_PATCH, 0) < 0)
-		return -1;
-
-	return patch_count;
-}
-
-#define PS_RAM_SIZE 2048
-
-static int ps_config_download(int fd, int tag_count)
-{
-	if (write_ps_cmd(fd, PS_RESET, PS_RAM_SIZE) < 0)
-		return -1;
-
-	if (tag_count > 0)
-		if (write_ps_cmd(fd, PS_WRITE, tag_count) < 0)
-			return -1;
-	return 0;
-}
-
-#define PS_ASIC_FILE			"PS_ASIC.pst"
-#define PS_FPGA_FILE			"PS_FPGA.pst"
-
-static void get_ps_file_name(uint32_t devtype, uint32_t rom_version,
-							char *path)
-{
-	char *filename;
-
-	if (devtype == 0xdeadc0de)
-		filename = PS_ASIC_FILE;
-	else
-		filename = PS_FPGA_FILE;
-
-	snprintf(path, MAXPATHLEN, "%s%x/%s", FW_PATH, rom_version, filename);
-}
-
-#define PATCH_FILE        "RamPatch.txt"
-#define FPGA_ROM_VERSION  0x99999999
-#define ROM_DEV_TYPE      0xdeadc0de
-
-static void get_patch_file_name(uint32_t dev_type, uint32_t rom_version,
-				uint32_t build_version, char *path)
-{
-	if (rom_version == FPGA_ROM_VERSION && dev_type != ROM_DEV_TYPE &&
-					dev_type != 0 && build_version == 1)
-		path[0] = '\0';
-	else
-		snprintf(path, MAXPATHLEN, "%s%x/%s",
-				FW_PATH, rom_version, PATCH_FILE);
-}
-
-#define VERIFY_CRC   9
-#define PS_REGION    1
-#define PATCH_REGION 2
-
-static int get_ath3k_crc(int dev)
-{
-	uint8_t cmd[7];
-	uint8_t *event;
-	int err;
-
-	load_hci_ps_hdr(cmd, VERIFY_CRC, 0, PS_REGION | PATCH_REGION);
-
-	err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
-	if (err < 0)
-		return err;
-	/* Send error code if CRC check patched */
-	if (read_ps_event(event, HCI_PS_CMD_OCF) >= 0)
-		err = -EILSEQ;
-
-	if (!event)
-		free(event);
-
-	return err;
-}
-
-#define DEV_REGISTER      0x4FFC
-#define GET_DEV_TYPE_OCF  0x05
-
-static int get_device_type(int dev, uint32_t *code)
-{
-	uint8_t cmd[8];
-	uint8_t *event;
-	uint32_t reg;
-	int err;
-	uint8_t *ptr = cmd;
-	hci_command_hdr *ch = (void *)cmd;
-
-	ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-						GET_DEV_TYPE_OCF));
-	ch->plen = 5;
-	ptr += HCI_COMMAND_HDR_SIZE;
-
-	ptr[0] = (uint8_t)DEV_REGISTER;
-	ptr[1] = (uint8_t)DEV_REGISTER >> 8;
-	ptr[2] = (uint8_t)DEV_REGISTER >> 16;
-	ptr[3] = (uint8_t)DEV_REGISTER >> 24;
-	ptr[4] = 0x04;
-
-	err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
-	if (err < 0)
-		return err;
-
-	err = read_ps_event(event, GET_DEV_TYPE_OCF);
-	if (err < 0)
-		goto cleanup;
-
-	reg = event[10];
-	reg = (reg << 8) | event[9];
-	reg = (reg << 8) | event[8];
-	reg = (reg << 8) | event[7];
-	*code = reg;
-
-cleanup:
-	if (event)
-		free(event);
-
-	return err;
-}
-
-#define GET_VERSION_OCF 0x1E
-
-static int read_ath3k_version(int pConfig, uint32_t *rom_version,
-					uint32_t *build_version)
-{
-	uint8_t cmd[3];
-	uint8_t *event;
-	int err;
-	int status;
-	hci_command_hdr *ch = (void *)cmd;
-
-	ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-						GET_VERSION_OCF));
-	ch->plen = 0;
-
-	err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
-	if (err < 0)
-		return err;
-
-	err = read_ps_event(event, GET_VERSION_OCF);
-	if (err < 0)
-		goto cleanup;
-
-	status = event[10];
-	status = (status << 8) | event[9];
-	status = (status << 8) | event[8];
-	status = (status << 8) | event[7];
-	*rom_version = status;
-
-	status = event[14];
-	status = (status << 8) | event[13];
-	status = (status << 8) | event[12];
-	status = (status << 8) | event[11];
-	*build_version = status;
-
-cleanup:
-	if (event)
-		free(event);
-
-	return err;
-}
-
-static void convert_bdaddr(char *str_bdaddr, char *bdaddr)
-{
-	char bdbyte[3];
-	char *str_byte = str_bdaddr;
-	int i, j;
-	int colon_present = 0;
-
-	if (strstr(str_bdaddr, ":"))
-		colon_present = 1;
-
-	bdbyte[2] = '\0';
-
-	/* Reverse the BDADDR to LSB first */
-	for (i = 0, j = 5; i < 6; i++, j--) {
-		bdbyte[0] = str_byte[0];
-		bdbyte[1] = str_byte[1];
-		bdaddr[j] = strtol(bdbyte, NULL, 16);
-
-		if (colon_present == 1)
-			str_byte += 3;
-		else
-			str_byte += 2;
-	}
-}
-
-static int write_bdaddr(int pConfig, char *bdaddr)
-{
-	uint8_t *event;
-	int err;
-	uint8_t cmd[13];
-	uint8_t *ptr = cmd;
-	hci_command_hdr *ch = (void *)cmd;
-
-	memset(cmd, 0, sizeof(cmd));
-
-	ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-						HCI_PS_CMD_OCF));
-	ch->plen = 10;
-	ptr += HCI_COMMAND_HDR_SIZE;
-
-	ptr[0] = 0x01;
-	ptr[1] = 0x01;
-	ptr[2] = 0x00;
-	ptr[3] = 0x06;
-
-	convert_bdaddr(bdaddr, (char *)&ptr[4]);
-
-	err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
-	if (err < 0)
-		return err;
-
-	err = read_ps_event(event, HCI_PS_CMD_OCF);
-
-	if (event)
-		free(event);
-
-	return err;
-}
-
-#define BDADDR_FILE "ar3kbdaddr.pst"
-
-static void write_bdaddr_from_file(int rom_version, int fd)
-{
-	FILE *stream;
-	char bdaddr[PATH_MAX];
-	char bdaddr_file[PATH_MAX];
-
-	snprintf(bdaddr_file, MAXPATHLEN, "%s%x/%s",
-			FW_PATH, rom_version, BDADDR_FILE);
-
-	stream = fopen(bdaddr_file, "r");
-	if (!stream)
-		return;
-
-	if (fgets(bdaddr, PATH_MAX - 1, stream))
-		write_bdaddr(fd, bdaddr);
-
-	fclose(stream);
-}
-
-int ath_ps_download(int fd)
-{
-	int err = 0;
-	int tag_count;
-	int patch_count = 0;
-	uint32_t rom_version = 0;
-	uint32_t build_version = 0;
-	uint32_t dev_type = 0;
-	char patch_file[PATH_MAX];
-	char ps_file[PATH_MAX];
-	FILE *stream;
-
-	/*
-	 * Verfiy firmware version. depending on it select the PS
-	 * config file to download.
-	 */
-	if (get_device_type(fd, &dev_type) < 0) {
-		err = -EILSEQ;
-		goto download_cmplete;
-	}
-
-	if (read_ath3k_version(fd, &rom_version, &build_version) < 0) {
-		err = -EILSEQ;
-		goto download_cmplete;
-	}
-
-	/* Do not download configuration if CRC passes */
-	if (get_ath3k_crc(fd) < 0) {
-		err = 0;
-		goto download_cmplete;
-	}
-
-	get_ps_file_name(dev_type, rom_version, ps_file);
-	get_patch_file_name(dev_type, rom_version, build_version, patch_file);
-
-	stream = fopen(ps_file, "r");
-	if (!stream) {
-		perror("firmware file open error\n");
-		err = -EILSEQ;
-		goto download_cmplete;
-	}
-	tag_count = ath_parse_ps(stream);
-
-	fclose(stream);
-
-	if (tag_count < 0) {
-		err = -EILSEQ;
-		goto download_cmplete;
-	}
-
-	/*
-	 * It is not necessary that Patch file be available,
-	 * continue with PS Operations if patch file is not available.
-	 */
-	if (patch_file[0] == '\0')
-		err = 0;
-
-	stream = fopen(patch_file, "r");
-	if (!stream)
-		err = 0;
-	else {
-		patch_count = ps_patch_download(fd, stream);
-		fclose(stream);
-
-		if (patch_count < 0) {
-			err = -EILSEQ;
-			goto download_cmplete;
-		}
-	}
-
-	err = ps_config_download(fd, tag_count);
-
-download_cmplete:
-	if (!err)
-		write_bdaddr_from_file(rom_version, fd);
-
-	return err;
-}
-
-#define HCI_SLEEP_CMD_OCF     0x04
-
-/*
- * Atheros AR300x specific initialization post callback
- */
-int ath3k_post(int fd, int pm)
-{
-	int dev_id, dd;
-	struct timespec tm = { 0, 50000 };
-
-	sleep(1);
-
-	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
-	if (dev_id < 0) {
-		perror("cannot get device id");
-		return dev_id;
-	}
-
-	dd = hci_open_dev(dev_id);
-	if (dd < 0) {
-		perror("HCI device open failed");
-		return dd;
-	}
-
-	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {
-		perror("hci down:Power management Disabled");
-		hci_close_dev(dd);
-		return -1;
-	}
-
-	/* send vendor specific command with Sleep feature Enabled */
-	if (hci_send_cmd(dd, OGF_VENDOR_CMD, HCI_SLEEP_CMD_OCF,	1, &pm) < 0)
-		perror("PM command failed, power management Disabled");
-
-	nanosleep(&tm, NULL);
-	hci_close_dev(dd);
-
-	return 0;
-}
-
-#define HCI_VENDOR_CMD_OGF    0x3F
-#define HCI_PS_CMD_OCF        0x0B
-#define HCI_CHG_BAUD_CMD_OCF  0x0C
-
-#define WRITE_BDADDR_CMD_LEN 14
-#define WRITE_BAUD_CMD_LEN   6
-#define MAX_CMD_LEN          WRITE_BDADDR_CMD_LEN
-
-static int set_cntrlr_baud(int fd, int speed)
-{
-	int baud;
-	struct timespec tm = { 0, 500000 };
-	unsigned char cmd[MAX_CMD_LEN], rsp[HCI_MAX_EVENT_SIZE];
-	unsigned char *ptr = cmd + 1;
-	hci_command_hdr *ch = (void *)ptr;
-
-	cmd[0] = HCI_COMMAND_PKT;
-
-	/* set controller baud rate to user specified value */
-	ptr = cmd + 1;
-	ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-						HCI_CHG_BAUD_CMD_OCF));
-	ch->plen = 2;
-	ptr += HCI_COMMAND_HDR_SIZE;
-
-	baud = speed/100;
-	ptr[0] = (char)baud;
-	ptr[1] = (char)(baud >> 8);
-
-	if (write(fd, cmd, WRITE_BAUD_CMD_LEN) != WRITE_BAUD_CMD_LEN) {
-		perror("Failed to write change baud rate command");
-		return -ETIMEDOUT;
-	}
-
-	nanosleep(&tm, NULL);
-
-	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
-		return -ETIMEDOUT;
-
-	return 0;
-}
-
-/*
- * Atheros AR300x specific initialization and configuration file
- * download
- */
-int ath3k_init(int fd, int speed, int init_speed, char *bdaddr,
-						struct termios *ti)
-{
-	int r;
-	int err = 0;
-	struct timespec tm = { 0, 500000 };
-	unsigned char cmd[MAX_CMD_LEN], rsp[HCI_MAX_EVENT_SIZE];
-	unsigned char *ptr = cmd + 1;
-	hci_command_hdr *ch = (void *)ptr;
-
-	cmd[0] = HCI_COMMAND_PKT;
-
-	/* set both controller and host baud rate to maximum possible value */
-	err = set_cntrlr_baud(fd, speed);
-	if (err < 0)
-		return err;
-
-	err = set_speed(fd, ti, speed);
-	if (err < 0) {
-		perror("Can't set required baud rate");
-		return err;
-	}
-
-	/* Download PS and patch */
-	r = ath_ps_download(fd);
-	if (r < 0) {
-		perror("Failed to Download configuration");
-		err = -ETIMEDOUT;
-		goto failed;
-	}
-
-	/* Write BDADDR */
-	if (bdaddr) {
-		ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
-							HCI_PS_CMD_OCF));
-		ch->plen = 10;
-		ptr += HCI_COMMAND_HDR_SIZE;
-
-		ptr[0] = 0x01;
-		ptr[1] = 0x01;
-		ptr[2] = 0x00;
-		ptr[3] = 0x06;
-		str2ba(bdaddr, (bdaddr_t *)(ptr + 4));
-
-		if (write(fd, cmd, WRITE_BDADDR_CMD_LEN) !=
-					WRITE_BDADDR_CMD_LEN) {
-			perror("Failed to write BD_ADDR command\n");
-			err = -ETIMEDOUT;
-			goto failed;
-		}
-
-		if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
-			perror("Failed to set BD_ADDR\n");
-			err = -ETIMEDOUT;
-			goto failed;
-		}
-	}
-
-	/* Send HCI Reset */
-	cmd[1] = 0x03;
-	cmd[2] = 0x0C;
-	cmd[3] = 0x00;
-
-	r = write(fd, cmd, 4);
-	if (r != 4) {
-		err = -ETIMEDOUT;
-		goto failed;
-	}
-
-	nanosleep(&tm, NULL);
-	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
-		err = -ETIMEDOUT;
-		goto failed;
-	}
-
-	err = set_cntrlr_baud(fd, speed);
-	if (err < 0)
-		return err;
-
-failed:
-	if (err < 0) {
-		set_cntrlr_baud(fd, init_speed);
-		set_speed(fd, ti, init_speed);
-	}
-
-	return err;
-}
diff --git a/test/ar3k_bt/hciattach_qualcomm.c b/test/ar3k_bt/hciattach_qualcomm.c
deleted file mode 100644
index e4ff5e3..0000000
--- a/test/ar3k_bt/hciattach_qualcomm.c
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
- *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include <syslog.h>
-#include <termios.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/poll.h>
-#include <sys/param.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/uio.h>
-
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/hci_lib.h>
-
-#include "hciattach.h"
-
-#define FAILIF(x, args...) do { \
-	if (x) { \
-		fprintf(stderr, ##args); \
-		return -1; \
-	} \
-} while (0)
-
-typedef struct {
-	uint8_t uart_prefix;
-	hci_event_hdr hci_hdr;
-	evt_cmd_complete cmd_complete;
-	uint8_t status;
-	uint8_t data[16];
-} __attribute__((packed)) command_complete_t;
-
-static int read_command_complete(int fd,
-					unsigned short opcode,
-					unsigned char len)
-{
-	command_complete_t resp;
-	unsigned char vsevent[512];
-	int n;
-
-	/* Read reply. */
-	n = read_hci_event(fd, vsevent, sizeof(vsevent));
-	FAILIF(n < 0, "Failed to read response");
-
-	FAILIF(vsevent[1] != 0xFF, "Failed to read response");
-
-	n = read_hci_event(fd, (unsigned char *)&resp, sizeof(resp));
-	FAILIF(n < 0, "Failed to read response");
-
-	/* event must be event-complete */
-	FAILIF(resp.hci_hdr.evt != EVT_CMD_COMPLETE,
-		"Error in response: not a cmd-complete event, "
-		"but 0x%02x!\n", resp.hci_hdr.evt);
-
-	FAILIF(resp.hci_hdr.plen < 4, /* plen >= 4 for EVT_CMD_COMPLETE */
-		"Error in response: plen is not >= 4, but 0x%02x!\n",
-		resp.hci_hdr.plen);
-
-	/* cmd-complete event: opcode */
-	FAILIF(resp.cmd_complete.opcode != 0,
-		"Error in response: opcode is 0x%04x, not 0!",
-		resp.cmd_complete.opcode);
-
-	return resp.status == 0 ? 0 : -1;
-}
-
-static int qualcomm_load_firmware(int fd, const char *firmware, const char *bdaddr_s)
-{
-
-	int fw = open(firmware, O_RDONLY);
-
-	fprintf(stdout, "Opening firmware file: %s\n", firmware);
-
-	FAILIF(fw < 0,
-		"Could not open firmware file %s: %s (%d).\n",
-		firmware, strerror(errno), errno);
-
-	fprintf(stdout, "Uploading firmware...\n");
-	do {
-		/* Read each command and wait for a response. */
-		unsigned char data[1024];
-		unsigned char cmdp[1 + sizeof(hci_command_hdr)];
-		hci_command_hdr *cmd = (hci_command_hdr *) (cmdp + 1);
-		int nr;
-
-		nr = read(fw, cmdp, sizeof(cmdp));
-		if (!nr)
-			break;
-
-		FAILIF(nr != sizeof(cmdp),
-			"Could not read H4 + HCI header!\n");
-		FAILIF(*cmdp != HCI_COMMAND_PKT,
-			"Command is not an H4 command packet!\n");
-
-		FAILIF(read(fw, data, cmd->plen) != cmd->plen,
-				"Could not read %d bytes of data \
-				for command with opcode %04x!\n",
-				cmd->plen, cmd->opcode);
-
-		if ((data[0] == 1) && (data[1] == 2) && (data[2] == 6)) {
-			bdaddr_t bdaddr;
-			if (bdaddr_s != NULL) {
-				str2ba(bdaddr_s, &bdaddr);
-				memcpy(&data[3], &bdaddr, sizeof(bdaddr_t));
-			}
-		}
-
-		{
-			int nw;
-			struct iovec iov_cmd[2];
-			iov_cmd[0].iov_base = cmdp;
-			iov_cmd[0].iov_len = sizeof(cmdp);
-			iov_cmd[1].iov_base = data;
-			iov_cmd[1].iov_len = cmd->plen;
-			nw = writev(fd, iov_cmd, 2);
-			FAILIF(nw != (int) sizeof(cmdp) + cmd->plen,
-				"Could not send entire command \
-				(sent only %d bytes)!\n",
-				nw);
-		}
-
-		/* Wait for response */
-		if (read_command_complete(fd, cmd->opcode, cmd->plen) < 0)
-			return -1;
-	} while (1);
-	fprintf(stdout, "Firmware upload successful.\n");
-
-	close(fw);
-
-	return 0;
-}
-
-int qualcomm_init(int fd, int speed, struct termios *ti, const char *bdaddr)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[5];
-	unsigned char resp[100];		/* Response */
-	char fw[100];
-	int n;
-
-	memset(resp, 0, 100);
-
-	/* Get Manufacturer and LMP version */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x01;
-	cmd[2] = 0x10;
-	cmd[3] = 0x00;
-
-	do {
-		n = write(fd, cmd, 4);
-		if (n < 4) {
-			perror("Failed to write init command");
-			return -1;
-		}
-
-		/* Read reply. */
-		if (read_hci_event(fd, resp, 100) < 0) {
-			perror("Failed to read init response");
-			return -1;
-		}
-
-		/* Wait for command complete event for our Opcode */
-	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
-
-	/* Verify manufacturer */
-	if ((resp[11] & 0xFF) != 0x1d)
-		fprintf(stderr,
-			"WARNING : module's manufacturer is not Qualcomm\n");
-
-	/* Print LMP version */
-	fprintf(stderr,
-		"Qualcomm module LMP version : 0x%02x\n", resp[10] & 0xFF);
-
-	/* Print LMP subversion */
-	{
-		unsigned short lmp_subv = resp[13] | (resp[14] << 8);
-
-		fprintf(stderr, "Qualcomm module LMP sub-version : 0x%04x\n",
-								lmp_subv);
-	}
-
-	/* Get SoC type */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x00;
-	cmd[2] = 0xFC;
-	cmd[3] = 0x01;
-	cmd[4] = 0x06;
-
-	do {
-		n = write(fd, cmd, 5);
-		if (n < 5) {
-			perror("Failed to write vendor init command");
-			return -1;
-		}
-
-		/* Read reply. */
-		if ((n = read_hci_event(fd, resp, 100)) < 0) {
-			perror("Failed to read vendor init response");
-			return -1;
-		}
-
-	} while (resp[3] != 0 && resp[4] != 2);
-
-	snprintf(fw, sizeof(fw), "/etc/firmware/%c%c%c%c%c%c_%c%c%c%c.bin",
-				resp[18], resp[19], resp[20], resp[21],
-				resp[22], resp[23],
-				resp[32], resp[33], resp[34], resp[35]);
-
-	/* Wait for command complete event for our Opcode */
-	if (read_hci_event(fd, resp, 100) < 0) {
-		perror("Failed to read init response");
-		return -1;
-	}
-
-	qualcomm_load_firmware(fd, fw, bdaddr);
-
-	/* Reset */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x03;
-	cmd[2] = 0x0C;
-	cmd[3] = 0x00;
-
-	do {
-		n = write(fd, cmd, 4);
-		if (n < 4) {
-			perror("Failed to write reset command");
-			return -1;
-		}
-
-		/* Read reply. */
-		if ((n = read_hci_event(fd, resp, 100)) < 0) {
-			perror("Failed to read reset response");
-			return -1;
-		}
-
-	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
-
-	nanosleep(&tm, NULL);
-
-	return 0;
-}
diff --git a/test/ar3k_bt/hciattach_st.c b/test/ar3k_bt/hciattach_st.c
deleted file mode 100755
index dbb7c47..0000000
--- a/test/ar3k_bt/hciattach_st.c
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
-#include <dirent.h>
-#include <sys/param.h>
-
-#include <bluetooth/bluetooth.h>
-
-#include "hciattach.h"
-
-static int debug = 0;
-
-static int do_command(int fd, uint8_t ogf, uint16_t ocf,
-			uint8_t *cparam, int clen, uint8_t *rparam, int rlen)
-{
-	//uint16_t opcode = (uint16_t) ((ocf & 0x03ff) | (ogf << 10));
-	unsigned char cp[260], rp[260];
-	int len, size, offset = 3;
-
-	cp[0] = 0x01;
-	cp[1] = ocf & 0xff;
-	cp[2] = ogf << 2 | ocf >> 8;
-	cp[3] = clen;
-
-	if (clen > 0)
-		memcpy(cp + 4, cparam, clen);
-
-	if (debug) {
-		int i;
-		printf("[<");
-		for (i = 0; i < clen + 4; i++)
-			printf(" %02x", cp[i]);
-		printf("]\n");
-	}
-
-	if (write(fd, cp, clen + 4) < 0)
-		return -1;
-
-	do {
-		if (read(fd, rp, 1) < 1)
-			return -1;
-	} while (rp[0] != 0x04);
-
-	if (read(fd, rp + 1, 2) < 2)
-		return -1;
-
-	do {
-		len = read(fd, rp + offset, sizeof(rp) - offset);
-		offset += len;
-	} while (offset < rp[2] + 3);
-
-	if (debug) {
-		int i;
-		printf("[>");
-		for (i = 0; i < offset; i++)
-			printf(" %02x", rp[i]);
-		printf("]\n");
-	}
-
-	if (rp[0] != 0x04) {
-		errno = EIO;
-		return -1;
-	}
-
-	switch (rp[1]) {
-	case 0x0e:	/* command complete */
-		if (rp[6] != 0x00)
-			return -ENXIO;
-		offset = 3 + 4;
-		size = rp[2] - 4;
-		break;
-	case 0x0f:	/* command status */
-		/* fall through */
-	default:
-		offset = 3;
-		size = rp[2];
-		break;
-	}
-
-	if (!rparam || rlen < size)
-		return -ENXIO;
-
-	memcpy(rparam, rp + offset, size);
-
-	return size;
-}
-
-static int load_file(int dd, uint16_t version, const char *suffix)
-{
-	DIR *dir;
-	struct dirent *d;
-	char pathname[PATH_MAX], filename[NAME_MAX], prefix[20];
-	unsigned char cmd[256];
-	unsigned char buf[256];
-	uint8_t seqnum = 0;
-	int fd, size, len, found_fw_file;
-
-	memset(filename, 0, sizeof(filename));
-
-	snprintf(prefix, sizeof(prefix), "STLC2500_R%d_%02d_",
-						version >> 8, version & 0xff);
-
-	strcpy(pathname, "/lib/firmware");
-	dir = opendir(pathname);
-	if (!dir) {
-		strcpy(pathname, ".");
-		dir = opendir(pathname);
-		if (!dir)
-			return -errno;
-	}
-
-	found_fw_file = 0;
-	while (1) {
-		d = readdir(dir);
-		if (!d)
-			break;
-
-		if (strncmp(d->d_name + strlen(d->d_name) - strlen(suffix),
-						suffix, strlen(suffix)))
-			continue;
-
-		if (strncmp(d->d_name, prefix, strlen(prefix)))
-			continue;
-
-		snprintf(filename, sizeof(filename), "%s/%s",
-							pathname, d->d_name);
-		found_fw_file = 1;
-	}
-
-	closedir(dir);
-
-	if (!found_fw_file)
-		return -ENOENT;
-
-	printf("Loading file %s\n", filename);
-
-	fd = open(filename, O_RDONLY);
-	if (fd < 0) {
-		perror("Can't open firmware file");
-		return -errno;
-	}
-
-	while (1) {
-		size = read(fd, cmd + 1, 254);
-		if (size <= 0)
-			break;
-
-		cmd[0] = seqnum;
-
-		len = do_command(dd, 0xff, 0x002e, cmd, size + 1, buf, sizeof(buf));
-		if (len < 1)
-			break;
-
-		if (buf[0] != seqnum) {
-			fprintf(stderr, "Sequence number mismatch\n");
-			break;
-		}
-
-		seqnum++;
-	}
-
-	close(fd);
-
-	return 0;
-}
-
-int stlc2500_init(int dd, bdaddr_t *bdaddr)
-{
-	unsigned char cmd[16];
-	unsigned char buf[254];
-	uint16_t version;
-	int len;
-	int err;
-
-	/* Hci_Cmd_Ericsson_Read_Revision_Information */
-	len = do_command(dd, 0xff, 0x000f, NULL, 0, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	printf("%s\n", buf);
-
-	/* HCI_Read_Local_Version_Information */
-	len = do_command(dd, 0x04, 0x0001, NULL, 0, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	version = buf[2] << 8 | buf[1];
-
-	err = load_file(dd, version, ".ptc");
-	if (err < 0) {
-		if (err == -ENOENT)
-			fprintf(stderr, "No ROM patch file loaded.\n");
-		else
-			return -1;
-	}
-
-	err = load_file(dd, buf[2] << 8 | buf[1], ".ssf");
-	if (err < 0) {
-		if (err == -ENOENT)
-			fprintf(stderr, "No static settings file loaded.\n");
-		else
-			return -1;
-	}
-
-	cmd[0] = 0xfe;
-	cmd[1] = 0x06;
-	bacpy((bdaddr_t *) (cmd + 2), bdaddr);
-
-	/* Hci_Cmd_ST_Store_In_NVDS */
-	len = do_command(dd, 0xff, 0x0022, cmd, 8, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	/* HCI_Reset : applies parameters*/
-	len = do_command(dd, 0x03, 0x0003, NULL, 0, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	return 0;
-}
-
-int bgb2xx_init(int dd, bdaddr_t *bdaddr)
-{
-	unsigned char cmd[16];
-	unsigned char buf[254];
-	int len;
-
-	len = do_command(dd, 0xff, 0x000f, NULL, 0, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	printf("%s\n", buf);
-
-	cmd[0] = 0xfe;
-	cmd[1] = 0x06;
-	bacpy((bdaddr_t *) (cmd + 2), bdaddr);
-
-	len = do_command(dd, 0xff, 0x0022, cmd, 8, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	len = do_command(dd, 0x03, 0x0003, NULL, 0, buf, sizeof(buf));
-	if (len < 0)
-		return -1;
-
-	return 0;
-}
diff --git a/test/ar3k_bt/hciattach_ti.c b/test/ar3k_bt/hciattach_ti.c
deleted file mode 100755
index e107a65..0000000
--- a/test/ar3k_bt/hciattach_ti.c
+++ /dev/null
@@ -1,529 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2007-2008  Texas Instruments, Inc.
- *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <termios.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/uio.h>
-
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/hci_lib.h>
-
-#include "hciattach.h"
-
-#ifdef HCIATTACH_DEBUG
-#define DPRINTF(x...)	printf(x)
-#else
-#define DPRINTF(x...)
-#endif
-
-#define HCIUARTGETDEVICE	_IOR('U', 202, int)
-
-#define MAKEWORD(a, b)  ((uint16_t)(((uint8_t)(a)) | ((uint16_t)((uint8_t)(b))) << 8))
-
-#define TI_MANUFACTURER_ID	13
-
-#define FIRMWARE_DIRECTORY	"/lib/firmware/"
-
-#define ACTION_SEND_COMMAND	1
-#define ACTION_WAIT_EVENT	2
-#define ACTION_SERIAL		3
-#define ACTION_DELAY		4
-#define ACTION_RUN_SCRIPT	5
-#define ACTION_REMARKS		6
-
-#define BRF_DEEP_SLEEP_OPCODE_BYTE_1	0x0c
-#define BRF_DEEP_SLEEP_OPCODE_BYTE_2	0xfd
-#define BRF_DEEP_SLEEP_OPCODE		\
-	(BRF_DEEP_SLEEP_OPCODE_BYTE_1 | (BRF_DEEP_SLEEP_OPCODE_BYTE_2 << 8))
-
-#define FILE_HEADER_MAGIC	0x42535442
-
-/*
- * BRF Firmware header
- */
-struct bts_header {
-	uint32_t	magic;
-	uint32_t	version;
-	uint8_t	future[24];
-	uint8_t	actions[0];
-}__attribute__ ((packed));
-
-/*
- * BRF Actions structure
- */
-struct bts_action {
-	uint16_t	type;
-	uint16_t	size;
-	uint8_t	data[0];
-} __attribute__ ((packed));
-
-struct bts_action_send {
-	uint8_t data[0];
-} __attribute__ ((packed));
-
-struct bts_action_wait {
-	uint32_t msec;
-	uint32_t size;
-	uint8_t data[0];
-}__attribute__ ((packed));
-
-struct bts_action_delay {
-	uint32_t msec;
-}__attribute__ ((packed));
-
-struct bts_action_serial {
-	uint32_t baud;
-	uint32_t flow_control;
-}__attribute__ ((packed));
-
-static FILE *bts_load_script(const char* file_name, uint32_t* version)
-{
-	struct bts_header header;
-	FILE* fp;
-
-	fp = fopen(file_name, "rb");
-	if (!fp) {
-		perror("can't open firmware file");
-		goto out;
-	}
-
-	if (1 != fread(&header, sizeof(struct bts_header), 1, fp)) {
-		perror("can't read firmware file");
-		goto errclose;
-	}
-
-	if (header.magic != FILE_HEADER_MAGIC) {
-		fprintf(stderr, "%s not a legal TI firmware file\n", file_name);
-		goto errclose;
-	}
-
-	if (NULL != version)
-		*version = header.version;
-
-	goto out;
-
-errclose:
-	fclose(fp);
-	fp = NULL;
-out:
-	return fp;
-}
-
-static unsigned long bts_fetch_action(FILE* fp, unsigned char* action_buf,
-				unsigned long buf_size, uint16_t* action_type)
-{
-	struct bts_action action_hdr;
-	unsigned long nread;
-
-	if (!fp)
-		return 0;
-
-	if (1 != fread(&action_hdr, sizeof(struct bts_action), 1, fp))
-		return 0;
-
-	if (action_hdr.size > buf_size) {
-		fprintf(stderr, "bts_next_action: not enough space to read next action\n");
-		return 0;
-	}
-
-	nread = fread(action_buf, sizeof(uint8_t), action_hdr.size, fp);
-	if (nread != (action_hdr.size)) {
-		fprintf(stderr, "bts_next_action: fread failed to read next action\n");
-		return 0;
-	}
-
-	*action_type = action_hdr.type;
-
-	return nread * sizeof(uint8_t);
-}
-
-static void bts_unload_script(FILE* fp)
-{
-	if (fp)
-		fclose(fp);
-}
-
-static int is_it_texas(const uint8_t *respond)
-{
-	uint16_t manufacturer_id;
-
-	manufacturer_id = MAKEWORD(respond[11], respond[12]);
-
-	return TI_MANUFACTURER_ID == manufacturer_id ? 1 : 0;
-}
-
-static const char *get_firmware_name(const uint8_t *respond)
-{
-	static char firmware_file_name[PATH_MAX] = {0};
-	uint16_t version = 0, chip = 0, min_ver = 0, maj_ver = 0;
-
-	version = MAKEWORD(respond[13], respond[14]);
-	chip =  (version & 0x7C00) >> 10;
-	min_ver = (version & 0x007F);
-	maj_ver = (version & 0x0380) >> 7;
-
-	if (version & 0x8000)
-		maj_ver |= 0x0008;
-
-	sprintf(firmware_file_name, FIRMWARE_DIRECTORY "TIInit_%d.%d.%d.bts", chip, maj_ver, min_ver);
-
-	return firmware_file_name;
-}
-
-static void brf_delay(struct bts_action_delay *delay)
-{
-	usleep(1000 * delay->msec);
-}
-
-static int brf_set_serial_params(struct bts_action_serial *serial_action,
-						int fd, struct termios *ti)
-{
-	fprintf(stderr, "texas: changing baud rate to %u, flow control to %u\n",
-				serial_action->baud, serial_action->flow_control );
-	tcflush(fd, TCIOFLUSH);
-
-	if (serial_action->flow_control)
-		ti->c_cflag |= CRTSCTS;
-	else
-		ti->c_cflag &= ~CRTSCTS;
-
-	if (tcsetattr(fd, TCSANOW, ti) < 0) {
-		perror("Can't set port settings");
-		return -1;
-	}
-
-	tcflush(fd, TCIOFLUSH);
-
-	if (set_speed(fd, ti, serial_action->baud) < 0) {
-		perror("Can't set baud rate");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int brf_send_command_socket(int fd, struct bts_action_send* send_action)
-{
-	char response[1024] = {0};
-	hci_command_hdr *cmd = (hci_command_hdr *) send_action->data;
-	uint16_t opcode = cmd->opcode;
-
-	struct hci_request rq;
-	memset(&rq, 0, sizeof(rq));
-	rq.ogf    = cmd_opcode_ogf(opcode);
-	rq.ocf    = cmd_opcode_ocf(opcode);
-	rq.event  = EVT_CMD_COMPLETE;
-	rq.cparam = &send_action->data[3];
-	rq.clen   = send_action->data[2];
-	rq.rparam = response;
-	rq.rlen   = sizeof(response);
-
-	if (hci_send_req(fd, &rq, 15) < 0) {
-		perror("Cannot send hci command to socket");
-		return -1;
-	}
-
-	/* verify success */
-	if (response[0]) {
-		errno = EIO;
-		return -1;
-	}
-
-	return 0;
-}
-
-static int brf_send_command_file(int fd, struct bts_action_send* send_action, long size)
-{
-	unsigned char response[1024] = {0};
-	long ret = 0;
-
-	/* send command */
-	if (size != write(fd, send_action, size)) {
-		perror("Texas: Failed to write action command");
-		return -1;
-	}
-
-	/* read response */
-	ret = read_hci_event(fd, response, sizeof(response));
-	if (ret < 0) {
-		perror("texas: failed to read command response");
-		return -1;
-	}
-
-	/* verify success */
-	if (ret < 7 || 0 != response[6]) {
-		fprintf( stderr, "TI init command failed.\n" );
-		errno = EIO;
-		return -1;
-	}
-
-	return 0;
-}
-
-
-static int brf_send_command(int fd, struct bts_action_send* send_action, long size, int hcill_installed)
-{
-	int ret = 0;
-	char *fixed_action;
-
-	/* remove packet type when giving to socket API */
-	if (hcill_installed) {
-		fixed_action = ((char *) send_action) + 1;
-		ret = brf_send_command_socket(fd, (struct bts_action_send *) fixed_action);
-	} else {
-		ret = brf_send_command_file(fd, send_action, size);
-	}
-
-	return ret;
-}
-
-static int brf_do_action(uint16_t brf_type, uint8_t *brf_action, long brf_size,
-				int fd, struct termios *ti, int hcill_installed)
-{
-	int ret = 0;
-
-	switch (brf_type) {
-	case ACTION_SEND_COMMAND:
-		DPRINTF("W");
-		ret = brf_send_command(fd, (struct bts_action_send*) brf_action, brf_size, hcill_installed);
-		break;
-	case ACTION_WAIT_EVENT:
-		DPRINTF("R");
-		break;
-	case ACTION_SERIAL:
-		DPRINTF("S");
-		ret = brf_set_serial_params((struct bts_action_serial *) brf_action, fd, ti);
-		break;
-	case ACTION_DELAY:
-		DPRINTF("D");
-		brf_delay((struct bts_action_delay *) brf_action);
-		break;
-	case ACTION_REMARKS:
-		DPRINTF("C");
-		break;
-	default:
-		fprintf(stderr, "brf_init: unknown firmware action type (%d)\n", brf_type);
-		break;
-	}
-
-	return ret;
-}
-
-/*
- * tests whether a given brf action is a HCI_VS_Sleep_Mode_Configurations cmd
- */
-static int brf_action_is_deep_sleep(uint8_t *brf_action, long brf_size,
-							uint16_t brf_type)
-{
-	uint16_t opcode;
-
-	if (brf_type != ACTION_SEND_COMMAND)
-		return 0;
-
-	if (brf_size < 3)
-		return 0;
-
-	if (brf_action[0] != HCI_COMMAND_PKT)
-		return 0;
-
-	/* HCI data is little endian */
-	opcode = brf_action[1] | (brf_action[2] << 8);
-
-	if (opcode != BRF_DEEP_SLEEP_OPCODE)
-		return 0;
-
-	/* action is deep sleep configuration command ! */
-	return 1;
-}
-
-/*
- * This function is called twice.
- * The first time it is called, it loads the brf script, and executes its
- * commands until it reaches a deep sleep command (or its end).
- * The second time it is called, it assumes HCILL protocol is set up,
- * and sends rest of brf script via the supplied socket.
- */
-static int brf_do_script(int fd, struct termios *ti, const char *bts_file)
-{
-	int ret = 0,  hcill_installed = bts_file ? 0 : 1;
-	uint32_t vers;
-	static FILE *brf_script_file = NULL;
-	static uint8_t brf_action[512];
-	static long brf_size;
-	static uint16_t brf_type;
-
-	/* is it the first time we are called ? */
-	if (0 == hcill_installed) {
-		DPRINTF("Sending script to serial device\n");
-		brf_script_file = bts_load_script(bts_file, &vers );
-		if (!brf_script_file) {
-			fprintf(stderr, "Warning: cannot find BTS file: %s\n",
-					bts_file);
-			return 0;
-		}
-
-		fprintf( stderr, "Loaded BTS script version %u\n", vers );
-
-		brf_size = bts_fetch_action(brf_script_file, brf_action,
-						sizeof(brf_action), &brf_type);
-		if (brf_size == 0) {
-			fprintf(stderr, "Warning: BTS file is empty !");
-			return 0;
-		}
-	}
-	else {
-		DPRINTF("Sending script to bluetooth socket\n");
-	}
-
-	/* execute current action and continue to parse brf script file */
-	while (brf_size != 0) {
-		ret = brf_do_action(brf_type, brf_action, brf_size,
-						fd, ti, hcill_installed);
-		if (ret == -1)
-			break;
-
-		brf_size = bts_fetch_action(brf_script_file, brf_action,
-						sizeof(brf_action), &brf_type);
-
-		/* if this is the first time we run (no HCILL yet) */
-		/* and a deep sleep command is encountered */
-		/* we exit */
-		if (!hcill_installed &&
-				brf_action_is_deep_sleep(brf_action,
-							brf_size, brf_type))
-			return 0;
-	}
-
-	bts_unload_script(brf_script_file);
-	brf_script_file = NULL;
-	DPRINTF("\n");
-
-	return ret;
-}
-
-int texas_init(int fd, struct termios *ti)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[4];
-	unsigned char resp[100];		/* Response */
-	const char *bts_file;
-	int n;
-
-	memset(resp,'\0', 100);
-
-	/* It is possible to get software version with manufacturer specific
-	   HCI command HCI_VS_TI_Version_Number. But the only thing you get more
-	   is if this is point-to-point or point-to-multipoint module */
-
-	/* Get Manufacturer and LMP version */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x01;
-	cmd[2] = 0x10;
-	cmd[3] = 0x00;
-
-	do {
-		n = write(fd, cmd, 4);
-		if (n < 0) {
-			perror("Failed to write init command (READ_LOCAL_VERSION_INFORMATION)");
-			return -1;
-		}
-		if (n < 4) {
-			fprintf(stderr, "Wanted to write 4 bytes, could only write %d. Stop\n", n);
-			return -1;
-		}
-
-		/* Read reply. */
-		if (read_hci_event(fd, resp, 100) < 0) {
-			perror("Failed to read init response (READ_LOCAL_VERSION_INFORMATION)");
-			return -1;
-		}
-
-		/* Wait for command complete event for our Opcode */
-	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
-
-	/* Verify manufacturer */
-	if (! is_it_texas(resp)) {
-		fprintf(stderr,"ERROR: module's manufacturer is not Texas Instruments\n");
-		return -1;
-	}
-
-	fprintf(stderr, "Found a Texas Instruments' chip!\n");
-
-	bts_file = get_firmware_name(resp);
-	fprintf(stderr, "Firmware file : %s\n", bts_file);
-
-	n = brf_do_script(fd, ti, bts_file);
-
-	nanosleep(&tm, NULL);
-
-	return n;
-}
-
-int texas_post(int fd, struct termios *ti)
-{
-	int dev_id, dd, ret = 0;
-
-	sleep(1);
-
-	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
-	if (dev_id < 0) {
-		perror("cannot get device id");
-		return -1;
-	}
-
-	DPRINTF("\nAdded device hci%d\n", dev_id);
-
-	dd = hci_open_dev(dev_id);
-	if (dd < 0) {
-		perror("HCI device open failed");
-		return -1;
-	}
-
-	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {
-		fprintf(stderr, "Can't init device hci%d: %s (%d)", dev_id,
-							strerror(errno), errno);
-		hci_close_dev(dd);
-		return -1;
-	}
-
-	ret = brf_do_script(dd, ti, NULL);
-
-	hci_close_dev(dd);
-
-	return ret;
-}
diff --git a/test/ar3k_bt/hciattach_tialt.c b/test/ar3k_bt/hciattach_tialt.c
deleted file mode 100755
index 1ba009c..0000000
--- a/test/ar3k_bt/hciattach_tialt.c
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- *
- *  BlueZ - Bluetooth protocol stack for Linux
- *
- *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include <syslog.h>
-#include <termios.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/poll.h>
-#include <sys/param.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/uio.h>
-
-#include <bluetooth/bluetooth.h>
-#include <bluetooth/hci.h>
-#include <bluetooth/hci_lib.h>
-
-#include "hciattach.h"
-
-#define FAILIF(x, args...) do {   \
-	if (x) {					  \
-		fprintf(stderr, ##args);  \
-		return -1;				  \
-	}							  \
-} while(0)
-
-typedef struct {
-	uint8_t uart_prefix;
-	hci_event_hdr hci_hdr;
-	evt_cmd_complete cmd_complete;
-	uint8_t status;
-	uint8_t data[16];
-} __attribute__((packed)) command_complete_t;
-
-static int read_command_complete(int fd, unsigned short opcode, unsigned char len) {
-	command_complete_t resp;
-	/* Read reply. */
-	FAILIF(read_hci_event(fd, (unsigned char *)&resp, sizeof(resp)) < 0,
-		   "Failed to read response");
-
-	/* Parse speed-change reply */
-	FAILIF(resp.uart_prefix != HCI_EVENT_PKT,
-		   "Error in response: not an event packet, but 0x%02x!\n",
-		   resp.uart_prefix);
-
-	FAILIF(resp.hci_hdr.evt != EVT_CMD_COMPLETE, /* event must be event-complete */
-		   "Error in response: not a cmd-complete event, "
-		   "but 0x%02x!\n", resp.hci_hdr.evt);
-
-	FAILIF(resp.hci_hdr.plen < 4, /* plen >= 4 for EVT_CMD_COMPLETE */
-		   "Error in response: plen is not >= 4, but 0x%02x!\n",
-		   resp.hci_hdr.plen);
-
-	/* cmd-complete event: opcode */
-	FAILIF(resp.cmd_complete.opcode != (uint16_t)opcode,
-		   "Error in response: opcode is 0x%04x, not 0x%04x!",
-		   resp.cmd_complete.opcode, opcode);
-
-	return resp.status == 0 ? 0 : -1;
-}
-
-typedef struct {
-	uint8_t uart_prefix;
-	hci_command_hdr hci_hdr;
-	uint32_t speed;
-} __attribute__((packed)) texas_speed_change_cmd_t;
-
-static int texas_change_speed(int fd, uint32_t speed)
-{
-	return 0;
-}
-
-static int texas_load_firmware(int fd, const char *firmware) {
-
-	int fw = open(firmware, O_RDONLY);
-
-	fprintf(stdout, "Opening firmware file: %s\n", firmware);
-
-	FAILIF(fw < 0,
-		   "Could not open firmware file %s: %s (%d).\n",
-		   firmware, strerror(errno), errno);
-
-	fprintf(stdout, "Uploading firmware...\n");
-	do {
-		/* Read each command and wait for a response. */
-		unsigned char data[1024];
-		unsigned char cmdp[1 + sizeof(hci_command_hdr)];
-		hci_command_hdr *cmd = (hci_command_hdr *)(cmdp + 1);
-		int nr;
-		nr = read(fw, cmdp, sizeof(cmdp));
-		if (!nr)
-			break;
-		FAILIF(nr != sizeof(cmdp), "Could not read H4 + HCI header!\n");
-		FAILIF(*cmdp != HCI_COMMAND_PKT, "Command is not an H4 command packet!\n");
-
-		FAILIF(read(fw, data, cmd->plen) != cmd->plen,
-			   "Could not read %d bytes of data for command with opcode %04x!\n",
-			   cmd->plen,
-			   cmd->opcode);
-
-		{
-			int nw;
-#if 0
-			fprintf(stdout, "\topcode 0x%04x (%d bytes of data).\n",
-					cmd->opcode,
-					cmd->plen);
-#endif
-			struct iovec iov_cmd[2];
-			iov_cmd[0].iov_base = cmdp;
-			iov_cmd[0].iov_len	= sizeof(cmdp);
-			iov_cmd[1].iov_base = data;
-			iov_cmd[1].iov_len	= cmd->plen;
-			nw = writev(fd, iov_cmd, 2);
-			FAILIF(nw != (int) sizeof(cmd) +	cmd->plen,
-				   "Could not send entire command (sent only %d bytes)!\n",
-				   nw);
-		}
-
-		/* Wait for response */
-		if (read_command_complete(fd,
-								  cmd->opcode,
-								  cmd->plen) < 0) {
-			return -1;
-		}
-
-	} while(1);
-	fprintf(stdout, "Firmware upload successful.\n");
-
-	close(fw);
-	return 0;
-}
-
-int texasalt_init(int fd, int speed, struct termios *ti)
-{
-	struct timespec tm = {0, 50000};
-	char cmd[4];
-	unsigned char resp[100];		/* Response */
-	int n;
-
-	memset(resp,'\0', 100);
-
-	/* It is possible to get software version with manufacturer specific
-	   HCI command HCI_VS_TI_Version_Number. But the only thing you get more
-	   is if this is point-to-point or point-to-multipoint module */
-
-	/* Get Manufacturer and LMP version */
-	cmd[0] = HCI_COMMAND_PKT;
-	cmd[1] = 0x01;
-	cmd[2] = 0x10;
-	cmd[3] = 0x00;
-
-	do {
-		n = write(fd, cmd, 4);
-		if (n < 0) {
-			perror("Failed to write init command (READ_LOCAL_VERSION_INFORMATION)");
-			return -1;
-		}
-		if (n < 4) {
-			fprintf(stderr, "Wanted to write 4 bytes, could only write %d. Stop\n", n);
-			return -1;
-		}
-
-		/* Read reply. */
-		if (read_hci_event(fd, resp, 100) < 0) {
-			perror("Failed to read init response (READ_LOCAL_VERSION_INFORMATION)");
-			return -1;
-		}
-
-		/* Wait for command complete event for our Opcode */
-	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
-
-	/* Verify manufacturer */
-	if ((resp[11] & 0xFF) != 0x0d)
-		fprintf(stderr,"WARNING : module's manufacturer is not Texas Instrument\n");
-
-	/* Print LMP version */
-	fprintf(stderr, "Texas module LMP version : 0x%02x\n", resp[10] & 0xFF);
-
-	/* Print LMP subversion */
-	{
-		unsigned short lmp_subv = resp[13] | (resp[14] << 8);
-		unsigned short brf_chip = (lmp_subv & 0x7c00) >> 10;
-		static const char *c_brf_chip[8] = {
-			"unknown",
-			"unknown",
-			"brf6100",
-			"brf6150",
-			"brf6300",
-			"brf6350",
-			"unknown",
-			"wl1271"
-		};
-		char fw[100];
-
-		fprintf(stderr, "Texas module LMP sub-version : 0x%04x\n", lmp_subv);
-
-		fprintf(stderr,
-				"\tinternal version freeze: %d\n"
-				"\tsoftware version: %d\n"
-				"\tchip: %s (%d)\n",
-				lmp_subv & 0x7f,
-				((lmp_subv & 0x8000) >> (15-3)) | ((lmp_subv & 0x380) >> 7),
-				((brf_chip > 7) ? "unknown" : c_brf_chip[brf_chip]),
-				brf_chip);
-
-		sprintf(fw, "/etc/firmware/%s.bin", c_brf_chip[brf_chip]);
-		texas_load_firmware(fd, fw);
-
-		texas_change_speed(fd, speed);
-	}
-	nanosleep(&tm, NULL);
-	return 0;
-}
-- 
1.8.0

