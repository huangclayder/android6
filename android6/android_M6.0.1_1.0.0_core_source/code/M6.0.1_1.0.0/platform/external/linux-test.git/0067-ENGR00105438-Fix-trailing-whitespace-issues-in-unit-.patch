From 0bdbc1ea34502aa04e781ed6b53947abc6e3725f Mon Sep 17 00:00:00 2001
From: Liu Ying <b17645@freescale.com>
Date: Mon, 19 Jan 2009 16:25:15 +0800
Subject: [PATCH 067/505] ENGR00105438 Fix trailing whitespace issues in unit
 test source code

Fix trailing whitespace issues in unit test source code.

Signed-off-by: Liu Ying <b17645@freescale.com>
---
 include/dptc_daemon.h                              |  14 +-
 module_test/memalloc.h                             |   2 +-
 module_test/rng_test_driver.c                      | 118 +++++------
 module_test/scc2_test_driver.c                     |   6 +-
 readme.txt                                         |  36 ++--
 test/Makefile                                      |   2 +-
 test/demo/dptc_hi_demo/dptc_hi.c                   | 232 ++++++++++-----------
 test/max8660_pmic_test/pmic_testapp_rtc/Makefile   |   2 +-
 test/mxc_ata_test/identify.c                       |  54 ++---
 test/mxc_ata_test/mxc_ata_test.c                   |   6 +-
 test/mxc_fb_test/mxc_fb_test.c                     |  12 +-
 test/mxc_fb_test/mxc_tvout_test.c                  |  14 +-
 test/mxc_hdd_test/autorun-ata.sh                   |   2 +-
 test/mxc_i2c_test/mxc_i2c_test.c                   |   4 +-
 test/mxc_i2c_test/mxc_i2c_test_magna_cam.c         |   8 +-
 test/mxc_i2c_test/mxc_i2c_test_samsung_cam.c       |  12 +-
 test/mxc_i2c_test/mxc_i2c_test_usb.c               |  20 +-
 test/mxc_ipudev_test/mxc_ipu_dev.c                 |  30 +--
 test/mxc_mbx_test/autorun-mbx.sh                   |   2 +-
 test/mxc_mlb_test/mxc_mlb_test.c                   |   6 +-
 test/mxc_mmc_test/Makefile                         |   4 +-
 test/mxc_mmc_test/autorun-mmc.sh                   |   2 +-
 test/mxc_mpeg4_enc_test/MP4EncApi.h                |   4 +-
 test/mxc_mpeg4_enc_test/cam2mpeg4_cif.c            |   8 +-
 test/mxc_mpeg4_enc_test/cam2mpeg4_vga.c            |  32 +--
 test/mxc_mpeg4_enc_test/memalloc.h                 |   4 +-
 test/mxc_mpeg4_test/mpeg4_dec_api.h                |  62 +++---
 test/mxc_mpeg4_test/mpeg4_enc_api.h                |  54 ++---
 test/mxc_mpeg4_test/mxc_mpeg4enc_test.c            |  16 +-
 test/mxc_mu_test/autorun-mu.sh                     |   2 +-
 test/mxc_oprofile_test/Makefile                    |   2 +-
 test/mxc_oprofile_test/autorun-oprofile.sh         |   8 +-
 test/mxc_pf_test/mxc_pf_test.c                     |  34 +--
 test/mxc_pmic_test/include/dataascii.h             |  22 +-
 test/mxc_pmic_test/include/databin.h               |   2 +-
 test/mxc_pmic_test/include/file_lock.h             |  20 +-
 test/mxc_pmic_test/include/forker.h                |  24 +--
 test/mxc_pmic_test/include/open_flags.h            |  24 +--
 test/mxc_pmic_test/include/pattern.h               |  24 +--
 test/mxc_pmic_test/include/random_range.h          |  20 +-
 test/mxc_pmic_test/include/search_path.h           |  20 +-
 test/mxc_pmic_test/include/str_to_bytes.h          |  20 +-
 test/mxc_pmic_test/include/string_to_tokens.h      |  22 +-
 test/mxc_pmic_test/include/test.h                  |  28 +--
 test/mxc_pmic_test/include/tlibio.h                |  20 +-
 test/mxc_pmic_test/include/usctest.h               |  76 +++----
 test/mxc_pmic_test/include/write_log.h             |  20 +-
 test/mxc_pmic_test/lib/Makefile                    |   4 +-
 test/mxc_pmic_test/lib/dataascii.c                 |  20 +-
 test/mxc_pmic_test/lib/databin.c                   |  22 +-
 test/mxc_pmic_test/lib/datapid.c                   |  46 ++--
 test/mxc_pmic_test/lib/file_lock.c                 |  20 +-
 test/mxc_pmic_test/lib/forker.c                    |  46 ++--
 test/mxc_pmic_test/lib/get_high_address.c          |   2 +-
 test/mxc_pmic_test/lib/open_flags.c                |  34 +--
 test/mxc_pmic_test/lib/parse_opts.c                |  92 ++++----
 test/mxc_pmic_test/lib/pattern.c                   |  20 +-
 test/mxc_pmic_test/lib/random_range.c              |  44 ++--
 test/mxc_pmic_test/lib/rmobj.c                     |  20 +-
 test/mxc_pmic_test/lib/search_path.c               |  30 +--
 test/mxc_pmic_test/lib/str_to_bytes.c              |  34 +--
 test/mxc_pmic_test/lib/string_to_tokens.c          |  38 ++--
 test/mxc_pmic_test/lib/tlibio.c                    | 112 +++++-----
 test/mxc_pmic_test/lib/tst_kvercmp.c               |   6 +-
 test/mxc_pmic_test/lib/tst_res.c                   |  24 +--
 test/mxc_pmic_test/lib/tst_sig.c                   |  28 +--
 test/mxc_pmic_test/lib/tst_tmpdir.c                |  58 +++---
 test/mxc_pmic_test/lib/write_log.c                 |  40 ++--
 test/mxc_pmic_test/pmic_testapp_adc/Makefile       |   2 +-
 .../mxc_pmic_test/pmic_testapp_adc/pmic_adc_main.c |  72 +++----
 .../mxc_pmic_test/pmic_testapp_adc/pmic_adc_test.h |  22 +-
 .../pmic_testapp_adc/pmic_adc_test_TS.c            |  40 ++--
 .../pmic_testapp_adc/pmic_adc_test_TS.h            |  20 +-
 .../pmic_testapp_adc/pmic_adc_test_convert.c       |  30 +--
 .../pmic_testapp_adc/pmic_adc_test_convert.h       |  20 +-
 .../pmic_testapp_adc/pmic_adc_test_monitor.c       |  32 +--
 .../pmic_testapp_adc/pmic_adc_test_monitor.h       |  20 +-
 .../pmic_testapp_adc/pmic_adc_test_read.c          |  40 ++--
 .../pmic_testapp_adc/pmic_adc_test_read.h          |  22 +-
 test/mxc_pmic_test/pmic_testapp_battery/Makefile   |   2 +-
 .../pmic_testapp_battery/pmic_battery_main.c       |  10 +-
 .../pmic_testapp_battery/pmic_battery_test.c       |   8 +-
 .../pmic_testapp_battery/pmic_battery_test.h       |  26 +--
 .../pmic_testapp_light/pmic_testapp_light.c        |   2 +-
 test/mxc_pmic_test/pmic_testapp_rtc/Makefile       |   2 +-
 .../mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_main.c |  54 ++---
 .../mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.c | 210 +++++++++----------
 .../mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.h |  22 +-
 test/mxc_pmic_test/protocol_tests/mc13783_main.c   |  28 +--
 test/mxc_pmic_test/protocol_tests/mc13783_test.c   |  26 +--
 test/mxc_pmic_test/protocol_tests/mc13783_test.h   |  20 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_CA.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_CA.h |  22 +-
 test/mxc_pmic_test/protocol_tests/mc13783_test_D.c |  28 +--
 test/mxc_pmic_test/protocol_tests/mc13783_test_D.h |  22 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_IP.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_IP.h |  22 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_OC.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_OC.h |  22 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_RA.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_RA.h |  22 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_RW.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_RW.h |  22 +-
 .../mxc_pmic_test/protocol_tests/mc13783_test_SU.c |  28 +--
 .../mxc_pmic_test/protocol_tests/mc13783_test_SU.h |  22 +-
 .../protocol_tests/mc13783_test_S_IT_U.c           |  28 +--
 .../protocol_tests/mc13783_test_S_IT_U.h           |  22 +-
 .../protocol_tests/mc13783_test_common.c           |  30 +--
 .../protocol_tests/mc13783_test_common.h           |  24 +--
 test/mxc_sahara_test/readme.txt                    |  10 +-
 test/mxc_sahara_test/results.c                     |  12 +-
 test/mxc_scc/scc_setup.sh                          |   2 +-
 test/mxc_scc/scc_test.c                            |  30 +--
 test/mxc_scc/test_subs.sh                          |   4 +-
 test/mxc_sdma_test/Makefile                        |   2 +-
 test/mxc_sdma_test/mxc_sdma_test.c                 |   8 +-
 test/mxc_sound_test/Makefile                       |   4 +-
 test/mxc_sound_test/README                         |  10 +-
 test/mxc_sound_test/audio_controls.h               |  68 +++---
 test/mxc_sound_test/autorun-sound.sh               |   6 +-
 test/mxc_sound_test/check_audio_config.c           |   4 +-
 test/mxc_sound_test/check_mixer.c                  |   4 +-
 test/mxc_sound_test/check_recording.c              |  36 ++--
 test/mxc_sound_test/check_volume2.c                |   4 +-
 test/mxc_sound_test/dbmx31-ctrls.h                 |  16 +-
 test/mxc_sound_test/soundcard.h                    |  50 ++---
 test/mxc_sound_test/tool_playd.c                   |   4 +-
 test/mxc_uart_test/Makefile                        |   4 +-
 test/mxc_uart_test/mxc_uart_test.c                 |  12 +-
 test/mxc_usb_test/Makefile                         |   4 +-
 test/mxc_v4l2_test/mxc_v4l2_capture.c              |  56 ++---
 test/mxc_v4l2_test/mxc_v4l2_loopback.sh            |   4 +-
 test/mxc_v4l2_test/mxc_v4l2_overlay.c              |  80 +++----
 test/mxc_v4l2_test/mxc_v4l2_still.c                |  32 +--
 test/mxc_v4l2_test/mxc_v4l2_tvin.c                 |  12 +-
 test/mxc_vpu_test/capture.c                        |   2 +-
 test/mxc_vpu_test/dec.c                            |  20 +-
 test/mxc_vpu_test/display.c                        |  10 +-
 test/mxc_vpu_test/enc.c                            |  26 +--
 test/mxc_vpu_test/fb.c                             |   6 +-
 test/mxc_vpu_test/loopback.c                       |  12 +-
 test/mxc_vpu_test/main.c                           |   8 +-
 test/mxc_vpu_test/utils.c                          |  68 +++---
 test/wdog/wdt_driver_test.c                        |   8 +-
 144 files changed, 1859 insertions(+), 1859 deletions(-)

diff --git a/include/dptc_daemon.h b/include/dptc_daemon.h
index 7aa8b18..8605104 100644
--- a/include/dptc_daemon.h
+++ b/include/dptc_daemon.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -14,10 +14,10 @@
 /*!
  * @file include/dptc_daemon.h
  *
- * @brief DPTC daemon program header file. 
- * 
+ * @brief DPTC daemon program header file.
+ *
  * @ingroup DPTC
- */ 
+ */
 
 #ifndef __DAEMON_H__
 #define __DAEMON_H__
@@ -44,7 +44,7 @@ typedef struct
 	int dptc_fd;
 
 	/*!
-	 * File descriptor number of DPTC proc file system file 
+	 * File descriptor number of DPTC proc file system file
 	 * used for reading the DPTC log buffer.
 	 */
 	int log_fd;
@@ -135,9 +135,9 @@ typedef struct
 } command_msg_s;
 
 /*!
- * This structure is used in the daemon functions to indicate to the 
+ * This structure is used in the daemon functions to indicate to the
  * do_connection function (the communication thread main function) what
- * return message to send to the human interface and what is the data 
+ * return message to send to the human interface and what is the data
  * associated with the responce message.
  */
 typedef struct
diff --git a/module_test/memalloc.h b/module_test/memalloc.h
index f76992d..8450a54 100644
--- a/module_test/memalloc.h
+++ b/module_test/memalloc.h
@@ -1,4 +1,4 @@
-/* 
+/*
  * Memalloc, encoder memory allocation driver (kernel module)
  *
  * Copyright (C) 2005  Hantro Products Oy.
diff --git a/module_test/rng_test_driver.c b/module_test/rng_test_driver.c
index 759cbf8..da49ee3 100644
--- a/module_test/rng_test_driver.c
+++ b/module_test/rng_test_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -71,21 +71,21 @@ static os_driver_reg_t reg_handle;
 	OS_DEV_INIT(rng_test_init)
 	{
 		os_error_code code;
-	
+
 #ifdef RNG_DEBUG
 		os_printk("%s: Driver Initialization begins\n", RNG_TEST_DRIVER_NAME);
 #endif
 		code = rng_test_setup_user_driver_interaction();
-	
+
 #ifdef RNG_DEBUG
 		os_printk("%s: Driver Completed: %d\n", RNG_TEST_DRIVER_NAME, code);
 #endif
-	
+
 		os_dev_init_return(code);
 	} /* rng_test_init */
-	
-	
-	
+
+
+
 	/***********************************************************************
 	 * rng_test_open()													   *
 	 **********************************************************************/
@@ -98,13 +98,13 @@ static os_driver_reg_t reg_handle;
 	{
 		fsl_shw_uco_t* user_ctx = os_alloc_memory(sizeof(*user_ctx), 0);
 		os_error_code code = OS_ERROR_NO_MEMORY_S;
-	
+
 		if (user_ctx != NULL) {
 			fsl_shw_return_t ret;
-	
+
 			fsl_shw_uco_init(user_ctx, 20);
 			ret = fsl_shw_register_user(user_ctx);
-	
+
 			if (ret != FSL_RETURN_OK_S) {
 				code = OS_ERROR_FAIL_S;
 			} else {
@@ -112,11 +112,11 @@ static os_driver_reg_t reg_handle;
 				code = OS_ERROR_OK_S;
 			}
 		}
-	
+
 		os_dev_open_return(code);
 	}
-	
-	
+
+
 	/***********************************************************************
 	 * rng_test_ioctl() 												   *
 	 **********************************************************************/
@@ -145,7 +145,7 @@ static os_driver_reg_t reg_handle;
 	{
 		os_error_code  code = OS_ERROR_FAIL_S;
 		fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
+
 		switch (os_dev_get_ioctl_op()) {
 		case RNG_TEST_GET_RANDOM:
 			if (user_ctx != NULL) {
@@ -153,30 +153,30 @@ static os_driver_reg_t reg_handle;
 										   os_dev_get_ioctl_arg());
 			}
 			break;
-	
+
 		case RNG_TEST_ADD_ENTROPY:
 			if (user_ctx != NULL) {
 				code = rng_test_add_entropy(user_ctx,
 											os_dev_get_ioctl_arg());
 			}
 			break;
-	
+
 		case RNG_TEST_READ_REG:
 			code = rng_test_read_register(os_dev_get_ioctl_arg());
 			break;
-	
+
 		case RNG_TEST_WRITE_REG:
 			code = rng_test_write_register(os_dev_get_ioctl_arg());
 			break;
-	
+
 		default:
 			code = OS_ERROR_FAIL_S;
 		}
-	
+
 		os_dev_ioctl_return(code);
 	}
-	
-	
+
+
 	/***********************************************************************
 	 * rng_test_release()												   *
 	 **********************************************************************/
@@ -188,23 +188,23 @@ static os_driver_reg_t reg_handle;
 	OS_DEV_CLOSE(rng_test_release)
 	{
 		fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
+
 		if (user_ctx != NULL) {
 			fsl_shw_deregister_user(user_ctx);
 			os_free_memory(user_ctx);
 			os_dev_set_user_private(NULL);
 		}
-	
+
 		os_dev_close_return(OS_ERROR_OK_S);
 	}
-	
-	
+
+
 	/******************************************************************************
 	 *
 	 *	Function Implementations - IOCTL support
 	 *
 	 *****************************************************************************/
-	
+
 	/*****************************************************************************/
 	/* fn rng_test_get_random() 												 */
 	/*****************************************************************************/
@@ -224,7 +224,7 @@ static os_driver_reg_t reg_handle;
 		os_error_code	 code = OS_ERROR_BAD_ADDRESS_S;
 		uint32_t*		 data_buffer = NULL;
 		int 			 count_words;
-	
+
 		if (os_copy_from_user(&get_struct, (void *)rng_data, sizeof(get_struct))) {
 #ifdef RNG_DEBUG
 			os_printk("RNG TEST: Error reading get struct from user\n");
@@ -234,29 +234,29 @@ static os_driver_reg_t reg_handle;
 			count_words = (get_struct.count_bytes+sizeof(uint32_t)-1)/4;
 			rng_return = fsl_shw_get_random(user_ctx, sizeof(uint32_t)*count_words,
 											(uint8_t*) data_buffer);
-	
+
 			get_struct.function_return_code = rng_return;
-	
+
 			/* Copy return code back (by copying whole request structure. */
 			code = os_copy_to_user((void*)rng_data, &get_struct,
 								   sizeof(get_struct));
-	
+
 			/* If appropriate, copy back data. */
 			if (rng_return == RNG_RET_OK) {
 				code = os_copy_to_user(get_struct.random, data_buffer,
 									   get_struct.count_bytes);
 			}
-	
+
 			if (data_buffer != NULL) {
 				os_free_memory(data_buffer);
 			}
 		}
-	
-	
+
+
 		return code;
 	} /* rng_test_get_random */
-	
-	
+
+
 	/*****************************************************************************/
 	/* fn rng_test_add_entropy()												*/
 	/*****************************************************************************/
@@ -273,7 +273,7 @@ static os_driver_reg_t reg_handle;
 		rng_test_add_entropy_t add_struct;
 		uint8_t*			   entropy = NULL;
 		os_error_code		   code;
-	
+
 		code = os_copy_from_user(&add_struct, (void *)rng_data,
 								 sizeof(add_struct));
 		if (code != 0) {
@@ -297,11 +297,11 @@ static os_driver_reg_t reg_handle;
 				code = OS_ERROR_NO_MEMORY_S;
 			}
 		}
-	
+
 		return code;
 	} /* rng_test_add_entropy */
-	
-	
+
+
 	/*****************************************************************************/
 	/* fn rng_test_read_register()												*/
 	/*****************************************************************************/
@@ -325,7 +325,7 @@ static os_driver_reg_t reg_handle;
 		rng_test_reg_access_t reg_struct;
 		rng_return_t	 rng_return = -1;
 		os_error_code	 code;
-	
+
 		code = os_copy_from_user(&reg_struct, (void *)rng_data,
 								 sizeof(reg_struct));
 		if (code != OS_ERROR_OK_S) {
@@ -337,15 +337,15 @@ static os_driver_reg_t reg_handle;
 			rng_return = rng_read_register(reg_struct.reg_offset,
 										   &reg_struct.reg_data);
 			reg_struct.function_return_code = rng_return;
-	
+
 			code = os_copy_to_user((void *)rng_data, &reg_struct,
 								   sizeof(reg_struct));
 		}
-	
+
 		return code;
 	} /* rng_test_read_register */
-	
-	
+
+
 	/*****************************************************************************/
 	/* fn rng_test_write_register() 											*/
 	/*****************************************************************************/
@@ -369,7 +369,7 @@ static os_driver_reg_t reg_handle;
 		rng_test_reg_access_t reg_struct;
 		rng_return_t	 rng_return = -1;
 		os_error_code	 code;
-	
+
 		/* Try to copy user's reg_struct */
 		code = os_copy_from_user(&reg_struct, (void *)rng_data,
 								 sizeof(reg_struct));
@@ -385,19 +385,19 @@ static os_driver_reg_t reg_handle;
 			code = os_copy_to_user((void *)rng_data, &reg_struct,
 								   sizeof(reg_struct));
 		}
-	
+
 		return code;
 	} /* rng_test_write_register */
-	
-	
-	
+
+
+
 	/******************************************************************************
 	 *
 	 *	Function Implementations - Strictly Internal
 	 *
 	 *****************************************************************************/
-	
-	
+
+
 	/*****************************************************************************/
 	/* fn setup_user_driver_interaction()										 */
 	/*****************************************************************************/
@@ -411,7 +411,7 @@ static os_driver_reg_t reg_handle;
 	rng_test_setup_user_driver_interaction(void)
 	{
 		os_error_code code = OS_ERROR_FAIL_S;
-	
+
 		os_driver_init_registration(reg_handle);
 		os_driver_add_registration(reg_handle, OS_FN_OPEN,
 								   OS_DEV_IOCTL_REF(rng_test_open));
@@ -422,7 +422,7 @@ static os_driver_reg_t reg_handle;
 		code = os_driver_complete_registration(reg_handle,
 											   rng_test_major_node,
 											   RNG_TEST_DRIVER_NAME);
-	
+
 		if (code != OS_ERROR_OK_S) {
 			/* failure ! */
 #ifdef RNG_DEBUG
@@ -435,11 +435,11 @@ static os_driver_reg_t reg_handle;
 					  os_dev_driver_major_node(reg_handle));
 #endif
 		} /* else success */
-	
+
 		return code;
 	} /* rng_test_setup_user_driver_interaction */
-	
-	
+
+
 	/*****************************************************************************/
 	/* fn rng_test_cleanup()													*/
 	/*****************************************************************************/
@@ -455,17 +455,17 @@ static os_driver_reg_t reg_handle;
 	OS_DEV_SHUTDOWN(rng_test_cleanup)
 	{
 		os_error_code code = OS_ERROR_OK_S;
-	
+
 		if (rng_device_registered) {
 			/* turn off the mapping to the device special file */
 			code = os_driver_remove_registration(reg_handle);
 			rng_device_registered = 0;
 		}
-	
+
 #ifdef RNG_DEBUG
 		os_printk ("RNG Test: Cleaned up\n");
 #endif
-	
+
 		os_dev_shutdown_return(code);
 	} /* rng_test_cleanup */
 
diff --git a/module_test/scc2_test_driver.c b/module_test/scc2_test_driver.c
index 251bb39..8dd26e7 100644
--- a/module_test/scc2_test_driver.c
+++ b/module_test/scc2_test_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -463,7 +463,7 @@ do_encrypt_part(scc_part_cipher_access* acc, uint8_t* local_black,
     int status;
     uint32_t IV[4];
     uint32_t* iv_ptr = (uint32_t*)&(acc->iv);
-    
+
     /* Build the IV */
     IV[0] = iv_ptr[0];
     IV[1] = iv_ptr[1];
@@ -491,7 +491,7 @@ do_decrypt_part(scc_part_cipher_access* acc, uint8_t* local_black,
     int status;
     uint32_t IV[4];
     uint32_t* iv_ptr = (uint32_t*)&(acc->iv);
-    
+
     /* Build the IV */
     IV[0] = iv_ptr[0];
     IV[1] = iv_ptr[1];
diff --git a/readme.txt b/readme.txt
index 7ecdb33..e71aff2 100644
--- a/readme.txt
+++ b/readme.txt
@@ -2,15 +2,15 @@
 	Misc Stuff for Linux
 	====================
 
-This "misc" folder contains the source code and necessary build files for Linux 
-utility programs such as tests, demos, etc. All the non-Linux BSP source should 
+This "misc" folder contains the source code and necessary build files for Linux
+utility programs such as tests, demos, etc. All the non-Linux BSP source should
 go into this directory.
 
 
 1. Directory structure
 ======================
 
-Currently the "misc" directory is organized as follows to cover three types of 
+Currently the "misc" directory is organized as follows to cover three types of
 programs: bootloader, test and demo.
 
 misc
@@ -22,16 +22,16 @@ misc
   |_ test
        |_ demo
 
-  
+
 misc -> include
 ---------------
-	This directory's path is included in the build system so that generic 
-	header files can be put under this directory and be included by the source 
+	This directory's path is included in the build system so that generic
+	header files can be put under this directory and be included by the source
 	code.
 
 misc -> platform
 ----------------
-	This directory contains the build output files. Once "make" finishes, a 
+	This directory contains the build output files. Once "make" finishes, a
 	platform specific directory will be created.
 
 misc -> test
@@ -71,11 +71,11 @@ the linux tree.
 4. Adding autorun scripts
 =========================
 
-The autorun scripts are used to run the unit tests each night by the nightly build, 
-without human interaction.  After the tests are run, a script parses the output 
-into some emails to let the team know how well testing went that night and which 
-tests are having difficulty.  These scripts can also make it easier for people who 
-are not familiar with the unit tests to run them.  Currently the simplest autorun 
+The autorun scripts are used to run the unit tests each night by the nightly build,
+without human interaction.  After the tests are run, a script parses the output
+into some emails to let the team know how well testing went that night and which
+tests are having difficulty.  These scripts can also make it easier for people who
+are not familiar with the unit tests to run them.  Currently the simplest autorun
 script is misc/test/wdog/autorun-wdog.sh, which is quoted below.
 
       #!/bin/sh
@@ -92,12 +92,12 @@ script is misc/test/wdog/autorun-wdog.sh, which is quoted below.
       print_status
       exit $STATUS
 
-All scripts should have this form and contain basically everything that this test 
-have except for the "check_devnode" line.  Any tests deviating from this may break 
+All scripts should have this form and contain basically everything that this test
+have except for the "check_devnode" line.  Any tests deviating from this may break
 the autorun or have output that can't properly be parsed by the nightly build scripts.
 
-Tests must initialize STATUS=0 early on and can never set it to 0 again later in 
-the script as that might clear a failure code.  
+Tests must initialize STATUS=0 early on and can never set it to 0 again later in
+the script as that might clear a failure code.
 
 There are three files that you should be aware of, autorun.sh which runs the
 autorun scripts, autorun-suite.txt which lists the which autoruns to run (and
@@ -106,11 +106,11 @@ script uses.  All these are checked in to LINUX2.6/misc/.
 
 Any tests that require a specialized kernel build of course can not be run during
 the nightly run so they are not listed in autorun-suite.txt.  Still, these can
-be useful for humans running tests as they can run the test by hand without 
+be useful for humans running tests as they can run the test by hand without
 having to be familiar with the unit test.
 
 Also check the misc/test/wdog/Makefile for how the test gets copied.  The script
-just has to be added to the the OBJ list since there is a rule for .sh files in 
+just has to be added to the the OBJ list since there is a rule for .sh files in
 misc/tests/make.rules.
 
 If there are platforms that a test should not be built for or run on, add that
diff --git a/test/Makefile b/test/Makefile
index c1bef40..8c77c3c 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -1,5 +1,5 @@
 export INC = -I$(TOPDIR)/include $(INCLUDE)
- 
+
 # Get all dirs with a Makefile
 TMP_DIRS := $(foreach dir, $(wildcard *), $(wildcard $(dir)/Makefile))
 DIRS := $(patsubst %/Makefile,%,$(TMP_DIRS))
diff --git a/test/demo/dptc_hi_demo/dptc_hi.c b/test/demo/dptc_hi_demo/dptc_hi.c
index 181acb5..7960bd1 100644
--- a/test/demo/dptc_hi_demo/dptc_hi.c
+++ b/test/demo/dptc_hi_demo/dptc_hi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -14,11 +14,11 @@
 /*!
  * @file test/demo/dptc_hi_demo/dptc_hi.c
  *
- * @brief Human Interface program for the Freescale Semiconductor MXC DPTC module.  
- * 
+ * @brief Human Interface program for the Freescale Semiconductor MXC DPTC module.
+ *
  * The DPTC driver Human Interface program \n
- * This program communicates with the DPTC (Dynamic Process Temperature 
- * Compensation) daemon and allows the user to change parameters and control 
+ * This program communicates with the DPTC (Dynamic Process Temperature
+ * Compensation) daemon and allows the user to change parameters and control
  * the DPTC module. \n
  * This program allows the user to: \n
  *	1) Enable/Disable the DPTC module. \n
@@ -36,8 +36,8 @@
 #include <sys/ioctl.h>
 #include <errno.h>
 
-#include <unistd.h> 
-#include <termios.h> 
+#include <unistd.h>
+#include <termios.h>
 
 #include <asm-arm/arch-mxc/pm_api.h>
 
@@ -53,7 +53,7 @@
 typedef struct
 {
 	/*!
-	 * Points to the position in the buffer the next formatted log 
+	 * Points to the position in the buffer the next formatted log
 	 * entry will be written to.
 	 */
 	unsigned int	head;
@@ -94,43 +94,43 @@ void init_log_table(void)
  * @return    the character read from the terminal.
  *
  */
-char getch(void) 
-{ 
-	int rv; 
-	char ch; 
+char getch(void)
+{
+	int rv;
+	char ch;
 	/* force to stdin */
-	int fd = 0; 
-	struct termios oldflags, newflags; 
+	int fd = 0;
+	struct termios oldflags, newflags;
 
 	tcdrain(fd);
 
 	/*
-	 * Reset the terminal to accept unbuffered input 
+	 * Reset the terminal to accept unbuffered input
 	 */
 
 	/*
-	 * Get the current oldflags 
-	 */ 
-	tcgetattr(fd, &oldflags); 
-	/* Make a copy of the flags so we can easily restore them */ 
-	newflags = oldflags; 
-	/* Set raw input */ 
-	newflags.c_cflag |= (CLOCAL | CREAD); 
-	newflags.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); 
-
-
-	/* Set the newflags */ 
-	tcsetattr(fd, TCSANOW, &newflags); 
-	rv = read(fd, &ch, 1); 
-
-	/* 
-	 * Restore the oldflags -- This is important otherwise 
-	 * your terminal will no longer echo characters 
-	 */ 
-	tcflush(fd, TCIFLUSH); 
-	tcsetattr(fd, TCSANOW, &oldflags); 
-	return ch; 
-} 
+	 * Get the current oldflags
+	 */
+	tcgetattr(fd, &oldflags);
+	/* Make a copy of the flags so we can easily restore them */
+	newflags = oldflags;
+	/* Set raw input */
+	newflags.c_cflag |= (CLOCAL | CREAD);
+	newflags.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
+
+
+	/* Set the newflags */
+	tcsetattr(fd, TCSANOW, &newflags);
+	rv = read(fd, &ch, 1);
+
+	/*
+	 * Restore the oldflags -- This is important otherwise
+	 * your terminal will no longer echo characters
+	 */
+	tcflush(fd, TCIFLUSH);
+	tcsetattr(fd, TCSANOW, &oldflags);
+	return ch;
+}
 
 /*!
  * This function reads a single character from the terminal and echoes it
@@ -139,46 +139,46 @@ char getch(void)
  * @return    the character read from the terminal.
  *
  */
-char getche(void) 
-{ 
-	int rv; 
-	char ch; 
+char getche(void)
+{
+	int rv;
+	char ch;
 	int fd = 0; /* force to stdin */
-	struct termios oldflags, newflags; 
+	struct termios oldflags, newflags;
 
 	tcdrain(fd);
 	/*
-	 * Reset the terminal to accept unbuffered input 
+	 * Reset the terminal to accept unbuffered input
 	 */
 
 	/*
-	 * Get the current oldflags 
-	 */ 
-	tcgetattr(fd, &oldflags); 
+	 * Get the current oldflags
+	 */
+	tcgetattr(fd, &oldflags);
 
-	/* Make a copy of the flags so we can easily restore them */ 
-	newflags = oldflags; 
+	/* Make a copy of the flags so we can easily restore them */
+	newflags = oldflags;
 
-	/* Set raw input */ 
-	newflags.c_cflag |= (CLOCAL | CREAD); 
-	newflags.c_lflag &= ~(ICANON | ECHOE | ISIG); 
+	/* Set raw input */
+	newflags.c_cflag |= (CLOCAL | CREAD);
+	newflags.c_lflag &= ~(ICANON | ECHOE | ISIG);
 
 
-	/* Set the newflags */ 
-	tcsetattr(fd, TCSANOW, &newflags); 
+	/* Set the newflags */
+	tcsetattr(fd, TCSANOW, &newflags);
 
 	/* Read character from terminal */
-	rv = read(fd, &ch, 1); 
+	rv = read(fd, &ch, 1);
 
 	/* Flush received characters */
-	tcflush(fd, TCIFLUSH); 
+	tcflush(fd, TCIFLUSH);
 
-	/* 
+	/*
 	 * Restore the oldflags
-	 */ 
-	tcsetattr(fd, TCSANOW, &oldflags); 
-	return ch; 
-} 
+	 */
+	tcsetattr(fd, TCSANOW, &oldflags);
+	return ch;
+}
 
 /*!
  * This function check if a key was pressed on the terminal keyboard.
@@ -190,35 +190,35 @@ int kbhit(void)
 {
 	unsigned char ch;
 	int nread;
-	struct termios oldflags, newflags; 
+	struct termios oldflags, newflags;
 
-	tcgetattr(0, &oldflags); 
-	/* Make a copy of the flags so we can easily restore them */ 
-	newflags = oldflags; 
+	tcgetattr(0, &oldflags);
+	/* Make a copy of the flags so we can easily restore them */
+	newflags = oldflags;
 
-	/* Set raw input */ 
-	newflags.c_cflag |= (CLOCAL | CREAD); 
-	newflags.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); 
+	/* Set raw input */
+	newflags.c_cflag |= (CLOCAL | CREAD);
+	newflags.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
 
 	/* Set mimimal characters read to 0 */
 	newflags.c_cc[VMIN]=0;
 	newflags.c_cc[VTIME] = 0;
 
-	/* Set the newflags */ 
+	/* Set the newflags */
 	tcsetattr(0, TCSANOW, &newflags);
 
 	nread = read(0,&ch,1);
 
-	/* Restore the oldflags */ 
+	/* Restore the oldflags */
 	tcsetattr(0, TCSANOW, &oldflags);
-	if (nread == 1) 
+	if (nread == 1)
 		return 1;
 
 	return 0;
 }
 
 /*!
- * This function sends an DPTC module enable command to the DPTC daemon and 
+ * This function sends an DPTC module enable command to the DPTC daemon and
  * waits for an ack message.
  *
  * @param     sock	the communication socket file descriptor number.
@@ -231,7 +231,7 @@ void enable_dptc(int dptc_fh)
 }
 
 /*!
- * This function sends an DPTC module Disable command to the DPTC daemon and 
+ * This function sends an DPTC module Disable command to the DPTC daemon and
  * waits for an ack message.
  *
  * @param     sock	the communication socket file descriptor number.
@@ -250,7 +250,7 @@ void disable_dptc(int dptc_fh)
  *
  * @param     sock	the communication socket file descriptor number.
  *
- * @return    1 if the DPTC module is enabled, 0 if the DPTC is disabled and 
+ * @return    1 if the DPTC module is enabled, 0 if the DPTC is disabled and
  *	      -1 if an error occured while receiving the ack message.
  *
  */
@@ -260,14 +260,14 @@ int dptc_is_active(int dptc_fh)
 }
 
 /*!
- * This function checks the value of the frequency index used by 
+ * This function checks the value of the frequency index used by
  * the DPTC module.\n
  * The function sends a GET_FREQ command to the DPTC daemon and waits for an
  * ack message that contains the frequency index used in the message parameter.
  *
  * @param     sock	the communication socket file descriptor number.
  *
- * @return    the value of the frequency index used. returns -1 if an error 
+ * @return    the value of the frequency index used. returns -1 if an error
  *	      occured while receiving the ack message.
  *
  */
@@ -278,16 +278,16 @@ int get_current_freq_index(int dptc_fh)
 }
 */
 /*!
- * This function sets the value of the frequency index used by 
+ * This function sets the value of the frequency index used by
  * the DPTC module.\n
- * The function sends a SET_FREQ command to the DPTC daemon and waits 
- * for an ack message. if an ack message is not received the function 
+ * The function sends a SET_FREQ command to the DPTC daemon and waits
+ * for an ack message. if an ack message is not received the function
  * prints an error message.
  *
  * @param     sock	   the communication socket file descriptor number.
  * @param     freq_index   new frequency index value to be set.
  *
- * @return    the value of the frequency index used. returns -1 if an error 
+ * @return    the value of the frequency index used. returns -1 if an error
  *	      occured while receiving the ack message.
  *
  */
@@ -322,7 +322,7 @@ void set_wp(int wp,int dptc_fh)
  * @param     buffer	pointer to the new DPTC translation table.
  * @param     size	size of new DPTC translation table.
  *
- * @return    TRUE if ack message was received from the DPTC daemon else 
+ * @return    TRUE if ack message was received from the DPTC daemon else
  *	      returns FALSE.
  *
  */
@@ -332,7 +332,7 @@ int send_table(int dptc_fh, void *buffer, int size)
 }
 
 /*!
- * This function reads a new DPTC translation table from a file and 
+ * This function reads a new DPTC translation table from a file and
  * updates the DPTC driver to the new table through the DPTC daemon.\n
  * The function gets from the user the file name of the new translation table
  * opens and reads it and updates the driver by using the send_table function.
@@ -354,12 +354,12 @@ int write_table(int dptc_fh)
         count =0;
 
         memset(in_buffer,0,4096);
-        
+
 	/* Get table file name from user */
 	printf("\nInput file name: ");
 	scanf("%80s",file_name);
 
-	/* 
+	/*
 	 * Open table file for reading.
 	 * If error occured while opening file print error message and return -1
 	 */
@@ -370,15 +370,15 @@ int write_table(int dptc_fh)
 
         while (! feof(table_file)){
                 fgets(line,256,table_file);
-                
+
                 count += strlen(line);
-                
+
                 if(count > 4096){
                         free(in_buffer);
                         ret_val = -1;
                         break;
                 }
-                
+
                 strcat(in_buffer,line);
         }
 
@@ -386,8 +386,8 @@ int write_table(int dptc_fh)
                 printf("Failed reading table file\n");
         }
         else if (send_table(dptc_fh, (void*)in_buffer, count) < 0) {
-                /* 
-                 * Error updating the driver DPTC table 
+                /*
+                 * Error updating the driver DPTC table
                  * (ack not received from the DPTC daemon)
                  */
                 printf("Error updating DPTC table\n");
@@ -401,10 +401,10 @@ int write_table(int dptc_fh)
 }
 
 /*!
- * This function reads the DPTC translation table used by the DPTC driver via 
+ * This function reads the DPTC translation table used by the DPTC driver via
  * the DPTC daemon and writes it to an output file.\n
  * The function sends a READ_TABLE command to the DPTC daemon and waits
- * for the returned data containing the DPTC taranslation table currently used 
+ * for the returned data containing the DPTC taranslation table currently used
  * by the DPTC driver.\n
  *
  * @param     sock	the communication socket file descriptor number.
@@ -423,16 +423,16 @@ int read_table(int dptc_fh)
 	printf("\nOutput file name: ");
 	scanf("%80s",file_name);
 
-        in_buffer = malloc(4096);        
-		
+        in_buffer = malloc(4096);
+
         /* Check if memory was allocated */
         if (in_buffer) {
 
                 memset(in_buffer,0,4096);
-                
+
                 /* Wait and read message from daemon containing table data */
                 if (ioctl(dptc_fh,PM_IOCGTABLE,in_buffer) >= 0) {
-                        
+
                         /* Open output file for writing */
                         if ((table_file = open(file_name, O_WRONLY | O_CREAT)) < 0) {
                                 /* Unable to open output file */
@@ -441,7 +441,7 @@ int read_table(int dptc_fh)
                         } else {
                                 /* Write table data to output file */
                                 write(table_file, in_buffer, strlen(in_buffer)+1);
-                                
+
                                 /* Close output file */
                                 close(table_file);
                         }
@@ -450,18 +450,18 @@ int read_table(int dptc_fh)
                         printf("Error receiving message\n");
                         ret_val = -1;
                 }
-                
+
                 /* Free allocated memory */
                 free(in_buffer);
         } else {
-                /* 
-                 * Unable to allocate memory for table 
+                /*
+                 * Unable to allocate memory for table
                  * Print error message, close input file and return -1
                  */
                 printf("Error allocating memory\n");
                 ret_val = -1;
         }
-        
+
 	return ret_val;
 }
 
@@ -471,19 +471,19 @@ int read_table(int dptc_fh)
  *
  * @param     sock		the communication socket file descriptor number.
  * @param     num_of_entries	number of log entries to read.
- * @param     log_entries	pointer to the buffer where the log entries 
+ * @param     log_entries	pointer to the buffer where the log entries
  *				should be placed.
  *
- * @return    if read succeeded returns the number of bytes written to the 
+ * @return    if read succeeded returns the number of bytes written to the
  *	      log_entries buffer, else returns -1.
  *
  */
 int get_log_entries(int dptc_proc_fh, int num_of_entries, dptc_log_entry_s *log_entries)
 {
         int read_size;
-        
-        read_size = num_of_entries * sizeof(dptc_log_entry_s);        
-        
+
+        read_size = num_of_entries * sizeof(dptc_log_entry_s);
+
 	/* Wait for ack message from the daemon */
 	if ((read_size = read(dptc_proc_fh, log_entries, read_size)) >= 0) {
                 return read_size;
@@ -495,7 +495,7 @@ int get_log_entries(int dptc_proc_fh, int num_of_entries, dptc_log_entry_s *log_
 }
 
 /*!
- * This function displays the last LOG_NUM_OF_ROWS DPTC log entries as a 
+ * This function displays the last LOG_NUM_OF_ROWS DPTC log entries as a
  * formatted text table.
  *
  * @param     sock		the communication socket file descriptor number.
@@ -510,9 +510,9 @@ void show_dptc_log(int dptc_proc_fh)
 	while (!kbhit()) {
 		/* Clear screen */
 		system("clear");
-		/* 
+		/*
 		 * Read all the log entries from the DPTC driver.
-		 * Entries are read one by one, formatted as a text line and added 
+		 * Entries are read one by one, formatted as a text line and added
 		 * to the buffer to be displayed.
 		 */
 		while (get_log_entries(dptc_proc_fh, 1, &log_entry) > 0) {
@@ -553,7 +553,7 @@ void process_cmd(char cmd,int dptc_fh,int dptc_proc_fh)
 
 	switch (cmd) {
 	/* Enable DPTC module command */
-	case '1':		
+	case '1':
 		enable_dptc(dptc_fh);
 		break;
 	/* Disable DPTC module command */
@@ -578,12 +578,12 @@ void process_cmd(char cmd,int dptc_fh,int dptc_proc_fh)
 	case '6':
 		show_dptc_log(dptc_proc_fh);
 		break;
-        /* Set working point */        
+        /* Set working point */
         case '7':
                 printf("\nNew working point: ");
 		scanf("%d",&wp);
 		set_wp(wp,dptc_fh);
-		break;        
+		break;
 	/* Quit */
 	case '8':
 		send_quit(dptc_fh,dptc_proc_fh);
@@ -642,13 +642,13 @@ void human_interface(int dptc_fh,int dptc_proc_fh)
  * @param     argv	array of strings containing the program arguments.
  *
  * @return    0 if program exited with no error. else returns -1.
- * 
+ *
  */
 int main(int argc, char *argv[])
 {
 
         int dptc_fh,dptc_proc_fh;
-        
+
 	printf("DPTC Daemon Human Interface Program Ver 2.0\n");
 
 #ifdef DPTC_KKP_DEBUG
@@ -656,19 +656,19 @@ int main(int argc, char *argv[])
                 printf("Error openning //dev//mxckpd");
                 return -1;
         }
-#endif        
+#endif
 
         if((dptc_fh = open("/dev/dptc",O_RDWR))<0){
                 printf("Failed open /dev/dptc\n");
                 return -1;
         }
-        
-        
+
+
         if((dptc_proc_fh = open("/proc/dptc",O_RDONLY))<0){
                  printf("Failed open /proc/dptc\n");
                 return -1;
         }
-        
+
         init_log_table();
 
         /* Start human interface */
diff --git a/test/max8660_pmic_test/pmic_testapp_rtc/Makefile b/test/max8660_pmic_test/pmic_testapp_rtc/Makefile
index f6ea3e5..675413a 100644
--- a/test/max8660_pmic_test/pmic_testapp_rtc/Makefile
+++ b/test/max8660_pmic_test/pmic_testapp_rtc/Makefile
@@ -8,7 +8,7 @@ OBJS=$(patsubst %.c,%.o,$(SRCS))
 all : $(TARGET)
 	mkdir -p $(OBJDIR)
 	cp -f $(TARGET) $(OBJDIR)
-        
+
 $(TARGET): $(OBJS)
 	$(CC) $(OBJS) $(LOADLIBES) -o $@
 
diff --git a/test/mxc_ata_test/identify.c b/test/mxc_ata_test/identify.c
index aa3b741..cf29f6d 100644
--- a/test/mxc_ata_test/identify.c
+++ b/test/mxc_ata_test/identify.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -95,7 +95,7 @@
 #define ERASE_TIME		89  /*   - ordinary */
 #define ENH_ERASE_TIME		90  /*   - enhanced */
 #define ADV_PWR			91  /* current advanced power management level
-				       in low byte, 0x40 in high byte. */  
+				       in low byte, 0x40 in high byte. */
 #define PSWD_CODE		92  /* master password revision code	*/
 #define HWRST_RSLT		93  /* hardware reset result */
 #define ACOUSTIC  		94  /* acoustic mgmt values ( >= ATA-6) */
@@ -127,7 +127,7 @@
 #define NOVAL_1			0xffff
 
 /* word 0: gen_config */
-#define NOT_ATA			0x8000	
+#define NOT_ATA			0x8000
 #define NOT_ATAPI		0x4000	/* (check only if bit 15 == 1) */
 #define MEDIA_REMOVABLE		0x0080
 #define DRIVE_NOT_REMOVABLE	0x0040  /* bit obsoleted in ATA 6 */
@@ -200,7 +200,7 @@ const char *ata1_cfg_str[] = {			/* word 0 in ATA-1 mode */
 /* word 1: number of logical cylinders */
 #define LCYLS_MAX		0x3fff /* maximum allowable value */
 
-/* word 2: specific configureation 
+/* word 2: specific configureation
  * (a) require SET FEATURES to spin-up
  * (b) require spin-up to fully reply to IDENTIFY DEVICE
  */
@@ -291,7 +291,7 @@ const char *minor_str[MINOR_MAX+2] = {			/* word 81 value: */
 	"ATA/ATAPI-6 published, ANSI INCITS 361-2002",	/* 0x0022	*/
 	"Reserved"					/* 0x0023-0xfffe*/
 };
-const char actual_ver[MINOR_MAX+2] = { 
+const char actual_ver[MINOR_MAX+2] = {
 			/* word 81 value: */
 	0,		/* 0x0000	WARNING: 	*/
 	1,		/* 0x0001	WARNING: 	*/
@@ -335,14 +335,14 @@ const char actual_ver[MINOR_MAX+2] = {
 #define CMDS_W82		0x77ff  /* word 82: defined command locations*/
 #define CMDS_W83		0x3fff  /* word 83: defined command locations*/
 #define CMDS_W84		0x27ff  /* word 84: defined command locations*/
-#define SUPPORT_48_BIT		0x0400  
+#define SUPPORT_48_BIT		0x0400
 #define NUM_CMD_FEAT_STR	48
 
 static const char unknown[8] = "obsolete";
 //static const char unknown[8] = "unknown";
 #define unknown "unknown-"
 
-static const char *feat_0_str[16] = { 
+static const char *feat_0_str[16] = {
 	"obsolete 82[15]",				/* word 82 bit 15: obsolete  */
 	"NOP cmd",					/* word 82 bit 14 */
 	"READ_BUFFER command",				/* word 82 bit 13 */
@@ -360,7 +360,7 @@ static const char *feat_0_str[16] = {
 	"Security Mode feature set",			/* word 82 bit  1 */
 	"SMART feature set"				/* word 82 bit  0 */
 };
-static const char *feat_1_str[16] = { 
+static const char *feat_1_str[16] = {
 	NULL,						/* word 83 bit 15: !valid bit */
 	NULL,						/* word 83 bit 14:  valid bit */
 	"FLUSH_CACHE_EXT",				/* word 83 bit 13 */
@@ -378,7 +378,7 @@ static const char *feat_1_str[16] = {
 	"READ/WRITE_DMA_QUEUED",			/* word 83 bit  1 */
 	"DOWNLOAD_MICROCODE"				/* word 83 bit  0 */
 };
-static const char *feat_2_str[16] = { 
+static const char *feat_2_str[16] = {
 	NULL,						/* word 84 bit 15: !valid bit */
 	NULL,						/* word 84 bit 14:  valid bit */
 	"IDLE_IMMEDIATE with UNLOAD",			/* word 84 bit 13 */
@@ -396,7 +396,7 @@ static const char *feat_2_str[16] = {
 	"SMART self-test",				/* word 84 bit  1 */
 	"SMART error logging"				/* word 84 bit  0 */
 };
-static const char *feat_3_str[16] = { 
+static const char *feat_3_str[16] = {
 	NULL,						/* word 119 bit 15: !valid bit */
 	NULL,						/* word 119 bit 14:  valid bit */
 	"unknown 119[13]",				/* word 119 bit 13 */
@@ -414,7 +414,7 @@ static const char *feat_3_str[16] = {
 	"Write-Read-Verify feature set",		/* word 119 bit  1 */
 	"unknown 119[0]"				/* word 119 bit  0: reserved for DT2014 */
 };
-static const char *cap_sata0_str[16] = { 
+static const char *cap_sata0_str[16] = {
 	"unknown 76[15]",				/* word 76 bit 15 */
 	"unknown 76[14]",				/* word 76 bit 14 */
 	"unknown 76[13]",				/* word 76 bit 13 */
@@ -453,7 +453,7 @@ static const char *feat_sata0_str[16] = {
 
 /* words 85-87: cmds/feats enabled */
 /* use cmd_feat_str[] to display what commands and features have
- * been enabled with words 85-87 
+ * been enabled with words 85-87
  */
 
 /* words 89, 90, SECU ERASE TIME */
@@ -472,7 +472,7 @@ static const char *feat_sata0_str[16] = {
 /* word 127: removable media status notification feature set support */
 #define RM_STAT_BITS 		0x0003
 #define RM_STAT_SUP		0x0001
-	
+
 /* word 128: security */
 #define SECU_ENABLED		0x0002
 #define SECU_LEVEL		0x0100	/* was 0x0010 */
@@ -606,7 +606,7 @@ void identify (__u16 *id_supplied, const char *devname)
 			val[ii] = (__u16)scratch;
 			chksum += val[ii] + (val[ii] >> 8);
 		}
-		fclose(fl);  
+		fclose(fl);
 		if(ii < (INTEGRITY+1)) {
 			fprintf(stderr,"Input file wrong format or length\n");
 			exit(ii);
@@ -640,7 +640,7 @@ void identify (__u16 *id_supplied, const char *devname)
 
 	/* Info from the specific configuration word says whether or not the
 	 * ID command completed correctly.  It is only defined, however in
-	 * ATA/ATAPI-5 & 6; it is reserved (value theoretically 0) in prior 
+	 * ATA/ATAPI-5 & 6; it is reserved (value theoretically 0) in prior
 	 * standards.  Since the values allowed for this word are extremely
 	 * specific, it should be safe to check it now, even though we don't
 	 * know yet what standard this device is using.
@@ -651,7 +651,7 @@ void identify (__u16 *id_supplied, const char *devname)
 		if((val[CONFIG]==STBY_NID_VAL) || (val[CONFIG]==STBY_ID_VAL))
 			printf("powers-up in standby; SET FEATURES subcmd spins-up.\n");
 		if(((val[CONFIG]==STBY_NID_VAL) || (val[CONFIG]==PWRD_NID_VAL)) &&
-		   (val[GEN_CONFIG] & INCOMPLETE)) 
+		   (val[GEN_CONFIG] & INCOMPLETE))
 			printf("\n\tWARNING: ID response incomplete.\n\tWARNING: Following data may be incorrect.\n\n");
 	}
 
@@ -735,7 +735,7 @@ void identify (__u16 *id_supplied, const char *devname)
 			like_std = 5;
 		}  else if(((std == 3) || (!std && (like_std < 4))) &&
 			   ((((val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
-			     (((val[CMDS_SUPP_1] & CMDS_W83) > 0x0000) ||  
+			     (((val[CMDS_SUPP_1] & CMDS_W83) > 0x0000) ||
 			      ((val[CMDS_SUPP_0] & CMDS_W82) > 0x000f))) ||
 			    ((val[CAPAB_1] & VALID) == VALID_VAL) ||
 			    ((val[WHATS_VALID] & OK_W88) && val[ULTRA_DMA]) ||
@@ -836,16 +836,16 @@ void identify (__u16 *id_supplied, const char *devname)
 						mm = nn;
 				}
 				printf("\tCHS current addressable sectors:%11u\n",mm);
-			} 
+			}
 		}
 		if (val[CAPAB_0] & LBA_SUP) {
 		/* LBA addressing */
 			printf("\tLBA    user addressable sectors:%11u\n",ll);
 			if( ((val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
 			     (val[CMDS_SUPP_1] & SUPPORT_48_BIT) ) {
-				bbbig = (__u64)val[LBA_64_MSB] << 48 | 
+				bbbig = (__u64)val[LBA_64_MSB] << 48 |
 				        (__u64)val[LBA_48_MSB] << 32 |
-				        (__u64)val[LBA_MID] << 16 | 
+				        (__u64)val[LBA_MID] << 16 |
 					val[LBA_LSB] ;
 				printf("\tLBA48  user addressable sectors:%11llu\n", (unsigned long long)bbbig);
 			}
@@ -877,7 +877,7 @@ void identify (__u16 *id_supplied, const char *devname)
 		else			     printf("(cannot");
 		printf(" be disabled)");
 	} else {
-		printf("IORDY not likely"); 
+		printf("IORDY not likely");
 	}
 	printf("\n");
 	if((like_std == 1) && val[BUF_TYPE]) {
@@ -992,10 +992,10 @@ void identify (__u16 *id_supplied, const char *devname)
 		}
 		printf("\n");
 
-		if((dev == ATAPI_DEV) && (eqpt != CDROM) && (val[CAPAB_0] & DMA_IL_SUP)) 
+		if((dev == ATAPI_DEV) && (eqpt != CDROM) && (val[CAPAB_0] & DMA_IL_SUP))
 			printf("\t     Interleaved DMA support\n");
 
-		if((val[WHATS_VALID] & OK_W64_70) && 
+		if((val[WHATS_VALID] & OK_W64_70) &&
 		   (val[DMA_TIME_MIN] || val[DMA_TIME_NORM])) {
 			printf("\t     Cycle time:");
 			if(val[DMA_TIME_MIN])
@@ -1053,11 +1053,11 @@ void identify (__u16 *id_supplied, const char *devname)
 		if (transport == 1 || (val[SATA_SUPP_0] && val[SATA_SUPP_0] != 0xffff))
 			print_features(val[SATA_SUPP_0], val[SATA_EN_0], feat_sata0_str);
 	}
-	if((val[RM_STAT] & RM_STAT_BITS) == RM_STAT_SUP) 
+	if((val[RM_STAT] & RM_STAT_BITS) == RM_STAT_SUP)
 		printf("\tRemovable Media Status Notification feature set supported\n");
 
 	/* security */
-	if((eqpt != CDROM) && (like_std > 3) && 
+	if((eqpt != CDROM) && (like_std > 3) &&
 	   (val[SECU_STATUS] || val[ERASE_TIME] || val[ENH_ERASE_TIME])) {
 		printf("Security: \n");
 		if(val[PSWD_CODE] && (val[PSWD_CODE] != NOVAL_1))
@@ -1098,7 +1098,7 @@ void identify (__u16 *id_supplied, const char *devname)
 			printf("\tDevice num = 1");
 			jj = val[HWRST_RSLT] >> 8;
 		}
-		if((jj & DEV_DET) == JUMPER_VAL) 
+		if((jj & DEV_DET) == JUMPER_VAL)
 			printf(" determined by the jumper");
 		else if((jj & DEV_DET) == CSEL_VAL)
 			printf(" determined by CSEL");
@@ -1145,7 +1145,7 @@ __u8 mode_loop(__u16 mode_sup, __u16 mode_sel, int cc, __u8 *have_mode) {
 void print_ascii(__u16 *p, __u8 length) {
 	__u8 ii;
 	char cl;
-	
+
 	/* find first non-space & print it */
 	for(ii = 0; ii< length; ii++) {
 		if(((char) 0x00ff&((*p)>>8)) != ' ') break;
diff --git a/test/mxc_ata_test/mxc_ata_test.c b/test/mxc_ata_test/mxc_ata_test.c
index ae519ee..5b76b7f 100644
--- a/test/mxc_ata_test/mxc_ata_test.c
+++ b/test/mxc_ata_test/mxc_ata_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -233,7 +233,7 @@ static void dump_identity (const struct hd_driveid *id)
 		if (id->major_rev_num != 0x0000 &&  /* NOVAL_0 */
 		    id->major_rev_num != 0xFFFF) {  /* NOVAL_1 */
 			/* through ATA/ATAPI-7 is currently defined--
-			 * increase this value as further specs are 
+			 * increase this value as further specs are
 			 * standardized (though we can guess safely to 15)
 			 */
 			for (i=0; i <= 7; i++) {
@@ -754,7 +754,7 @@ int main(int argc, char **argv)
 	while (argc--) {
 		p = *argv++;
 		if (*p == '-') {
-		
+
 			if (!*++p) usage_error(1);
 
 			while ((c = *p++)) {
diff --git a/test/mxc_fb_test/mxc_fb_test.c b/test/mxc_fb_test/mxc_fb_test.c
index cc84688..a36e921 100644
--- a/test/mxc_fb_test/mxc_fb_test.c
+++ b/test/mxc_fb_test/mxc_fb_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -82,7 +82,7 @@ struct testbuffer buffers[5];
 int process_cmdline(int argc, char **argv)
 {
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-iw") == 0) {
                         g_in_width = atoi(argv[++i]);
@@ -123,7 +123,7 @@ int process_cmdline(int argc, char **argv)
 
         printf("g_in_width = %d, g_in_height = %d\n", g_in_width, g_in_height);
         printf("g_display_width = %d, g_display_height = %d\n", g_display_width, g_display_height);
-        
+
         if ((g_in_width == 0) || (g_display_width == 0) || (g_in_height == 0) ||
             (g_display_height == 0)) {
                 return -1;
@@ -192,7 +192,7 @@ void fb_test_bpp(int fd, unsigned short * fb)
                 fb[i] = 0x07E0;
         sleep(3);
 
-}        
+}
 
 
 void fb_test_gbl_alpha(void)
@@ -326,7 +326,7 @@ main(int argc, char **argv)
         {
                 goto err1;
         }
-	
+
 
         printf("Opened fb0 and fb1\n");
 
@@ -369,7 +369,7 @@ main(int argc, char **argv)
                 goto err3;
         }
         g_fb1_size = screen_info.xres * screen_info.yres_virtual * screen_info.bits_per_pixel / 8;
-        
+
         /* Map the device to memory*/
         fb1 = (unsigned short *)mmap(0, g_fb1_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb1, 0);
         if ((int)fb1 <= 0)
diff --git a/test/mxc_fb_test/mxc_tvout_test.c b/test/mxc_fb_test/mxc_tvout_test.c
index a8c908f..516c44f 100644
--- a/test/mxc_fb_test/mxc_tvout_test.c
+++ b/test/mxc_fb_test/mxc_tvout_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -13,9 +13,9 @@
 
 /*
  * @file mxc_tvout_test.c
- * 
+ *
  * @brief MXC TVOUT test application
- * 
+ *
  */
 
 #ifdef __cplusplus
@@ -68,9 +68,9 @@ void usage(char *app)
 }
 
 int main(int argc, char **argv)
-{    
+{
 	int fd, err, rt;
-	
+
 	if (argc < 2) {
 		usage(argv[0]);
 		return 0;
@@ -123,7 +123,7 @@ int main(int argc, char **argv)
 		printf(MSGHEADER"Can not open %s.\n", TVOUT_DEV);
 		return -1;
 	}
-	
+
 	if (cap.inputs != -1) {
 		err = ioctl(fd, ENCODER_GET_CAPABILITIES, &cap);
 		if (err) {
@@ -177,7 +177,7 @@ int main(int argc, char **argv)
 	}
 
 	close(fd);
-	
+
 	return 0;
 }
 
diff --git a/test/mxc_hdd_test/autorun-ata.sh b/test/mxc_hdd_test/autorun-ata.sh
index 3d9faea..de315d8 100755
--- a/test/mxc_hdd_test/autorun-ata.sh
+++ b/test/mxc_hdd_test/autorun-ata.sh
@@ -19,7 +19,7 @@ run_hdd_case()
 		dd if=/root/hdd_data of=/dev/hda bs=512 count=10240
 		dd if=/dev/hda of=/root/hdd_data1 bs=512 count=10240
 	else
-	
+
 		dd if=/root/hdd_data of=/dev/sda bs=512 count=10240
 		dd if=/dev/sda of=/root/hdd_data1 bs=512 count=10240
 	fi
diff --git a/test/mxc_i2c_test/mxc_i2c_test.c b/test/mxc_i2c_test/mxc_i2c_test.c
index 34cfa61..284208b 100644
--- a/test/mxc_i2c_test/mxc_i2c_test.c
+++ b/test/mxc_i2c_test/mxc_i2c_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -38,7 +38,7 @@ int main(int argc, char **argv)
         /* Enable the CSI clock */
         ioctl(i2c_file, MXCTEST_I2C_CSICLKENB, &i2c_test);
 
-        i2c_test.bus = 0;         
+        i2c_test.bus = 0;
         i2c_test.slave_addr = 0x48;
 
         printf("Slave address=0x%x\n\n", i2c_test.slave_addr);
diff --git a/test/mxc_i2c_test/mxc_i2c_test_magna_cam.c b/test/mxc_i2c_test/mxc_i2c_test_magna_cam.c
index 0a3bfea..60fc87e 100644
--- a/test/mxc_i2c_test/mxc_i2c_test_magna_cam.c
+++ b/test/mxc_i2c_test/mxc_i2c_test_magna_cam.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -39,14 +39,14 @@ int main(int argc, char **argv)
         /* Enable the CSI clock */
         ioctl(i2c_file, MXCTEST_I2C_CSICLKENB, &i2c_test);
 
-        i2c_test.bus = 0;         
+        i2c_test.bus = 0;
         i2c_test.slave_addr = 0x11; // Camera slave address
 
         printf("Slave address=%x\n", i2c_test.slave_addr);
 
         /* Write to reg */
         reg[0] = 0x32;
-        buf[0] = 0x3; 
+        buf[0] = 0x3;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         i2c_test.buf = buf;
@@ -67,7 +67,7 @@ int main(int argc, char **argv)
         } else {
                 printf("\nI2C TEST PASSED\n\n");
         }
-        
+
         /* Disable the CSI clock */
         ioctl(i2c_file, MXCTEST_I2C_CSICLKDIS, &i2c_test);
 
diff --git a/test/mxc_i2c_test/mxc_i2c_test_samsung_cam.c b/test/mxc_i2c_test/mxc_i2c_test_samsung_cam.c
index 5c3d0c9..5856340 100644
--- a/test/mxc_i2c_test/mxc_i2c_test_samsung_cam.c
+++ b/test/mxc_i2c_test/mxc_i2c_test_samsung_cam.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -38,14 +38,14 @@ int main(int argc, char **argv)
         /* Enable the CSI clock */
         ioctl(i2c_file, MXCTEST_I2C_CSICLKENB, &i2c_test);
 
-        i2c_test.bus = 0;         
+        i2c_test.bus = 0;
         i2c_test.slave_addr = 0x2d; // Camera slave address
 
         printf("Slave address=%x\n", i2c_test.slave_addr);
-        
+
         /* Change to CIS register map page 02 */
         reg[0] = 0xEC;
-        buf[0] = 0x2; 
+        buf[0] = 0x2;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         i2c_test.buf = buf;
@@ -55,7 +55,7 @@ int main(int argc, char **argv)
 
         /* Write the min H-Blank */
         reg[0] = 0x1E;
-        buf[0] = 142; 
+        buf[0] = 142;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         i2c_test.buf = buf;
@@ -76,7 +76,7 @@ int main(int argc, char **argv)
         } else {
                 printf("\nI2C TEST PASSED\n\n");
         }
-        
+
         /* Disable the CSI clock */
         ioctl(i2c_file, MXCTEST_I2C_CSICLKDIS, &i2c_test);
 
diff --git a/test/mxc_i2c_test/mxc_i2c_test_usb.c b/test/mxc_i2c_test/mxc_i2c_test_usb.c
index bc02e83..ccc81d4 100644
--- a/test/mxc_i2c_test/mxc_i2c_test_usb.c
+++ b/test/mxc_i2c_test/mxc_i2c_test_usb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -35,18 +35,18 @@ int main(int argc, char **argv)
                 exit(-1);
         }
 
-        i2c_test.bus = 0;         
+        i2c_test.bus = 0;
         i2c_test.slave_addr = 0x2d; //USB Slave Address
-        
+
         printf("Slave address=%x\n", i2c_test.slave_addr);
-      
+
         reg[0] = 0x6;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         buf[0] = 0x20;
         i2c_test.buf = (char *)&buf;
         i2c_test.buf_size = 1;
-        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]); 
+        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]);
         ioctl(i2c_file, MXCTEST_I2C_WRITE, &i2c_test);
 
         reg[0] = 0x4;
@@ -55,25 +55,25 @@ int main(int argc, char **argv)
         buf[0] = 0x4;
         i2c_test.buf = (char *)&buf;
         i2c_test.buf_size = 1;
-        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]); 
+        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]);
         ioctl(i2c_file, MXCTEST_I2C_WRITE, &i2c_test);
-        
+
         reg[0] = 0x13;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         buf[0] = 0x4;
         i2c_test.buf = (char *)&buf;
         i2c_test.buf_size = 1;
-        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]); 
+        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]);
         ioctl(i2c_file, MXCTEST_I2C_WRITE, &i2c_test);
-        
+
         reg[0] = 0x12;
         i2c_test.reg = reg;
         i2c_test.reg_size = 1;
         buf[0] = 0x2;
         i2c_test.buf = (char *)&buf;
         i2c_test.buf_size = 1;
-        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]); 
+        printf("Write Data=%x to reg=%x\n", buf[0], reg[0]);
         ioctl(i2c_file, MXCTEST_I2C_WRITE, &i2c_test);
 
         reg[0] = 0x6;
diff --git a/test/mxc_ipudev_test/mxc_ipu_dev.c b/test/mxc_ipudev_test/mxc_ipu_dev.c
index cec720e..ea2bc3a 100644
--- a/test/mxc_ipudev_test/mxc_ipu_dev.c
+++ b/test/mxc_ipudev_test/mxc_ipu_dev.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  */
 
@@ -145,7 +145,7 @@ static cs_t colorspaceofpixel(int fmt)
 }
 
 static int need_csc(int ifmt, int ofmt)
-{	
+{
 	cs_t ics,ocs;
 
 	ics = colorspaceofpixel(ifmt);
@@ -188,7 +188,7 @@ static pp_mode_t ipu_ic_task_check(ipu_ic_param *i_para, ipu_ic_param *o_para)
 	/*need IDMAC do format(same color space)?*/
 	if((pp_mode == NULL_MODE) && (i_para->fmt != o_para->fmt))
 		pp_mode |= IC_MODE;
-	
+
 	return pp_mode;
 }
 
@@ -199,7 +199,7 @@ static int ipu_ic_mem_alloc(ipu_ic_param *i_para, ipu_ic_param *o_para,
 		int bufcnt, int fd_ipu)
 {
 	int i, ret = 0;
-	
+
 	for (i=0;i<bufcnt;i++) {
 		i_minfo[i].size = i_para->width/8*i_para->height*fmt_to_bpp(i_para->fmt);
 		if (ioctl(fd_ipu, IPU_ALOC_MEM, &(i_minfo[i])) < 0) {
@@ -215,7 +215,7 @@ static int ipu_ic_mem_alloc(ipu_ic_param *i_para, ipu_ic_param *o_para,
 			ret = -1;
 			goto err;
 		}
-		
+
 		if (show_to_fb == 0) {
 			o_minfo[i].size = o_para->width/8*o_para->height*fmt_to_bpp(o_para->fmt);
 			if (ioctl(fd_ipu, IPU_ALOC_MEM, &(o_minfo[i])) < 0) {
@@ -242,7 +242,7 @@ static int ipu_ic_mem_alloc(ipu_ic_param *i_para, ipu_ic_param *o_para,
 			}
 		}
 	}
-	
+
 	/*for the case output direct to framebuffer*/
 	if (show_to_fb) {
 		int owidth, oheight;
@@ -276,7 +276,7 @@ static int ipu_ic_mem_alloc(ipu_ic_param *i_para, ipu_ic_param *o_para,
 			owidth = o_para->width;
 			oheight = o_para->height;
 		}
-		
+
 		if ((owidth > fb_var.xres) || (oheight > fb_var.yres)
 			|| (colorspaceofpixel(o_para->fmt) != RGB_CS)
 			|| (fmt_to_bpp(o_para->fmt) != fb_var.bits_per_pixel)) {
@@ -345,7 +345,7 @@ static int ipu_ic_task_setup(ipu_ic_param *i_para, ipu_ic_param *o_para,
 	ipu_channel_params_t params;
 	int tmp, ret = 0, out_stride;
 
-	
+
 	printf("Enabling:");
 
 	/*Setup ipu channel*/
@@ -518,7 +518,7 @@ static int ipu_ic_task_setup(ipu_ic_param *i_para, ipu_ic_param *o_para,
 
 	if (show_to_fb)
 		ipu_link_channels(end_chan, fb_chan);
-	
+
 	return ret;
 }
 
@@ -531,7 +531,7 @@ static int ipu_ic_task_enable(pp_mode_t pp_mode, int bufcnt)
 		irq = rot_out_eof_irq;
 	else
 		irq = ic_out_eof_irq;
-	
+
 	if (show_to_fb) {
 		if (pp_mode == ROT_MODE)
 			irq = rot_in_eof_irq;
@@ -582,7 +582,7 @@ static int ipu_ic_task_enable(pp_mode_t pp_mode, int bufcnt)
 static void ipu_ic_task_disable(pp_mode_t pp_mode)
 {
 	ipu_free_irq(irq, NULL);
-	
+
 	if (show_to_fb)
 		ipu_unlink_channels(end_chan, fb_chan);
 
@@ -660,7 +660,7 @@ int ipu_ic_task(int fd_ipu, FILE *file_in, FILE *file_out,
 			goto done;
 		}
 	}
-	
+
 	if ((ret = ipu_ic_task_enable(pp_mode, bufcnt)) < 0)
 		goto done;
 
@@ -673,13 +673,13 @@ int ipu_ic_task(int fd_ipu, FILE *file_in, FILE *file_out,
 		do {
 			ipu_get_interrupt_event(&einfo);
 		} while ((einfo.irq != irq) && !ctrl_c_rev);
-		
+
 		if (!show_to_fb)
 			if(fwrite(outbuf_start[pingpang], 1, o_minfo[pingpang].size, file_out) < o_minfo[pingpang].size) {
 				ret = -1;
 				printf("Can not write enough data into output file!\n");
 			}
-		
+
 		/*need fill in more data?*/
 		if ((fcount > 2) && (i < (fcount-2))) {
 			if (fread(inbuf_start[pingpang], 1, i_minfo[pingpang].size, file_in) < i_minfo[pingpang].size) {
@@ -840,7 +840,7 @@ int main(int argc, char *argv[])
 		ipu_close();
 		return -1;
 	}
-	
+
 	if (outfile)
 		file_out = fopen(outfile, "wb");
 
diff --git a/test/mxc_mbx_test/autorun-mbx.sh b/test/mxc_mbx_test/autorun-mbx.sh
index 6ef475a..01ab604 100755
--- a/test/mxc_mbx_test/autorun-mbx.sh
+++ b/test/mxc_mbx_test/autorun-mbx.sh
@@ -14,7 +14,7 @@ device_2=$(cat /proc/devices | grep swcamera | cut -d' ' -f2)
 echo device present is $device_1
 echo device present is $device_2
 
-if [ "$device_1" = clcdc ]; then 
+if [ "$device_1" = clcdc ]; then
 	echo "$script: PASS Device Found $device_1"
 else
 	STATUS=1
diff --git a/test/mxc_mlb_test/mxc_mlb_test.c b/test/mxc_mlb_test/mxc_mlb_test.c
index f24f019..f480f42 100644
--- a/test/mxc_mlb_test/mxc_mlb_test.c
+++ b/test/mxc_mlb_test/mxc_mlb_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -72,7 +72,7 @@ int main(int argc, char *argv[])
 			break;
 		case 't':
 			if (strcmp(optarg, "async") == 0) {
-				tcase = 1;		
+				tcase = 1;
 			} else if (strcmp(optarg, "ctrl") == 0) {
 				tcase = 0;
 			} else {
@@ -208,7 +208,7 @@ int do_txrx_test(int fd)
 	char buf[2048];
 	int gotlen = 0;
 
-	/** 
+	/**
 	 * set channel address
 	 * MSB is for tx, LSB is for rx
 	 * the normal address range [0x02, 0x3E]
diff --git a/test/mxc_mmc_test/Makefile b/test/mxc_mmc_test/Makefile
index b73be21..9e473a2 100644
--- a/test/mxc_mmc_test/Makefile
+++ b/test/mxc_mmc_test/Makefile
@@ -1,10 +1,10 @@
 # list of platforms which did not want this test case
-EXCLUDE_LIST:= 
+EXCLUDE_LIST:=
 
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = $(OBJDIR)/autorun-mmc.sh
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_mmc_test/autorun-mmc.sh b/test/mxc_mmc_test/autorun-mmc.sh
index 1da7775..67ad49d 100755
--- a/test/mxc_mmc_test/autorun-mmc.sh
+++ b/test/mxc_mmc_test/autorun-mmc.sh
@@ -31,7 +31,7 @@ run_mmc_case()
 check_devnode "/dev/mmcblk0"
 
 if [ "$STATUS" = 0 ]; then
-	run_mmc_case 
+	run_mmc_case
 fi
 
 print_status
diff --git a/test/mxc_mpeg4_enc_test/MP4EncApi.h b/test/mxc_mpeg4_enc_test/MP4EncApi.h
index 5d7865e..6a294b5 100644
--- a/test/mxc_mpeg4_enc_test/MP4EncApi.h
+++ b/test/mxc_mpeg4_enc_test/MP4EncApi.h
@@ -214,13 +214,13 @@ typedef enum
     /* bigger buffer should be used when limit is often reached */
     /* Type of the parameter to be read: u32 */
     MP4API_ENC_PID_TXTR_VLC_BUF_FULL,
-    
+
     /* setup a table where macroblock offsets are returned */
     /* Type of the parameter to be set: (u32*) */
     MP4API_ENC_PID_MB_OFFSET_TABLE,
     /* setup a table where macroblock QP are returned */
     /* Type of the parameter to be set: (u8*) */
-    MP4API_ENC_PID_MB_QP_TABLE    
+    MP4API_ENC_PID_MB_QP_TABLE
 }
 MP4API_EncParamId;
 
diff --git a/test/mxc_mpeg4_enc_test/cam2mpeg4_cif.c b/test/mxc_mpeg4_enc_test/cam2mpeg4_cif.c
index 7b6b67f..c87182b 100644
--- a/test/mxc_mpeg4_enc_test/cam2mpeg4_cif.c
+++ b/test/mxc_mpeg4_enc_test/cam2mpeg4_cif.c
@@ -172,8 +172,8 @@ int v4l_capture_test(int fd_v4l, unsigned int *pStrm, void *encInst,
 		printf("get format failed\n");
 		close(fid_mpeg4);
 		return -1;
-	} 
-	
+	}
+
 	printf("\t Width = %d", fmt.fmt.pix.width);
 	printf("\t Height = %d", fmt.fmt.pix.height);
 	printf("\t Image size = %d\n", fmt.fmt.pix.sizeimage);
@@ -184,7 +184,7 @@ int v4l_capture_test(int fd_v4l, unsigned int *pStrm, void *encInst,
 	encInp.u32_TimeIncrement = 0;
 	encInp.pu32_OutputBuffer = pStrm;
 	encInp.u32_OutBufSize = 1.5 * 384 * 1024 / 8 * VOPS;
-	
+
 	/* 1st = intra */
 	encInp.VopCodingType = MP4API_ENC_VOP_CODING_TYPE_INTRA;
 	ret = MP4API_EncoderStartStream(encInst, &encInp, &encOut);
@@ -341,7 +341,7 @@ int main(int argc, char **argv)
 			goto error2;
 		}
 	}
-	
+
 	{
 		MP4API_EncParam_PictureSize pic_param;
 		pic_param.u16_Height = g_height;
diff --git a/test/mxc_mpeg4_enc_test/cam2mpeg4_vga.c b/test/mxc_mpeg4_enc_test/cam2mpeg4_vga.c
index 90d1d7e..5d9f7b2 100644
--- a/test/mxc_mpeg4_enc_test/cam2mpeg4_vga.c
+++ b/test/mxc_mpeg4_enc_test/cam2mpeg4_vga.c
@@ -133,7 +133,7 @@ int v4l_capture_setup(void)
 		close(fd_v4l);
 		return -1;
 	}
-	
+
 	memset(&req, 0, sizeof(req));
 	req.count = TEST_BUFFER_NUM;
 	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@ -161,14 +161,14 @@ int v4l_capture_and_encode_test(void)
 		printf("start capturing failed\n");
 		return -1;
 	}
-	
-	/* Step 3: Assign memory resources */	
+
+	/* Step 3: Assign memory resources */
 	encIn.pOutBuf = outbuf;
 	encIn.outBufSize = outbuf_size;
 	encIn.outBufBusAddress = outbuf_bus_address;
 
 	/* The use of VP size buffer is optional */
-	encIn.pVpSizes = NULL; 
+	encIn.pVpSizes = NULL;
 
 	printf("Output buffer %d bytes\n", encIn.outBufSize);
 
@@ -196,8 +196,8 @@ int v4l_capture_and_encode_test(void)
 	next = 0;
 	last = cmdl.count;
 
-	while ( (next < last) && 
-		(ret == ENC_VOP_READY || ret == ENC_VOP_READY_VBV_FAIL || 
+	while ( (next < last) &&
+		(ret == ENC_VOP_READY || ret == ENC_VOP_READY_VBV_FAIL ||
 		 ret == ENC_OUTPUT_BUFFER_OVERFLOW ))
 	{
 		/* Select VOP type */
@@ -254,7 +254,7 @@ int v4l_capture_and_encode_test(void)
 				break;
 			}
 		} else {
-			printf("buf.index %d	count = %d\n", 
+			printf("buf.index %d	count = %d\n",
 					buf.index, (last - next));
 		}
 	} /* End of main encoding loop */
@@ -294,10 +294,10 @@ void FreeRes(void)
 
     AllocRes
 
-    OS dependent implementation for allocating the physical memories 
+    OS dependent implementation for allocating the physical memories
     used by both SW and HW: output buffer.
 
-    To access the memory HW uses the physical linear address (bus address) 
+    To access the memory HW uses the physical linear address (bus address)
     and SW uses virtual address (user address).
 
     In Linux the physical memories can only be allocated with sizes
@@ -315,11 +315,11 @@ int AllocRes(void)
 
 	outbuf_size = outbuf_bus_address = 64 * sysconf(_SC_PAGESIZE);
 	printf("Output buffer size:\t\t\t%d\n", outbuf_size);
-	
+
 	ioctl(memdev_fd, MEMALLOC_IOCXGETBUFFER, &outbuf_bus_address);
 	printf("Output buffer bus address:\t\t0x%08x\n", outbuf_bus_address);
-	
-	outbuf = (u32 *) mmap(0, outbuf_size, PROT_READ | PROT_WRITE, 
+
+	outbuf = (u32 *) mmap(0, outbuf_size, PROT_READ | PROT_WRITE,
 			MAP_SHARED, memdev_fd, outbuf_bus_address);
 	printf("Output buffer user address:\t\t0x%08x\n", (u32) outbuf);
 	if(outbuf == MAP_FAILED)
@@ -341,7 +341,7 @@ int main(int argc, char **argv)
 
 	/* Command line parameters */
 	if (argc < 6) {
-		fprintf(stdout, 
+		fprintf(stdout,
 			"Usage: cam2mpeg4 [width] [height] [number of frames] [frame rate] [filename]\n");
 		return -1;
 	}
@@ -369,7 +369,7 @@ int main(int argc, char **argv)
     	cfg.frmRateNum = 30;
     	cfg.width = cmdl.width;
     	cfg.height = cmdl.height;
-    	cfg.strmType = MPEG4_PLAIN_STRM; 
+    	cfg.strmType = MPEG4_PLAIN_STRM;
     	cfg.profileAndLevel = MPEG4_ADV_SIMPLE_PROFILE_LEVEL_5;
     	if ((ret = MP4EncInit(&cfg, &encoder)) != ENC_OK)
     	{
@@ -379,7 +379,7 @@ int main(int argc, char **argv)
     	}
 
 	retcode = v4l_capture_and_encode_test();
-	
+
 	/* Free all resources */
 	if ((ret = MP4EncRelease(encoder)) != ENC_OK)
     	{
@@ -387,7 +387,7 @@ int main(int argc, char **argv)
 		retcode = -1;
     	}
 
-error:	
+error:
 	FreeRes();
 	close(fd_v4l);
 	return retcode;
diff --git a/test/mxc_mpeg4_enc_test/memalloc.h b/test/mxc_mpeg4_enc_test/memalloc.h
index 2d5de83..6410f36 100644
--- a/test/mxc_mpeg4_enc_test/memalloc.h
+++ b/test/mxc_mpeg4_enc_test/memalloc.h
@@ -1,4 +1,4 @@
-/* 
+/*
  * Memalloc, encoder memory allocation driver (kernel module)
  *
  * Copyright (C) 2005  Hantro Products Oy.
@@ -18,7 +18,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  *
  */
-    
+
 #ifndef _MEMALLOC_H_
 #define _MEMALLOC_H_
 #include <linux/ioctl.h>    /* needed for the _IOW etc stuff used later */
diff --git a/test/mxc_mpeg4_test/mpeg4_dec_api.h b/test/mxc_mpeg4_test/mpeg4_dec_api.h
index a2a2d04..33eefdd 100644
--- a/test/mxc_mpeg4_test/mpeg4_dec_api.h
+++ b/test/mxc_mpeg4_test/mpeg4_dec_api.h
@@ -16,7 +16,7 @@
 //  Jun/23/2004 - Vijay: Review Comments Incorporated.
 //  Jun/28/2004 - Debashis: Memquery implemented, removed RGB format structures
 //  Aug/11/2004 - Anurag: Implemented APIs for skipping frames.
-//  Aug/19/2004 - Anurag: Incorporated Review Comments. 
+//  Aug/19/2004 - Anurag: Incorporated Review Comments.
 //  Aug/24/2004 - Anurag: Exposed VOP_Type to Application.
 //  Aug/10/2004 - Debashis Additional type in memquery
 //  Sep/07/2004 - Debashis Renamed file to mpeg4_dec_api.h
@@ -27,33 +27,33 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 /*! \file
- * The interface definitions for the Mpeg4 / H.263 decoder library 
+ * The interface definitions for the Mpeg4 / H.263 decoder library
  */
 
 #define MAX_NUM_MEM_REQS 30         /*! Maximum Number of MEM Requests  */
 #define MAX_VIDEO_OBJECTS 1         /*! Maximum Number of Video Objects */
 #define VOL_INDEX 0                 /*! VOLs per Video Object           */
 
-/*! \def SCP_MASK 
- *  Mask for extracting 24 bit Start Code Prefix from 32 bit MPEG4 Start Codes. 
- *  User should not alter the mask. 
+/*! \def SCP_MASK
+ *  Mask for extracting 24 bit Start Code Prefix from 32 bit MPEG4 Start Codes.
+ *  User should not alter the mask.
  */
 
-/*! \def SVH_MASK 
+/*! \def SVH_MASK
  *  Mask for extracting 24 bit Start Code Prefix for Short Video Header from 32
- *  bits. User should not alter the mask. 
+ *  bits. User should not alter the mask.
  */
 
-/*! \def ZERO_MASK_16 
+/*! \def ZERO_MASK_16
  *  Mask for extracting 16 bit 0 from 32 bits. User should not alter the mask.
  */
 
-/*! \def ZERO_MASK_8 
+/*! \def ZERO_MASK_8
  *  Mask for extracting 8 bit 0 from 32 bits. User should not alter the mask.
  */
 
-#define SCP_MASK       0x00ffffff  
-#define SVH_MASK       0x00ffffff      
+#define SCP_MASK       0x00ffffff
+#define SVH_MASK       0x00ffffff
 #define ZERO_MASK_16   0x0000ffff
 #define ZERO_MASK_8    0x000000ff
 
@@ -86,7 +86,7 @@ typedef enum
     /* Successfull return values */
     E_MPEG4D_SUCCESS = 0,         /*!< Success                             */
     E_MPEG4D_ERROR_CONCEALED,     /*!< Error in the bitstream, but concealed */
-    E_MPEG4D_ENDOF_BITSTREAM,     /*!< End of Bit Stream                   */                                                 
+    E_MPEG4D_ENDOF_BITSTREAM,     /*!< End of Bit Stream                   */
 
     /* Successful return with warning, decoding can continue */
     /* Start with number 11 */
@@ -121,7 +121,7 @@ typedef enum
                                       opposite to PLAY and FF. Current Decoder
                                       doesn't support REW feature */
 } eDecodeState;
- 
+
 /*! \enum Enumeration of possible buffer alignment */
 typedef enum
 {
@@ -160,16 +160,16 @@ typedef struct
  *  The size and alignment are must to meet crteria, whereas others
  *  help to achive the performace projected. MPEG4D_Usage is provided to help
  *  the application to decide if the memory has to be saved, in case of
- *  memory scarcity. Type of the memory has a direct impact on the 
- *  performance. Priority of the block shall act as a hint, in case not 
- *  all requested FAST memory is available. There is no gurantee that 
+ *  memory scarcity. Type of the memory has a direct impact on the
+ *  performance. Priority of the block shall act as a hint, in case not
+ *  all requested FAST memory is available. There is no gurantee that
  *  the priority will be unique for all the memory blocks.
- */ 
+ */
 
 typedef struct
 {
     int 	s32Size;         /*!< size of the memory block            */
-    int 	s32Type;         /*!< type of the memory - slow/fast and 
+    int 	s32Type;         /*!< type of the memory - slow/fast and
                                   static/scratch                      */
     int     s32Priority;     /*!< how important the block is          */
     int 	s32Align;        /*!< alignment of the memory block       */
@@ -178,12 +178,12 @@ typedef struct
 
 
 /*! Structure to hold all the memory requests from the decoder  */
- 
+
 typedef struct
 {
     int               s32NumReqs;                   /*!< Number of blocks  */
     sMpeg4DecMemBlock asMemBlks[MAX_NUM_MEM_REQS];  /*!< array of requests */
-} sMpeg4DecMemAllocInfo;   
+} sMpeg4DecMemAllocInfo;
 
 /*! Structure for Vop Time */
 typedef struct
@@ -200,11 +200,11 @@ typedef struct
     unsigned short int 	 u16FrameWidth;           /*!< FrameWidth         */
     unsigned short int 	 u16FrameHeight;          /*!< FrameHeight        */
     unsigned short int   u16DecodingScheme;       /*!< enable decoding at P */
-    
-    unsigned short int   u16TicksPerSec;          /*!< Time Ticks Per Sec */ 
+
+    unsigned short int   u16TicksPerSec;          /*!< Time Ticks Per Sec */
     sMpeg4DecTime        sTime;                   /*!< Current Decode Time */
-    int                  s32TimeIncrementInTicks; /*!< Time Increment from 
-                                                       prev vop decode time 
+    int                  s32TimeIncrementInTicks; /*!< Time Increment from
+                                                       prev vop decode time
                                                        in ticks */
     unsigned char        u8VopType;               /*!< Current VOP Type */
 } sMpeg4DecoderParams;
@@ -224,7 +224,7 @@ typedef  struct
 /*! This structure defines the decoder context. All the decoder API
  *  needs this structure as one of its argument.
  */
-typedef struct 
+typedef struct
 {
     sMpeg4DecMemAllocInfo   sMemInfo;      /*!< memory requirements info */
     sMpeg4DecoderParams     sDecParam;     /*!< decoder parameters       */
@@ -233,7 +233,7 @@ typedef struct
     void                    *pvAppContext; /*!< Anything app specific    */
     eDecodeState            eState;        /*!< Indicates current Decoder
                                                 State */
-} sMpeg4DecObject; 
+} sMpeg4DecObject;
 
 
 
@@ -259,19 +259,19 @@ eMpeg4DecRetType  eMPEG4DFree (sMpeg4DecObject *psMp4Obj);
  * an I Frame, or start decoding immedeately, depending on the decoding
  * scheme specified in the decoder param.
  */
-eMpeg4DecRetType  eMPEG4DSkipFrames (sMpeg4DecObject *psMp4Obj, 
+eMpeg4DecRetType  eMPEG4DSkipFrames (sMpeg4DecObject *psMp4Obj,
                                      unsigned int u32NumSkipFrames,
                                      unsigned int *pu32NumSkippedFrames);
 
 /*! \brief
- *        Skips to next INTRA frame 
+ *        Skips to next INTRA frame
  */
-eMpeg4DecRetType  eMPEG4DSkip2NextIFrame (sMpeg4DecObject *psMp4Obj, 
+eMpeg4DecRetType  eMPEG4DSkip2NextIFrame (sMpeg4DecObject *psMp4Obj,
                                           unsigned int *pu32NumSkippedFrames);
 
 /*! \brief
  *    Rewinds the given number of frames starting from the current frame.
- * The decoder can later skip all the P frames, till the next I frame, or can 
+ * The decoder can later skip all the P frames, till the next I frame, or can
  * start decoding immedeately, even if it is p frame.
  */
 eMpeg4DecRetType eMPEG4DRewindFrames (sMpeg4DecObject *psMp4Obj,
@@ -283,7 +283,7 @@ eMpeg4DecRetType eMPEG4DRewindFrames (sMpeg4DecObject *psMp4Obj,
  * Call back function for reading the input buffer by the decoder.
  *
  * Whenver the internul buffer inside the decoder is empty, the decoder will
- * call this function, passing the application context also. The application 
+ * call this function, passing the application context also. The application
  * shall implement a function to provide the required portion of the bitstream
  * of the given size, starting at the given offset in the provided buffer.
  */
diff --git a/test/mxc_mpeg4_test/mpeg4_enc_api.h b/test/mxc_mpeg4_test/mpeg4_enc_api.h
index 5f565ea..c59bf0e 100644
--- a/test/mxc_mpeg4_test/mpeg4_enc_api.h
+++ b/test/mxc_mpeg4_test/mpeg4_enc_api.h
@@ -3,7 +3,7 @@
 //  Motorola India Electronics Limited
 //
 //
-//  Primary Author  : 
+//  Primary Author  :
 //
 //                  This code is the property of Motorola.
 //          (C) Copyright 2004 Motorola,Inc. All Rights Reserved.
@@ -13,13 +13,13 @@
 //  Date            Author       Version    Description
 //
 //  June,2004      Chandra         0.1        Created
-//  Aug, 2004      Chandra         1.0        RELEASE 1.0 with all review 
+//  Aug, 2004      Chandra         1.0        RELEASE 1.0 with all review
 //                                            comments
 //  Oct 1, 2004    Chandra         1.1        Removed application context
 //                                            from the configuration structure
 //  Oct 14,2004    Chandra         1.2        Removed references to video
 //                                            packet size
-//  
+//
 //
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -72,7 +72,7 @@
 #define IS_SCRATCH_MEMORY(memType) (memType & E_MPEG4D_SCRATCH_MEMORY)
 
 //! Enumeration types
-typedef enum 
+typedef enum
 {
     E_INTRA_CODING = 0,
     E_PREDICTIVE_CODING,
@@ -82,7 +82,7 @@ typedef enum
 typedef enum
 {
     /* Success full completion */
-    E_MPEG4E_SUCCESS = 0, 
+    E_MPEG4E_SUCCESS = 0,
     E_MPEG4E_REACHED_END,
     E_MPEG4E_SKIPPED,
 
@@ -109,7 +109,7 @@ typedef enum
 //! End of Enumuration types
 
 
-//! Structure definitions    
+//! Structure definitions
 typedef struct
 {
     int     s32Seconds;           //!< Number of Seconds
@@ -121,17 +121,17 @@ sMpeg4ETimeStruct;
  *  The size and alignment are must to meet crteria, whereas others
  *  help to achive the performace projected. Usage is provided to help
  *  the application to decide if the memory has to be saved, in case of
- *  memory scarcity. Type of the memory has a direct impact on the 
- *  performance. Priority of the block shall act as a hint, in case not 
- *  all requested FAST memory is available. There is no gurantee that 
+ *  memory scarcity. Type of the memory has a direct impact on the
+ *  performance. Priority of the block shall act as a hint, in case not
+ *  all requested FAST memory is available. There is no gurantee that
  *  the priority will be unique for all the memory blocks.
- */ 
+ */
 typedef struct
  {
      int    s32Size;              //!< Size of the memory to be allocated
-     int    s32Align;             //!< memory MPEG4E_usage -  static/scratch      
-     int    s32Type;              //!< type of the memory slow/fast        
-     int    s32Priority;          //!< how important the block is 
+     int    s32Align;             //!< memory MPEG4E_usage -  static/scratch
+     int    s32Type;              //!< type of the memory slow/fast
+     int    s32Priority;          //!< how important the block is
      int    s32CurrSize;          //!< For encoder internal MPEG4E_usage
      void  *pvBuffer;             //!< Pointer to the memory
 }sMpeg4EMemBlock;
@@ -141,10 +141,10 @@ typedef struct
      int              s32NumReqs;
      sMpeg4EMemBlock  asMemBlks[MPEG4E_MAX_NUM_MEM_REQS];
 }sMpeg4EMemAllocInfo;
-            
+
 typedef struct sMpeg4EncoderStruct
 {
-    unsigned char  *pu8OutputBufferPtr;           //!< Ptr to Output bitstream 
+    unsigned char  *pu8OutputBufferPtr;           //!< Ptr to Output bitstream
                                                   //!< buffer (1 frame)
     int             s32MaxOutputBufferSize;       //!< Size of output buffer
     int             s32SourceWidth;               //!< Width of source sequence
@@ -183,12 +183,12 @@ typedef struct sMpeg4EncoderStruct
 
     // Rate Control Parameters
     int             s32TargetBitRate;              //!< In bits/sec (= 0 for static quant)
-    unsigned char   u8DelayFactor;                 //!< 1  - minimum delay, 
+    unsigned char   u8DelayFactor;                 //!< 1  - minimum delay,
                                                    //!< 31 - max delay
-                                                   //!< 0  - default delay (minimum) 
+                                                   //!< 0  - default delay (minimum)
     unsigned char   u8QualityTradeoff;             //!< 1  - highest spatial quality
                                                    //!< 31 - highest temporal quality
-                                                   //!< 0  - default quality (16) 
+                                                   //!< 0  - default quality (16)
 
     // Rounding Control
     int            s32RoundingControl;             //!< Enable=1, Disable=0
@@ -200,11 +200,11 @@ typedef struct sMpeg4EncoderStruct
     int            s32H263NoShortVideoHeader;     //!< Pure H.263 bitstream
 
     void          *pvData;                        //!< Ptr to Encoder datastructure
-    int            s32NextFrameNumber;            //!< Required next frame number 
+    int            s32NextFrameNumber;            //!< Required next frame number
     int            s32BitstreamSize;              //!< Size of output bitstream buffer
     eMPEG4ECodingType    eFrameType;              //!< Coding type for frame.
 
-    sMpeg4ETimeStruct    s32TotalTimeElapsed;     //!< Time increment 
+    sMpeg4ETimeStruct    s32TotalTimeElapsed;     //!< Time increment
     sMpeg4EMemAllocInfo  sMemInfo;
 }
 sMpeg4EncoderConfig;
@@ -220,9 +220,9 @@ sMpeg4EncoderConfig;
 *  parameters with the desired values. This should be the
 *  first function call.
 *  All important parameters such as source width, source height
-*  source/encoding frame rate, bit rate, level and data partiton 
+*  source/encoding frame rate, bit rate, level and data partiton
 *  requirement are set before calling this function
-*/ 
+*/
 eMPEG4ERetType eMpeg4EncoderSetDefaultParam(sMpeg4EncoderConfig *psMpeg4EncPtr);
 
 
@@ -232,7 +232,7 @@ eMPEG4ERetType eMpeg4EncoderSetDefaultParam(sMpeg4EncoderConfig *psMpeg4EncPtr);
 *   This is a query memory routine that returns the memory
 *   requirement such as size, alignment, type (FAST or SLOW)
 *   to the application.
-*/ 
+*/
 eMPEG4ERetType eMpeg4EncoderQueryMemory(sMpeg4EncoderConfig *psMpeg4EncPtr);
 
 //! Initialize Encoder
@@ -241,7 +241,7 @@ eMPEG4ERetType eMpeg4EncoderQueryMemory(sMpeg4EncoderConfig *psMpeg4EncPtr);
 *   Initialization function that initializes the frame
 *   pointers and other parameters in the encoder so as to
 *   provide the settings and frame work for video encode.
-*/ 
+*/
 eMPEG4ERetType eMpeg4EncoderInit(sMpeg4EncoderConfig *psMpeg4EncPtr);
 
 //! Get next frame information
@@ -252,14 +252,14 @@ eMPEG4ERetType eMpeg4EncoderInit(sMpeg4EncoderConfig *psMpeg4EncPtr);
 *   the encoding frame routine. Information regarding the next
 *   frame number and it's type are the important parameters
 *   that could be observed here.
-*/ 
+*/
 
 eMPEG4ERetType  eMpeg4EncoderGetNextFrameNum(sMpeg4EncoderConfig *psMpeg4EncPtr);
 //! Encode Image
 /*!
 *  \brief
 *   Function call to encode a single frame/VOP.
-*/ 
+*/
 eMPEG4ERetType eMpeg4EncoderEncode(sMpeg4EncoderConfig *psMpeg4EncPtr);
 
 //! Free Encoder
@@ -267,7 +267,7 @@ eMPEG4ERetType eMpeg4EncoderEncode(sMpeg4EncoderConfig *psMpeg4EncPtr);
 *  \brief
 *   Function call to free resources. It is to be called when
 *   encoding for all the frames are completed.
-*/ 
+*/
 eMPEG4ERetType eMpeg4EncoderFree(sMpeg4EncoderConfig *psMpeg4EncPtr);
 
 
diff --git a/test/mxc_mpeg4_test/mxc_mpeg4enc_test.c b/test/mxc_mpeg4_test/mxc_mpeg4enc_test.c
index d5cabb6..81dda09 100644
--- a/test/mxc_mpeg4_test/mxc_mpeg4enc_test.c
+++ b/test/mxc_mpeg4_test/mxc_mpeg4enc_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005, Freescale Semiconductor, Inc. All Rights Reserved
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  * THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
  * BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
  * FREESCALE SEMICONDUCTOR, INC.
@@ -23,7 +23,7 @@ int g_frame_rate = 30;
 int process_cmdline(int argc, char **argv)
 {
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-w") == 0) {
                         g_width = atoi(argv[++i]);
@@ -65,7 +65,7 @@ void EncoderLoop (sMpeg4EncoderConfig  *psMpeg4EncPtr, FILE * in_file, FILE * ou
                 //psMpeg4EncPtr->pu8OutputBufferPtr = outbuf;
 
 //                printf("loop %d\n", loop_count++);
-                
+
                 /* Encode one frame.*/
                 retval =  eMpeg4EncoderEncode(psMpeg4EncPtr);
 
@@ -142,10 +142,10 @@ int main(int argc, char **argv)
         eMpeg4EncoderQueryMemory(&sMpeg4EncPtr);
 
         /* Give memory to the encoder for the size, type and alignment returned */
-      
+
       	for(i=0; i< MemInfo->s32NumReqs ;i++)
         {
-                // Allocate memory according to this request. This example does not consider alignment, 
+                // Allocate memory according to this request. This example does not consider alignment,
                 // user should take care of this using any available routines
                 if (MemInfo->asMemBlks[i].s32Size <= 0)
                     continue;
@@ -166,7 +166,7 @@ int main(int argc, char **argv)
                     }
 
                     pvUnalignedMem = (void*)malloc (MemInfo->asMemBlks[i].s32Size + s32Extra);
-                    MemInfo->asMemBlks[i].pvBuffer = (void*)(((int)pvUnalignedMem + s32Extra) & 
+                    MemInfo->asMemBlks[i].pvBuffer = (void*)(((int)pvUnalignedMem + s32Extra) &
                                          (s32Mask));
                 }
         }
@@ -184,8 +184,8 @@ int main(int argc, char **argv)
         {
                 fwrite(sMpeg4EncPtr.pu8OutputBufferPtr, 1, sMpeg4EncPtr.s32BitstreamSize, out_file);
         }
-        
-         	/* Encode the bit stream and produce the outputs */	
+
+         	/* Encode the bit stream and produce the outputs */
         EncoderLoop (&sMpeg4EncPtr, in_file, out_file); // sub function to call the main encoding API
 
         /*Free memory resources*/
diff --git a/test/mxc_mu_test/autorun-mu.sh b/test/mxc_mu_test/autorun-mu.sh
index 057017f..c5e6f3d 100755
--- a/test/mxc_mu_test/autorun-mu.sh
+++ b/test/mxc_mu_test/autorun-mu.sh
@@ -8,7 +8,7 @@ source /unit_tests/test-utils.sh
 STATUS=0
 platform=`cat /proc/cpuinfo | grep Hardware |cut -f3 -d' '`
  if  [ $platform = "MXC300-31" ]  || [ $platform = "MXC300-20"  ]
- then 
+ then
  m2ramaddr=10000100
  else
  m2ramaddr=ff002800
diff --git a/test/mxc_oprofile_test/Makefile b/test/mxc_oprofile_test/Makefile
index ec73a58..aadc9ba 100644
--- a/test/mxc_oprofile_test/Makefile
+++ b/test/mxc_oprofile_test/Makefile
@@ -4,7 +4,7 @@ EXCLUDE_LIST:="MXC27520EVB IMX27ADS MXC30020EVB"
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = $(OBJDIR)/autorun-oprofile.sh
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_oprofile_test/autorun-oprofile.sh b/test/mxc_oprofile_test/autorun-oprofile.sh
index 0595669..3e4a2b7 100755
--- a/test/mxc_oprofile_test/autorun-oprofile.sh
+++ b/test/mxc_oprofile_test/autorun-oprofile.sh
@@ -23,14 +23,14 @@ oprofile_test()
 	# devnode test
 	check_devnode "/dev/oprofile"
 
-	output=`cat /tmp/tmp_file | wc -l`      
-	if test $output -ge 10 ; then 
+	output=`cat /tmp/tmp_file | wc -l`
+	if test $output -ge 10 ; then
 		printf "OProfile Test Passed \n\n"
 		rm /tmp/tmp_file
 	else
 		STATUS=1
 		printf "OProfile Test Failed \n\n"
-	fi         
+	fi
 	# sleep a little to let autotest.pl script catch up with the logging.
 	sleep 2
 }
@@ -38,7 +38,7 @@ oprofile_test()
 cmd=`which opcontrol`
 check_executable "$cmd"
 
-if [ "$STATUS" = 0 ]; then 
+if [ "$STATUS" = 0 ]; then
 	oprofile_test
 fi
 
diff --git a/test/mxc_pf_test/mxc_pf_test.c b/test/mxc_pf_test/mxc_pf_test.c
index 19df24d..3870426 100644
--- a/test/mxc_pf_test/mxc_pf_test.c
+++ b/test/mxc_pf_test/mxc_pf_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -60,7 +60,7 @@ pf_buf g_buf_desc[2];
 int process_cmdline(int argc, char **argv)
 {
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-w") == 0) {
                         g_width = atoi(argv[++i]);
@@ -109,7 +109,7 @@ int main (int argc, char *argv[])
 		ret = 1;
 		goto err1;
 	}
-	
+
 	fd_inbuf = fopen(argv[--argc], "r");
 	if (!fd_inbuf) {
 		ret = 1;
@@ -123,7 +123,7 @@ int main (int argc, char *argv[])
 			goto err3;
 		}
 	}
-	
+
         printf("Calling PF init\n");
         pf_init(g_width, g_height, g_width);
 	g_frame_size = (g_width * g_height * 3) / 2;
@@ -134,7 +134,7 @@ int main (int argc, char *argv[])
 		if (fread(g_pf_buf[0], 1, g_frame_size, fd_inbuf) < g_frame_size)
 			break;
 
-		
+
 		if (fread(g_pf_qp_buf[qp_buf], 1, g_pf_qp_size, fd_qpbuf) < g_pf_qp_size)
 			break;
 
@@ -162,7 +162,7 @@ int main (int argc, char *argv[])
 			printf("frames - %d\r", frame_cnt);
 	}
 	printf("frames - %d\n", frame_cnt);
-	
+
         pf_uninit();
 
 	if (fd_outbuf)
@@ -191,7 +191,7 @@ static int pf_init(uint32_t width, uint32_t height, uint32_t stride)
         int retval = 0;
         pf_init_params pf_init;
         pf_reqbufs_params pf_reqbufs;
-        
+
         if ((fd_pf = open("/dev/mxc_ipu_pf", O_RDWR, 0)) < 0)
         {
                 printf("Unable to open pf device\n");
@@ -211,8 +211,8 @@ static int pf_init(uint32_t width, uint32_t height, uint32_t stride)
                 goto err1;
         }
 	g_pf_qp_size = pf_init.qp_size / 2;
-        g_pf_qp_buf[0] = mmap(NULL, pf_init.qp_size, 
-                         PROT_READ | PROT_WRITE, MAP_SHARED, 
+        g_pf_qp_buf[0] = mmap(NULL, pf_init.qp_size,
+                         PROT_READ | PROT_WRITE, MAP_SHARED,
                          fd_pf, pf_init.qp_paddr);
 	g_pf_qp_buf[1] = g_pf_qp_buf[0] + g_pf_qp_size;
         if (g_pf_qp_buf[0] == NULL) {
@@ -220,7 +220,7 @@ static int pf_init(uint32_t width, uint32_t height, uint32_t stride)
                 retval = -1;
                 goto err1;
         }
-        
+
         pf_reqbufs.count = 2;
         pf_reqbufs.req_size = 0;
         if (ioctl(fd_pf, PF_IOCTL_REQBUFS, &pf_reqbufs) < 0)
@@ -239,9 +239,9 @@ static int pf_init(uint32_t width, uint32_t height, uint32_t stride)
                         retval = -1;
                         goto err1;
                 }
-                        
-                g_pf_buf[i] = mmap (NULL, g_buf_desc[i].size, 
-                                 PROT_READ | PROT_WRITE, MAP_SHARED, 
+
+                g_pf_buf[i] = mmap (NULL, g_buf_desc[i].size,
+                                 PROT_READ | PROT_WRITE, MAP_SHARED,
                                  fd_pf, g_buf_desc[i].offset);
                 if (g_pf_buf[i] == NULL) {
                         printf("v4l2_out test: mmap for input buffer failed\n");
@@ -265,7 +265,7 @@ static int pf_uninit(void)
         int retval = 0;
 
         printf("Closing PF driver");
-        
+
         pf_reqbufs.count = 0;   // Zero deallocates buffers
         if (ioctl(fd_pf, PF_IOCTL_REQBUFS, &pf_reqbufs) < 0)
         {
@@ -287,13 +287,13 @@ static int pf_uninit(void)
         printf(" - Done\n");
 err1:
         return retval;
-}        
+}
 
 static int pf_start(int qp_buf)
 {
         int retval = 0;
         pf_start_params pf_st;
-        
+
         memset(&pf_st, 0, sizeof(pf_st));
         pf_st.wait = !g_use_wait;
         pf_st.in = g_buf_desc[0];
@@ -309,7 +309,7 @@ static int pf_start(int qp_buf)
                 printf("PF start failed: %d\n", retval);
                 goto err1;
         }
-	
+
 	if (g_use_wait) {
 		if ((retval = ioctl(fd_pf, PF_IOCTL_WAIT, PF_WAIT_Y)) < 0)
 		{
diff --git a/test/mxc_pmic_test/include/dataascii.h b/test/mxc_pmic_test/include/dataascii.h
index cd75245..d08fe86 100644
--- a/test/mxc_pmic_test/include/dataascii.h
+++ b/test/mxc_pmic_test/include/dataascii.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _DATAASCII_H_
@@ -39,7 +39,7 @@
  * The ascii characters are obtained from listofchars or the CHARS array
  *  if listofchars is NULL.
  * Each char is selected by an index.  The index is the remainder
- *  of count divided by the array size. 
+ *  of count divided by the array size.
  * This method allows more than one process to write to a location
  *  in a file without corrupting it for another process' point of view.
  *
diff --git a/test/mxc_pmic_test/include/databin.h b/test/mxc_pmic_test/include/databin.h
index b71fbc0..993443f 100644
--- a/test/mxc_pmic_test/include/databin.h
+++ b/test/mxc_pmic_test/include/databin.h
@@ -14,7 +14,7 @@
 *
 * DESCRIPTION
 *       datagen fills the buffer pointed to by 'buffer' with 'bsize' bytes
-*       of data of the form indicated by 'mode'.  
+*       of data of the form indicated by 'mode'.
 *	All modes (expect r -random) are file offset based.
 *	This allows more than process to do writing to the file without
 *	corrupting it if the same modes were used.
diff --git a/test/mxc_pmic_test/include/file_lock.h b/test/mxc_pmic_test/include/file_lock.h
index 8c9a948..7448f36 100644
--- a/test/mxc_pmic_test/include/file_lock.h
+++ b/test/mxc_pmic_test/include/file_lock.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _FILE_LOCK_H_
diff --git a/test/mxc_pmic_test/include/forker.h b/test/mxc_pmic_test/include/forker.h
index effd5d6..dfad625 100644
--- a/test/mxc_pmic_test/include/forker.h
+++ b/test/mxc_pmic_test/include/forker.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _FORKER_H_
@@ -45,10 +45,10 @@ extern int Forker_npids;               /* number of entries in Forker_pids */
 int background( char * );
 
 /*
- * Forker will fork ncopies-1 copies of self. 
+ * Forker will fork ncopies-1 copies of self.
  *
  * arg 1: Number of copies of the process to be running after return.
- *        This value minus one is the number of forks performed. 
+ *        This value minus one is the number of forks performed.
  * arg 2: mode: 0 - all children are first generation descendents.
  *              1 - each subsequent child is a descendent of another
  *              descendent, resulting in only one direct descendent of the
diff --git a/test/mxc_pmic_test/include/open_flags.h b/test/mxc_pmic_test/include/open_flags.h
index 87fe6ff..966d684 100644
--- a/test/mxc_pmic_test/include/open_flags.h
+++ b/test/mxc_pmic_test/include/open_flags.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _OPEN_FLAGS_H_
@@ -39,7 +39,7 @@
  * Commonly used separators would be a comma "," or pipe "|".
  * If <mode> is one and not all <openflags> bits can be converted to
  * symbols, the "UNKNOWN" symbol will be added to return string.
- * 
+ *
  * Return Value
  * openflags2symbols will return the indentified symbols.
  * If no symbols are recognized the return value will be a empty
@@ -62,7 +62,7 @@ char *openflags2symbols( int, char *, int );
  * If any symbol is not valid, -1 is returned.  On this error condition
  * the badname pointer is updated if not NULL.  badname will point
  * to the beginning location of where the invalid symbol was found.
- * string will be returned unchanged. 
+ * string will be returned unchanged.
  *
  * A signal received while parsing string could cause the string to
  * contain a NULL character in the middle of it.
diff --git a/test/mxc_pmic_test/include/pattern.h b/test/mxc_pmic_test/include/pattern.h
index 74f841c..29c75d3 100644
--- a/test/mxc_pmic_test/include/pattern.h
+++ b/test/mxc_pmic_test/include/pattern.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _PATTERN_H_
@@ -45,7 +45,7 @@
  * pattern_check returns -1 if the buffer does not contain repeated
  * occurrances of the indicated pattern (shifted by patshift).
  *
- * The algorithm used to check the buffer relies on the fact that buf is 
+ * The algorithm used to check the buffer relies on the fact that buf is
  * supposed to be repeated copies of pattern.  The basic algorithm is
  * to validate the first patlen bytes of buf against the pat argument
  * passed in - then validate the next patlen bytes against the 1st patlen
@@ -76,7 +76,7 @@ int pattern_check( char * , int , char * , int , int );
  *
  * pattern_fill always returns 0 - no validation of arguments is done.
  *
- * The algorithm used to fill the buffer relies on the fact that buf is 
+ * The algorithm used to fill the buffer relies on the fact that buf is
  * supposed to be repeated copies of pattern.  The basic algorithm is
  * to fill the first patlen bytes of buf with the pat argument
  * passed in - then copy the next patlen bytes with the 1st patlen
diff --git a/test/mxc_pmic_test/include/random_range.h b/test/mxc_pmic_test/include/random_range.h
index d3e1cce..c8c4858 100644
--- a/test/mxc_pmic_test/include/random_range.h
+++ b/test/mxc_pmic_test/include/random_range.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _RANDOM_RANGE_H_
diff --git a/test/mxc_pmic_test/include/search_path.h b/test/mxc_pmic_test/include/search_path.h
index f7e3ceb..d586288 100644
--- a/test/mxc_pmic_test/include/search_path.h
+++ b/test/mxc_pmic_test/include/search_path.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
diff --git a/test/mxc_pmic_test/include/str_to_bytes.h b/test/mxc_pmic_test/include/str_to_bytes.h
index 100d37d..977a6b1 100644
--- a/test/mxc_pmic_test/include/str_to_bytes.h
+++ b/test/mxc_pmic_test/include/str_to_bytes.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _STR_TO_BYTES_
diff --git a/test/mxc_pmic_test/include/string_to_tokens.h b/test/mxc_pmic_test/include/string_to_tokens.h
index 9c0935e..75c7d24 100644
--- a/test/mxc_pmic_test/include/string_to_tokens.h
+++ b/test/mxc_pmic_test/include/string_to_tokens.h
@@ -1,39 +1,39 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _STRING_TO_TOKENS_H_
 #define _STRING_TO_TOKENS_H_
 
 /*
- * string_to_tokens() 
+ * string_to_tokens()
  *
  * This function parses the string 'arg_string', placing pointers to
  * the 'separator' separated tokens into the elements of 'arg_array'.
diff --git a/test/mxc_pmic_test/include/test.h b/test/mxc_pmic_test/include/test.h
index 434fb3e..a4b0f5e 100644
--- a/test/mxc_pmic_test/include/test.h
+++ b/test/mxc_pmic_test/include/test.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
@@ -56,7 +56,7 @@
  * defined.
  * if ( sysconf(_SC_CRAY_SYSTEM) == 1 )
  *    on UMK
- * else   # returned 0 or -1 
+ * else   # returned 0 or -1
  *    on Unicos
  * This is only being done on CRAY systems.
  */
@@ -71,7 +71,7 @@
  * It should be defined in signal.h or sys/signal.h on
  * UNICOS/mk and IRIX systems.   On UNICOS systems,
  * it is not defined, thus it is being set to UNICOS's NSIG.
- * Note:  IRIX's NSIG (signals are 1-(NSIG-1)) 
+ * Note:  IRIX's NSIG (signals are 1-(NSIG-1))
  *      is not same meaning as UNICOS/UMK's NSIG  (signals 1-NSIG)
  */
 #ifndef NUMSIGS
@@ -194,9 +194,9 @@ extern void tst_clear_error();
  */
 extern void tst_res(int ttype, char *fname, char *arg_fmt, ...);
 extern void tst_resm(int ttype, char *arg_fmt, ...);
-extern void tst_brk(int ttype, char *fname, void (*func)(), 
+extern void tst_brk(int ttype, char *fname, void (*func)(),
 							char *arg_fmt, ...);
-extern void tst_brkloop(int ttype, char *fname, void (*func)(), 
+extern void tst_brkloop(int ttype, char *fname, void (*func)(),
 							char *arg_fmt, ...);
 extern void tst_brkm(int ttype, void (*func)(), char *arg_fmt, ...);
 extern void tst_brkloopm(int ttype, void (*func)(), char *arg_fmt, ...);
diff --git a/test/mxc_pmic_test/include/tlibio.h b/test/mxc_pmic_test/include/tlibio.h
index ac0d570..d036bab 100644
--- a/test/mxc_pmic_test/include/tlibio.h
+++ b/test/mxc_pmic_test/include/tlibio.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
diff --git a/test/mxc_pmic_test/include/usctest.h b/test/mxc_pmic_test/include/usctest.h
index 85fcc93..f239303 100644
--- a/test/mxc_pmic_test/include/usctest.h
+++ b/test/mxc_pmic_test/include/usctest.h
@@ -1,56 +1,56 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
 /* $Id: usctest.h,v 1.1 2004/07/21 09:11:01 rb878c Exp $ */
 
 /**********************************************************
- * 
+ *
  *    IRIX/Linux Feature Test and Evaluation - Silicon Graphics, Inc.
- * 
+ *
  *    FUNCTION NAME 	: usctest.h
- * 
+ *
  *    FUNCTION TITLE	: System Call Test Macros
- * 
+ *
  *    SYNOPSIS:
  *	See DESCRIPTION below.
- * 
+ *
  *    AUTHOR		: William Roske
- * 
+ *
  *    INITIAL RELEASE	: UNICOS 7.0
- * 
+ *
  *    DESCRIPTION
  * 	TEST(SCALL) - calls a system call
  *	TEST_VOID(SCALL) - same as TEST() but for syscalls with no return value.
- *	TEST_CLEANUP - print the log of errno return counts if STD_ERRNO_LOG 
+ *	TEST_CLEANUP - print the log of errno return counts if STD_ERRNO_LOG
  *		       is set.
  *	TEST_PAUSEF(HAND) - Pause for SIGUSR1 if the pause flag is set.
  *		      Use "hand" as the interrupt handling function
@@ -92,8 +92,8 @@
 
 #include <sys/param.h>
 
-/* 
- * Ensure that PATH_MAX is defined 
+/*
+ * Ensure that PATH_MAX is defined
  */
 #ifndef PATH_MAX
 #ifdef MAXPATHLEN
@@ -104,7 +104,7 @@
 #endif
 
 #ifndef CRAY
-#ifndef BSIZE 
+#ifndef BSIZE
 #define BSIZE BBSIZE
 #endif
 #endif
@@ -114,14 +114,14 @@
  * Entries in this struct are used by the parse_opts routine
  * to indicate valid options and return option arguments
  ***********************************************************************/
-typedef struct {		
+typedef struct {
   char *option;      	/* Valid option string (one option only) like "a:" */
   int  *flag;		/* pointer to location to set true if option given */
   char **arg;		/* pointer to location to place argument, if needed */
 } option_t;
 
 /***********************************************************************
- * The following globals are defined in parse_opts.c but must be 
+ * The following globals are defined in parse_opts.c but must be
  * externed here because they are used in the macros defined below.
  ***********************************************************************/
 extern int STD_FUNCTIONAL_TEST,	/* turned off by -f to not do functional test */
@@ -138,7 +138,7 @@ extern float STD_LOOP_DURATION, /* wall clock time to iterate */
 	     STD_LOOP_DELAY;    /* delay time after each iteration */
 
 #define USC_MAX_ERRNO	2000
-    
+
 /**********************************************************************
  * Prototype for parse_opts routine
  **********************************************************************/
@@ -146,7 +146,7 @@ extern char *parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 
 
 /*
- * define a structure 
+ * define a structure
  */
 struct usc_errno_t {
     int flag;
@@ -154,7 +154,7 @@ struct usc_errno_t {
 
 /***********************************************************************
  ****
- **** 
+ ****
  ****
  **********************************************************************/
 #ifdef  _USC_LIB_
@@ -179,12 +179,12 @@ int TEST_ERRNO;
 /***********************************************************************
  * temporary variables for determining max and min times in TEST macro
  ***********************************************************************/
-long btime, etime, tmptime;	
+long btime, etime, tmptime;
 
 #endif  /* _USC_LIB_ */
 
 /***********************************************************************
- * structure for timing accumulator and counters 
+ * structure for timing accumulator and counters
  ***********************************************************************/
 struct tblock {
     long tb_max;
@@ -204,8 +204,8 @@ extern void STD_opts_help();
 
 
 /***********************************************************************
- * TEST: calls a system call 
- * 
+ * TEST: calls a system call
+ *
  * parameters:
  *	SCALL = system call and parameters to execute
  *
@@ -214,12 +214,12 @@ extern void STD_opts_help();
 
 /***********************************************************************
  * TEST_VOID: calls a system call
- * 
+ *
  * parameters:
  *	SCALL = system call and parameters to execute
  *
  * Note: This is IDENTICAL to the TEST() macro except that it is intended
- * for use with syscalls returning no values (void syscall()).  The 
+ * for use with syscalls returning no values (void syscall()).  The
  * Typecasting nothing (void) into an unsigned integer causes compilation
  * errors.
  *
@@ -230,7 +230,7 @@ extern void STD_opts_help();
  * TEST_CLEANUP: print system call timing stats and errno log entries
  * to stdout if STD_TIMING_ON and STD_ERRNO_LOG are set, respectively.
  * Do NOT print ANY information if no system calls logged.
- * 
+ *
  * parameters:
  *	none
  *
@@ -254,7 +254,7 @@ if ( STD_ERRNO_LOG ) {						\
  * TEST_PAUSEF: Pause for SIGUSR1 if the pause flag is set.
  * 		 Set the user specified function as the interrupt
  *		 handler instead of "STD_go"
- * 
+ *
  * parameters:
  *	none
  *
@@ -269,7 +269,7 @@ if ( STD_PAUSE ) { 					\
 /***********************************************************************
  * TEST_PAUSE: Pause for SIGUSR1 if the pause flag is set.
  *	       Just continue when signal comes in.
- * 
+ *
  * parameters:
  *	none
  *
@@ -288,7 +288,7 @@ int usc_test_looping(int counter);
 
 /***********************************************************************
  * TEST_ERROR_LOG(eno): log this errno if STD_ERRNO_LOG flag set
- * 
+ *
  * parameters:
  *	int eno: the errno location in STD_ERRNO_LIST to log.
  *
@@ -302,7 +302,7 @@ int usc_test_looping(int counter);
 /***********************************************************************
  * TEST_EXP_ENOS(array): set the bits associated with the nput errnos
  *	in the TEST_VALID_ENO array.
- * 
+ *
  * parameters:
  *	int array[]: a zero terminated array of errnos expected.
  *
@@ -314,6 +314,6 @@ int usc_test_looping(int counter);
 	    TEST_VALID_ENO[array[tmptime]].flag=1;	\
 	tmptime++;					\
     }
-					
+
 
 #endif  /* end of __USCTEST_H__ */
diff --git a/test/mxc_pmic_test/include/write_log.h b/test/mxc_pmic_test/include/write_log.h
index c97ef58..4229584 100644
--- a/test/mxc_pmic_test/include/write_log.h
+++ b/test/mxc_pmic_test/include/write_log.h
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #ifndef _WRITE_LOG_H_
diff --git a/test/mxc_pmic_test/lib/Makefile b/test/mxc_pmic_test/lib/Makefile
index 5a986f2..ff238e2 100644
--- a/test/mxc_pmic_test/lib/Makefile
+++ b/test/mxc_pmic_test/lib/Makefile
@@ -1,12 +1,12 @@
 
-CFLAGS+= -Wall -I../include 
+CFLAGS+= -Wall -I../include
 LDFLAGS+=
 TARGET=libltp.a
 SRCS=$(wildcard *.c)
 OBJS=$(patsubst %.c,%.o,$(SRCS))
 
 $(TARGET): $(OBJS)
-	$(AR) -cr $@ $^    
+	$(AR) -cr $@ $^
 
 .PHONY: clean
 clean:
diff --git a/test/mxc_pmic_test/lib/dataascii.c b/test/mxc_pmic_test/lib/dataascii.c
index 4b18e38..775eb48 100644
--- a/test/mxc_pmic_test/lib/dataascii.c
+++ b/test/mxc_pmic_test/lib/dataascii.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <stdio.h>
diff --git a/test/mxc_pmic_test/lib/databin.c b/test/mxc_pmic_test/lib/databin.c
index f09c2c8..f0d55c0 100644
--- a/test/mxc_pmic_test/lib/databin.c
+++ b/test/mxc_pmic_test/lib/databin.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <stdio.h>
@@ -108,7 +108,7 @@ char **errmsg;
 	if ( errmsg != NULL ) {
 	    *errmsg = Errmsg;
 	}
-	
+
         switch (mode)
         {
         default:
diff --git a/test/mxc_pmic_test/lib/datapid.c b/test/mxc_pmic_test/lib/datapid.c
index 9414eae..c047792 100644
--- a/test/mxc_pmic_test/lib/datapid.c
+++ b/test/mxc_pmic_test/lib/datapid.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /************
@@ -44,7 +44,7 @@ ________________________________________________________________
 
 
 8 bits to a bytes == character
- NBPW            8 
+ NBPW            8
 ************/
 
 #include <stdio.h>
@@ -72,12 +72,12 @@ static char Errmsg[80];
 
 /***********************************************************************
  *
- * 
+ *
  * 1   2   3   4   5   6   7   8   9   10  11  12  13  14  14  15	bytes
  * 1234567890123456789012345678901234567890123456789012345678901234	bits
  * ________________________________________________________________	1 word
  * <    pid       >< offset in file of this word  ><    pid       >
- * 
+ *
  * the words are put together where offset zero is the start.
  * thus, offset 16 is the start of  the second full word
  * Thus, offset 8 is in middle of word 1
@@ -90,7 +90,7 @@ int bsize;
 int offset;
 {
 #if CRAY
-	
+
    int cnt;
    int tmp;
    char *chr;
@@ -124,13 +124,13 @@ printf("partial at beginning, cnt = %d, woff = %d\n", cnt, woff);
     }
 
     /*
-     * full words 
+     * full words
      */
 
     num_full_words = (bsize-boff)/NBPW;
-	
+
     woff = offset+boff;
-	
+
     for (cnt=0; cnt<num_full_words; woff += NBPW, cnt++ ) {
 
 	word = ((LOWER16BITS(pid) << 48) | (LOWER32BITS(woff) << 16) | LOWER16BITS(pid));
@@ -171,7 +171,7 @@ printf("partial at end\n");
 
 #endif
 
-} 
+}
 
 /***********************************************************************
  *
@@ -186,7 +186,7 @@ int offset;
 char **errmsg;
 {
 #if CRAY
-	
+
    int cnt;
    int tmp;
    char *chr;
@@ -225,13 +225,13 @@ char **errmsg;
     }
 
     /*
-     * full words 
+     * full words
      */
 
     num_full_words = (bsize-boff)/NBPW;
-	
+
     woff = offset+boff;
-	
+
     for (cnt=0; cnt<num_full_words; woff += NBPW, cnt++ ) {
 	word = ((LOWER16BITS(pid) << 48) | (LOWER32BITS(woff) << 16) | LOWER16BITS(pid));
 
@@ -281,7 +281,7 @@ printf("partial at end\n");
     return -1;      /* buffer is ok */
 
 #else
-	
+
     if ( errmsg != NULL ) {
         *errmsg = Errmsg;
     }
diff --git a/test/mxc_pmic_test/lib/file_lock.c b/test/mxc_pmic_test/lib/file_lock.c
index e6823a2..8b66ab5 100644
--- a/test/mxc_pmic_test/lib/file_lock.c
+++ b/test/mxc_pmic_test/lib/file_lock.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <sys/types.h>
diff --git a/test/mxc_pmic_test/lib/forker.c b/test/mxc_pmic_test/lib/forker.c
index ca2c033..ad3ffbf 100644
--- a/test/mxc_pmic_test/lib/forker.c
+++ b/test/mxc_pmic_test/lib/forker.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /**************************************************************
@@ -144,7 +144,7 @@ char *prefix;
   case 0:	/* child process */
     break;
 
-  default:	
+  default:
     exit(0);
   }
 
@@ -153,8 +153,8 @@ char *prefix;
 }	/* end of background */
 
 /***********************************************************************
- * Forker will fork ncopies-1 copies of self. 
- * 
+ * Forker will fork ncopies-1 copies of self.
+ *
  ***********************************************************************/
 int
 forker(ncopies, mode, prefix)
@@ -175,16 +175,16 @@ char *prefix;   /* if ! NULL, an message will be printed to stderr */
 	switch ( mode ) {
         case 1  :	/* only 1 direct child */
 	    if ( (pid = fork()) == -1 ) {
-		if ( prefix != NULL ) 
+		if ( prefix != NULL )
 		    fprintf(stderr, "%s: %s,forker(): fork() failed, errno:%d %s\n",
 			prefix, __FILE__, errno, strerror(errno));
 	        return 0;
 	    }
 	    Forker_npids++;
-	    
+
 	    switch (pid ) {
             case 0:     /* child - continues the forking */
-	        
+
 		if ( Forker_npids < FORKER_MAX_PIDS )
                     Forker_pids[Forker_npids-1]=getpid();
                 break;
@@ -192,25 +192,25 @@ char *prefix;   /* if ! NULL, an message will be printed to stderr */
             default:    /* parent - stop the forking */
 		if ( Forker_npids < FORKER_MAX_PIDS )
                     Forker_pids[Forker_npids-1]=pid;
-                return cnt-1;      
+                return cnt-1;
             }
 
 	    break;
 
 	default :	/* all new processes are childern of parent */
 	    if ( (pid = fork()) == -1 ) {
-		if ( prefix != NULL ) 
+		if ( prefix != NULL )
 		    fprintf(stderr, "%s: %s,forker(): fork() failed, errno:%d %s\n",
 			prefix, __FILE__, errno, strerror(errno));
 	        return cnt-1;
 	    }
 	    Forker_npids++;
-	    
+
 	    switch (pid ) {
 	    case 0:	/* child - stops the forking */
 		if ( Forker_npids < FORKER_MAX_PIDS )
                     Forker_pids[Forker_npids-1]=getpid();
-	        return cnt;	
+	        return cnt;
 
 	    default:	/* parent - continues the forking */
 		if ( Forker_npids < FORKER_MAX_PIDS )
@@ -267,16 +267,16 @@ char **argv;
 
     ret=forker(ncopies, mode, argv[0]);
 
-    printf("forker(%d, %d, %s) ret:%d, pid = %d, sleeping 30 seconds.\n", 
+    printf("forker(%d, %d, %s) ret:%d, pid = %d, sleeping 30 seconds.\n",
 	ncopies, mode, argv[0], ret, getpid());
 
-    printf("%d My version of Forker_pids[],  Forker_npids = %d\n", 
+    printf("%d My version of Forker_pids[],  Forker_npids = %d\n",
 	getpid(), Forker_npids);
 
     for (ind=0; ind<Forker_npids; ind++){
 	printf("%d ind:%-2d pid:%d\n", getpid(), ind, Forker_pids[ind]);
     }
-    
+
     sleep(30);
     exit(0);
 }
diff --git a/test/mxc_pmic_test/lib/get_high_address.c b/test/mxc_pmic_test/lib/get_high_address.c
index 36a9a15..d340bd2 100644
--- a/test/mxc_pmic_test/lib/get_high_address.c
+++ b/test/mxc_pmic_test/lib/get_high_address.c
@@ -30,7 +30,7 @@
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
-#include <unistd.h> 
+#include <unistd.h>
 
 char *
 get_high_address()
diff --git a/test/mxc_pmic_test/lib/open_flags.c b/test/mxc_pmic_test/lib/open_flags.c
index 3b81237..eaa8051 100644
--- a/test/mxc_pmic_test/lib/open_flags.c
+++ b/test/mxc_pmic_test/lib/open_flags.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /**************************************************************
@@ -66,10 +66,10 @@
  *	If parse_open_flags returns, <string> will left unchanged.
  *
  * 	The openflags2symbols function attempts to convert open flag
- *	bits into human readable  symbols (i.e. O_TRUNC).  If there 
+ *	bits into human readable  symbols (i.e. O_TRUNC).  If there
  *	are more than one symbol, the <sep> string will be placed as
  *	a separator between symbols.  Commonly used separators would
- *	be a comma "," or pipe "|".  If <mode> is one and not all 
+ *	be a comma "," or pipe "|".  If <mode> is one and not all
  *	<openflags> bits can be converted to symbols, the "UNKNOWN"
  *	symbol will be added to return string.
  * 	Openflags2symbols will return the indentified symbols.
@@ -187,7 +187,7 @@ static struct open_flag_t Open_flags[] = {
 
 };
 
-int 
+int
 parse_open_flags(char *string, char **badname)
 {
    int  bits = 0;
@@ -262,9 +262,9 @@ openflags2symbols(int openflags, char *sep, int mode)
      *  Loop through all but O_RDONLY elments of Open_flags
      */
     for(ind=1; ind < size; ind++) {
-	  
+
 	if ( (bits & Open_flags[ind].flag) == Open_flags[ind].flag ) {
-	    if ( havesome ) 
+	    if ( havesome )
 		strcat(Open_symbols, sep);
 
 	    strcat(Open_symbols, Open_flags[ind].symbol);
@@ -314,11 +314,11 @@ char **argv;
     if ( sscanf(argv[1], "%i", &bits) == 1 ) {
 	printf("openflags2symbols(%#o, \",\", 1) returned %s\n",
 	    bits, openflags2symbols(bits, ",", 1));
-	
+
     } else {
 	ret=parse_open_flags(argv[1], &err);
 	if ( ret == -1 )
-	    printf("parse_open_flags(%s, &err) returned -1, err = %s\n", 
+	    printf("parse_open_flags(%s, &err) returned -1, err = %s\n",
 	        argv[0], err);
         else
 	    printf("parse_open_flags(%s, &err) returned %#o\n", argv[0], ret);
diff --git a/test/mxc_pmic_test/lib/parse_opts.c b/test/mxc_pmic_test/lib/parse_opts.c
index d113132..c87370d 100644
--- a/test/mxc_pmic_test/lib/parse_opts.c
+++ b/test/mxc_pmic_test/lib/parse_opts.c
@@ -1,45 +1,45 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
 /* $Id: parse_opts.c,v 1.1 2004/07/21 09:10:41 rb878c Exp $ */
 
 /**********************************************************
- * 
+ *
  *    OS Testing - Silicon Graphics, Inc.
- * 
+ *
  *    FUNCTION NAME 	: parse_opts
- * 
+ *
  *    FUNCTION TITLE	: parse standard & user options for system call tests
- * 
+ *
  *    SYNOPSIS:
  *	#include "usctest.h"
  *
@@ -48,11 +48,11 @@
  * 	char **av;
  *	option_t user_optarr[];
  *	void (*uhf)();
- * 
+ *
  *    AUTHOR		: William Roske/Richard Logan
- * 
+ *
  *    INITIAL RELEASE	: UNICOS 7.0
- * 
+ *
  *    DESCRIPTION
  * 	The parse_opts library routine takes that argc and argv parameters
  *	recevied by main() and an array of structures defining user options.
@@ -62,11 +62,11 @@
  *
  *      This module contains the functions usc_global_setup_hook and
  *      usc_test_looping, which are called by marcos defined in usctest.h.
- * 
+ *
  *    RETURN VALUE
  * 	parse_opts returns a pointer to an error message if an error occurs.
  *	This pointer is (char *)NULL if parsing is successful.
- * 
+ *
  *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
 #include <errno.h>
 #include <stdlib.h>
@@ -151,7 +151,7 @@ struct std_option_t {
     { "h" , "  -h      Show this help screen\n", NULL, NULL},
     { "i:", "  -i n    Execute test n times\n", NULL, NULL},
     { "I:", "  -I x    Execute test for x seconds\n", NULL, NULL},
-    { "p" , "  -p      Pause for SIGUSR1 before starting\n", NULL, NULL}, 
+    { "p" , "  -p      Pause for SIGUSR1 before starting\n", NULL, NULL},
     { "P:", "  -P x    Pause for x seconds between iterations\n", NULL, NULL},
     { "t" , "  -t      Turn on syscall timing\n", NULL, NULL},
     {NULL, NULL, NULL, NULL}};
@@ -191,7 +191,7 @@ static void usc_recressive_func();
 
 
 /**********************************************************************
- * parse_opts: 
+ * parse_opts:
  **********************************************************************/
 char *
 parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
@@ -217,7 +217,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
     }
     /* Calculate how much space we need for the option string */
     optstrlen = 0;
-    for (i = 0; std_options[i].optstr; ++i) 
+    for (i = 0; std_options[i].optstr; ++i)
 	optstrlen += strlen(std_options[i].optstr);
     if (user_optarr)
 	for (i = 0; user_optarr[i].option; ++i) {
@@ -229,7 +229,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 
     /* Create the option string for getopt */
     optionstr = (char *)malloc(optstrlen);
-    if (!optionstr) 
+    if (!optionstr)
 	return "parse_opts: ERROR - Could not allocate memory for optionstr";
 
     optionstr[0] = '\0';
@@ -239,7 +239,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
     if (user_optarr)
 	for (i = 0; user_optarr[i].option; ++i)
 	    /* only add the option if it wasn't there already */
-	    if (strchr(optionstr, user_optarr[i].option[0]) == NULL) 
+	    if (strchr(optionstr, user_optarr[i].option[0]) == NULL)
 		strcat(optionstr, user_optarr[i].option);
 
 #if DEBUG > 1
@@ -275,7 +275,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 		case 'I': /* Time duration */
 			options |= OPT_duration;
 			STD_LOOP_DURATION = atof(optarg);
-			if ( STD_LOOP_DURATION == 0.0 ) STD_INFINITE=1; 
+			if ( STD_LOOP_DURATION == 0.0 ) STD_INFINITE=1;
 			break;
 		case 'c': /* Copies */
 			options |= OPT_copies;
@@ -298,7 +298,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 			exit(0);
 			break;
 		default:
-			
+
             /* Check all the user specified options */
             found=0;
 	    for(i = 0; user_optarr[i].option; ++i) {
@@ -311,14 +311,14 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
                     found++;
 
 		    /* save the argument at the user's location */
-                    if ( user_optarr[i].option[strlen(user_optarr[i].option)-1] == ':' ) {  
+                    if ( user_optarr[i].option[strlen(user_optarr[i].option)-1] == ':' ) {
                         *user_optarr[i].arg=optarg;
                     }
                     break;  /* option found - break out of the for loop */
                 }
             }
 	    /* This condition "should never happen".  SO CHECK FOR IT!!!! */
-            if ( ! found ) { 
+            if ( ! found ) {
                 sprintf(Mesg2,
 		    "parse_opts: ERROR - option:\"%c\" NOT FOUND... INTERNAL ERROR", opt);
                 return(Mesg2);
@@ -453,7 +453,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 	}
         else
 	    STD_LP_barrier=1;
-	if ( Debug ) 
+	if ( Debug )
 	    printf("using env USC_LP_BARRIER, Set STD_LP_barrier to %d\n",
 	        STD_LP_barrier);
     }
@@ -526,7 +526,7 @@ parse_opts(int ac, char **av, option_t *user_optarr, void (*uhf)())
 		    STD_LD_recfun);
         }
     }
- 
+
 #if UNIT_TEST
     printf("The following variables after option and env parsing:\n");
     printf("STD_FUNCTIONAL_TEST = %d\n", STD_FUNCTIONAL_TEST);
@@ -568,7 +568,7 @@ STD_opts_help()
     }
 }
 
-/* 
+/*
  * routine to goto when we get the SIGUSR1 for STD_PAUSE
  */
 void STD_go(int sig)
@@ -607,14 +607,14 @@ usc_global_setup_hook()
 		break;
 	}
     }
-    
+
     /*
      * pause waiting for sigusr1.
      */
-    if ( STD_PAUSE ) {                                      
-        _TMP_FUNC = (int (*)())signal(SIGUSR1, STD_go);   
-        pause();                                          
-        signal(SIGUSR1, (void (*)())_TMP_FUNC);          
+    if ( STD_PAUSE ) {
+        _TMP_FUNC = (int (*)())signal(SIGUSR1, STD_go);
+        pause();
+        signal(SIGUSR1, (void (*)())_TMP_FUNC);
     }
 
 
@@ -624,7 +624,7 @@ usc_global_setup_hook()
 
     if ( STD_TP_sbrk ) {
 	sbrk(STD_TP_sbrk);
-	if ( Debug ) 
+	if ( Debug )
 	    printf("after sbrk(%d)\n", STD_TP_sbrk);
     }
     return 0;
@@ -669,7 +669,7 @@ get_current_time()
  * If the STD_LOOP_DURATION variable is set, compare current time against
  * calculated stop_time.
  * This function will return 1 until all desired looping methods
- * have been met.  
+ * have been met.
  *
  * counter integer is supplied by the user program.
  ***********************************************************************/
@@ -685,7 +685,7 @@ int counter;
     int keepgoing=0;		/* used to determine return value */
 
     /*
-     * If this is the first iteration and we are looping for 
+     * If this is the first iteration and we are looping for
      * duration of STD_LOOP_DURATION seconds (fractional) or
      * doing loop delays, get the clocks per second.
      */
@@ -700,7 +700,7 @@ int counter;
 	 * If looping for duration, calculate stop time in
 	 * clocks.
 	 */
-	
+
 	if ( STD_LOOP_DURATION) {
 	    ct=get_current_time();
 	    stop_time=(int)((float)hz * STD_LOOP_DURATION) + ct;
@@ -715,7 +715,7 @@ int counter;
 	}
 
     }
-	
+
     /*
      * if delay each iteration, loop for delay clocks.
      * This will not be done on first iteration.
@@ -731,7 +731,7 @@ int counter;
 	     */
 	    if ( STD_LD_recfun ) {
 		if ( Debug )
-		    printf("calling usc_recressive_func(0, %d, &STD_bigstack)\n", 
+		    printf("calling usc_recressive_func(0, %d, &STD_bigstack)\n",
 		        STD_LD_recfun);
 		usc_recressive_func(0, STD_LD_recfun, &STD_bigstack);
 	    }
@@ -761,7 +761,7 @@ int counter;
 
     if ( STD_LP_recfun ) {
 	if ( Debug )
-	    printf("calling usc_recressive_func(0, %d, &STD_bigstack)\n", 
+	    printf("calling usc_recressive_func(0, %d, &STD_bigstack)\n",
 	        STD_LP_recfun);
 	usc_recressive_func(0, STD_LP_recfun, &STD_bigstack);
     }
@@ -782,7 +782,7 @@ int counter;
 
 /*
  * This function recressively calls itself max times.
- */ 
+ */
 static void
 usc_recressive_func(cnt, max, bstack)
 int cnt;
@@ -798,7 +798,7 @@ struct usc_bigstack_t bstack;
 /******************************************************************************
  * UNIT TEST CODE
  * UNIT TEST CODE
- * 
+ *
  * this following code is provide so that unit testing can
  * be done fairly easily.
  ******************************************************************************/
@@ -860,7 +860,7 @@ char **argv;
     TEST_PAUSE;
 
     for (lc=0; TEST_LOOPING(lc); lc++) {
-    
+
         TEST( gettimeofday(&t, NULL) );
         printf("iter=%d: sec:%d, usec:%6.6d %s", lc+1, t.tv_sec,
 	    t.tv_usec, ctime(&t.tv_sec));
diff --git a/test/mxc_pmic_test/lib/pattern.c b/test/mxc_pmic_test/lib/pattern.c
index 7f4d587..c36eff1 100644
--- a/test/mxc_pmic_test/lib/pattern.c
+++ b/test/mxc_pmic_test/lib/pattern.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <string.h>
diff --git a/test/mxc_pmic_test/lib/random_range.c b/test/mxc_pmic_test/lib/random_range.c
index ac3ef57..9c05cf7 100644
--- a/test/mxc_pmic_test/lib/random_range.c
+++ b/test/mxc_pmic_test/lib/random_range.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <stdio.h>
@@ -69,7 +69,7 @@ struct range {
  *	str		The string to parse - assumed to be a comma-separated
  *			list of tokens having the above format.
  *	defmin		default value to plug in for min, if it is missing
- *	defmax		default value to plug in for max, if it is missing     
+ *	defmax		default value to plug in for max, if it is missing
  *	defmult		default value to plug in for mult, if missing
  *	parse_func	A user-supplied function pointer, which parse_ranges()
  *			can call to parse the min, max, and mult strings.  This
@@ -77,7 +77,7 @@ struct range {
  *			MUST have the following prototype:
  *				parse_func(char *str, int *val)
  *			The function should return -1 if str cannot be parsed
- *			into an integer, or >= 0 if it was successfully 
+ *			into an integer, or >= 0 if it was successfully
  *			parsed.  The resulting integer will be stored in
  *			*val.  If parse_func is NULL, parse_ranges will parse
  *			the tokens in a manner consistent with the the sscanf
@@ -168,7 +168,7 @@ char	**errptr;
 
 		/*
 		 * Process the 'max' field - if one was not present (n1 format)
-		 * set max equal to min.  If the field was present, but 
+		 * set max equal to min.  If the field was present, but
 		 * zero length (n1: format), retain the default.  Otherwise
 		 * pass the string to the parse function.
 		 */
@@ -185,7 +185,7 @@ char	**errptr;
 		}
 
 		/*
-		 * Process the 'mult' field - if one was not present 
+		 * Process the 'mult' field - if one was not present
 		 * (n1:n2 format), or the field was zero length (n1:n2: format)
 		 * then set the mult field to defmult - otherwise pass then
 		 * mult field to the parse function.
@@ -352,7 +352,7 @@ char	**errp;
 	}
 
     	nmults = ((max - min) / mult) + 1;
-#if CRAY 
+#if CRAY
         /*
          * If max is less than 2gb, then the value can fit in 32 bits
          * and the standard lrand48() routine can be used.
@@ -540,7 +540,7 @@ char		**errp;
 	 * If max is less than 2gb, then the value can fit in 32 bits
 	 * and the standard lrand48() routine can be used.
 	 */
-	if ( max <= (long)2147483647 ) {  
+	if ( max <= (long)2147483647 ) {
     	    return (long long) (min + (((long long)lrand48() % nmults) * mult));
 	} else {
 	    /*
@@ -583,7 +583,7 @@ divider(long long min, long long max, long long cnt, long long rand)
     /*
      * Only get a random number the first time.
      */
-    if ( cnt == 0 || rand < -1 ) { 
+    if ( cnt == 0 || rand < -1 ) {
         rand = (long long)lrand48();  /* 32 bit random number */
     }
 
@@ -620,7 +620,7 @@ printf("   diff = %lld, half = %lld,   med = %lld\n", diff, half, med);
 	} else {
 	    return divider(min, med, cnt+1, rand);
 	}
-	
+
     }
 
 }
@@ -760,7 +760,7 @@ char **argv;
     int imax=1048576;
 #endif
 
-    long lret, lmin=0, lmult=1, ltmin, ltmax=0; 
+    long lret, lmin=0, lmult=1, ltmin, ltmax=0;
 #if CRAY || (_MIPS_SZLONG == 64)
     long lmax=6*(long)GIG;	/* higher than 32 bits */
 #else
@@ -777,7 +777,7 @@ char **argv;
 
     for (ind=0; ind<PARTNUM; ind++ )
 	cntarr[ind]=0;
-    
+
     if ( argc < 2 ) {
         printf("Usage: %s func [iterations] \n", argv[0]);
 	printf("func can be random_range, random_rangel, random_rangell\n");
@@ -826,7 +826,7 @@ char **argv;
 	        valbound[ind], valbound[ind+1], cntarr[ind],
 	        (float)(cntarr[ind]/(float)iter));
         }
-        printf("%2d %-13ld to  %-13ld   %5ld %4.4f\n", PARTNUM, 
+        printf("%2d %-13ld to  %-13ld   %5ld %4.4f\n", PARTNUM,
 	    valbound[PARTNUM-1], lmax, cntarr[PARTNUM-1],
 	    (float)(cntarr[PARTNUM-1]/(float)iter));
 	printf("  min=%ld,  max=%ld\n", ltmin, ltmax);
@@ -904,7 +904,7 @@ char **argv;
 	        valbound[ind], valbound[ind+1], cntarr[ind],
 	        (float)(cntarr[ind]/(float)iter));
         }
-        printf("%2d %-13ld to  %-13ld   %5ld %4.4f\n", PARTNUM, 
+        printf("%2d %-13ld to  %-13ld   %5ld %4.4f\n", PARTNUM,
 	    valbound[PARTNUM-1], (long)imax, cntarr[PARTNUM-1],
 	    (float)(cntarr[PARTNUM-1]/(float)iter));
 	printf("  min=%d,  max=%d\n", itmin, itmax);
diff --git a/test/mxc_pmic_test/lib/rmobj.c b/test/mxc_pmic_test/lib/rmobj.c
index 281613d..66a6eed 100644
--- a/test/mxc_pmic_test/lib/rmobj.c
+++ b/test/mxc_pmic_test/lib/rmobj.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
diff --git a/test/mxc_pmic_test/lib/search_path.c b/test/mxc_pmic_test/lib/search_path.c
index 22cce0a..884bda5 100644
--- a/test/mxc_pmic_test/lib/search_path.c
+++ b/test/mxc_pmic_test/lib/search_path.c
@@ -32,24 +32,24 @@
 
 
 /**********************************************************
- * 
+ *
  *    UNICOS Feature Test and Evaluation - Cray Research, Inc.
- * 
- *    FUNCTION NAME 	: search_path 
- * 
+ *
+ *    FUNCTION NAME 	: search_path
+ *
  *    FUNCTION TITLE	: search PATH locations for desired filename
- * 
+ *
  *    SYNOPSIS:
  *	int search_path(cmd, res_path, access_mode, fullpath)
  *	char *cmd;
  *	char *res_path;
  *	int access_mode;
  *	int fullpath;
- * 
+ *
  *    AUTHOR		: Richard Logan
- * 
+ *
  *    INITIAL RELEASE	: UNICOS 7.0
- * 
+ *
  *    DESCRIPTION
  *	Search_path will walk through PATH and attempt to find "cmd".  If cmd is
  *	a full or relative path, it is checked but PATH locations are not scanned.
@@ -64,10 +64,10 @@
  *	directory is prepended to path/cmd before access is called.
  *	If cmd is found, search_path will return 0.  If cmd cannot be
  *	found, 1 is returned.  If an error has occurred, -1 is returned
- *	and an error mesg is placed in res_path. 
+ *	and an error mesg is placed in res_path.
  *	If the length of path/cmd is larger then PATH_MAX, then that path
  *	location is skipped.
- * 
+ *
  *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
 
 #include <stdio.h>
@@ -119,7 +119,7 @@ char **argv;
 	    printf("path of %s is %s\n", argv[ind], path);
 	}
     }
-    
+
 }
 
 #endif
@@ -149,7 +149,7 @@ printf("search_path: cmd = %s, access_mode = %d, fullpath = %d\n", cmd, access_m
     /*
      * full or relative path was given
      */
-    if ( (cmd[0] == '/') || ( (cp=strchr(cmd, '/')) != NULL )) {  
+    if ( (cmd[0] == '/') || ( (cp=strchr(cmd, '/')) != NULL )) {
 	if ( access(cmd, access_mode) == 0 ) {
 
 	    if ( cmd[0] != '/' ) { /* relative path */
@@ -182,8 +182,8 @@ printf("search_path: cmd = %s, access_mode = %d, fullpath = %d\n", cmd, access_m
     }
 
     /*
-     * walk through each path in PATH. 
-     * Each path in PATH is placed in tmppath.  
+     * walk through each path in PATH.
+     * Each path in PATH is placed in tmppath.
      * pathenv cannot be modified since it will affect PATH.
      * If a signal came in while we have modified the PATH
      * memory, we could create a problem for the caller.
@@ -234,7 +234,7 @@ printf("search_path: res_path = '%s'\n", res_path);
 	    /* if the path is not full at this point, prepend the current
 	     * path to get the full path.
 	     * Note:  this could not be wise to do when under a protected
-	     * directory.  
+	     * directory.
 	     */
 
 	if ( fullpath && res_path[0] != '/' ) {	/* not a full path */
diff --git a/test/mxc_pmic_test/lib/str_to_bytes.c b/test/mxc_pmic_test/lib/str_to_bytes.c
index af63a1b..01c0d50 100644
--- a/test/mxc_pmic_test/lib/str_to_bytes.c
+++ b/test/mxc_pmic_test/lib/str_to_bytes.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 #include <stdio.h>
@@ -99,7 +99,7 @@ char    *s;
 		return (int)((num * (float)M_MULT) * sizeof(long));
     case 'g':
 		return (int)(num * (float)G_MULT);
-    case 'G':	
+    case 'G':
     		return (int)((num * (float)G_MULT) * sizeof(long));
     default:
 	return -1;
@@ -134,7 +134,7 @@ char    *s;
 		return (long)((num * (float)M_MULT) * sizeof(long));
     case 'g':
 		return (long)(num * (float)G_MULT);
-    case 'G':	
+    case 'G':
     		return (long)((num * (float)G_MULT) * sizeof(long));
     default:
 	return -1;
@@ -174,7 +174,7 @@ char    *s;
 		return (long long)((num * (float)M_MULT) * sizeof(long long));
     case 'g':
 		return (long long)(num * (float)G_MULT);
-    case 'G':	
+    case 'G':
     		return (long long)((num * (float)G_MULT) * sizeof(long long));
     default:
 	return -1;
@@ -191,16 +191,16 @@ main(int argc, char **argv)
 	fprintf(stderr, "missing str_to_bytes() parameteres\n");
 	exit(1);
     }
-   
+
     for (ind=1; ind<argc; ind++) {
 
-	printf("str_to_bytes(%s) returned %d\n", 
+	printf("str_to_bytes(%s) returned %d\n",
 	    argv[ind], str_to_bytes(argv[ind]));
 
-	printf("str_to_lbytes(%s) returned %ld\n", 
+	printf("str_to_lbytes(%s) returned %ld\n",
 	    argv[ind], str_to_lbytes(argv[ind]));
 
-	printf("str_to_llbytes(%s) returned %lld\n", 
+	printf("str_to_llbytes(%s) returned %lld\n",
 	    argv[ind], str_to_llbytes(argv[ind]));
     }
 }
diff --git a/test/mxc_pmic_test/lib/string_to_tokens.c b/test/mxc_pmic_test/lib/string_to_tokens.c
index 6f0d775..09be8c0 100644
--- a/test/mxc_pmic_test/lib/string_to_tokens.c
+++ b/test/mxc_pmic_test/lib/string_to_tokens.c
@@ -1,42 +1,42 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /**********************************************************
- * 
+ *
  *    OS Testing - Silicon Graphics, Inc.
- * 
+ *
  *    FUNCTION NAME     : string_to_tokens
- * 
+ *
  *    FUNCTION TITLE    : Break a string into its tokens
- * 
+ *
  *    SYNOPSIS:
  *
  * int string_to_tokens(arg_string, arg_array, array_size, separator)
@@ -44,13 +44,13 @@
  *    char *arg_array[];
  *    int array_size;
  *    char *separator;
- * 
+ *
  *    AUTHOR            : Richard Logan
  *
  *    DATE		: 10/94
  *
  *    INITIAL RELEASE   : UNICOS 7.0
- * 
+ *
  *    DESCRIPTION
  * This function parses the string 'arg_string', placing pointers to
  * the 'separator' separated tokens into the elements of 'arg_array'.
@@ -64,7 +64,7 @@
  * This function returns the number of 'separator' separated tokens that
  * were found in 'arg_string'.
  * If 'arg_array' or 'separator' is NULL or 'array_size' is less than 2, -1 is returned.
- * 
+ *
  *    WARNING
  * This function uses strtok() to parse 'arg_string', and thus
  * physically alters 'arg_string' by placing null characters where the
@@ -72,7 +72,7 @@
  *
  *
  *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
-#include <stdio.h>         
+#include <stdio.h>
 #include <string.h>        /* for string functions */
 #include "string_to_tokens.h"
 
@@ -81,7 +81,7 @@ string_to_tokens(char *arg_string, char *arg_array[], int array_size, char *sepa
 {
    int num_toks = 0;  /* number of tokens found */
    char *strtok();
-	
+
    if ( arg_array == NULL || array_size <= 1 || separator == NULL )
 	return -1;
 
diff --git a/test/mxc_pmic_test/lib/tlibio.c b/test/mxc_pmic_test/lib/tlibio.c
index d8c355d..72b76c9 100644
--- a/test/mxc_pmic_test/lib/tlibio.c
+++ b/test/mxc_pmic_test/lib/tlibio.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /*
@@ -84,7 +84,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/time.h>          
+#include <sys/time.h>
 #include <sys/param.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -135,14 +135,14 @@ struct lio_info_type  Lio_info1[] = {
     { "b", LIO_IO_ASYNC|LIO_WAIT_SIGPAUSE, "async i/o using pause" },
     { "a", LIO_IO_ASYNC|LIO_WAIT_RECALL, "async i/o using recall/aio_suspend" },
 #ifdef sgi
-    { "r", 
+    { "r",
 	LIO_RANDOM|LIO_IO_TYPES|LIO_WAIT_TYPES, "random sync i/o types and wait methods" },
-    { "R", 
+    { "R",
 	LIO_RANDOM|LIO_IO_ATYPES|LIO_WAIT_ATYPES, "random i/o types and wait methods" },
 #else
-    { "r", 
+    { "r",
 	LIO_RANDOM|LIO_IO_TYPES|LIO_WAIT_TYPES, "random i/o types and wait methods" },
-    { "R", 
+    { "R",
 	LIO_RANDOM|LIO_IO_TYPES|LIO_WAIT_TYPES, "random i/o types and wait methods" },
 #endif
     { "l", LIO_IO_SLISTIO|LIO_WAIT_RECALL, "single stride sync listio" },
@@ -169,8 +169,8 @@ struct lio_info_type  Lio_info2[] = {
 /* nowait is a touchy thing, it's an accident that this implementation worked at all.  6/27/97 roehrich */
 /*    { "nowait",    LIO_WAIT_NONE,	"do not wait for async io to complete" },*/
     { "random",    LIO_RANDOM,		"set random bit" },
-    { "randomall", 
-	LIO_RANDOM|LIO_IO_TYPES|LIO_WAIT_TYPES, 
+    { "randomall",
+	LIO_RANDOM|LIO_IO_TYPES|LIO_WAIT_TYPES,
 	"all random i/o types and wait methods (except nowait)" },
 };
 
@@ -192,7 +192,7 @@ static int Debug_level = 0;
  *
  * Determine the bounds of a strided request, normalized to offset.  Returns
  * the number of bytes needed to satisfy the request, and optionally sets
- * *min and *max to the mininum and maximum bytes referenced, normalized 
+ * *min and *max to the mininum and maximum bytes referenced, normalized
  * around offset.
  *
  * Returns -1 on error - the only possible error conditions are illegal values
@@ -240,11 +240,11 @@ int	*max;
 		min_byte = offset;
 		max_byte = min_byte + nbytes - 1;
 	}
-	
+
 	if (min != NULL) {
 		*min = min_byte;
 	}
-	
+
 	if (max != NULL) {
 		*max = max_byte;
 	}
@@ -325,7 +325,7 @@ lio_help1(char *prefix)
  * method tokens as defined in Lio_info2[].  If a token does not match
  * any of the tokens in Lio_info2[], it will be coverted to a number.
  * If it was a number, those bits are also set.
- * 
+ *
  *  (rrl 04/96)
  ***********************************************************************/
 int
@@ -349,7 +349,7 @@ lio_parse_io_arg2(char *string, char **badtoken)
         savecc = *cc;
         *cc = '\0';
 
-        found = 0; 
+        found = 0;
 
         /*
 	 * Determine if token is a valid string or number and if
@@ -457,7 +457,7 @@ lio_async_callback_handler(sigval_t sigval)
  *
  * Return Value
  * This function will return a value with all non choosen io type
- * and wait method bits cleared.  The LIO_RANDOM bit is also 
+ * and wait method bits cleared.  The LIO_RANDOM bit is also
  * cleared.  All other bits are left unchanged.
  *
  * (rrl 04/96)
@@ -481,7 +481,7 @@ lio_random_methods(long curr_mask)
 }
 
 /***********************************************************************
- * Generic write function 
+ * Generic write function
  * This function can be used to do a write using write(2), writea(2),
  * aio_write(3), writev(2), pwrite(2),
  * or single stride listio(2)/lio_listio(3).
@@ -493,12 +493,12 @@ lio_random_methods(long curr_mask)
  * wait method is: recall(2) for writea(2) and listio(2); aio_suspend(3) for
  * aio_write(3) and lio_listio(3).
  *
- * If multiple wait methods are specified, 
+ * If multiple wait methods are specified,
  * only one wait method will be used. The order is predetermined.
  *
  * If the call specifies a signal and one of the two signal wait methods,
  * a signal handler for the signal is set.  This will reset an already
- * set handler for this signal. 
+ * set handler for this signal.
  *
  * If the LIO_RANDOM method bit is set, this function will randomly
  * choose a io type and wait method from bits in the method argument.
@@ -516,7 +516,7 @@ lio_random_methods(long curr_mask)
  *	If the size the system call say was written is different
  *	then what was asked to be written, errmsg is updated for
  *	this error condition.  The return value is still the amount
- *	the system call says was written.  
+ *	the system call says was written.
  *
  * (rrl 04/96)
  ***********************************************************************/
@@ -538,7 +538,7 @@ long wrd;	/* to allow future features, use zero for now */
 #endif
 #ifdef  CRAY
     struct listreq request;	/* Used when a listio is wanted */
-    struct iosw status, *statptr[1];  
+    struct iosw status, *statptr[1];
 #else
     /* for linux or sgi */
     struct iovec iov;	/* iovec for writev(2) */
@@ -629,7 +629,7 @@ long wrd;	/* to allow future features, use zero for now */
      * Otherwise there is not necessary a signal handler to trap
      * the signal.
      */
-    if ( sig && !(method & LIO_USE_SIGNAL) && 
+    if ( sig && !(method & LIO_USE_SIGNAL) &&
 	! (method & LIO_WAIT_SIGTYPES) ){
 
 	sig=0;	/* ignore signal parameter */
@@ -677,7 +677,7 @@ long wrd;	/* to allow future features, use zero for now */
      * system call failure.  If sync i/o, return the number of
      * bytes written/read.
      */
-     
+
     if ( (method & LIO_IO_SYNC) || (method & LIO_IO_TYPES) == 0 ){
 	/*
 	 * write(2) is used if LIO_IO_SYNC bit is set or not none
@@ -771,7 +771,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LC_WAIT;
 	io_type="listio(2) sync write";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"listio(LC_WAIT, &req, 1) LO_WRITE, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -845,7 +845,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LC_START;
 	io_type="listio(2) async write";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"listio(LC_START, &req, 1) LO_WRITE, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -892,7 +892,7 @@ long wrd;	/* to allow future features, use zero for now */
     else if ( method & LIO_IO_SYNCV ) {
 	io_type="writev(2)";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"writev(%d, &iov, 1) nbyte:%d", fd, size);
 
         if ( Debug_level ) {
@@ -923,7 +923,7 @@ long wrd;	/* to allow future features, use zero for now */
     else if ( method & LIO_IO_SYNCP ) {
 	io_type="pwrite(2)";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"pwrite(%d, buf, %d, %lld)", fd, size, poffset);
 
         if ( Debug_level ) {
@@ -985,10 +985,10 @@ long wrd;	/* to allow future features, use zero for now */
      * check that async io was successful.
      * Note:  if the there was an system call failure, -errno
      * was returned and Errormsg should already have been updated.
-     * If amount i/o was different than size, Errormsg should already 
+     * If amount i/o was different than size, Errormsg should already
      * have been updated but the actual i/o size if returned.
      */
-    
+
 #ifdef CRAY
     ret=lio_check_asyncio(io_type, size, &status);
 #endif
@@ -1000,7 +1000,7 @@ long wrd;	/* to allow future features, use zero for now */
 }	/* end of lio_write_buffer */
 
 /***********************************************************************
- * Generic read function 
+ * Generic read function
  * This function can be used to do a read using read(2), reada(2),
  * aio_read(3), readv(2), pread(2),
  * or single stride listio(2)/lio_listio(3).
@@ -1012,12 +1012,12 @@ long wrd;	/* to allow future features, use zero for now */
  * wait method is: recall(2) for reada(2) and listio(2); aio_suspend(3) for
  * aio_read(3) and lio_listio(3).
  *
- * If multiple wait methods are specified, 
+ * If multiple wait methods are specified,
  * only one wait method will be used. The order is predetermined.
  *
  * If the call specifies a signal and one of the two signal wait methods,
  * a signal handler for the signal is set.  This will reset an already
- * set handler for this signal. 
+ * set handler for this signal.
  *
  * If the LIO_RANDOM method bit is set, this function will randomly
  * choose a io type and wait method from bits in the method argument.
@@ -1035,7 +1035,7 @@ long wrd;	/* to allow future features, use zero for now */
  *	If the size the system call say was written is different
  *	then what was asked to be written, errmsg is updated for
  *	this error condition.  The return value is still the amount
- *	the system call says was written.  
+ *	the system call says was written.
  *
  * (rrl 04/96)
  ***********************************************************************/
@@ -1057,7 +1057,7 @@ long wrd;	/* to allow future features, use zero for now */
 #endif
 #ifdef  CRAY
     struct listreq request;	/* Used when a listio is wanted */
-    struct iosw status, *statptr[1];  
+    struct iosw status, *statptr[1];
 #else
     /* for linux or sgi */
     struct iovec iov; /* iovec for readv(2) */
@@ -1196,7 +1196,7 @@ long wrd;	/* to allow future features, use zero for now */
      * system call failure.  If sync i/o, return the number of
      * bytes written/read.
      */
-     
+
     if ( (method & LIO_IO_SYNC) || (method & LIO_IO_TYPES) == 0 ){
 	/*
 	 * read(2) is used if LIO_IO_SYNC bit is set or not none
@@ -1290,7 +1290,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LC_WAIT;
 	io_type="listio(2) sync read";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"listio(LC_WAIT, &req, 1) LO_READ, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -1319,7 +1319,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LIO_WAIT;
 	io_type="lio_listio(3) sync read";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"lio_listio(LIO_WAIT, aiolist, 1, NULL) LIO_READ, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -1362,7 +1362,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LC_START;
 	io_type="listio(2) async read";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"listio(LC_START, &req, 1) LO_READ, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -1384,7 +1384,7 @@ long wrd;	/* to allow future features, use zero for now */
 	listio_cmd=LIO_NOWAIT;
 	io_type="lio_listio(3) async read";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"lio_listio(LIO_NOWAIT, aiolist, 1, NULL) LIO_READ, fd:%d, nbyte:%d",
                 fd, size);
 
@@ -1409,7 +1409,7 @@ long wrd;	/* to allow future features, use zero for now */
     else if ( method & LIO_IO_SYNCV ) {
 	io_type="readv(2)";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"readv(%d, &iov, 1) nbyte:%d", fd, size);
 
         if ( Debug_level ) {
@@ -1440,7 +1440,7 @@ long wrd;	/* to allow future features, use zero for now */
     else if ( method & LIO_IO_SYNCP ) {
 	io_type="pread(2)";
 
-	sprintf(Lio_SysCall, 
+	sprintf(Lio_SysCall,
 		"pread(%d, buf, %d, %lld)", fd, size, poffset);
 
         if ( Debug_level ) {
@@ -1503,10 +1503,10 @@ long wrd;	/* to allow future features, use zero for now */
      * check that async io was successful.
      * Note:  if the there was an system call failure, -errno
      * was returned and Errormsg should already have been updated.
-     * If amount i/o was different than size, Errormsg should already 
+     * If amount i/o was different than size, Errormsg should already
      * have been updated but the actual i/o size if returned.
      */
-    
+
 #ifdef CRAY
     ret=lio_check_asyncio(io_type, size, &status);
 #endif
@@ -1655,13 +1655,13 @@ lio_wait4asyncio(int method, int fd, aiocb_t *aiocbp)
     int cnt;
 #ifdef sgi
     int ret;
-    const aiocb_t *aioary[1]; 
+    const aiocb_t *aioary[1];
 #endif
 
     if ( (method & LIO_WAIT_RECALL)
 #ifdef sgi
-	|| (method & LIO_WAIT_CBSUSPEND) 
-	|| (method & LIO_WAIT_SIGSUSPEND) 
+	|| (method & LIO_WAIT_CBSUSPEND)
+	|| (method & LIO_WAIT_SIGSUSPEND)
 #endif
 	|| ((method & LIO_WAIT_TYPES) == 0) ){
 	/*
@@ -1718,12 +1718,12 @@ lio_wait4asyncio(int method, int fd, aiocb_t *aiocbp)
             printf("DEBUG %s/%d: wait method : active\n", __FILE__, __LINE__);
 #ifdef CRAY
         sigon();
-	/* 
+	/*
          * loop until sw_flag, sw_count or sw_error field elements
 	 * change to non-zero.
  	 */
         cnt=0;
-        while ( (*statptr)->sw_flag == 0 && 
+        while ( (*statptr)->sw_flag == 0 &&
 		(*statptr)->sw_count == 0 &&
 		(*statptr)->sw_error == 0 ) {
 	   cnt++;
@@ -1814,7 +1814,7 @@ lio_wait4asyncio(int method, int fd, aiocb_t *aiocbp)
 /***********************************************************************
  * The following code is provided as unit test.
  * Just define add "-DUNIT_TEST=1" to the cc line.
- * 
+ *
  * (rrl 04/96)
  ***********************************************************************/
 struct unit_info_t {
diff --git a/test/mxc_pmic_test/lib/tst_kvercmp.c b/test/mxc_pmic_test/lib/tst_kvercmp.c
index 3690044..d5d931e 100644
--- a/test/mxc_pmic_test/lib/tst_kvercmp.c
+++ b/test/mxc_pmic_test/lib/tst_kvercmp.c
@@ -16,9 +16,9 @@
  *   along with this program;  if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
- 
+
 /*
- * 
+ *
  *    AUTHOR
  *    	Paul Larson <plars@linuxtestproject.org>
  *
@@ -41,7 +41,7 @@ void get_kver(int *k1, int *k2, int *k3)
 	struct utsname uval;
 	char *kver;
 	char *r1, *r2, *r3;
-	
+
 	uname(&uval);
 	kver = uval.release;
 	r1 = strsep(&kver, ".");
diff --git a/test/mxc_pmic_test/lib/tst_res.c b/test/mxc_pmic_test/lib/tst_res.c
index 0550b23..ace2583 100644
--- a/test/mxc_pmic_test/lib/tst_res.c
+++ b/test/mxc_pmic_test/lib/tst_res.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
@@ -420,7 +420,7 @@ tst_print(char *tcid, int tnum, int trange, int ttype, char *tmesg)
    /*
     * Save the test result type by ORing ttype into the current exit
     * value (used by tst_exit()).  This is already done in tst_res(), but
-    * is also done here to catch internal warnings.  For internal warnings, 
+    * is also done here to catch internal warnings.  For internal warnings,
     * tst_print() is called directly with a case of TWARN.
     */
    T_exitval |= ttype;
@@ -827,7 +827,7 @@ cat_file(char *filename)
 
    /*
     * While something to read, continue to read blocks.
-    * From fread(3) man page: 
+    * From fread(3) man page:
     *   If an error occurs, or the end-of-file is reached, the return
     *   value is zero.
     */
diff --git a/test/mxc_pmic_test/lib/tst_sig.c b/test/mxc_pmic_test/lib/tst_sig.c
index bcf27e4..0aa85c7 100644
--- a/test/mxc_pmic_test/lib/tst_sig.c
+++ b/test/mxc_pmic_test/lib/tst_sig.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
@@ -53,7 +53,7 @@
 
 		handler - a pointer to the unexpected signal handler to
 			be executed after an unexpected signal has been
-			detected.  If handler is set to DEF_HANDLER, a 
+			detected.  If handler is set to DEF_HANDLER, a
 			default handler is used.  This routine should be
 			declared as function returning an int.
 
@@ -61,7 +61,7 @@
 			by the unexpected signal handler before tst_exit is
 			called.  This parameter is set to NULL if no cleanup
 			routine is required.  An external variable, T_cleanup
-			is set so that other user-defined handlers have 
+			is set so that other user-defined handlers have
 			access to the cleanup routine.  This routine should be
 			declared as returning type void.
 
@@ -109,7 +109,7 @@ tst_sig(int fork_flag, void (*handler)(), void (*cleanup)())
 		/* use default handler */
 		handler = def_handler;
 	}
-  
+
 	/*
 	 * now loop through all signals and set the handlers
 	 */
@@ -239,7 +239,7 @@ def_handler(int sig)
  *                    control over its personality.
  */
 static void (*tst_setup_signal( int sig, void (*handler)(int)))(int)
-{ 
+{
   struct sigaction my_act,old_act;
   int ret;
 
diff --git a/test/mxc_pmic_test/lib/tst_tmpdir.c b/test/mxc_pmic_test/lib/tst_tmpdir.c
index a1cc941..66a293f 100644
--- a/test/mxc_pmic_test/lib/tst_tmpdir.c
+++ b/test/mxc_pmic_test/lib/tst_tmpdir.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 
@@ -130,7 +130,7 @@ tst_tmpdir()
 #  define HAVE_MKDTEMP 0
 	int tfd;
 # endif
-#else 
+#else
 # define HAVE_MKDTEMP 0
 	int tfd;
 #endif
@@ -149,7 +149,7 @@ tst_tmpdir()
 #endif
 	} else {
 		/*
-		 * Create a template for the temporary directory.  Use the 
+		 * Create a template for the temporary directory.  Use the
 		 * environment variable TMPDIR if it is available, otherwise
 		 * use our default TEMPDIR.
 		 */
@@ -158,35 +158,35 @@ tst_tmpdir()
 		} else {
 			snprintf(template, PATH_MAX, "%s/%.3sXXXXXX", TEMPDIR, TCID);
 		}
-		
+
 
 #if HAVE_MKDTEMP
 		/*
 		 * Make the temporary directory in one shot using mkdtemp()
 		 */
 		if (mkdtemp(template) == NULL)
-			tst_brkm(TBROK, tmpdir_cleanup, 
-				"%s: mkdtemp(%s) failed; errno = %d: %s", 
+			tst_brkm(TBROK, tmpdir_cleanup,
+				"%s: mkdtemp(%s) failed; errno = %d: %s",
 				FN_NAME, template, errno, strerror(errno));
 		TESTDIR = strdup(template);
-#else 
+#else
 		/*
 		 * Make the template name, then the directory
 		 */
 		if (tfd = mkstemp(template) == -1)
-			tst_brkm(TBROK, tmpdir_cleanup, 
-				"%s: mkstemp(%s) failed; errno = %d: %s", 
+			tst_brkm(TBROK, tmpdir_cleanup,
+				"%s: mkstemp(%s) failed; errno = %d: %s",
 				FN_NAME, template, errno, strerror(errno));
 		close(tfd);
 		unlink(template);
 		TESTDIR = strdup(template);
 		if (mkdir(TESTDIR, DIR_MODE)) {
-			/* If we start failing with EEXIST, wrap this section in 
+			/* If we start failing with EEXIST, wrap this section in
 			 * a loop so we can try again.
 			 */
-			tst_brkm(TBROK, tmpdir_cleanup, 
-				"%s: mkdir(%s, %#o) failed; errno = %d: %s", 
-				FN_NAME, TESTDIR, DIR_MODE, errno, 
+			tst_brkm(TBROK, tmpdir_cleanup,
+				"%s: mkdir(%s, %#o) failed; errno = %d: %s",
+				FN_NAME, TESTDIR, DIR_MODE, errno,
 				strerror(errno));
 		}
 #endif
@@ -196,8 +196,8 @@ tst_tmpdir()
 		 * gid of the person running the tests.
 		 */
 		if ( chown(TESTDIR, -1, getgid()) == -1 )
-			tst_brkm(TBROK, tmpdir_cleanup, 
-				"chown(%s, -1, %d) failed; errno = %d: %s", 
+			tst_brkm(TBROK, tmpdir_cleanup,
+				"chown(%s, -1, %d) failed; errno = %d: %s",
 				TESTDIR, getgid(), errno, strerror(errno));
  	}
 
@@ -209,7 +209,7 @@ tst_tmpdir()
   	 * Change to the temporary directory.  If the chdir() fails, issue
    	 * TBROK messages for all test cases, attempt to remove the
 	 * directory (if it was created), and exit.  If the removal also
-	 * fails, also issue a TWARN message.   
+	 * fails, also issue a TWARN message.
 	 */
 	if ( chdir(TESTDIR) == -1 ) {
 		tst_brkm(TBROK, NULL, "%s: chdir(%s) failed; errno = %d: %s",
@@ -222,7 +222,7 @@ tst_tmpdir()
 
 		tmpdir_cleanup();
 	}
-	
+
 #if UNIT_TEST
 	printf("CWD is %s\n", getcwd((char *)NULL, PATH_MAX));
 #endif
@@ -241,7 +241,7 @@ tst_tmpdir()
  *               companion to tst_tmpdir().  If the TDIRECTORY
  *               environment variable is set, no cleanup will be
  *               attempted.
- */ 
+ */
 #undef   FN_NAME
 #define  FN_NAME  "tst_rmdir()"
 
@@ -265,7 +265,7 @@ tst_rmdir()
 #endif
       return;
    }
-   
+
    /*
     * Check that TESTDIR is not NULL.
     */
@@ -315,7 +315,7 @@ tst_rmdir()
       tst_resm(TWARN,
                "%s: chdir(%s) failed; errno = %d: %s\nAttempting to remove temp dir anyway",
                FN_NAME, parent_dir, errno, strerror(errno));
-   
+
    /*
     * Attempt to remove the "TESTDIR" directory, using rmobj().
     */
diff --git a/test/mxc_pmic_test/lib/write_log.c b/test/mxc_pmic_test/lib/write_log.c
index 7d034b0..52dc098 100644
--- a/test/mxc_pmic_test/lib/write_log.c
+++ b/test/mxc_pmic_test/lib/write_log.c
@@ -1,32 +1,32 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it would be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * Further, this software is distributed without any warranty that it is
  * free of the rightful claim of any third person regarding infringement
  * or the like.  Any license provided herein, whether implied or
  * otherwise, applies only to this software file.  Patent licenses, if
  * any, provided herein do not apply to combinations of this program with
  * other software, or any other product whatsoever.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write the Free Software Foundation, Inc., 59
  * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- * 
+ *
  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
  * Mountain View, CA  94043, or:
- * 
- * http://www.sgi.com 
- * 
- * For further information regarding this notice, see: 
- * 
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  */
 /*
@@ -45,7 +45,7 @@
  * The wlog_rec datatype is a structure which contains all the information
  * about a file write.  Examples include the file name, offset, length,
  * pattern, etc.  In addition there is a bit which is cleared/set based
- * on whether or not the write has been confirmed as complete.  This 
+ * on whether or not the write has been confirmed as complete.  This
  * allows the write logfile to contain information on writes which have
  * been initiated, but not yet completed (as in async io).
  *
@@ -152,7 +152,7 @@ int			mode;
 		wfile->w_afd = -1;
 		return -1;
 	}
-    
+
 	return 0;
 }
 
@@ -178,10 +178,10 @@ struct wlog_file	*wfile;
  * is so that we can record writes which are outstanding (with the w_done
  * bit in wrec cleared), but not completed, and then later update the
  * logfile when the write request completes (as with async io).  When
- * offset is >= 0, only the fixed length portion of the record is 
+ * offset is >= 0, only the fixed length portion of the record is
  * rewritten.  See text in write_log.h for details on the format of an
  * on-disk record.
- * 
+ *
  * The return value of the function is the byte offset in the logfile
  * where the record begins.
  *
@@ -221,7 +221,7 @@ long			offset;
 	 * its length onto the end so that wlog_scan_backward() will work.
 	 * Length is asumed to fit into 2 bytes.
 	 */
-	    
+
 	    wbuf[reclen] = reclen / 256;
 	    wbuf[reclen+1] = reclen % 256;
 	    reclen += 2;
@@ -232,7 +232,7 @@ long			offset;
 	    lseek(wfile->w_rfd, offset, SEEK_SET);
 	    write(wfile->w_rfd, wbuf, reclen);
     }
-    
+
     return offset;
 }
 
@@ -283,7 +283,7 @@ long			data;
 			offset -= sizeof(buf) - leftover;
 		}
 
-		/* 
+		/*
 		 * Move to the proper file offset, and read into buf
 		 */
 
@@ -406,13 +406,13 @@ int             flag;
 		file = buf + sizeof(struct wlog_rec_disk);
 		host = file + wrecd->w_pathlen;
 		pattern = host + wrecd->w_hostlen;
-	
+
 		if (wrecd->w_pathlen > 0)
 			memcpy(file, wrec->w_path, wrecd->w_pathlen);
-	
+
 		if (wrecd->w_hostlen > 0)
 			memcpy(host, wrec->w_host, wrecd->w_hostlen);
-	
+
 		if (wrecd->w_patternlen > 0)
 			memcpy(pattern, wrec->w_pattern, wrecd->w_patternlen);
 
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/Makefile b/test/mxc_pmic_test/pmic_testapp_adc/Makefile
index 9bb22e3..7d40268 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/Makefile
+++ b/test/mxc_pmic_test/pmic_testapp_adc/Makefile
@@ -8,7 +8,7 @@ OBJS=$(patsubst %.c,%.o,$(SRCS))
 all : $(TARGET)
 	mkdir -p $(OBJDIR)
 	cp -f $(TARGET) $(OBJDIR)
-        
+
 $(TARGET): $(OBJS)
 	$(CC) $(OBJS) $(LOADLIBES) -o $@
 
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_main.c b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_main.c
index 4db64ea..23dd2b2 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_main.c
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_main.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -36,7 +36,7 @@ extern "C"{
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 #include "usctest.h"
@@ -107,7 +107,7 @@ void help(void);
 
 @param  Input :      None.
         Output:      None.
-  
+
 @return Nothing
 */
 /*============================================================================*/
@@ -117,17 +117,17 @@ void cleanup(void)
 
         if(!strcmp(ch_test_case,TEST_CASE_TS))
         {
-                VT_rv = VT_pmic_adc_TS_cleanup(); 
+                VT_rv = VT_pmic_adc_TS_cleanup();
         } else if (!strcmp(ch_test_case,TEST_CASE_R))
         {
-                VT_rv = VT_pmic_adc_read_cleanup(); 
+                VT_rv = VT_pmic_adc_read_cleanup();
         } else if (!strcmp(ch_test_case,TEST_CASE_CONV))
         {
-                VT_rv = VT_pmic_adc_convert_cleanup(); 
+                VT_rv = VT_pmic_adc_convert_cleanup();
         } else if (!strcmp(ch_test_case,TEST_CASE_MON))
         {
-                VT_rv = VT_pmic_adc_monitor_cleanup(); 
-        }  else 
+                VT_rv = VT_pmic_adc_monitor_cleanup();
+        }  else
 
         if ((fd_adc > 0) & (close(fd_adc) < 0))
         {
@@ -138,7 +138,7 @@ void cleanup(void)
 
         if (VT_rv != TPASS)
         {
-                tst_resm(TWARN, "VT_cleanup() Failed : error code = %d\n", 
+                tst_resm(TWARN, "VT_cleanup() Failed : error code = %d\n",
         		VT_rv);
         }
 
@@ -158,7 +158,7 @@ void cleanup(void)
 
 @param  Input :      None.
         Output:      None.
-  
+
 @return On failure - Exits by calling cleanup().
         On success - returns 0.
 */
@@ -174,17 +174,17 @@ void setup(void)
 
         if(!strcmp(ch_test_case,TEST_CASE_TS))
         {
-                VT_rv = VT_pmic_adc_TS_setup(); 
+                VT_rv = VT_pmic_adc_TS_setup();
         } else if (!strcmp(ch_test_case,TEST_CASE_R))
         {
-                VT_rv = VT_pmic_adc_read_setup(); 
+                VT_rv = VT_pmic_adc_read_setup();
         } else if (!strcmp(ch_test_case,TEST_CASE_CONV))
         {
-                VT_rv = VT_pmic_adc_convert_setup(); 
+                VT_rv = VT_pmic_adc_convert_setup();
         } else if (!strcmp(ch_test_case,TEST_CASE_MON))
         {
-                VT_rv = VT_pmic_adc_monitor_setup(); 
-        } else 
+                VT_rv = VT_pmic_adc_monitor_setup();
+        } else
         {
                 tst_brkm(TBROK , tst_exit, "Not correct parametres");
         }
@@ -212,7 +212,7 @@ void setup(void)
                 TS - Test touch screen and convert function
                 read - Test read interface
                 CONV - Test touch screen and convert function correctness
-  
+
 @return On failure - Exits by calling cleanup().
         On success - exits with 0 exit value.
 */
@@ -220,18 +220,18 @@ void setup(void)
 int main(int argc, char **argv)
 {
         int VT_rv = TFAIL;
-        
+
         /* parse options. */
         int tflag=0;                 /* binary flags: opt or not */
         char *msg;
-        
+
         option_t options[] =
         {
                 { "T:", &tflag, &ch_test_case  },/* Test case */
-                { NULL, NULL, NULL }             /* NULL required to 
+                { NULL, NULL, NULL }             /* NULL required to
                                                     end array */
         };
-        
+
         if ( (msg=parse_opts(argc, argv, options, &help)) != NULL )
         {
                 tst_brkm(TBROK, tst_exit, "Not correct params\n", TCID);
@@ -239,28 +239,28 @@ int main(int argc, char **argv)
 
         /* Test Case Body. */
         if(tflag) {
-                /* Print test Assertion using tst_resm() function 
+                /* Print test Assertion using tst_resm() function
                    with argument TINFO. */
-                tst_resm(TINFO, "Testing if %d test case is OK\n", 
+                tst_resm(TINFO, "Testing if %d test case is OK\n",
         		TCID,ch_test_case);
                 setup();
                 if(!strcmp(ch_test_case,TEST_CASE_TS))
                 {
-                        VT_rv = VT_pmic_adc_test_TS(); 
+                        VT_rv = VT_pmic_adc_test_TS();
                 } else if (!strcmp(ch_test_case,TEST_CASE_R))
                 {
-                        VT_rv = VT_pmic_adc_test_read(); 
+                        VT_rv = VT_pmic_adc_test_read();
                 } else if (!strcmp(ch_test_case,TEST_CASE_CONV))
                 {
-                        VT_rv = VT_pmic_adc_test_convert(); 
+                        VT_rv = VT_pmic_adc_test_convert();
                 } else if (!strcmp(ch_test_case,TEST_CASE_MON))
                 {
-                        VT_rv = VT_pmic_adc_test_monitor(); 
+                        VT_rv = VT_pmic_adc_test_monitor();
                 }
 
                 if(VT_rv == TPASS)
                 {
-                        tst_resm(TPASS, "%d test case worked as expected\n", 
+                        tst_resm(TPASS, "%d test case worked as expected\n",
         		TCID,ch_test_case);
                 } else
                 {
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test.h b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test.h
index dd36ded..09e2411 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test.h
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test.h
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -35,7 +35,7 @@ extern "C"{
 #include <stdio.h>	/* sscanf() & perror() */
 #include <stdlib.h>	/* atoi() */
 
-#include <asm/arch/pmic_external.h>   
+#include <asm/arch/pmic_external.h>
 #include <asm/arch/pmic_adc.h>
 
 /*==============================================================================
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.c b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.c
index b2f6e22..d8b402d 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.c
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -25,7 +25,7 @@ extern "C"{
 ==============================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 
@@ -74,7 +74,7 @@ extern int fd_adc;
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -82,9 +82,9 @@ extern int fd_adc;
 int VT_pmic_adc_TS_setup(void)
 {
     int rv = TFAIL;
-    
+
     rv=TPASS;
-    
+
     return rv;
 }
 
@@ -94,7 +94,7 @@ int VT_pmic_adc_TS_setup(void)
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -102,9 +102,9 @@ int VT_pmic_adc_TS_setup(void)
 int VT_pmic_adc_TS_cleanup(void)
 {
     int rv = TFAIL;
-    
+
     rv=TPASS;
-    
+
     return rv;
 }
 
@@ -114,7 +114,7 @@ int VT_pmic_adc_TS_cleanup(void)
 @brief  PMIC test scenario TS function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -130,9 +130,9 @@ int VT_pmic_adc_test_TS(void)
         }
         printf(("Value of X position is %d\n"), (int) ts_value.x_position);
         printf(("Value of Y position is %d\n"), (int) ts_value.y_position);
-        printf(("Value of contact resistance is %d\n"), 
+        printf(("Value of contact resistance is %d\n"),
                 (int) ts_value.contact_resistance);
-        
+
         if ((ts_value.x_position < 0) | (ts_value.x_position > 1000) |
                 (ts_value.y_position < 0) | (ts_value.y_position > 1000))
         {
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.h b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.h
index 35b4909..fbc23e3 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.h
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_TS.h
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.c b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.c
index f879132..0632bab 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.c
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -25,7 +25,7 @@ extern "C"{
 ==============================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 
@@ -46,7 +46,7 @@ extern int fd_adc;
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -64,7 +64,7 @@ int VT_pmic_adc_convert_setup(void)
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -82,7 +82,7 @@ int VT_pmic_adc_convert_cleanup(void)
 @brief  PMIC test scenario convert function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -113,7 +113,7 @@ int VT_pmic_adc_test_convert(void)
                 printf(("Convert 8x channel %d - %d: %d\n"),option,i,
         		adc_convert_param.result[i]);
         }
-        if (ioctl(fd_adc, PMIC_ADC_CONVERT_MULTICHANNEL, 
+        if (ioctl(fd_adc, PMIC_ADC_CONVERT_MULTICHANNEL,
         		&adc_convert_param) != 0) {
                 printf(("Error in ADC convert_multichannel test\n"));
                 return TFAIL;
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.h b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.h
index b57ea93..8147505 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.h
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_convert.h
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.c b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.c
index 86d479f..1dc3ad1 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.c
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -25,7 +25,7 @@ extern "C"{
 ==============================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 
@@ -46,7 +46,7 @@ extern int fd_adc;
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -64,7 +64,7 @@ int VT_pmic_adc_monitor_setup(void)
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -88,7 +88,7 @@ static void callback_wcomp(void)
 @brief  PMIC test scenario monitor functionG
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -96,10 +96,10 @@ static void callback_wcomp(void)
 int VT_pmic_adc_test_monitor(void)
 {
         t_adc_comp_param mon_param;
-        
+
         mon_param.wlow = 3;
         mon_param.whigh = 60;
-        mon_param.channel = BATTERY_CURRENT; 
+        mon_param.channel = BATTERY_CURRENT;
         mon_param.callback = (t_comparator_cb*)callback_wcomp;
 
         printf(("Test monitoring ADC functions\n"));
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.h b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.h
index 9d38f6c..9f3a547 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.h
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_monitor.h
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.c b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.c
index 6f6caf2..5b30284 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.c
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_adc_test_read.c 
+ * @file   pmic_adc_test_read.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -25,7 +25,7 @@ extern "C"{
 ==============================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 
@@ -73,7 +73,7 @@ extern int fd_adc;
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -81,9 +81,9 @@ extern int fd_adc;
 int VT_pmic_adc_read_setup(void)
 {
     int rv = TFAIL;
-    
+
     rv=TPASS;
-    
+
     return rv;
 }
 
@@ -93,7 +93,7 @@ int VT_pmic_adc_read_setup(void)
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -101,9 +101,9 @@ int VT_pmic_adc_read_setup(void)
 int VT_pmic_adc_read_cleanup(void)
 {
     int rv = TFAIL;
-    
+
     rv=TPASS;
-    
+
     return rv;
 }
 
@@ -113,7 +113,7 @@ int VT_pmic_adc_read_cleanup(void)
 @brief  PMIC Digitizer test scenario read function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -145,7 +145,7 @@ int VT_pmic_adc_test_read(void)
                 trv = read(fd_adc, buffer, new_count);
                 x = *(buffer+1);
                 y = *(buffer+2);
-                printf("Values:\t%d:%d:%d:%d\tReturn:%d\n", *(buffer), x, 
+                printf("Values:\t%d:%d:%d:%d\tReturn:%d\n", *(buffer), x,
         		y, *(buffer+3), trv);
                 if (trv < 0)
                 {
diff --git a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.h b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.h
index 4e3ce6b..292d40c 100644
--- a/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.h
+++ b/test/mxc_pmic_test/pmic_testapp_adc/pmic_adc_test_read.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_adc_test_read.h 
+ * @file   pmic_adc_test_read.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/pmic_testapp_battery/Makefile b/test/mxc_pmic_test/pmic_testapp_battery/Makefile
index 770c8bd..9f3144f 100644
--- a/test/mxc_pmic_test/pmic_testapp_battery/Makefile
+++ b/test/mxc_pmic_test/pmic_testapp_battery/Makefile
@@ -8,7 +8,7 @@ OBJS=$(patsubst %.c,%.o,$(SRCS))
 all : $(TARGET)
 	mkdir -p $(OBJDIR)
 	cp -f $(TARGET) $(OBJDIR)
-        
+
 $(TARGET): $(OBJS)
 	$(CC) $(OBJS) $(LOADLIBES) -o $@
 
diff --git a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_main.c b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_main.c
index b384887..9fbcac1 100644
--- a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_main.c
+++ b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_main.c
@@ -1,7 +1,7 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
+
 /*
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -67,7 +67,7 @@ extern "C" {
 @brief  This function assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -87,7 +87,7 @@ extern "C" {
 @brief  This function assumes the setup condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -112,7 +112,7 @@ extern "C" {
 @param  Input :      argc - number of command line parameters.
         Output:      **argv - pointer to the array of the command
         		      line parameters.
-  
+
 @return On failure - Exits by calling cleanup().
         On success - exits with 0 exit value.
 */
diff --git a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.c b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.c
index 162c1e1..5a0fa64 100644
--- a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.c
+++ b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.c
@@ -1,7 +1,7 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
+
 /*
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -46,7 +46,7 @@ extern int fd;
 
 @param  switch_fct
         Number test case.
-  
+
 @return On success - return PMIC_SUCCESS
         On failure - return the error code
 */
@@ -89,7 +89,7 @@ int VT_pmic_batt_test(int switch_fct)
 						 "(main charger). Error code: %d",
 						 status);
 				}
-				
+
 				tset1.c_voltage = 0;
 				tset1.c_current = 0;
 
diff --git a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.h b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.h
index bd193cc..54f2131 100644
--- a/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.h
+++ b/test/mxc_pmic_test/pmic_testapp_battery/pmic_battery_test.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_battery_test.h 
+ * @file   pmic_battery_test.h
  * @brief  Test scenario C header PMIC.
  */
 
@@ -43,7 +43,7 @@ extern "C"{
 /*==============================================================================
                                        DEFINES AND MACROS
 ==============================================================================*/
-#define	PMIC_BATT_DEV "pmic_battery" 
+#define	PMIC_BATT_DEV "pmic_battery"
 
 #if !defined(TRUE) && !defined(FALSE)
 #define TRUE  1
@@ -59,4 +59,4 @@ int VT_pmic_batt_test(int switch_fct);
 }
 #endif
 
-#endif 
+#endif
diff --git a/test/mxc_pmic_test/pmic_testapp_light/pmic_testapp_light.c b/test/mxc_pmic_test/pmic_testapp_light/pmic_testapp_light.c
index ce35a1f..e0416c3 100644
--- a/test/mxc_pmic_test/pmic_testapp_light/pmic_testapp_light.c
+++ b/test/mxc_pmic_test/pmic_testapp_light/pmic_testapp_light.c
@@ -1,7 +1,7 @@
 
 /*!
  * @file pmic_testapp_light.c
- * @brief This is the main file of PMIC tests for Light and Backlight driver. 
+ * @brief This is the main file of PMIC tests for Light and Backlight driver.
  *
  * @ingroup MC13783_LIGHT
  */
diff --git a/test/mxc_pmic_test/pmic_testapp_rtc/Makefile b/test/mxc_pmic_test/pmic_testapp_rtc/Makefile
index 9d1c297..4f290fa 100644
--- a/test/mxc_pmic_test/pmic_testapp_rtc/Makefile
+++ b/test/mxc_pmic_test/pmic_testapp_rtc/Makefile
@@ -8,7 +8,7 @@ OBJS=$(patsubst %.c,%.o,$(SRCS))
 all : $(TARGET)
 	mkdir -p $(OBJDIR)
 	cp -f $(TARGET) $(OBJDIR)
-        
+
 $(TARGET): $(OBJS)
 	$(CC) $(OBJS) $(LOADLIBES) -o $@
 
diff --git a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_main.c b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_main.c
index dfd972a..41c3c75 100644
--- a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_main.c
+++ b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_main.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_rtc_main.c 
+ * @file   pmic_rtc_main.c
  * @brief  PMIC RTC test main source file.
  */
 
@@ -36,7 +36,7 @@ extern "C"{
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-    
+
 /* Harness Specific Include Files. */
 #include "test.h"
 #include "usctest.h"
@@ -106,7 +106,7 @@ void cleanup(void);
                 -l - Number of iteration
                 -v - Prints verbose output
                 -V - Prints the version number
-  
+
 @return On failure - Exits by calling cleanup().
         On success - exits with 0 exit value.
 */
@@ -121,41 +121,41 @@ void cleanup(void)
 int main(int argc, char **argv)
 {
         int VT_rv = TFAIL;
-        
+
         /* parse options. */
         int tflag=0;                 /* binary flags: opt or not */
         char *ch_test_case;  /* option arguments */
         char *msg;
-        
+
         option_t options[] = {
                 { "T:", &tflag, &ch_test_case  },       /* argument required */
                 { NULL, NULL, NULL }           /* NULL required to end array */
         };
-        
+
         if ( (msg=parse_opts(argc, argv, options, &help)) != NULL ) {
-                tst_brkm(TBROK , cleanup, 
+                tst_brkm(TBROK , cleanup,
                         "%s test case did NOT work as expected\n", VT_rv);
         }
-        
+
         /* Test Case Body. */
         if(tflag) {
-                /* Print test Assertion using tst_resm() function with 
+                /* Print test Assertion using tst_resm() function with
                    argument TINFO. */
                 tst_resm(TINFO, "Testing if %s_%s test case is OK\n", TCID,
                         ch_test_case);
-        
+
                 if(!strcmp(ch_test_case,TEST_CASE1)) {
-                        VT_rv = VT_pmic_rtc_test(0); 
+                        VT_rv = VT_pmic_rtc_test(0);
                 } else if(!strcmp(ch_test_case,TEST_CASE2)) {
-                        VT_rv = VT_pmic_rtc_test(1); 
+                        VT_rv = VT_pmic_rtc_test(1);
                 } else if(!strcmp(ch_test_case,TEST_CASE3)) {
-                        VT_rv = VT_pmic_rtc_test(2); 
+                        VT_rv = VT_pmic_rtc_test(2);
                 } else if(!strcmp(ch_test_case,TEST_CASE4)) {
-                        VT_rv = VT_pmic_rtc_test(3); 
+                        VT_rv = VT_pmic_rtc_test(3);
                 } else if(!strcmp(ch_test_case,TEST_CASE5)) {
-                        VT_rv = VT_pmic_rtc_test(4); 
+                        VT_rv = VT_pmic_rtc_test(4);
                 }
-                    
+
                 if(VT_rv == TPASS) {
                         tst_resm(TPASS, "%s_%s test case worked as expected\n",
                                 TCID,ch_test_case);
@@ -164,7 +164,7 @@ int main(int argc, char **argv)
                                 "expected\n", TCID,ch_test_case);
                 }
         }
-        
+
         if(tflag==0) {
                 /* VTE : print results and exit test scenario */
                 help();
diff --git a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.c b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.c
index f8c64f9..9e62460 100644
--- a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.c
+++ b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_rtc_test.c 
+ * @file   pmic_rtc_test.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -23,7 +23,7 @@ extern "C"{
 /*==============================================================================
                                         INCLUDE FILES
 ==============================================================================*/
-    
+
 /* Harness Specific Include Files. */
 
 #include "test.h"
@@ -45,25 +45,25 @@ extern "C"{
                                        LOCAL CONSTANTS
 ==============================================================================*/
 
-char *jours[]= {"Sunday", 
-                "monday", 
-                "tuesday", 
-                "Wednesday", 
-                "Thursday", 
-                "Friday", 
+char *jours[]= {"Sunday",
+                "monday",
+                "tuesday",
+                "Wednesday",
+                "Thursday",
+                "Friday",
                 "Saturday"};
 
-char *mois[]= {"January", 
-               "February", 
-               "March", 
-               "April", 
-               "May", 
+char *mois[]= {"January",
+               "February",
+               "March",
+               "April",
+               "May",
                "June",
-               "July", 
-               "August", 
-               "September", 
-               "October", 
-               "November", 
+               "July",
+               "August",
+               "September",
+               "October",
+               "November",
                "December"};
 
 /*==============================================================================
@@ -94,7 +94,7 @@ char *mois[]= {"January",
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -102,9 +102,9 @@ char *mois[]= {"January",
 int VT_pmic_rtc_test_setup(void)
 {
     int rv = TFAIL;
-    
+
     rv=TPASS;
-    
+
     return rv;
 }
 
@@ -114,7 +114,7 @@ int VT_pmic_rtc_test_setup(void)
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -130,7 +130,7 @@ void VT_pmic_rtc_test_cleanup(void)
 @brief  PMIC test scenario X function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -143,170 +143,170 @@ int VT_pmic_rtc_test(int switch_fct)
         struct tm *m;
         int VT_rv = TFAIL;
         struct pollfd fds;
-        
+
         fd = open(PMIC_DEVICE_RTC, O_RDWR);
         if (fd < 0) {
-                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                         "Unable to open %s\n", VT_rv);
         }
-        
+
         if (switch_fct == 0) {
                 tst_resm(TINFO, "Get PMIC time\n");
                 ret = ioctl(fd, PMIC_RTC_GET_TIME, &pmic_time_read);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                  "Error in rtc test\n", VT_rv);
                 }
-                
+
                 m= localtime(&pmic_time_read.tv_sec);
-                
+
                 tst_resm(TINFO, "%ld seconds between the current time\n\t\t\t"
-                        "and midnight, January 1, 1970 UTC", 
+                        "and midnight, January 1, 1970 UTC",
                         pmic_time_read.tv_sec);
                 tst_resm(TINFO, "The PMIC time is : %02d/%02d/%02d %02d:%02d:"
-                        "%02d",m->tm_mon + 1,m->tm_mday, m->tm_year % 100, 
+                        "%02d",m->tm_mon + 1,m->tm_mday, m->tm_year % 100,
                         m->tm_hour, m->tm_min, m->tm_sec);
-                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year", 
-                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday, 
-                        m->tm_year + 1900, m->tm_yday);        
-               
+                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year",
+                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday,
+                        m->tm_year + 1900, m->tm_yday);
+
         }
-        
+
         if (switch_fct == 1) {
                 time(&maintenant);
                 pmic_time.tv_sec = maintenant;
-                
+
                 tst_resm(TINFO, "%ld seconds between the current time and "
                         "midnight, January 1, 1970 UTC\n", maintenant);
-                
+
                 m= localtime(&maintenant);
-                
+
                 tst_resm(TINFO, "The date and time is : %02d/%02d/%02d %02d:"
-                               "%02d:%02d\n",m->tm_mon + 1,m->tm_mday, 
+                               "%02d:%02d\n",m->tm_mon + 1,m->tm_mday,
                         m->tm_year % 100, m->tm_hour, m->tm_min, m->tm_sec);
-                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year\n", 
-                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday, 
-                        m->tm_year + 1900, m->tm_yday);        
-                
+                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year\n",
+                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday,
+                        m->tm_year + 1900, m->tm_yday);
+
                 tst_resm(TINFO, "Set PMIC time\n");
                 ret = ioctl(fd, PMIC_RTC_SET_TIME, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                         "Error in rtc test\n", VT_rv);
-                        
+
                 }
-                
+
                 tst_resm(TINFO, "Get PMIC time\n");
                 ret = ioctl(fd, PMIC_RTC_GET_TIME, &pmic_time_read);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                  "Error in rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "Return value of PMIC time is %ld\n",
                         pmic_time_read.tv_sec);
-                
+
                 if (pmic_time.tv_sec > pmic_time_read.tv_sec) {
                         if ((pmic_time.tv_sec+5) < pmic_time_read.tv_sec) {
-                                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                         "Error in RTC test\n", VT_rv);
                         }
-                }      
-        }      
+                }
+        }
         if (switch_fct == 2) {
                 time(&maintenant);
                 pmic_time.tv_sec = maintenant;
-                
+
                 tst_resm(TINFO, "%ld seconds between the current time and "
                         "midnight, January 1, 1970 UTC\n", maintenant);
-                
+
                 m= localtime(&maintenant);
-                
+
                 tst_resm(TINFO, "The date and time is : %02d/%02d/%02d %02d:"
-                        "%02d:%02d\n",m->tm_mon + 1,m->tm_mday, 
+                        "%02d:%02d\n",m->tm_mon + 1,m->tm_mday,
                         m->tm_year % 100, m->tm_hour, m->tm_min, m->tm_sec);
-                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year\n", 
-                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday, 
-                        m->tm_year + 1900, m->tm_yday);        
-                
+                tst_resm(TINFO, "%s, %s %d, %04d %de day of the year\n",
+                        jours[m->tm_wday], mois[m->tm_mon], m->tm_mday,
+                        m->tm_year + 1900, m->tm_yday);
+
                 tst_resm(TINFO, "Set PMIC Alarm time\n");
                 ret = ioctl(fd, PMIC_RTC_SET_ALARM, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "Get PMIC Alarm time\n");
                 ret = ioctl(fd, PMIC_RTC_GET_ALARM, &pmic_time_read);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "Return value of PMIC Alarm time is %ld\n",
                         pmic_time_read.tv_sec);
-                
+
                 if (pmic_time.tv_sec != pmic_time_read.tv_sec) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in alarm rtc test\n", VT_rv);
-                }      
+                }
         }
-        
+
         if (switch_fct == 3) {
                 time(&maintenant);
                 pmic_time.tv_sec = maintenant;
-                
+
                 tst_resm(TINFO, "Test PMIC Alarm event\n");
-                
-                
+
+
                 tst_resm(TINFO, "Set PMIC time to local time\n");
                 ret = ioctl(fd, PMIC_RTC_SET_TIME, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
-                tst_resm(TINFO, 
+
+                tst_resm(TINFO,
                         "Set PMIC Alarm time to local time +10 second\n");
                 pmic_time.tv_sec = pmic_time.tv_sec + 10;
                 ret = ioctl(fd, PMIC_RTC_SET_ALARM, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "Wait Alarm event...\n");
                 ret = ioctl(fd, PMIC_RTC_WAIT_ALARM, NULL);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in IT rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "*** Alarm event DONE ***\n");
-                
+
         }
         if (switch_fct == 4) {
                 time(&maintenant);
                 pmic_time.tv_sec = maintenant;
-                
+
                 tst_resm(TINFO, "Test PMIC Alarm event\n");
-                
+
                 tst_resm(TINFO, "Set PMIC time to local time\n");
                 ret = ioctl(fd, PMIC_RTC_SET_TIME, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
-                tst_resm(TINFO, 
+
+                tst_resm(TINFO,
                         "Set PMIC Alarm time to local time +10 second\n");
                 pmic_time.tv_sec = pmic_time.tv_sec + 10;
                 ret = ioctl(fd, PMIC_RTC_SET_ALARM, &pmic_time);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in rtc test\n", VT_rv);
                 }
-                
+
                 fds.fd = fd;
                 fds.events = POLLIN;
                 fds.revents = 0;
@@ -318,30 +318,30 @@ int VT_pmic_rtc_test(int switch_fct)
                 tst_resm(TINFO, "Register Alarm\n");
                 ret = ioctl(fd, PMIC_RTC_ALARM_REGISTER,0);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in IT rtc test\n", VT_rv);
                 }
-                
+
                 tst_resm(TINFO, "Call poll until alarm\n");
-                
+
                 do {
                         ret = poll(&fds,1,0);
                 } while (ret == 0);
 
-                
+
                 tst_resm(TINFO, "Unregister Alarm\n");
                 ret = ioctl(fd, PMIC_RTC_ALARM_UNREGISTER,0);
                 if (ret != 0) {
-                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                        tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                                 "Error in IT rtc test\n", VT_rv);
                 }
-                
+
         }
-        
+
         ret = close(fd);
         if (ret < 0) {
                 tst_resm(TINFO, "Unable to close file descriptor %d", fd);
-                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup, 
+                tst_brkm(TBROK , VT_pmic_rtc_test_cleanup,
                         "Error in rtc test\n", VT_rv);
         }
         return TPASS;
diff --git a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.h b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.h
index 9d4d93a..f70bc2d 100644
--- a/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.h
+++ b/test/mxc_pmic_test/pmic_testapp_rtc/pmic_rtc_test.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   pmic_rtc_test.h 
+ * @file   pmic_rtc_test.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_main.c b/test/mxc_pmic_test/protocol_tests/mc13783_main.c
index 2d987ba..4a93c8b 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_main.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_main.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -99,7 +99,7 @@ extern "C" {
 
 @param  Input :      None.
         Output:      None.
-  
+
 @return Nothing
 */
 /*============================================================================*/
@@ -133,7 +133,7 @@ extern "C" {
 
 @param  Input :      None.
         Output:      None.
-  
+
 @return On failure - Exits by calling cleanup().
         On success - returns 0.
 */
@@ -221,7 +221,7 @@ extern "C" {
 			{"U:", &uflag, &ch_event_num},	/* Unsubscribe event opt */
 			{"T:", &tflag, &ch_test_case},	/* Execute test case */
 			{"v", &verbose_flag, NULL},	/* Verbose flag */
-			{NULL, NULL, NULL}	/* NULL required to 
+			{NULL, NULL, NULL}	/* NULL required to
 						   end array */
 		};
 
@@ -251,7 +251,7 @@ extern "C" {
 		/* Test Case Body. */
 
 		if (tflag) {
-			/* Print test Assertion using tst_resm() function 
+			/* Print test Assertion using tst_resm() function
 			   with argument TINFO. */
 			func = &VT_mc13783_exec_test_case;
 			params = (void *)ch_test_case;
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test.c b/test/mxc_pmic_test/protocol_tests/mc13783_test.c
index e9a7dc3..a5fa172 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test.c
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
@@ -77,11 +77,11 @@ extern "C" {
 /**
 @brief  open MC13783, perform operation on it and then close it.
 
-@param  Input :		params - pointer to opt_params structure, 
-                        operation - performing operation 
+@param  Input :		params - pointer to opt_params structure,
+                        operation - performing operation
                         	(CMD_READ, CMD_WRITE, CMD_SUB, CMD_UNSUB)
                         val1 - reg number if operation is CMD_READ or CMD_WRITE,
-                                reg number if operation is CMD_READ 
+                                reg number if operation is CMD_READ
                                 or CMD_WRITE,
                         *val2 - writing reg value in case of CMD_WRITE operation
         Output:         *val2 - return reg value in case of CMD_READ operation
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test.h b/test/mxc_pmic_test/protocol_tests/mc13783_test.h
index 3cc1dc4..6431dec 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test.h
@@ -1,14 +1,14 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.c
index 77000c3..34a4ff3 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_CA.c 
+ * @file   mc13783_test_CA.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -83,7 +83,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -102,7 +102,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -121,7 +121,7 @@ extern "C" {
 @brief  MC13783 test scenario Concurrent Access
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.h
index 9370cf7..399ab8f 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_CA.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_CA.h 
+ * @file   mc13783_test_CA.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_D.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_D.c
index df6aada..e5fd0d1 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_D.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_D.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_D.c 
+ * @file   mc13783_test_D.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -78,7 +78,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -97,7 +97,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -116,7 +116,7 @@ extern "C" {
 @brief  MC13783 test scenario Register dependencies
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_D.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_D.h
index 0882841..05a360a 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_D.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_D.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_D.h 
+ * @file   mc13783_test_D.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.c
index 3243daa..5b97634 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_IP.c 
+ * @file   mc13783_test_IP.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -91,7 +91,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -110,7 +110,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -129,7 +129,7 @@ extern "C" {
 @brief  MC13783 test scenario Access with incorrect parameters
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.h
index cbeb5f2..f027f36 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_IP.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_IP.h 
+ * @file   mc13783_test_IP.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.c
index 7ebf254..3405973 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_OC.c 
+ * @file   mc13783_test_OC.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -71,7 +71,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -87,7 +87,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 *//*============================================================================*/ int VT_mc13783_OC_cleanup(void) {
@@ -104,7 +104,7 @@ extern "C" {
 @brief  MC13783 test scenario Open/Close function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.h
index 459a108..ff5e3ef 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_OC.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_OC.h 
+ * @file   mc13783_test_OC.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.c
index 5552902..9dc4b4a 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_RA.c 
+ * @file   mc13783_test_RA.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -74,7 +74,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -90,7 +90,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 *//*============================================================================*/ int VT_mc13783_RA_cleanup(void) {
@@ -107,7 +107,7 @@ extern "C" {
 @brief  MC13783 test scenario Random Access
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.h
index b472026..ad658e3 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_RA.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_RA.h 
+ * @file   mc13783_test_RA.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.c
index 0eb78b3..9787545 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_RW.c 
+ * @file   mc13783_test_RW.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -84,7 +84,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -103,7 +103,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -122,7 +122,7 @@ extern "C" {
 @brief  MC13783 test scenario Read / Write function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.h
index 0f7bae7..00a0daf 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_RW.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_RW.h 
+ * @file   mc13783_test_RW.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.c
index 9de57be..0d32cc7 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_SU.c 
+ * @file   mc13783_test_SU.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -71,7 +71,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -87,7 +87,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 *//*============================================================================*/ int VT_mc13783_SU_cleanup(void) {
@@ -104,7 +104,7 @@ extern "C" {
 @brief  MC13783 test scenario SU function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.h
index 34b1f65..fe51613 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_SU.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_SU.h 
+ * @file   mc13783_test_SU.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.c
index f24e9e5..ea967dd 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_S_IT_U.c 
+ * @file   mc13783_test_S_IT_U.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -73,7 +73,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -89,7 +89,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
           On failure - return the error code
 *//*============================================================================*/ int VT_mc13783_S_IT_U_cleanup(void) {
@@ -122,7 +122,7 @@ extern "C" {
 @brief  MC13783 test scenario IT function
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.h
index 3f610df..a37d2b2 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_S_IT_U.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_S_IT_U.h 
+ * @file   mc13783_test_S_IT_U.h
  * @brief  Test scenario C header PMIC.
  */
 
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_common.c b/test/mxc_pmic_test/protocol_tests/mc13783_test_common.c
index b1d08ea..79f2e51 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_common.c
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_common.c
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_common.c 
+ * @file   mc13783_test_common.c
  * @brief  Test scenario C source PMIC.
  */
 
@@ -70,7 +70,7 @@ extern "C" {
 @brief  assumes the initial condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -85,7 +85,7 @@ extern "C" {
 @brief  assumes the post-condition of the test case execution
 
 @param  None
-  
+
 @return On success - return TPASS
         On failure - return the error code
 *//*============================================================================*/ int VT_mc13783_cleanup(void) {
@@ -104,7 +104,7 @@ extern "C" {
 @param  Input :                fd - file descriptor assigned to the mc13783
                                reg - reg number
                                *val - return read value
-  
+
 @return On success - return TPASS
         On failure - return the error code
 */
@@ -242,7 +242,7 @@ extern "C" {
 /*============================================================================*/
 /*===== VT_mc13783_opt =====*/
 /**
-@brief  perform operations (read reg, write reg, subscribe event, Unsubscribe 
+@brief  perform operations (read reg, write reg, subscribe event, Unsubscribe
         event) on already opened MC13783 file
 
 @param  Input : fd - file descriptor assigned to the mc13783
diff --git a/test/mxc_pmic_test/protocol_tests/mc13783_test_common.h b/test/mxc_pmic_test/protocol_tests/mc13783_test_common.h
index c060625..4dde4a8 100644
--- a/test/mxc_pmic_test/protocol_tests/mc13783_test_common.h
+++ b/test/mxc_pmic_test/protocol_tests/mc13783_test_common.h
@@ -1,18 +1,18 @@
-/* 
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved. 
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
- 
-/* 
- * The code contained herein is licensed under the GNU General Public 
- * License. You may obtain a copy of the GNU General Public License 
- * Version 2 or later at the following locations: 
- * 
- * http://www.opensource.org/licenses/gpl-license.html 
- * http://www.gnu.org/copyleft/gpl.html 
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
  */
 
 /*!
- * @file   mc13783_test_common.h 
+ * @file   mc13783_test_common.h
  * @brief  Test scenario C header PMIC.
  */
 
@@ -69,7 +69,7 @@ extern "C" {
 #define MAX_REG                50
 
 	typedef struct {
-		// operation - performing operation (CMD_READ, CMD_WRITE, CMD_SUB, 
+		// operation - performing operation (CMD_READ, CMD_WRITE, CMD_SUB,
 		//             CMD_UNSUB)
 		int operation;
 		// val1 - reg number if operation is CMD_READ or CMD_WRITE,
diff --git a/test/mxc_sahara_test/readme.txt b/test/mxc_sahara_test/readme.txt
index 452ff97..ab10597 100644
--- a/test/mxc_sahara_test/readme.txt
+++ b/test/mxc_sahara_test/readme.txt
@@ -34,16 +34,16 @@ know the driver's major number.  Look for the driver's name, sahara,
 in /proc/devices.
 
   mknod /dev/sahara c <major-node> 0
-  
+
   Or, after the driver is in operation,  just execute this command:
     mknod /dev/sahara c `grep sahara  /proc/devices | sed -e 's/ .*//'` 0
-    
+
     In order to make the devnode for the kernel tester, you will need to
     know the driver's major number.  Look for the driver's name,
     FSL_API_TEST, in /proc/devices.
-    
+
    mknod /dev/shwtest c <major-node> 0
-      
+
   Or, after the driver is in operation, just execute this command:
     mknod /dev/shwtest c `grep FSL_API_TEST  /proc/devices | sed -e 's/
-      .*//'` 0     
+      .*//'` 0
diff --git a/test/mxc_sahara_test/results.c b/test/mxc_sahara_test/results.c
index 8eb1ee8..f5bcc88 100644
--- a/test/mxc_sahara_test/results.c
+++ b/test/mxc_sahara_test/results.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -76,7 +76,7 @@ void run_result(fsl_shw_uco_t* my_ctx, uint32_t* total_passed_count,
 	unsigned int received_count = 0;
 	struct rand_test *tests;
 	unsigned passed = 1;	/* boolean */
-	
+
 	printf("\nTest: GET RESULTS\n");
 
 	tests = malloc(NUM_REQUESTS * sizeof(*tests));
@@ -126,8 +126,8 @@ void run_result(fsl_shw_uco_t* my_ctx, uint32_t* total_passed_count,
 			if (actual > 0)
 			{
 				printf("%d results received\n", actual);
-				
-				
+
+
 			 /* and loop over each result received. */
 			 for (i = 0; i < actual; i++) {
 				unsigned testno =
@@ -160,9 +160,9 @@ void run_result(fsl_shw_uco_t* my_ctx, uint32_t* total_passed_count,
 					}
 			    }
 			 }
-			 
+
 			} /* for each result received */
-			 
+
 		}
 	}
 
diff --git a/test/mxc_scc/scc_setup.sh b/test/mxc_scc/scc_setup.sh
index 758ea82..69017e2 100755
--- a/test/mxc_scc/scc_setup.sh
+++ b/test/mxc_scc/scc_setup.sh
@@ -136,7 +136,7 @@ determine_offsets()
         SMN_TIMER=1038
 	do_exports
         return_value=0
-        
+
     elif [ $platform -eq 2 ]; then
 
         # must bump SCM offsets
diff --git a/test/mxc_scc/scc_test.c b/test/mxc_scc/scc_test.c
index 05dd687..1064d4b 100644
--- a/test/mxc_scc/scc_test.c
+++ b/test/mxc_scc/scc_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -145,7 +145,7 @@ scc_configuration_access *get_scc_configuration(int);
 int
 main(int arg_count,             /* # command-line arguments */
      char *arg_list[])            /* pointers to command-line arguments */
-{ 
+{
     /* Declare and initialize variables */
     int scc_fd;                 /* The SCC device */
     char *scc_device_path = "/dev/scc_test";
@@ -154,7 +154,7 @@ main(int arg_count,             /* # command-line arguments */
     uint32_t timer_value = 0x5f0000;
     char *test_to_run = "Cres"; /* default list of tests to be run in order */
     int test_status = 0;
-       
+
     init_plaintext();
 
     /* Open up the SCC device */
@@ -403,7 +403,7 @@ main(int arg_count,             /* # command-line arguments */
         default:
             fprintf(stderr, "Test switch %c unknown\n", test_switch);
         }
-        
+
     }
 
     close(scc_fd);
@@ -416,7 +416,7 @@ main(int arg_count,             /* # command-line arguments */
 void
 display_configuration(int scc_fd) {
     scc_configuration_access *config;
-    
+
     config = get_scc_configuration(scc_fd);
     if (config == NULL) {
         perror("\nCannot display SCC Configuration");
@@ -829,7 +829,7 @@ run_cipher_tests(int scc_fd)
             read_scc_register(scc_fd, SMN_STATUS, &value);
             printf("SMN Status                  (0x%08x): ", value);
             print_smn_status_register(value);
-  
+
             read_scc_register(scc_fd, SCM_ERROR_STATUS, &value);
             printf("SCM Error Register          (0x%08x):", value);
             print_scc_error_status_register(value);
@@ -848,7 +848,7 @@ run_cipher_tests(int scc_fd)
             cipher_control.data_out = new_plaintext;
             cipher_control.data_out_length = plaintext_length +
                 decrypt_padding_allowance;
-        
+
             if (inject_crc_error) {
                 ciphertext[rand()%cipher_control.data_in_length] ^= 1;
             }
@@ -900,7 +900,7 @@ run_cipher_tests(int scc_fd)
                     printf("SCM Error Register          (0x%08x):", value);
                     print_scc_error_status_register(value);
                 }
- 
+
                 if (cipher_control.data_out_length != plaintext_length) {
                     printf("Error:  input plaintext length (%d) and output "
                            "plaintext length (%ld) do not match.\n",
@@ -988,7 +988,7 @@ run_aic_tests(int scc_fd) {
     printf("SMN Status: ");
     print_smn_status_register(value);
 
-    
+
     return 0;
 }
 
@@ -1156,7 +1156,7 @@ run_wrap_tests (int scc_fd)
     scc_get_slot_info_access info_acc;
     scc_encrypt_slot_access unload_acc;
     int slot_allocated = 0;
-    
+
     strcpy((char *)key,"abcdefgh");
 
     alloc_acc.owner_id = owner1;
@@ -1230,7 +1230,7 @@ run_wrap_tests (int scc_fd)
             }
         }
     }
-                            
+
     /* Now unload the key */
     if (status == 0) {
         unload_acc.slot = alloc_acc.slot;
@@ -1250,7 +1250,7 @@ run_wrap_tests (int scc_fd)
             }
         }
     }
-    
+
     /* Reacquire a slot */
     if ((status == 0) && !slot_allocated) {
         status = ioctl(scc_fd, SCC_TEST_ALLOC_SLOT, &alloc_acc);
@@ -1572,7 +1572,7 @@ print_smn_status_register(uint32_t status)
 {
     int version_id;
     uint8_t state;
-          
+
     version_id = (status&SMN_STATUS_VERSION_ID_MASK)
         >> SMN_STATUS_VERSION_ID_SHIFT;
     state = (status&SMN_STATUS_STATE_MASK) >> SMN_STATUS_STATE_SHIFT;
@@ -1647,7 +1647,7 @@ print_scm_status_register(uint32_t status)
            (status&SCM_STATUS_CIPHERING) ? ", CIPHERING" : "",
            (status&SCM_STATUS_ZEROIZING) ? ", ZEROIZING" : "",
            (status&SCM_STATUS_BUSY) ? ", BUSY" : "");
-           
+
 
 }
 
@@ -1684,7 +1684,7 @@ print_scc_error_status_register(uint32_t error)
            (error&SCM_ERR_CIPHERING) ? ", CIPHERING" : "",
            (error&SCM_ERR_ZEROIZING) ? ", ZEROIZING" : "",
            (error&SCM_ERR_BUSY) ? ", BUSY" : "");
-           
+
 }
 
 
diff --git a/test/mxc_scc/test_subs.sh b/test/mxc_scc/test_subs.sh
index dfc163f..d81a9a8 100755
--- a/test/mxc_scc/test_subs.sh
+++ b/test/mxc_scc/test_subs.sh
@@ -82,7 +82,7 @@ run_test()
 ##
 pos_test()
 {
-  
+
     run_test $*
     if [ $? -eq 0 ]; then
         test_pass_count=$(($test_pass_count+1))
@@ -104,7 +104,7 @@ pos_test()
 ## will be stripped.
 ##
 neg_test()
-{  
+{
     run_test $*
     if [ $? -ne 0 ]; then
         test_pass_count=$(($test_pass_count+1))
diff --git a/test/mxc_sdma_test/Makefile b/test/mxc_sdma_test/Makefile
index 3a70c5f..eb26a6d 100644
--- a/test/mxc_sdma_test/Makefile
+++ b/test/mxc_sdma_test/Makefile
@@ -6,7 +6,7 @@ EXCLUDE_LIST:= IMX21ADS IMX27ADS
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = $(OBJDIR)/mxc_sdma_test.out
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_sdma_test/mxc_sdma_test.c b/test/mxc_sdma_test/mxc_sdma_test.c
index f077a42..0b84caf 100644
--- a/test/mxc_sdma_test/mxc_sdma_test.c
+++ b/test/mxc_sdma_test/mxc_sdma_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -27,13 +27,13 @@ int test() {
 
   fd = open("/dev/sdma_test",O_RDWR);
 
- 
+
   if(fd < 0){
     printf("Failed open\n");
     exit(-1);
   }
 
-  
+
   write(fd, buf, 0);
 
   sleep(1);
@@ -48,6 +48,6 @@ int test() {
 int main(int argc,char **argv) {
   test();
 
-  return 0;  
+  return 0;
 }
 
diff --git a/test/mxc_sound_test/Makefile b/test/mxc_sound_test/Makefile
index 71cfe0d..0ac87b3 100644
--- a/test/mxc_sound_test/Makefile
+++ b/test/mxc_sound_test/Makefile
@@ -4,7 +4,7 @@
 CFLAGS += -Wall -D__LINUX -I$(LINUXPATH)/sound/oss -g $(CCOPTS) -lpthread
 
 # list of platforms which did not want this test case
-EXCLUDE_LIST:= 
+EXCLUDE_LIST:=
 
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = \
@@ -18,7 +18,7 @@ OBJS = \
 	$(OBJDIR)/check_2w1r.out \
 	$(OBJDIR)/autorun-sound.sh
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_sound_test/README b/test/mxc_sound_test/README
index 05a889b..3ec6db7 100755
--- a/test/mxc_sound_test/README
+++ b/test/mxc_sound_test/README
@@ -44,7 +44,7 @@ tool_loopback
 
 
 #
-# tool_player 
+# tool_player
 #
 description:
         Plays the file to /dev/dspX (uncompressed data)
@@ -56,7 +56,7 @@ usage:
 
 
 #
-# tool_listplayer 
+# tool_listplayer
 #
 description:
         Plays the playlist to /dev/dspX (uncompressed data)
@@ -69,7 +69,7 @@ usage:
 
 
 #
-# check_2play_capability 
+# check_2play_capability
 #
 description:
         Plays two file to /dev/dsp and /dev/dsp1 (uncompressed data)
@@ -99,7 +99,7 @@ note:
 # tool_loopback
 #
 description:
-        
+
 usage:
         loopback <source> <type> <bytes> [b f c]. Plays data recorded (loopback at SSI level)
 	source: 1:handset, 2:headset, 3: line in
@@ -143,7 +143,7 @@ usage:
 description:
         This program reconfigures the balance and plays a file
 usage:
-        check_balance <soundfile.wav> <bal> [nb_loops] 
+        check_balance <soundfile.wav> <bal> [nb_loops]
         bal : the new balance setting; 0=full left; 50: none; 100: full right
         nb_loops : number of times the current file is played
 
diff --git a/test/mxc_sound_test/audio_controls.h b/test/mxc_sound_test/audio_controls.h
index d92332e..aeba6a5 100644
--- a/test/mxc_sound_test/audio_controls.h
+++ b/test/mxc_sound_test/audio_controls.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -15,19 +15,19 @@
 #define __AUDIO_CONTROLS_H__
 
 /*!
- * This ioctl can be used to get the adder configuration, use the audio control 
- * SNDCTL_MC13783_READ_OUT_MIXER.\n 
+ * This ioctl can be used to get the adder configuration, use the audio control
+ * SNDCTL_MC13783_READ_OUT_MIXER.\n
  * Possible returned values are :
  * @see MC13783_AUDIO_ADDER_STEREO
  * @see MC13783_AUDIO_ADDER_STEREO_OPPOSITE
  * @see MC13783_AUDIO_ADDER_MONO
- * @see MC13783_AUDIO_ADDER_MONO_OPPOSITE 
- * 
+ * @see MC13783_AUDIO_ADDER_MONO_OPPOSITE
+ *
  */
 #define SNDCTL_MC13783_READ_OUT_ADDER        		_SIOR('Z', 6, int)
 
 /*!
- * To set the adder configuration, use the audio control 
+ * To set the adder configuration, use the audio control
  * SNDCTL_MC13783_WRITE_OUT_MIXER. Possible arguments are : \n
  * @see MC13783_AUDIO_ADDER_STEREO
  * @see MC13783_AUDIO_ADDER_STEREO_OPPOSITE
@@ -38,9 +38,9 @@
 #define SNDCTL_MC13783_WRITE_OUT_ADDER     		_SIOWR('Z', 7, int)
 
 /*!
- * To get the codec balance configuration, use the audio control 
- * SNDCTL_MC13783_READ_OUT_BALANCE.\n 
- * Range is 0 (-21 dB left) to 100 (-21 dB right), linear, 3dB step ; 
+ * To get the codec balance configuration, use the audio control
+ * SNDCTL_MC13783_READ_OUT_BALANCE.\n
+ * Range is 0 (-21 dB left) to 100 (-21 dB right), linear, 3dB step ;
  * 50 is no balance.
  * \n    Examples:
  * \n      0 : -21dB left   50 : balance deactivated   100 : -21 dB right
@@ -49,9 +49,9 @@
 #define SNDCTL_MC13783_READ_OUT_BALANCE     		 _SIOR('Z', 8, int)
 
 /*!
- * To set the codec balance configuration, use the audio control 
- * SNDCTL_MC13783_WRITE_OUT_BALANCE.\n 
- * Range is 0 (-21 dB left) to 100 (-21 dB right), linear, 3dB step ; 
+ * To set the codec balance configuration, use the audio control
+ * SNDCTL_MC13783_WRITE_OUT_BALANCE.\n
+ * Range is 0 (-21 dB left) to 100 (-21 dB right), linear, 3dB step ;
  * 50 is no balance.
  * \n    Examples:
  * \n      0 : -21dB left   50 : balance deactivated   100 : -21 dB right
@@ -60,14 +60,14 @@
 #define SNDCTL_MC13783_WRITE_OUT_BALANCE      		_SIOWR('Z', 9, int)
 
 /*!
- * To set the codec filter configuration, use the audio control 
+ * To set the codec filter configuration, use the audio control
  * SNDCTL_MC13783_WRITE_CODEC_FILTER.
- * The new configuration replaces the old one.\n 
+ * The new configuration replaces the old one.\n
  * Possible arguments are :
  * @see MC13783_CODEC_FILTER_DISABLE
  * @see MC13783_CODEC_FILTER_HIGH_PASS_IN
  * @see MC13783_CODEC_FILTER_HIGH_PASS_OUT
- * @see MC13783_CODEC_FILTER_DITHERING \n 
+ * @see MC13783_CODEC_FILTER_DITHERING \n
  *
  */
 #define SNDCTL_MC13783_WRITE_CODEC_FILTER      		_SIOWR('Z', 20, int)
@@ -75,19 +75,19 @@
 /*!
  * To get the codec filter configuration, use the audio control :
  * SNDCTL_MC13783_READ_CODEC_FILTER.
- * The new configuration replaces the old one.\n 
+ * The new configuration replaces the old one.\n
  * Possible returned values are :
  * @see MC13783_CODEC_FILTER_DISABLE
  * @see MC13783_CODEC_FILTER_HIGH_PASS_IN
  * @see MC13783_CODEC_FILTER_HIGH_PASS_OUT
- * @see MC13783_CODEC_FILTER_DITHERING \n 
+ * @see MC13783_CODEC_FILTER_DITHERING \n
  *
  */
 #define SNDCTL_MC13783_READ_CODEC_FILTER       		_SIOR('Z', 21, int)
 
 /*
- * To set the clock configuration, use the audio control 
- * SNDCTL_MC13783_WRITE_MASTER_CLOCK.		\n 
+ * To set the clock configuration, use the audio control
+ * SNDCTL_MC13783_WRITE_MASTER_CLOCK.		\n
  * Possible arguments are : 			\n
  *          1 : to MCU master			\n
  *          2 : to MC13783 master
@@ -95,8 +95,8 @@
 #define SNDCTL_MC13783_WRITE_MASTER_CLOCK                   _SIOR('Z', 30, int)
 
 /*!
- * To set the output port, use the audio control 
- * SNDCTL_MC13783_WRITE_PORT.\n 
+ * To set the output port, use the audio control
+ * SNDCTL_MC13783_WRITE_PORT.\n
  * Possible returned values are :
  * \n         1 : to port 4
  * \n         2 : to port 5
@@ -106,25 +106,25 @@
  */
 #define SNDCTL_MC13783_WRITE_PORT                 	_SIOR('Z', 31, int)
 
-/*! 
+/*!
  * Argument for the MC13783 adder configuration
  * @see SNDCTL_MC13783_WRITE_OUT_ADDER
  * @see SNDCTL_MC13783_READ_OUT_ADDER
  */
 #define MC13783_AUDIO_ADDER_STEREO                	0x1
-/*! 
+/*!
  * Argument for the MC13783 adder configuration
  * @see SNDCTL_MC13783_WRITE_OUT_ADDER
  * @see SNDCTL_MC13783_READ_OUT_ADDER
  */
 #define MC13783_AUDIO_ADDER_STEREO_OPPOSITE       	0x2
-/*! 
+/*!
  * Argument for the MC13783 adder configuration
  * @see SNDCTL_MC13783_WRITE_OUT_ADDER
  * @see SNDCTL_MC13783_READ_OUT_ADDER
  */
 #define MC13783_AUDIO_ADDER_MONO                  	0x4
-/*! 
+/*!
  * Argument for the MC13783 adder configuration
  * @see SNDCTL_MC13783_WRITE_OUT_ADDER
  * @see SNDCTL_MC13783_READ_OUT_ADDER
@@ -133,26 +133,26 @@
 
 /*!
  * Argument for the MC13783 codec filter configuration
- * @see SNDCTL_MC13783_WRITE_CODEC_FILTER 
- * @see SNDCTL_MC13783_READ_CODEC_FILTER 
+ * @see SNDCTL_MC13783_WRITE_CODEC_FILTER
+ * @see SNDCTL_MC13783_READ_CODEC_FILTER
  */
 #define MC13783_CODEC_FILTER_DISABLE              	0x0
 /*!
  * Argument for the MC13783 codec filter configuration
- * @see SNDCTL_MC13783_WRITE_CODEC_FILTER 
- * @see SNDCTL_MC13783_READ_CODEC_FILTER 
+ * @see SNDCTL_MC13783_WRITE_CODEC_FILTER
+ * @see SNDCTL_MC13783_READ_CODEC_FILTER
  */
 #define MC13783_CODEC_FILTER_HIGH_PASS_IN         	0x1
 /*!
  * Argument for the MC13783 codec filter configuration
- * @see SNDCTL_MC13783_WRITE_CODEC_FILTER 
- * @see SNDCTL_MC13783_READ_CODEC_FILTER 
+ * @see SNDCTL_MC13783_WRITE_CODEC_FILTER
+ * @see SNDCTL_MC13783_READ_CODEC_FILTER
  */
 #define MC13783_CODEC_FILTER_HIGH_PASS_OUT        	0x2
 /*!
  * Argument for the MC13783 codec filter configuration
- * @see SNDCTL_MC13783_WRITE_CODEC_FILTER 
- * @see SNDCTL_MC13783_READ_CODEC_FILTER 
+ * @see SNDCTL_MC13783_WRITE_CODEC_FILTER
+ * @see SNDCTL_MC13783_READ_CODEC_FILTER
  */
 #define MC13783_CODEC_FILTER_DITHERING            	0x4
 
@@ -184,5 +184,5 @@
  */
 #define MXC_DAM_OUT_PORT_AD2                    	0x1
 
-        	
+
 #endif /* __AUDIO_CONTROLS_H__ */
diff --git a/test/mxc_sound_test/autorun-sound.sh b/test/mxc_sound_test/autorun-sound.sh
index a88a41e..c4eabb9 100755
--- a/test/mxc_sound_test/autorun-sound.sh
+++ b/test/mxc_sound_test/autorun-sound.sh
@@ -15,16 +15,16 @@ check_devnode "/dev/mixer"
 
 
 if [ "$STATUS" = 0 ]; then
-run_testcase " arecord -N -M -r 8000 -f S16_LE -c 1 -d 8 test.wav" 
+run_testcase " arecord -N -M -r 8000 -f S16_LE -c 1 -d 8 test.wav"
 fi
 
 
 if [ "$STATUS" = 0 ]; then
-run_testcase " aplay -N -M test.wav" 
+run_testcase " aplay -N -M test.wav"
 fi
 
 if [ "$STATUS" = 0 ]; then
-run_testcase " aplay -N -M -D hw:0,1 test.wav" 
+run_testcase " aplay -N -M -D hw:0,1 test.wav"
 fi
 
 print_status
diff --git a/test/mxc_sound_test/check_audio_config.c b/test/mxc_sound_test/check_audio_config.c
index 13393bb..26a8513 100644
--- a/test/mxc_sound_test/check_audio_config.c
+++ b/test/mxc_sound_test/check_audio_config.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -204,7 +204,7 @@ void detect_enter(int time_out)
 		do {
 			read(fd_console, &c, 1);
 		}
-		while (c != 10);	// i.e. line-feed 
+		while (c != 10);	// i.e. line-feed
 	}
 }
 
diff --git a/test/mxc_sound_test/check_mixer.c b/test/mxc_sound_test/check_mixer.c
index 2f8e16d..d4f87ff 100644
--- a/test/mxc_sound_test/check_mixer.c
+++ b/test/mxc_sound_test/check_mixer.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -20,7 +20,7 @@
 
 #include "soundcard.h"
 #include "audio_controls.h"
- int main(int argc, char **argv) 
+ int main(int argc, char **argv)
 {
 	int fd_mixer = -1;
 	int balance = 0;
diff --git a/test/mxc_sound_test/check_recording.c b/test/mxc_sound_test/check_recording.c
index 57a01b6..b1ac915 100644
--- a/test/mxc_sound_test/check_recording.c
+++ b/test/mxc_sound_test/check_recording.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -10,7 +10,7 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
-    
+
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
@@ -64,7 +64,7 @@ int main(int ac, char *av[])
 	printf("Hi... \n");
 
 	if (ac != 6) {
-		
+
 #ifdef CONFIG_MX21ADS
 		    printf
 		    ("Records an audio file from /dev/sound/dsp (uncompressed data)\n");
@@ -79,7 +79,7 @@ int main(int ac, char *av[])
 #ifdef CONFIG_MX21ADS
 		printf
 		    ("input_dev options: 1 (handphone, for mono/stereo recording)\n\n");
-		
+
 #else
 		printf
 		    ("input_dev options: 1 (handset, J4, for mono/stereo recording)\n");
@@ -87,17 +87,17 @@ int main(int ac, char *av[])
 		    ("                   2 (headset, J3, for mono recording)\n");
 		printf
 		    ("		   3 (line in, J7, for mono recording)\n\n");
-		
+
 #endif
 		    printf("bytes            : Amount of bytes to record\n\n");
 		printf("frequency options: 8000\n");
-		
+
 #ifdef CONFIG_MX21ADS
 		    printf("                   44100\n\n");
-		
+
 #else
 		    printf("                   16000\n\n");
-		
+
 #endif
 		    printf("channels options : 1 (mono)\n");
 		printf
@@ -108,12 +108,12 @@ int main(int ac, char *av[])
 	input_dev = 1;
 #else
 	input_dev = atoi(av[2]);
-	
+
 #endif
 	    bytes = atoi(av[3]);
 	frequency = atoi(av[4]);
 	channels = atoi(av[5]);
-	
+
 #ifdef CONFIG_MX21ADS
 	    if ((fd_audio = open("/dev/sound/dsp", O_RDONLY)) < 0) {
 		printf("Error opening /dev/sound/dsp");
@@ -142,13 +142,13 @@ int main(int ac, char *av[])
 
 	printf("frequency = %d, bytes = %d, input_dev = %d\n", frequency,
 	       bytes, input_dev);
-	
+
 #ifdef CONFIG_MX21ADS
 	    if ((frequency != 44100) && (frequency != 8000)) {
-		
+
 #else
 	    if ((frequency != 16000) && (frequency != 8000)) {
-		
+
 #endif
 		    printf("frequency error: %d\n", frequency);
 		goto error2;
@@ -189,20 +189,20 @@ int main(int ac, char *av[])
 		printf("Unknown input src, using the default one\n");
 		val = SOUND_MASK_MIC;
 	}
-	
+
 #endif
 	    res = ioctl(fd_audio, SOUND_MIXER_WRITE_RECSRC, &val);
 	if (res < 0) {
 		printf("SOUND_MIXER_WRITE_RECSRC error\n");
 		goto error2;
 	}
-	
+
 	    /* write the WAV header, it will be filled in later on */
 	    memset(buf, 0, BUF_SIZE);
 	fwrite(buf, 44, 1, fd_file);
 	bytes_to_read = remaining_bytes = bytes;
 	while (remaining_bytes > 0) {
-		
+
 		    /* read samples */
 		    if (bytes_to_read > BUF_SIZE) {
 			bytes_to_read = BUF_SIZE;
@@ -218,7 +218,7 @@ int main(int ac, char *av[])
 		bytes_to_read = remaining_bytes;
 		total_bytes += bytes_read;
 
-		/* write the samples in file */ 
+		/* write the samples in file */
 		    bytes_written = fwrite(buf, 1, bytes_read, fd_file);
 		if (bytes_written < 0) {
 			perror("/dev/audio\n");
@@ -226,7 +226,7 @@ int main(int ac, char *av[])
 	}
 
 	printf(" total bytes read: (%d)", total_bytes);
-	
+
 	    /* Fill in the wav header */
 	    bits = 16;
 	chan = channels;
diff --git a/test/mxc_sound_test/check_volume2.c b/test/mxc_sound_test/check_volume2.c
index 79eaf8a..1d8d17b 100644
--- a/test/mxc_sound_test/check_volume2.c
+++ b/test/mxc_sound_test/check_volume2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -20,7 +20,7 @@
 
 #include "soundcard.h"
 #include "audio_controls.h"
- int main(int argc, char **argv) 
+ int main(int argc, char **argv)
 {
 	int fd_mixer = -1;
 	int left, right;
diff --git a/test/mxc_sound_test/dbmx31-ctrls.h b/test/mxc_sound_test/dbmx31-ctrls.h
index bd59764..b9286a3 100644
--- a/test/mxc_sound_test/dbmx31-ctrls.h
+++ b/test/mxc_sound_test/dbmx31-ctrls.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -16,17 +16,17 @@
  * History :
  *	04/06/29 : Creation
  */
-  
+
  /*!
   * @defgroup dbmx31_audio common definitions for the dbmx sound driver
   */
- 
+
  /*!
   * @file dbmx31-ctrls.h
   * @brief common definitions for the dbmx sound driver
   * @ingroup dbmx31_audio
   */
-  
+
 #ifndef _MXC_CTRLS_H
 #define _MXC_CTRLS_H
 
@@ -41,8 +41,8 @@ typedef struct _dbmx_cfg {
 	int val;	/*!< The value to write, or returned by read */
 } dbmx_cfg;
 
-/*! 
-* These controls are only debug purposes. 
+/*!
+* These controls are only debug purposes.
 */
 #define SNDCTL_DBMX_HW_SSI_CFG_W	_SIOW('Z', 0, dbmx_cfg)		/*!< debug only*/
 #define SNDCTL_DBMX_HW_SSI_CFG_R	_SIOR('Z', 1, dbmx_cfg)		/*!< debug only*/
@@ -152,8 +152,8 @@ typedef struct _dbmx_cfg {
 /*! Definition for SNDCTL_MC13783_WRITE_CODEC_FILTER and SNDCTL_MC13783_READ_CODEC_FILTER */
 #define MC13783_CODEC_FILTER_DITHERING		4
 
-/*! 
-* These controls are only debug purposes. 
+/*!
+* These controls are only debug purposes.
 */
 #define SNDCTL_DBMX_HW_WRITE_REG		_SIOW('Z', 100, dbmx_cfg)	/*!< debug only*/
 #define SNDCTL_DBMX_HW_READ_REG			_SIOR('Z', 101, dbmx_cfg)	/*!< debug only*/
diff --git a/test/mxc_sound_test/soundcard.h b/test/mxc_sound_test/soundcard.h
index aba6b26..de26d15 100644
--- a/test/mxc_sound_test/soundcard.h
+++ b/test/mxc_sound_test/soundcard.h
@@ -112,7 +112,7 @@
 #define	_SIOW(x,y,t)	((int)(SIOC_IN|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
 /* this should be _SIORW, but stdio got there first */
 #define	_SIOWR(x,y,t)	((int)(SIOC_INOUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
-#define _SIOC_SIZE(x)	((x>>16)&SIOCPARM_MASK)	
+#define _SIOC_SIZE(x)	((x>>16)&SIOCPARM_MASK)
 #define _SIOC_DIR(x)	(x & 0xf0000000)
 #define _SIOC_NONE	SIOC_VOID
 #define _SIOC_READ	SIOC_OUT
@@ -196,7 +196,7 @@ typedef struct seq_event_rec {
  *	Gravis UltraSound. It tries to be universal format for uploading
  *	sample based patches but is probably too limited.
  *
- *      (PBD) As Hannu guessed, the GUS structure is too limited for 
+ *      (PBD) As Hannu guessed, the GUS structure is too limited for
  *      the WaveFront, but this is the right place for a constant definition.
  */
 
@@ -236,7 +236,7 @@ struct patch_info {
 		int len;	/* Size of the wave data in bytes */
 		int loop_start, loop_end; /* Byte offsets from the beginning */
 
-/* 
+/*
  * The base_freq and base_note fields are used when computing the
  * playback speed for a note. The base_note defines the tone frequency
  * which is heard if the sample is played using the base_freq as the
@@ -265,7 +265,7 @@ struct patch_info {
 		unsigned char	env_rate[ 6 ];	 /* GUS HW ramping rate */
 		unsigned char	env_offset[ 6 ]; /* 255 == 100% */
 
-	/* 
+	/*
 	 * The tremolo, vibrato and scale info are not supported yet.
 	 * Enable by setting the mode bits WAVE_TREMOLO, WAVE_VIBRATO or
 	 * WAVE_SCALE
@@ -274,14 +274,14 @@ struct patch_info {
 		unsigned char	tremolo_sweep;
 		unsigned char	tremolo_rate;
 		unsigned char	tremolo_depth;
-	
+
 		unsigned char	vibrato_sweep;
 		unsigned char	vibrato_rate;
 		unsigned char	vibrato_depth;
 
 		int		scale_frequency;
 		unsigned int	scale_factor;		/* from 0 to 2048 or 0 to 2 */
-	
+
 	        int		volume;
 		int		fractions;
 		int		reserved1;
@@ -302,7 +302,7 @@ struct sysex_info {
  * /dev/sequencer input events.
  *
  * The data written to the /dev/sequencer is a stream of events. Events
- * are records of 4 or 8 bytes. The first byte defines the size. 
+ * are records of 4 or 8 bytes. The first byte defines the size.
  * Any number of events can be written with a write call. There
  * is a set of macros for sending these events. Use these macros if you
  * want to maximize portability of your program.
@@ -435,13 +435,13 @@ struct sysex_info {
  *	of the associated synthesizer device. There is no limit to the size
  *	of the extended events. These events are not queued but executed
  *	immediately when the write() is called (execution can take several
- *	seconds of time). 
+ *	seconds of time).
  *
  *	When a SEQ_FULLSIZE message is written to the device, it must
  *	be written using exactly one write() call. Other events cannot
  *	be mixed to the same write.
- *	
- *	For FM synths (YM3812/OPL3) use struct sbi_instrument and write it to the 
+ *
+ *	For FM synths (YM3812/OPL3) use struct sbi_instrument and write it to the
  *	/dev/sequencer. Don't write other data together with the instrument structure
  *	Set the key field of the structure to FM_PATCH. The device field is used to
  *	route the patch to the corresponding device.
@@ -488,7 +488,7 @@ struct synth_info {	/* Read only */
 		int	nr_voices;
 		int	nr_drums;	/* Obsolete field */
 		int	instr_bank_size;
-		unsigned int	capabilities;	
+		unsigned int	capabilities;
 #define SYNTH_CAP_PERCMODE		0x00000001 /* No longer used */
 #define SYNTH_CAP_OPL3			0x00000002 /* Set if OPL3 supported */
 #define SYNTH_CAP_INPUT			0x00000004 /* Input (MIDI) device */
@@ -638,7 +638,7 @@ typedef struct buffmem_desc {
 
 /*
  * Application's profile defines the way how playback underrun situations should be handled.
- * 
+ *
  *	APF_NORMAL (the default) and APF_NETWORK make the driver to cleanup the
  *	playback buffer whenever an underrun occurs. This consumes some time
  *	prevents looping the existing buffer.
@@ -700,7 +700,7 @@ typedef struct copr_debug_buf {
 		int command;	/* Used internally. Set to 0 */
 		int parm1;
 		int parm2;
-		int flags;	
+		int flags;
 		int len;	/* Length of data in bytes */
 	} copr_debug_buf;
 
@@ -723,12 +723,12 @@ typedef struct copr_msg {
 /*********************************************
  * IOCTL commands for /dev/mixer
  */
-	
-/* 
+
+/*
  * Mixer devices
  *
  * There can be up to 20 different analog mixer channels. The
- * SOUND_MIXER_NRDEVICES gives the currently supported maximum. 
+ * SOUND_MIXER_NRDEVICES gives the currently supported maximum.
  * The SOUND_MIXER_READ_DEVMASK returns a bitmask which tells
  * the devices supported by the particular mixer.
  */
@@ -748,7 +748,7 @@ typedef struct copr_msg {
 #define SOUND_MIXER_RECLEV	11	/* Recording level */
 #define SOUND_MIXER_IGAIN	12	/* Input gain */
 #define SOUND_MIXER_OGAIN	13	/* Output gain */
-/* 
+/*
  * The AD1848 codec and compatibles have three line level inputs
  * (line, aux1 and aux2). Since each card manufacturer have assigned
  * different meanings to these inputs, it's inpractical to assign
@@ -960,7 +960,7 @@ typedef struct mixer_vol_table {
 #define SOUND_MIXER_GETLEVELS		_SIOWR('M', 116, mixer_vol_table)
 #define SOUND_MIXER_SETLEVELS		_SIOWR('M', 117, mixer_vol_table)
 
-/* 
+/*
  * An ioctl for identifying the driver version. It will return value
  * of the SOUND_VERSION macro used when compiling the driver.
  * This call was introduced in OSS version 3.6 and it will not work
@@ -974,7 +974,7 @@ typedef struct mixer_vol_table {
 
 /*
  * The 4 most significant bits of byte 0 specify the class of
- * the event: 
+ * the event:
  *
  *	0x8X = system level events,
  *	0x9X = device/port specific events, event[1] = device/port,
@@ -1034,7 +1034,7 @@ typedef struct mixer_vol_table {
  */
 #define LOCL_STARTAUDIO		1
 
-#if (!defined(__KERNEL__) && !defined(KERNEL) && !defined(INKERNEL) && !defined(_KERNEL)) || defined(USE_SEQ_MACROS) 
+#if (!defined(__KERNEL__) && !defined(KERNEL) && !defined(INKERNEL) && !defined(_KERNEL)) || defined(USE_SEQ_MACROS)
 /*
  *	Some convenience macros to simplify programming of the
  *	/dev/sequencer interface
@@ -1107,16 +1107,16 @@ extern int OSS_write_patch2(int fd, unsigned char *buf, int len);
 /*
  * This variation of the sequencer macros is used just to format one event
  * using fixed buffer.
- * 
+ *
  * The program using the macro library must define the following macros before
  * using this library.
  *
- * #define _seqbuf 		 name of the buffer (unsigned char[]) 
+ * #define _seqbuf 		 name of the buffer (unsigned char[])
  * #define _SEQ_ADVBUF(len)	 If the applic needs to know the exact
  *				 size of the event, this macro can be used.
  *				 Otherwise this must be defined as empty.
  * #define _seqbufptr		 Define the name of index variable or 0 if
- *				 not required. 
+ *				 not required.
  */
 #define _SEQ_NEEDBUF(len)	/* empty */
 #endif
@@ -1177,7 +1177,7 @@ extern int OSS_write_patch2(int fd, unsigned char *buf, int len);
  * sending any MIDI bytes but it's absolutely not possible. Trying to do
  * so _will_ cause problems with MPU401 intelligent mode).
  *
- * Sysex messages are sent in blocks of 1 to 6 bytes. Longer messages must be 
+ * Sysex messages are sent in blocks of 1 to 6 bytes. Longer messages must be
  * sent by calling SEQ_SYSEX() several times (there must be no other events
  * between them). First sysex fragment must have 0xf0 in the first byte
  * and the last byte (buf[len-1] of the last fragment must be 0xf7. No byte
@@ -1276,7 +1276,7 @@ extern int OSS_write_patch2(int fd, unsigned char *buf, int len);
 
 #define SEQ_PLAYAUDIO(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO, devmask)
 /*
- * Events for the level 1 interface only 
+ * Events for the level 1 interface only
  */
 
 #define SEQ_MIDIOUT(device, byte)	{_SEQ_NEEDBUF(4);\
diff --git a/test/mxc_sound_test/tool_playd.c b/test/mxc_sound_test/tool_playd.c
index 4f0c922..bc96fa6 100644
--- a/test/mxc_sound_test/tool_playd.c
+++ b/test/mxc_sound_test/tool_playd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -86,7 +86,7 @@ int play_file(int fd_audio, FILE * file)
 		while (nleft) {
 			value = *p;
 			ioctl(fd_audio, SNDCTL_DBMX_HW_WRITE_SSI_STX0, &value)
-		
+
 			nleft -= 1;
 			p += 1;
 		}
diff --git a/test/mxc_uart_test/Makefile b/test/mxc_uart_test/Makefile
index 50f2d39..f4b65d7 100644
--- a/test/mxc_uart_test/Makefile
+++ b/test/mxc_uart_test/Makefile
@@ -1,10 +1,10 @@
 # list of platforms which did not want this test case
-EXCLUDE_LIST:= 
+EXCLUDE_LIST:=
 
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = 	$(OBJDIR)/mxc_uart_test.out  $(OBJDIR)/autorun-mxc_uart.sh
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_uart_test/mxc_uart_test.c b/test/mxc_uart_test/mxc_uart_test.c
index 91f6e41..41c9fcf 100644
--- a/test/mxc_uart_test/mxc_uart_test.c
+++ b/test/mxc_uart_test/mxc_uart_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -29,7 +29,7 @@ int main(int argc, char **argv)
         char buf[5];
         struct termios mxc, old;
         int retval;
-        
+
         printf("Test: MXC UART!\n");
         printf("Usage: mxc_uart_test <UART device name, opens UART2 if no dev name is specified>\n");
 
@@ -50,20 +50,20 @@ int main(int argc, char **argv)
                         printf("%s opened\n", *argv);
                 }
         }
-                
+
         tcgetattr(uart_file1, &old);
         mxc = old;
         mxc.c_lflag &= ~(ICANON | ECHO | ISIG);
         retval = tcsetattr(uart_file1, TCSANOW, &mxc);
-        printf("Attributes set\n"); 
-        
+        printf("Attributes set\n");
+
         line_val = LOOPBACK;
         ioctl(uart_file1, TIOCMSET, &line_val);
         printf("Test: IOCTL Set\n");
 
         write(uart_file1, "Test\0", 5);
         printf("Data Written= Test\n");
-       
+
         read(uart_file1, buf, 5);
         printf("Data Read back= %s\n", buf);
         sleep(2);
diff --git a/test/mxc_usb_test/Makefile b/test/mxc_usb_test/Makefile
index 73bd23a..cb136bb 100644
--- a/test/mxc_usb_test/Makefile
+++ b/test/mxc_usb_test/Makefile
@@ -1,11 +1,11 @@
 # list of platforms which did not want this test case
-EXCLUDE_LIST:= 
+EXCLUDE_LIST:=
 
 ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
 OBJS = $(OBJDIR)/autorun-usb-gadget.sh $(OBJDIR)/autorun-usb-host.sh
 
 else
-OBJS = 
+OBJS =
 endif
 
 all : $(OBJS)
diff --git a/test/mxc_v4l2_test/mxc_v4l2_capture.c b/test/mxc_v4l2_test/mxc_v4l2_capture.c
index 0857b55..fc5ba22 100644
--- a/test/mxc_v4l2_test/mxc_v4l2_capture.c
+++ b/test/mxc_v4l2_test/mxc_v4l2_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -13,9 +13,9 @@
 
 /*
  * @file mxc_v4l2_capture.c
- * 
+ *
  * @brief Mxc Video For Linux 2 driver test application
- * 
+ *
  */
 
 #ifdef __cplusplus
@@ -27,13 +27,13 @@ extern "C"{
 =======================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-    
+
 /* Verification Test Environment Include Files */
-#include <sys/types.h>	
-#include <sys/stat.h>	
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
-#include <unistd.h>    
+#include <unistd.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -87,8 +87,8 @@ int start_capturing(int fd_v4l)
 
                 buffers[i].length = buf.length;
                 buffers[i].offset = (size_t) buf.m.offset;
-                buffers[i].start = mmap (NULL, buffers[i].length, 
-                    PROT_READ | PROT_WRITE, MAP_SHARED, 
+                buffers[i].start = mmap (NULL, buffers[i].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED,
                     fd_v4l, buffers[i].offset);
 				memset(buffers[i].start, 0xFF, buffers[i].length);
         }
@@ -99,9 +99,9 @@ int start_capturing(int fd_v4l)
                 buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                 buf.memory = V4L2_MEMORY_MMAP;
                 buf.index = i;
-				buf.m.offset = buffers[i].offset; 
+				buf.m.offset = buffers[i].offset;
 				if (g_extra_pixel){
-	                buf.m.offset += g_extra_pixel * 
+	                buf.m.offset += g_extra_pixel *
 	                	(g_width + 2 * g_extra_pixel) + g_extra_pixel;
 				}
 
@@ -148,13 +148,13 @@ int v4l_capture_setup(void)
         fmt.fmt.pix.height = g_height;
         if (g_extra_pixel){
 			off.u_offset = (2 * g_extra_pixel + g_width) * (g_height + g_extra_pixel)
-				 - g_extra_pixel + (g_extra_pixel / 2) * ((g_width / 2) 
-				 + g_extra_pixel) + g_extra_pixel / 2;  
-			off.v_offset = off.u_offset + (g_extra_pixel + g_width / 2) * 
-				((g_height / 2) + g_extra_pixel);  
+				 - g_extra_pixel + (g_extra_pixel / 2) * ((g_width / 2)
+				 + g_extra_pixel) + g_extra_pixel / 2;
+			off.v_offset = off.u_offset + (g_extra_pixel + g_width / 2) *
+				((g_height / 2) + g_extra_pixel);
         	fmt.fmt.pix.bytesperline = g_width + g_extra_pixel * 2;
 			fmt.fmt.pix.priv = (uint32_t) &off;
-        	fmt.fmt.pix.sizeimage = (g_width + g_extra_pixel * 2 ) 
+        	fmt.fmt.pix.sizeimage = (g_width + g_extra_pixel * 2 )
         		* (g_height + g_extra_pixel * 2) * 3 / 2;
 		} else {
 	        fmt.fmt.pix.bytesperline = g_width;
@@ -166,18 +166,18 @@ int v4l_capture_setup(void)
         {
                 printf("set format failed\n");
                 return 0;
-        } 
+        }
 
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         parm.parm.capture.timeperframe.numerator = 1;
         parm.parm.capture.timeperframe.denominator = g_camera_framerate;
         parm.parm.capture.capturemode = 0;
-         
+
         if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0)
         {
                 printf("VIDIOC_S_PARM failed\n");
                 return -1;
-        } 
+        }
 
         // Set rotation
         ctrl.id = V4L2_CID_PRIVATE_BASE + 0;
@@ -212,7 +212,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
         struct v4l2_format fmt;
         FILE * fd_y_file = 0;
         int count = g_capture_count;
-   
+
         if ((fd_y_file = fopen(file, "wb")) < 0)
         {
                 printf("Unable to create y frame recording file\n");
@@ -224,7 +224,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
         {
                 printf("get format failed\n");
                 return -1;
-        } 
+        }
         else
         {
                 printf("\t Width = %d", fmt.fmt.pix.width);
@@ -237,7 +237,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
         {
                 printf("start_capturing failed\n");
                 return -1;
-        } 
+        }
 
         while (count-- > 0) {
                 memset(&buf, 0, sizeof (buf));
@@ -247,7 +247,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
                         printf("VIDIOC_DQBUF failed.\n");
                 }
 
-                fwrite(buffers[buf.index].start, fmt.fmt.pix.sizeimage, 1, fd_y_file); 
+                fwrite(buffers[buf.index].start, fmt.fmt.pix.sizeimage, 1, fd_y_file);
 
 #if TEST_OUTSYNC_ENQUE
 				/* Testing out of order enque */
@@ -264,7 +264,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
                         }
 				}
 #endif
-                if (count >= TEST_BUFFER_NUM) { 
+                if (count >= TEST_BUFFER_NUM) {
                         if (ioctl (fd_v4l, VIDIOC_QBUF, &buf) < 0) {
                                 printf("VIDIOC_QBUF failed\n");
                         		break;
@@ -278,7 +278,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
         {
                 printf("stop_capturing failed\n");
                 return -1;
-        } 
+        }
 
         fclose(fd_y_file);
 
@@ -290,7 +290,7 @@ int v4l_capture_test(int fd_v4l, const char * file)
 int process_cmdline(int argc, char **argv)
 {
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-w") == 0) {
                         g_width = atoi(argv[++i]);
@@ -314,7 +314,7 @@ int process_cmdline(int argc, char **argv)
                         i++;
                         g_cap_fmt = v4l2_fourcc(argv[i][0], argv[i][1],argv[i][2],argv[i][3]);
 
-                        if ( (g_cap_fmt != V4L2_PIX_FMT_BGR24) && 
+                        if ( (g_cap_fmt != V4L2_PIX_FMT_BGR24) &&
                              (g_cap_fmt != V4L2_PIX_FMT_BGR32) &&
                              (g_cap_fmt != V4L2_PIX_FMT_RGB565) &&
                              (g_cap_fmt != V4L2_PIX_FMT_YUV420) )
@@ -334,7 +334,7 @@ int process_cmdline(int argc, char **argv)
         }
 
         printf("g_width = %d, g_height = %d\n", g_width, g_height);
-        
+
         if ((g_width == 0) || (g_height == 0)) {
                 return -1;
         }
diff --git a/test/mxc_v4l2_test/mxc_v4l2_loopback.sh b/test/mxc_v4l2_test/mxc_v4l2_loopback.sh
index aba9306..36a902d 100755
--- a/test/mxc_v4l2_test/mxc_v4l2_loopback.sh
+++ b/test/mxc_v4l2_test/mxc_v4l2_loopback.sh
@@ -30,7 +30,7 @@ do
     height=`expr $width \* 480`
     height=`expr $height / 640`
     remainder=`expr $height % 8`
-    if test $remainder -le 3 
+    if test $remainder -le 3
     then
         height=`expr $height - $remainder`
     else
@@ -54,7 +54,7 @@ do
     height=`expr $width \* 480`
     height=`expr $height / 640`
     remainder=`expr $height % 8`
-    if test $remainder -le 3 
+    if test $remainder -le 3
     then
         height=`expr $height - $remainder`
     else
diff --git a/test/mxc_v4l2_test/mxc_v4l2_overlay.c b/test/mxc_v4l2_test/mxc_v4l2_overlay.c
index 270aa74..f9f3b20 100644
--- a/test/mxc_v4l2_test/mxc_v4l2_overlay.c
+++ b/test/mxc_v4l2_test/mxc_v4l2_overlay.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -13,9 +13,9 @@
 
 /*
  * @file mxc_v4l2_overlay.c
- * 
+ *
  * @brief Mxc Video For Linux 2 driver test application
- * 
+ *
  */
 
 #ifdef __cplusplus
@@ -29,13 +29,13 @@ extern "C"{
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-    
+
 /* Verification Test Environment Include Files */
-#include <sys/types.h>	
-#include <sys/stat.h>	
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
-#include <unistd.h>    
+#include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <asm/types.h>
@@ -84,7 +84,7 @@ int g_overlay = 0;
 int g_camera_color = 0;
 int g_camera_framerate = 0;
 
-int 
+int
 mxc_v4l_overlay_test(int timeout)
 {
         int i;
@@ -95,9 +95,9 @@ mxc_v4l_overlay_test(int timeout)
         {
                 printf("VIDIOC_OVERLAY start failed\n");
 		return TFAIL;
-        } 
+        }
 
-        for (i = 0; i < 3 ; i++) { 
+        for (i = 0; i < 3 ; i++) {
                 // flash a frame
                 ctl.id = V4L2_CID_PRIVATE_BASE + 1;
                 if (ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl) < 0)
@@ -115,7 +115,7 @@ mxc_v4l_overlay_test(int timeout)
                 	printf("change the brightness %d\n", i);
                     ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl);
 		            sleep(1);
-                } 
+                }
 		}
 		else if (g_camera_color == 2) {
                 ctl.id = V4L2_CID_SATURATION;
@@ -124,7 +124,7 @@ mxc_v4l_overlay_test(int timeout)
 	                printf("change the color saturation %d\n", i);
                     ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl);
 		            sleep(5);
-                } 
+                }
 		}
 		else if (g_camera_color == 3) {
                 ctl.id = V4L2_CID_RED_BALANCE;
@@ -133,7 +133,7 @@ mxc_v4l_overlay_test(int timeout)
 	                printf("change the red balance %d\n", i);
                     ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl);
 		            sleep(1);
-                } 
+                }
 		}
 		else if (g_camera_color == 4) {
                 ctl.id = V4L2_CID_BLUE_BALANCE;
@@ -142,7 +142,7 @@ mxc_v4l_overlay_test(int timeout)
                 	printf("change the blue balance %d\n", i);
                     ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl);
 		            sleep(1);
-                } 
+                }
 		}
 		else if (g_camera_color == 5) {
                 ctl.id = V4L2_CID_BLACK_LEVEL;
@@ -151,8 +151,8 @@ mxc_v4l_overlay_test(int timeout)
                 	printf("change the black balance %d\n", i);
                     ioctl(fd_v4l, VIDIOC_S_CTRL, &ctl);
 		            sleep(5);
-                } 
-        } 
+                }
+        }
         else {
 		        sleep(timeout);
         }
@@ -162,11 +162,11 @@ mxc_v4l_overlay_test(int timeout)
         {
                 printf("VIDIOC_OVERLAY stop failed\n");
 		return TFAIL;
-        } 
+        }
 	return 0;
 }
 
-int 
+int
 mxc_v4l_overlay_setup(struct v4l2_format *fmt)
 {
         struct v4l2_streamparm parm;
@@ -178,7 +178,7 @@ mxc_v4l_overlay_setup(struct v4l2_format *fmt)
         {
                 printf("VIDIOC_S_OUTPUT failed\n");
                 return TFAIL;
-        } 
+        }
 
         ctl.id = V4L2_CID_PRIVATE_BASE;
 		ctl.value = g_rotate;
@@ -186,7 +186,7 @@ mxc_v4l_overlay_setup(struct v4l2_format *fmt)
         {
                 printf("set control failed\n");
                 return TFAIL;
-        } 
+        }
 
         crop.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
         crop.c.left = g_sensor_left;
@@ -197,36 +197,36 @@ mxc_v4l_overlay_setup(struct v4l2_format *fmt)
         {
                 printf("set cropping failed\n");
                 return TFAIL;
-        } 
+        }
 
         if (ioctl(fd_v4l, VIDIOC_S_FMT, fmt) < 0)
         {
                 printf("set format failed\n");
                 return TFAIL;
-        } 
+        }
 
         if (ioctl(fd_v4l, VIDIOC_G_FMT, fmt) < 0)
         {
                 printf("get format failed\n");
                 return TFAIL;
-        } 
+        }
 
         if (ioctl(fd_v4l, VIDIOC_G_STD, &id) < 0)
         {
                 printf("VIDIOC_G_STD failed\n");
                 return TFAIL;
-        } 
+        }
 
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         parm.parm.capture.timeperframe.numerator = 1;
         parm.parm.capture.timeperframe.denominator = g_camera_framerate;
         parm.parm.capture.capturemode = 0;
-         
+
         if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0)
         {
                 printf("VIDIOC_S_PARM failed\n");
                 return TFAIL;
-        } 
+        }
 
         parm.parm.capture.timeperframe.numerator = 0;
         parm.parm.capture.timeperframe.denominator = 0;
@@ -235,7 +235,7 @@ mxc_v4l_overlay_setup(struct v4l2_format *fmt)
         {
                 printf("get frame rate failed\n");
                 return TFAIL;
-        } 
+        }
 
         printf("frame_rate is %d\n", parm.parm.capture.timeperframe.denominator);
         return TPASS;
@@ -244,7 +244,7 @@ mxc_v4l_overlay_setup(struct v4l2_format *fmt)
 int process_cmdline(int argc, char **argv)
 {
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-iw") == 0) {
                         g_sensor_width = atoi(argv[++i]);
@@ -299,7 +299,7 @@ int process_cmdline(int argc, char **argv)
                                " -v <camera color> 1-brightness 2-saturation"
                                " 3-red 4-blue 5-black balance\n"\
                                " -fr <frame rate 0-Auto> \n"	\
-                               " -fg foreground mode when -fg specified," 
+                               " -fg foreground mode when -fg specified,"
                                " otherwise go to frame buffer\n");
                         return -1;
                 }
@@ -307,14 +307,14 @@ int process_cmdline(int argc, char **argv)
 
         printf("g_display_width = %d, g_display_height = %d\n", g_display_width, g_display_height);
         printf("g_display_top = %d, g_display_left = %d\n", g_display_top, g_display_left);
-        
+
         if ((g_display_width == 0) || (g_display_height == 0)) {
                 return -1;
         }
         return 0;
 }
 
-int 
+int
 main(int argc, char **argv)
 {
         struct v4l2_format fmt;
@@ -353,7 +353,7 @@ main(int argc, char **argv)
                 return TFAIL;
 		}
 
-        memset(&fb_v4l2, 0, sizeof(fb_v4l2)); 
+        memset(&fb_v4l2, 0, sizeof(fb_v4l2));
 
         if ((fd_fb = open(fb_device, O_RDWR )) < 0)	{
                 printf("Unable to open frame buffer\n");
@@ -374,21 +374,21 @@ main(int argc, char **argv)
                 fb_v4l2.fmt.height = var.yres;
                 if (var.bits_per_pixel == 32) {
                         fb_v4l2.fmt.pixelformat = IPU_PIX_FMT_BGR32;
-                        fb_v4l2.fmt.bytesperline = 4 * fb_v4l2.fmt.width; 
+                        fb_v4l2.fmt.bytesperline = 4 * fb_v4l2.fmt.width;
                 }
                 else if (var.bits_per_pixel == 24) {
                         fb_v4l2.fmt.pixelformat = IPU_PIX_FMT_BGR24;
-                        fb_v4l2.fmt.bytesperline = 3 * fb_v4l2.fmt.width; 
+                        fb_v4l2.fmt.bytesperline = 3 * fb_v4l2.fmt.width;
                 }
                 else if (var.bits_per_pixel == 16) {
                         fb_v4l2.fmt.pixelformat = IPU_PIX_FMT_RGB565;
-                        fb_v4l2.fmt.bytesperline = 2 * fb_v4l2.fmt.width; 
+                        fb_v4l2.fmt.bytesperline = 2 * fb_v4l2.fmt.width;
                 }
 
                 fb_v4l2.flags = V4L2_FBUF_FLAG_PRIMARY;
                 fb_v4l2.base = (void *) fix.smem_start;
         } else {
-        
+
 	        alpha.alpha = 255;
 	        alpha.enable = 1;
 	        if ( ioctl(fd_fb, MXCFB_SET_GBL_ALPHA, &alpha) < 0) {
@@ -414,7 +414,7 @@ main(int argc, char **argv)
                         return TFAIL;
 	        }
 
-	        
+
 	        if (var.bits_per_pixel == 16) {
 	                for (h = g_display_top; h < (g_display_height + g_display_top); h++) {
 	                        cur_fb16 = (unsigned short *)((__u32)fb0 + h*fix.line_length);
@@ -454,14 +454,14 @@ main(int argc, char **argv)
         {
                 printf("set framebuffer failed\n");
                 return TFAIL;
-        } 
+        }
 
         if (ioctl(fd_v4l, VIDIOC_G_FBUF, &fb_v4l2) < 0) {
                 printf("set framebuffer failed\n");
                 return TFAIL;
-        } 
+        }
 
-        printf("\n frame buffer width %d, height %d, bytesperline %d\n", 
+        printf("\n frame buffer width %d, height %d, bytesperline %d\n",
                 fb_v4l2.fmt.width, fb_v4l2.fmt.height, fb_v4l2.fmt.bytesperline);
         ret = mxc_v4l_overlay_test(g_timeout);
 
diff --git a/test/mxc_v4l2_test/mxc_v4l2_still.c b/test/mxc_v4l2_test/mxc_v4l2_still.c
index 1e0a192..7940c2c 100644
--- a/test/mxc_v4l2_test/mxc_v4l2_still.c
+++ b/test/mxc_v4l2_test/mxc_v4l2_still.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -13,9 +13,9 @@
 
 /*
  * @file mxc_v4l2_still.c
- * 
+ *
  * @brief Mxc Video For Linux 2 driver test application
- * 
+ *
  */
 
 #ifdef __cplusplus
@@ -27,11 +27,11 @@ extern "C"{
 =======================================================================*/
 /* Standard Include Files */
 #include <errno.h>
-#include <sys/types.h>	
-#include <sys/stat.h>	
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
-#include <unistd.h>    
+#include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <asm/types.h>
@@ -130,7 +130,7 @@ int v4l_capture_setup(void)
         {
                 printf("set format failed\n");
                 return 0;
-        } 
+        }
 
         crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         crop.c.left = 0;
@@ -141,7 +141,7 @@ int v4l_capture_setup(void)
         {
                 printf("set cropping failed\n");
                 return 0;
-        } 
+        }
 
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         parm.parm.capture.timeperframe.numerator = 1;
@@ -150,12 +150,12 @@ int v4l_capture_setup(void)
                 parm.parm.capture.capturemode = V4L2_MODE_HIGHQUALITY;
         else
                 parm.parm.capture.capturemode = 0;
-         
+
         if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0)
         {
                 printf("VIDIOC_S_PARM failed\n");
                 return 0;
-        } 
+        }
 
         return fd_v4l;
 }
@@ -167,7 +167,7 @@ void v4l_capture_test(int fd_v4l)
         int fd_still = 0;
         char *buf1, *buf2;
         char still_file[100] = "./still.yuv";
-   
+
         if ((fd_still = open(still_file, O_RDWR | O_CREAT)) < 0)
         {
                 printf("Unable to create y frame recording file\n");
@@ -193,8 +193,8 @@ void v4l_capture_test(int fd_v4l)
         buf2 = (char *)malloc(fmt.fmt.pix.sizeimage);
         if (!buf1 || !buf2)
                 goto exit0;
-        
-        memset(buf1, 0, fmt.fmt.pix.sizeimage); 
+
+        memset(buf1, 0, fmt.fmt.pix.sizeimage);
         memset(buf2, 0, fmt.fmt.pix.sizeimage);
 
         if (read(fd_v4l, buf1, fmt.fmt.pix.sizeimage) != fmt.fmt.pix.sizeimage) {
@@ -212,12 +212,12 @@ void v4l_capture_test(int fd_v4l)
                 printf("VIDIOC_S_PARM failed\n");
         }
 
-        if ((g_convert == 1) && (g_pixelformat != V4L2_PIX_FMT_YUV422P) 
+        if ((g_convert == 1) && (g_pixelformat != V4L2_PIX_FMT_YUV422P)
         	&& (g_pixelformat != V4L2_PIX_FMT_YUV420)) {
                 fmt_convert(buf2, buf1, fmt);
                 write(fd_still, buf2, fmt.fmt.pix.width * fmt.fmt.pix.height * 3 / 2);
         }
-        else 
+        else
                 write(fd_still, buf1, fmt.fmt.pix.sizeimage);
 
 exit0:
@@ -233,7 +233,7 @@ int main(int argc, char **argv)
 {
         int fd_v4l;
         int i;
-        
+
         for (i = 1; i < argc; i++) {
                 if (strcmp(argv[i], "-w") == 0) {
                         g_width = atoi(argv[++i]);
diff --git a/test/mxc_v4l2_test/mxc_v4l2_tvin.c b/test/mxc_v4l2_test/mxc_v4l2_tvin.c
index b8b016b..e5c98c0 100644
--- a/test/mxc_v4l2_test/mxc_v4l2_tvin.c
+++ b/test/mxc_v4l2_test/mxc_v4l2_tvin.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2007-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -29,7 +29,7 @@ extern "C"{
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-    
+
 /* Verification Test Environment Include Files */
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -73,7 +73,7 @@ mxc_v4l_tvin_test(void)
         int overlay = 1;
 	v4l2_std_id id;
 	struct v4l2_streamparm parm;
-	 
+
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         parm.parm.capture.timeperframe.numerator = 1;
         parm.parm.capture.timeperframe.denominator = 0;
@@ -108,7 +108,7 @@ mxc_v4l_tvin_test(void)
                     sleep(1);
 		    continue;
 		 }
-		
+
        }
 
     return 0;
@@ -158,12 +158,12 @@ mxc_v4l_tvin_setup(struct v4l2_format *fmt)
                 printf("get format failed\n");
                 return TFAIL;
         }
-		
+
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         parm.parm.capture.timeperframe.numerator = 1;
         parm.parm.capture.timeperframe.denominator = 0;
         parm.parm.capture.capturemode = 0;
-         
+
         if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0)
         {
                 printf("VIDIOC_S_PARM failed\n");
diff --git a/test/mxc_vpu_test/capture.c b/test/mxc_vpu_test/capture.c
index fe9e427..7f6e526 100644
--- a/test/mxc_vpu_test/capture.c
+++ b/test/mxc_vpu_test/capture.c
@@ -128,7 +128,7 @@ v4l_capture_setup(struct encode *enc, int width, int height, int fps)
 		cap_fd = -1;
 		return -1;
 	}
-	
+
 	memset(&req, 0, sizeof(req));
 	req.count = TEST_BUFFER_NUM;
 	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
diff --git a/test/mxc_vpu_test/dec.c b/test/mxc_vpu_test/dec.c
index 491e66b..9f60de0 100644
--- a/test/mxc_vpu_test/dec.c
+++ b/test/mxc_vpu_test/dec.c
@@ -174,10 +174,10 @@ int dec_fill_bsbuffer(DecHandle handle, struct cmd_line *cmd,
 			if (nread < 0) {
 				if (nread == -EAGAIN)
 					return 0;
-				
+
 				return -1;
 			}
-			
+
 			*eos = 1;
 		} else {
 			/* unable to fill the requested size, so back off! */
@@ -193,7 +193,7 @@ int dec_fill_bsbuffer(DecHandle handle, struct cmd_line *cmd,
 				if (nread < 0) {
 					if (nread == -EAGAIN)
 						return 0;
-					
+
 					return -1;
 				}
 
@@ -212,7 +212,7 @@ int dec_fill_bsbuffer(DecHandle handle, struct cmd_line *cmd,
 
 				return -1;
 			}
-			
+
 			*eos = 1;
 		}
 	}
@@ -676,7 +676,7 @@ decoder_start(struct decode *dec)
 	if (deblock_en) {
 		deblock_fb = &fb[dblkid];
 	}
-	
+
 	if (dec->cmdl->dst_scheme == PATH_V4L2) {
 		img_size = dec->stride * dec->picheight;
 	} else {
@@ -692,7 +692,7 @@ decoder_start(struct decode *dec)
 	gettimeofday(&total_start, NULL);
 
 	while (1) {
-		
+
 		if (rot_en || dering_en) {
 			vpu_DecGiveCommand(handle, SET_ROTATOR_OUTPUT,
 						(void *)&fb[rotid]);
@@ -709,7 +709,7 @@ decoder_start(struct decode *dec)
 				}
 			}
 		}
-		
+
 		if (deblock_en) {
 			ret = vpu_DecGiveCommand(handle, DEC_SET_DEBLOCK_OUTPUT,
 						(void *)deblock_fb);
@@ -1093,7 +1093,7 @@ decoder_allocate_framebuffer(struct decode *dec)
 		dec->fb = NULL;
 		return -1;
 	}
-	
+
 	if ((dst_scheme != PATH_V4L2) ||
 	    ((dst_scheme == PATH_V4L2) && deblock_en)) {
 
@@ -1113,7 +1113,7 @@ decoder_allocate_framebuffer(struct decode *dec)
 			}
 		}
 	}
-	
+
 	if (dst_scheme == PATH_V4L2) {
 		rotation.rot_en = dec->cmdl->rot_en;
 		rotation.rot_angle = dec->cmdl->rot_angle;
@@ -1162,7 +1162,7 @@ decoder_allocate_framebuffer(struct decode *dec)
 	stride = ((dec->stride + 15) & ~15);
 	bufinfo.avcSliceBufInfo.sliceSaveBuffer = dec->phy_slice_buf;
 	bufinfo.avcSliceBufInfo.sliceSaveBufferSize = dec->phy_slicebuf_size;
-	
+
 	ret = vpu_DecRegisterFrameBuffer(handle, fb, fbcount, stride, &bufinfo);
 	if (ret != RETCODE_SUCCESS) {
 		err_msg("Register frame buffer failed\n");
diff --git a/test/mxc_vpu_test/display.c b/test/mxc_vpu_test/display.c
index a659781..563ac6d 100644
--- a/test/mxc_vpu_test/display.c
+++ b/test/mxc_vpu_test/display.c
@@ -218,7 +218,7 @@ v4l_display_open(struct decode *dec, int nframes, struct rot rotation, Rect crop
 	if (cpu_is_mx27()) {
 		fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY;
 		fb.flags = V4L2_FBUF_FLAG_PRIMARY;
-	
+
 		err = ioctl(fd, VIDIOC_S_FBUF, &fb);
 		if (err < 0) {
 			err_msg("VIDIOC_S_FBUF failed\n");
@@ -295,9 +295,9 @@ v4l_display_open(struct decode *dec, int nframes, struct rot rotation, Rect crop
 			v4l_free_bufs(i, disp);
 			goto err;
 		}
-	        	
+
 		disp->buffers[i] = buf;
-		
+
 		buffer.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
 		buffer.memory = V4L2_MEMORY_MMAP;
 		buffer.index = i;
@@ -315,7 +315,7 @@ v4l_display_open(struct decode *dec, int nframes, struct rot rotation, Rect crop
 					(unsigned int)buf->offset, buf->length);
 		buf->start = mmap(NULL, buffer.length, PROT_READ | PROT_WRITE,
 				MAP_SHARED, fd, buffer.m.offset);
-		
+
 		if (buf->start == MAP_FAILED) {
 			err_msg("mmap failed\n");
 			v4l_free_bufs(i, disp);
@@ -376,7 +376,7 @@ int v4l_put_data(struct vpu_display *disp, int index)
 			disp->sec += 1;
 			disp->usec -= 1000000;
 		}
-		
+
 		disp->buf.timestamp.tv_sec = disp->sec;
 		disp->buf.timestamp.tv_usec = disp->usec;
 
diff --git a/test/mxc_vpu_test/enc.c b/test/mxc_vpu_test/enc.c
index 6392e7b..6fd0795 100644
--- a/test/mxc_vpu_test/enc.c
+++ b/test/mxc_vpu_test/enc.c
@@ -52,11 +52,11 @@ enc_readbs_ring_buffer(EncHandle handle, struct cmd_line *cmd,
 	/* No space in ring buffer */
 	if (size <= 0)
 		return 0;
-	
+
 	if (defaultsize > 0) {
 		if (size < defaultsize)
 			return 0;
-		
+
 		space = defaultsize;
 	} else {
 		space = size;
@@ -78,7 +78,7 @@ enc_readbs_ring_buffer(EncHandle handle, struct cmd_line *cmd,
 			return -1;
 		}
 	}
-			
+
 	return space;
 }
 #endif
@@ -185,7 +185,7 @@ encoder_allocate_framebuffer(struct encode *enc)
 		err_msg("Failed to allocate enc->fb\n");
 		return -1;
 	}
-	
+
 	pfbpool = enc->pfbpool = calloc(fbcount + 1,
 					sizeof(struct frame_buf *));
 	if (pfbpool == NULL) {
@@ -200,12 +200,12 @@ encoder_allocate_framebuffer(struct encode *enc)
 			fbcount = i;
 			goto err1;
 		}
-		
+
 		fb[i].bufY = pfbpool[i]->addrY;
 		fb[i].bufCb = pfbpool[i]->addrCb;
 		fb[i].bufCr = pfbpool[i]->addrCr;
 	}
-	
+
 	/* Must be a multiple of 16 */
 	if (enc->cmdl->rot_angle == 90 || enc->cmdl->rot_angle == 270)
 		stride = (enc->picheight + 15 ) & ~15;
@@ -217,7 +217,7 @@ encoder_allocate_framebuffer(struct encode *enc)
 		err_msg("Register frame buffer failed\n");
 		goto err1;
 	}
-	
+
 	if (enc->cmdl->src_scheme == PATH_V4L2) {
 		ret = v4l_capture_setup(enc, enc->picwidth, enc->picheight, 30);
 		if (ret < 0) {
@@ -231,7 +231,7 @@ encoder_allocate_framebuffer(struct encode *enc)
 			err_msg("failed to allocate single framebuf\n");
 			goto err1;
 		}
-		
+
 		fb[src_fbid].bufY = pfbpool[src_fbid]->addrY;
 		fb[src_fbid].bufCb = pfbpool[src_fbid]->addrCb;
 		fb[src_fbid].bufCr = pfbpool[src_fbid]->addrCr;
@@ -310,7 +310,7 @@ encoder_start(struct encode *enc)
 			if (ret < 0) {
 				goto err2;
 			}
-			
+
 			fb[src_fbid].bufY = cap_buffers[v4l2_buf.index].offset;
 			fb[src_fbid].bufCb = fb[src_fbid].bufY + img_size;
 			fb[src_fbid].bufCr = fb[src_fbid].bufCb +
@@ -339,7 +339,7 @@ encoder_start(struct encode *enc)
 									ret);
 			goto err2;
 		}
-		
+
 		while (vpu_IsBusy()) {
 #if STREAM_ENC_PIC_RESET == 0
 			ret = enc_readbs_ring_buffer(handle, enc->cmdl,
@@ -422,7 +422,7 @@ err2:
 	/* For automation of test case */
 	if (ret > 0)
 		ret = 0;
-	
+
 	return ret;
 }
 
@@ -526,7 +526,7 @@ encoder_open(struct encode *enc)
 		enc->picwidth = enc->cmdl->width;
 		enc->picheight = enc->cmdl->height;
 	}
-	
+
 	/* If rotation angle is 90 or 270, pic width and height are swapped */
 	if (enc->cmdl->rot_angle == 90 || enc->cmdl->rot_angle == 270) {
 		encop.picWidth = enc->picheight;
@@ -755,7 +755,7 @@ encode_test(void *arg)
 
 	/* start encoding */
 	ret = encoder_start(enc);
-	
+
 	/* free the allocated framebuffers */
 	encoder_free_framebuffer(enc);
 err1:
diff --git a/test/mxc_vpu_test/fb.c b/test/mxc_vpu_test/fb.c
index 6c76fce..f23f53e 100644
--- a/test/mxc_vpu_test/fb.c
+++ b/test/mxc_vpu_test/fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Copyright (c) 2006, Chips & Media.  All rights reserved.
  */
@@ -76,7 +76,7 @@ struct frame_buf *framebuf_alloc(int stdMode, int strideY, int height)
 	fb->desc.size = (strideY * height * 3 / 2);
 	if (cpu_is_mx37() || cpu_is_mx51())
 		fb->desc.size += strideY * height / 4;
-	
+
 	err = IOGetPhyMem(&fb->desc);
 	if (err) {
 		printf("Frame buffer allocation failure\n");
@@ -99,7 +99,7 @@ struct frame_buf *framebuf_alloc(int stdMode, int strideY, int height)
 		memset(&(fb->desc), 0, sizeof(vpu_mem_desc));
 		return NULL;
 	}
-	
+
 	return fb;
 }
 
diff --git a/test/mxc_vpu_test/loopback.c b/test/mxc_vpu_test/loopback.c
index 77ec14a..1f57a3a 100644
--- a/test/mxc_vpu_test/loopback.c
+++ b/test/mxc_vpu_test/loopback.c
@@ -38,7 +38,7 @@ decode()
 	DecOutputInfo outinfo = {0};
 	struct vpu_display *disp = dec->disp;
 	RetCode ret;
-	
+
 	/* Suggest to enable prescan in loopback, then decoder performs scanning stream buffers
 	 * to check whether data is enough to prevent decoder hang.
 	 */
@@ -66,12 +66,12 @@ decode()
 		err_msg("PS Buffer overflow\n");
 		return -1;
 	}
-	
+
 	if (outinfo.notSufficientSliceBuffer) {
 		err_msg("Slice Buffer overflow\n");
 		return -1;
 	}
-			
+
 	if ((outinfo.indexFrameDisplay == -1) ||
 			(outinfo.indexFrameDisplay > dec->fbcount))
 		return -1;
@@ -104,7 +104,7 @@ decode()
 			     " %d\n", ret);
 	}
 	disp_clr_index = disp->buf.index;
-	
+
 out:
 	return 0;
 }
@@ -150,7 +150,7 @@ dec_fill_bsbuffer(char *buf, int size)
 		err_msg("vpu_DecUpdateBitstreamBuffer failed\n");
 		return -1;
 	}
-	
+
 	return size;
 }
 
@@ -434,7 +434,7 @@ encdec_test(void *arg)
 			err_msg("Encode failed\n");
 			break;
 		}
-		
+
 		ret = decode();
 		if (ret) {
 			err_msg("Decode failed\n");
diff --git a/test/mxc_vpu_test/main.c b/test/mxc_vpu_test/main.c
index c4b2f8c..65a1fd3 100644
--- a/test/mxc_vpu_test/main.c
+++ b/test/mxc_vpu_test/main.c
@@ -215,7 +215,7 @@ int
 parse_args(int argc, char *argv[], int i)
 {
 	int status = 0, opt;
-	
+
 	do {
 		opt = getopt(argc, argv, options);
 		switch (opt)
@@ -391,7 +391,7 @@ main(int argc, char *argv[])
 					}
 				}
 			}
-			
+
 		}
 	} else {
 		if (using_config_file == 0) {
@@ -410,7 +410,7 @@ main(int argc, char *argv[])
 				} else if (input_arg[0].mode == ENCODE) {
 					ret = encode_test(&input_arg[0].cmd);
 				}
-			
+
 				close_files(&input_arg[0].cmd);
 			} else {
 				ret = -1;
@@ -418,7 +418,7 @@ main(int argc, char *argv[])
 		} else {
 			ret = -1;
 		}
-		
+
 		if (input_arg[0].mode == LOOPBACK) {
 			encdec_test(&input_arg[0].cmd);
 		}
diff --git a/test/mxc_vpu_test/utils.c b/test/mxc_vpu_test/utils.c
index 4e4a019..b071a12 100644
--- a/test/mxc_vpu_test/utils.c
+++ b/test/mxc_vpu_test/utils.c
@@ -108,7 +108,7 @@ udp_recv(struct cmd_line *cmd, int sd, char *buf, int n)
 			cmd->noffset += n;
 			return n;
 		}
-		
+
 		memcpy(buf, (cmd->nbuf + cmd->noffset), cmd->nlen);
 		ptr = buf + cmd->nlen;
 		nleft = n - cmd->nlen;
@@ -122,7 +122,7 @@ udp_recv(struct cmd_line *cmd, int sd, char *buf, int n)
 	while (nleft > 0) {
 		tv.tv_sec = 0;
 		tv.tv_usec = 3000;
-		
+
 		FD_ZERO(&rfds);
 		FD_SET(sd, &rfds);
 
@@ -143,7 +143,7 @@ udp_recv(struct cmd_line *cmd, int sd, char *buf, int n)
 			if (cmd->complete) {
 				continue;
 			}
-		
+
 			if (ntotal == 0) {
 			       return -EAGAIN;
 			}
@@ -172,7 +172,7 @@ udp_recv(struct cmd_line *cmd, int sd, char *buf, int n)
 		if (net_h->len != nactual) {
 			warn_msg("length mismatch\n");
 		}
-		
+
 		if (cmd->seq_no++ != net_h->seqno) {
 			/* read till we get an I frame */
 			if (net_h->iframe == 1) {
@@ -192,7 +192,7 @@ udp_recv(struct cmd_line *cmd, int sd, char *buf, int n)
 		} else {
 			nremain = nactual;
 		}
-		
+
 		memcpy(ptr, (cmd->nbuf + hdrlen), nremain);
 		ntotal += nremain;
 		nleft -= nremain;
@@ -216,7 +216,7 @@ udp_send(struct cmd_line *cmd, int sd, char *buf, int n)
 		err_msg("panic: increase default udp pkt size! %d\n", n);
 		while (1);
 	}
-	
+
 	if (n == 0) {
 		net_h.seqno = -1;
 		net_h.len = 0;
@@ -233,7 +233,7 @@ udp_send(struct cmd_line *cmd, int sd, char *buf, int n)
 	addr.sin_family = AF_INET;
 	addr.sin_port = htons(cmd->port);
 	addr.sin_addr.s_addr = inet_addr(cmd->output);
-	
+
 	nwrite = sendto(sd, cmd->nbuf, n, 0, (struct sockaddr *)&addr,
 				sizeof(addr));
 	if (nwrite != n) {
@@ -259,7 +259,7 @@ int
 vpu_write(struct cmd_line *cmd, char *buf, int n)
 {
 	int fd = cmd->dst_fd;
-	
+
 	if (cmd->dst_scheme == PATH_NET) {
 		return udp_send(cmd, fd, buf, n);
 	}
@@ -295,11 +295,11 @@ skip(char *ptr)
 		}
 		break;
 	}
-	
+
 	while ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\n')) {
 		ptr++;
 	}
-	
+
 	return (ptr);
 }
 
@@ -333,7 +333,7 @@ udp_open(struct cmd_line *cmd)
 		err_msg("failed to malloc udp buffer\n");
 		return -1;
 	}
-	
+
 	sd = socket(PF_INET, SOCK_DGRAM, 0);
 	if (sd < 0) {
 		err_msg("failed to open udp socket\n");
@@ -378,10 +378,10 @@ open_files(struct cmd_line *cmd)
 		if (cmd->src_fd < 0) {
 			return -1;
 		}
-		
+
 		info_msg("decoder listening on port %d\n", cmd->port);
 	}
-	
+
 	if (cmd->dst_scheme == PATH_FILE) {
 		cmd->dst_fd = open(cmd->output, O_CREAT | O_RDWR | O_TRUNC,
 					S_IRWXU | S_IRWXG | S_IRWXO);
@@ -402,7 +402,7 @@ open_files(struct cmd_line *cmd)
 				close(cmd->src_fd);
 			return -1;
 		}
-		
+
 		info_msg("encoder sending on port %d\n", cmd->port);
 	}
 
@@ -421,7 +421,7 @@ close_files(struct cmd_line *cmd)
 		close(cmd->dst_fd);
 		cmd->dst_fd = -1;
 	}
-	
+
 	if (cmd->nbuf) {
 		free(cmd->nbuf);
 		cmd->nbuf = 0;
@@ -468,7 +468,7 @@ check_params(struct cmd_line *cmd, int op)
 	if (cmd->src_scheme != PATH_FILE && op == DECODE) {
 		cmd->src_scheme = PATH_NET;
 	}
-	
+
 	if (cmd->src_scheme == PATH_FILE && op == ENCODE) {
 		if (cmd->width == 0 || cmd->height == 0) {
 			warn_msg("Enter width and height for YUV file\n");
@@ -488,7 +488,7 @@ check_params(struct cmd_line *cmd, int op)
 			warn_msg("width not divisible by 16, adjusted %d\n",
 					cmd->width);
 		}
-	
+
 		if (cmd->height % 16 != 0) {
 			cmd->height -= cmd->height % 16;
 			warn_msg("height not divisible by 16, adjusted %d\n",
@@ -548,7 +548,7 @@ skip_unwanted(char *ptr)
 
 		if (*ptr == '#')
 			break;
-		
+
 		buf[i++] = *ptr;
 		ptr++;
 	}
@@ -565,7 +565,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 	if (str != NULL) {
 		return 100;
 	}
-	
+
 	str = strstr(buf, "operation");
 	if (str != NULL) {
 		str = index(buf, '=');
@@ -575,7 +575,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				*mode = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -589,7 +589,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->src_scheme = PATH_FILE;
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -603,7 +603,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->dst_scheme = PATH_FILE;
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -616,7 +616,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->port = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -629,7 +629,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->format = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -643,7 +643,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->rot_angle = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -658,7 +658,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 					cmd->rot_en = 0;
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -685,7 +685,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->count = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -711,7 +711,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->deblock_en = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -724,7 +724,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->dering_en = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -737,7 +737,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->mirror = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -750,7 +750,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->width = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -763,7 +763,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->height = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -776,7 +776,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->bitrate = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
@@ -802,7 +802,7 @@ int parse_options(char *buf, struct cmd_line *cmd, int *mode)
 				cmd->gop = strtol(str, NULL, 10);
 			}
 		}
-		
+
 		return 0;
 	}
 
diff --git a/test/wdog/wdt_driver_test.c b/test/wdog/wdt_driver_test.c
index 03291d9..da470d8 100644
--- a/test/wdog/wdt_driver_test.c
+++ b/test/wdog/wdt_driver_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2006-2009 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -19,7 +19,7 @@
 
 void help_info(void);
 
-int main(int argc, const char *argv[]) 
+int main(int argc, const char *argv[])
 {
 	int fd, timeout, sleep_sec, test;
 	if (argc < 2) {
@@ -57,10 +57,10 @@ int main(int argc, const char *argv[])
 	return 0;
 }
 
-void help_info(void) 
+void help_info(void)
 {
 	printf("Usage: wdt_driver_test <timeout> <sleep> <test>\n");
 	printf("    timeout: value in seconds to cause wdt timeout/reset\n");
 	printf("    sleep: value in seconds to service the wdt\n");
 	printf("    test: 0 - Service wdt with ioctl(), 1 - with write()\n");
-} 
+}
-- 
1.8.0

