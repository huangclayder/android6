From 96cf32fb7b5903058125e4443dd87be9283110db Mon Sep 17 00:00:00 2001
From: "Ye.Li" <B37916@freescale.com>
Date: Fri, 22 May 2015 14:16:35 +0800
Subject: [PATCH] MLK-10956 imx: mx6ul: Change BSP name and dtb name for 14x14
 package

Since there is another 9x9 package for mx6ul, modify the BSP names
of ddr3 arm2 board and evk board to add 14x14 package info.
Also modify the loaded dtb file to align with kernel.

After the change, the build target for mx6ul ddr3 arm2 board is:
mx6ul_14x14_ddr3_arm2_config

and the build target for mx6ul evk board is:
mx6ul_14x14_evk_config

Signed-off-by: Ye.Li <B37916@freescale.com>
---
 arch/arm/Kconfig                                   |   12 +-
 board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig      |   15 +
 board/freescale/mx6ul_14x14_ddr3_arm2/Makefile     |   10 +
 board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg |  115 +++
 .../mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c  | 1025 ++++++++++++++++++++
 board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S     |  135 +++
 board/freescale/mx6ul_14x14_evk/Kconfig            |   15 +
 board/freescale/mx6ul_14x14_evk/MAINTAINERS        |    6 +
 board/freescale/mx6ul_14x14_evk/Makefile           |   10 +
 board/freescale/mx6ul_14x14_evk/imximage.cfg       |  116 +++
 board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c  |  988 +++++++++++++++++++
 board/freescale/mx6ul_14x14_evk/plugin.S           |  135 +++
 board/freescale/mx6ul_ddr3_arm2/Kconfig            |   15 -
 board/freescale/mx6ul_ddr3_arm2/Makefile           |   10 -
 board/freescale/mx6ul_ddr3_arm2/imximage.cfg       |  115 ---
 board/freescale/mx6ul_ddr3_arm2/mx6ul_ddr3_arm2.c  | 1025 --------------------
 board/freescale/mx6ul_ddr3_arm2/plugin.S           |  135 ---
 board/freescale/mx6ulevk/Kconfig                   |   15 -
 board/freescale/mx6ulevk/MAINTAINERS               |    6 -
 board/freescale/mx6ulevk/Makefile                  |   10 -
 board/freescale/mx6ulevk/imximage.cfg              |  116 ---
 board/freescale/mx6ulevk/mx6ulevk.c                |  988 -------------------
 board/freescale/mx6ulevk/plugin.S                  |  135 ---
 configs/mx6ul_14x14_ddr3_arm2_defconfig            |    7 +
 configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig     |    7 +
 configs/mx6ul_14x14_ddr3_arm2_nand_defconfig       |    7 +
 configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig      |    7 +
 configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig     |    7 +
 configs/mx6ul_14x14_evk_android_defconfig          |    5 +
 configs/mx6ul_14x14_evk_defconfig                  |    5 +
 configs/mx6ul_14x14_evk_qspi1_defconfig            |    5 +
 configs/mx6ul_ddr3_arm2_defconfig                  |    7 -
 configs/mx6ul_ddr3_arm2_eimnor_defconfig           |    7 -
 configs/mx6ul_ddr3_arm2_nand_defconfig             |    7 -
 configs/mx6ul_ddr3_arm2_qspi1_defconfig            |    7 -
 configs/mx6ul_ddr3_arm2_spinor_defconfig           |    7 -
 configs/mx6ulevk_defconfig                         |    5 -
 configs/mx6ulevk_qspi1_defconfig                   |    5 -
 configs/mx6ulevkandroid_defconfig                  |    5 -
 include/configs/mx6ul_14x14_ddr3_arm2.h            |  433 +++++++++
 include/configs/mx6ul_14x14_evk.h                  |  399 ++++++++
 include/configs/mx6ul_14x14_evk_android.h          |   62 ++
 include/configs/mx6ul_ddr3_arm2.h                  |  433 ---------
 include/configs/mx6ulevk.h                         |  399 --------
 include/configs/mx6ulevkandroid.h                  |   62 --
 45 files changed, 3520 insertions(+), 3520 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index edda97b..8f7ee12 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -560,12 +560,12 @@ config TARGET_MX7DSABRESD
 	bool "Support mx7dsabresd"
 	select CPU_V7
 
-config TARGET_MX6ULEVK
-        bool "Support mx6ulevk"
+config TARGET_MX6UL_14X14_EVK
+        bool "Support mx6ul_14x14_evk"
         select CPU_V7
 
-config TARGET_MX6UL_DDR3_ARM2
-	bool "Support mx6ul_ddr3_arm2"
+config TARGET_MX6UL_14X14_DDR3_ARM2
+	bool "Support mx6ul_14x14_ddr3_arm2"
 	select CPU_V7
 
 config TARGET_GW_VENTANA
@@ -868,8 +868,8 @@ source "board/freescale/mx7d_12x12_lpddr3_arm2/Kconfig"
 source "board/freescale/mx7d_19x19_lpddr3_arm2/Kconfig"
 source "board/freescale/mx7d_19x19_ddr3_arm2/Kconfig"
 source "board/freescale/mx7dsabresd/Kconfig"
-source "board/freescale/mx6ulevk/Kconfig"
-source "board/freescale/mx6ul_ddr3_arm2/Kconfig"
+source "board/freescale/mx6ul_14x14_evk/Kconfig"
+source "board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig"
 source "board/freescale/vf610twr/Kconfig"
 source "board/gateworks/gw_ventana/Kconfig"
 source "board/genesi/mx51_efikamx/Kconfig"
diff --git a/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig b/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig
new file mode 100644
index 0000000..c7d15bd
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX6UL_14X14_DDR3_ARM2
+
+config SYS_BOARD
+       default "mx6ul_14x14_ddr3_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_SOC
+       default "mx6"
+
+config SYS_CONFIG_NAME
+       default "mx6ul_14x14_ddr3_arm2"
+
+endif
diff --git a/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile b/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile
new file mode 100644
index 0000000..bf63d54
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_ddr3_arm2/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ul_14x14_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg b/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg
new file mode 100644
index 0000000..87c4eaa
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_ddr3_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x0013000F
+DATA 4 0x021B083C 0x415D0159
+DATA 4 0x021B0848 0x4040484F
+DATA 4 0x021B0850 0x40405247
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333000
+DATA 4 0x021B000C 0x676B54B3
+DATA 4 0x021B0010 0xB68E0A83
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00211740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0x85180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c b/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c
new file mode 100644
index 0000000..057a580
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_ddr3_arm2/mx6ul_14x14_ddr3_arm2.c
@@ -0,0 +1,1025 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/*
+	 * The following 4 pins conflicts with qspi.
+	 * You can comment out the following 4 pins and  change
+	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
+	 * to make emmc and qspi coexists.
+	 */
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#if !defined(CONFIG_SYS_USE_NAND)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#ifdef CONFIG_MX6UL_DDR3_ARM2_USDHC2_REWORK
+#if defined(CONFIG_SYS_USE_EIMNOR) || defined(CONFIG_SYS_USE_SPINOR)
+#error "Pin conflicts!"
+#endif
+	/* conflict with eimnor/spinor */
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#endif
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/*
+	 * Pin conflicts with NAND ALE, if want to test nand,
+	 * Connect R169(B), disconnect R169(A).
+	 *
+	 * RST_B
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	clrbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&mxc_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&mxc_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+/* pin conflicts with eim nor */
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+/* pin conflicts with nand usdhc2 lcd enet */
+static iomux_v3_cfg_t const eimnor_pads[] = {
+	MX6_PAD_CSI_DATA00__EIM_AD00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__EIM_AD01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__EIM_AD02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__EIM_AD03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__EIM_AD04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA05__EIM_AD05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA06__EIM_AD06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__EIM_AD07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__EIM_AD08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__EIM_AD09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__EIM_AD10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__EIM_AD11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__EIM_AD12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__EIM_AD13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__EIM_AD14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__EIM_AD15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CLE__EIM_ADDR16 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_ALE__EIM_ADDR17 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CMD__EIM_ADDR19 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_CLK__EIM_ADDR20 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_PIXCLK__EIM_OE | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_CSI_VSYNC__EIM_RW | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_LCD_DATA08__EIM_DATA00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__EIM_DATA01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__EIM_DATA02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__EIM_DATA03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__EIM_DATA04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__EIM_DATA05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__EIM_DATA06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__EIM_DATA07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__EIM_DATA08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__EIM_DATA09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__EIM_DATA10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__EIM_DATA11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__EIM_DATA12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__EIM_DATA13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__EIM_DATA14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__EIM_DATA15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6_PAD_CSI_MCLK__EIM_CS0_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_NAND_DQS__EIM_WAIT | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00010181, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
+	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	/* Pin conflicts with LCD PWM1 */
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET1_RST
+	 */
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_SYS_USE_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+	/* If want to use qspi, should change to 4 bit width */
+	{USDHC1_BASE_ADDR, 0, 8},
+#else
+	{USDHC1_BASE_ADDR, 0, 4},
+#endif
+#if !defined(CONFIG_SYS_USE_NAND)
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 17)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+#endif
+		break;
+#if !defined(CONFIG_SYS_USE_NAND)
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+#endif
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			/* 3.3V */
+			gpio_direction_output(USDHC1_VSELECT, 0);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND)
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) && (strcmp(autodetect_str, "yes") == 0))
+		return 1;
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		/* clk from phy, set gpr1[14], clear gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 1.3V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(13000);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 *
+	 * Here we can not set this, since SD1_RST_B conflicts with GWDOG.
+	 * We use SD1, so will not set WDOG pads, also GWDOG default is
+	 * DNP.
+	 */
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6UL 14X14 DDR3 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S b/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S
new file mode 100644
index 0000000..3ce00da
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_ddr3_arm2/plugin.S
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x0013000F
+	str r1, [r0, #0x80C]
+	ldr r1, =0x415D0159
+	str r1, [r0, #0x83C]
+	ldr r1, =0x4040484F
+	str r1, [r0, #0x848]
+	ldr r1, =0x40405247
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333000
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B54B3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB68E0A83
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00211740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0x85180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+	str r1, [r0, #0x84]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ul_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6ul_14x14_evk/Kconfig b/board/freescale/mx6ul_14x14_evk/Kconfig
new file mode 100644
index 0000000..393aca6
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX6UL_14X14_EVK
+
+config SYS_BOARD
+	default "mx6ul_14x14_evk"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6ul_14x14_evk"
+
+endif
diff --git a/board/freescale/mx6ul_14x14_evk/MAINTAINERS b/board/freescale/mx6ul_14x14_evk/MAINTAINERS
new file mode 100644
index 0000000..fe65153
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/MAINTAINERS
@@ -0,0 +1,6 @@
+MX6ULEVK BOARD
+M:	Fabio Estevam <fabio.estevam@freescale.com>
+S:	Maintained
+F:	board/freescale/mx6ulevk/
+F:	include/configs/mx6ulevk.h
+F:	configs/mx6ulevk_defconfig
diff --git a/board/freescale/mx6ul_14x14_evk/Makefile b/board/freescale/mx6ul_14x14_evk/Makefile
new file mode 100644
index 0000000..393dc13
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ul_14x14_evk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ul_14x14_evk/imximage.cfg b/board/freescale/mx6ul_14x14_evk/imximage.cfg
new file mode 100644
index 0000000..2af4d86
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/imximage.cfg
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ulevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00000000
+DATA 4 0x021B083C 0x41490145
+DATA 4 0x021B0848 0x40404546
+DATA 4 0x021B0850 0x4040524D
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333000
+DATA 4 0x021B000C 0x676B54F3
+DATA 4 0x021B0010 0xB68E0A83
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00211740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x84180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
new file mode 100644
index 0000000..10e9a35
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
@@ -0,0 +1,988 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_DAT3_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+
+#define IOX_SDI IMX_GPIO_NR(5, 10)
+#define IOX_STCP IMX_GPIO_NR(5, 7)
+#define IOX_SHCP IMX_GPIO_NR(5, 11)
+#define IOX_OE IMX_GPIO_NR(5, 18)
+
+static iomux_v3_cfg_t const iox_pads[] = {
+	/* IOX_SDI */
+	MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_SHCP */
+	MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_STCP */
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_nOE */
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * HDMI_nRST --> Q0
+ * ENET1_nRST --> Q1
+ * ENET2_nRST --> Q2
+ * CAN1_2_STBY --> Q3
+ * BT_nPWD --> Q4
+ * CSI_RST --> Q5
+ * CSI_PWDN --> Q6
+ * LCD_nPWREN --> Q7
+ */
+enum qn {
+	HDMI_nRST,
+	ENET1_nRST,
+	ENET2_nRST,
+	CAN1_2_STBY,
+	BT_nPWD,
+	CSI_RST,
+	CSI_PWDN,
+	LCD_nPWREN,
+};
+
+enum qn_func {
+	qn_reset,
+	qn_enable,
+	qn_disable,
+};
+
+enum qn_level {
+	qn_low = 0,
+	qn_high = 1,
+};
+
+static enum qn_level seq[3][2] = {
+	{0, 1}, {1, 1}, {0, 0}
+};
+
+static enum qn_func qn_output[8] = {
+	qn_reset, qn_reset, qn_reset, qn_enable, qn_disable, qn_reset, qn_disable,
+	qn_enable
+};
+
+void iox74lv_init(void)
+{
+	int i;
+
+	gpio_direction_output(IOX_OE, 0);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	gpio_direction_output(IOX_OE, 1);
+};
+
+void iox74lv_set(int index)
+{
+	int i;
+
+	gpio_direction_output(IOX_OE, 0);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	gpio_direction_output(IOX_OE, 1);
+};
+
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode =  MX6_PAD_UART4_TX_DATA__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_UART4_TX_DATA__GPIO1_IO28 | PC,
+		.gp = IMX_GPIO_NR(1, 28),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_UART4_RX_DATA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_UART4_RX_DATA__GPIO1_IO29 | PC,
+		.gp = IMX_GPIO_NR(1, 29),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
+static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * RST_B
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_cd_pads[] = {
+
+	/* The evk board uses DAT3 to detect CD card plugin, in u-boot we mux the pin to
+	  * GPIO when doing board_mmc_getcd.
+	  */
+	MX6_PAD_NAND_DATA03__GPIO4_IO05 | MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_dat3_pads[] = {
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
+};
+
+
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	clrbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&mxc_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&mxc_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
+	{USDHC2_BASE_ADDR, 0, 8},
+#else
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 5)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
+		ret = 1;
+#else
+		imx_iomux_v3_setup_multiple_pads(
+				usdhc2_cd_pads, ARRAY_SIZE(usdhc2_cd_pads));
+		gpio_direction_input(USDHC2_CD_GPIO);
+
+		/* Since it is the DAT3 pin, this pin is pulled to a low voltage if no card */
+		ret = gpio_get_value(USDHC2_CD_GPIO);
+
+		imx_iomux_v3_setup_multiple_pads(
+				usdhc2_dat3_pads, ARRAY_SIZE(usdhc2_dat3_pads));
+#endif
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+		case 1:
+#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+#endif
+			gpio_direction_output(USDHC2_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/* LCD_RST */
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09	| MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(5, 9) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(5, 9) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "TFT43AB",
+		.xres           = 480,
+		.yres           = 272,
+		.pixclock       = 108695,
+		.left_margin    = 8,
+		.right_margin   = 4,
+		.upper_margin   = 2,
+		.lower_margin   = 4,
+		.hsync_len      = 41,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/* Use 50M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], set gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		/* Use 50M anatop loopback REF_CLK2 for ENET2, clear gpr1[14], set gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/* At default the 3v3 enables the MIC2026 for VBUS power */
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
+
+	iox74lv_init();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6UL 14x14 EVK\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+static iomux_v3_cfg_t const otg_udc_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+}
+
+#endif /*CONFIG_IMX_UDC*/
diff --git a/board/freescale/mx6ul_14x14_evk/plugin.S b/board/freescale/mx6ul_14x14_evk/plugin.S
new file mode 100644
index 0000000..13b6963
--- /dev/null
+++ b/board/freescale/mx6ul_14x14_evk/plugin.S
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41490145
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40404546
+	str r1, [r0, #0x848]
+	ldr r1, =0x4040524D
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333000
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B54F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB68E0A83
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00211740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x84180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+	str r1, [r0, #0x84]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ul_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6ul_ddr3_arm2/Kconfig b/board/freescale/mx6ul_ddr3_arm2/Kconfig
deleted file mode 100644
index d4fe742..0000000
--- a/board/freescale/mx6ul_ddr3_arm2/Kconfig
+++ /dev/null
@@ -1,15 +0,0 @@
-if TARGET_MX6UL_DDR3_ARM2
-
-config SYS_BOARD
-       default "mx6ul_ddr3_arm2"
-
-config SYS_VENDOR
-       default "freescale"
-
-config SYS_SOC
-       default "mx6"
-
-config SYS_CONFIG_NAME
-       default "mx6ul_ddr3_arm2"
-
-endif
diff --git a/board/freescale/mx6ul_ddr3_arm2/Makefile b/board/freescale/mx6ul_ddr3_arm2/Makefile
deleted file mode 100644
index 992d847..0000000
--- a/board/freescale/mx6ul_ddr3_arm2/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# (C) Copyright 2015 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y  := mx6ul_ddr3_arm2.o
-
-extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
-$(obj)/plugin.bin: $(obj)/plugin.o
-	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ul_ddr3_arm2/imximage.cfg b/board/freescale/mx6ul_ddr3_arm2/imximage.cfg
deleted file mode 100644
index 87c4eaa..0000000
--- a/board/freescale/mx6ul_ddr3_arm2/imximage.cfg
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Refer docs/README.imxmage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-
-#define __ASSEMBLY__
-#include <config.h>
-
-/* image version */
-
-IMAGE_VERSION 2
-
-/*
- * Boot Device : one of
- * spi/sd/nand/onenand, qspi/nor
- */
-
-#ifdef CONFIG_SYS_BOOT_QSPI
-BOOT_FROM	qspi
-#elif defined(CONFIG_SYS_BOOT_EIMNOR)
-BOOT_FROM	nor
-#else
-BOOT_FROM	sd
-#endif
-
-#ifdef CONFIG_USE_PLUGIN
-/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
-PLUGIN	board/freescale/mx6ul_ddr3_arm2/plugin.bin 0x00907000
-#else
-
-#ifdef CONFIG_SECURE_BOOT
-CSF 0x2000
-#endif
-
-/*
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *	Addr-type register length (1,2 or 4 bytes)
- *	Address	  absolute address of the register
- *	value	  value to be stored in the register
- */
-
-DATA 4 0x020c4068 0xffffffff
-DATA 4 0x020c406c 0xffffffff
-DATA 4 0x020c4070 0xffffffff
-DATA 4 0x020c4074 0xffffffff
-DATA 4 0x020c4078 0xffffffff
-DATA 4 0x020c407c 0xffffffff
-DATA 4 0x020c4080 0xffffffff
-DATA 4 0x020c4084 0xffffffff
-
-DATA 4 0x020E04B4 0x000C0000
-DATA 4 0x020E04AC 0x00000000
-DATA 4 0x020E027C 0x00000030
-DATA 4 0x020E0250 0x00000030
-DATA 4 0x020E024C 0x00000030
-DATA 4 0x020E0490 0x00000030
-DATA 4 0x020E0288 0x00000030
-DATA 4 0x020E0270 0x00000000
-DATA 4 0x020E0260 0x00000030
-DATA 4 0x020E0264 0x00000030
-DATA 4 0x020E04A0 0x00000030
-DATA 4 0x020E0494 0x00020000
-DATA 4 0x020E0280 0x00000030
-DATA 4 0x020E0284 0x00000030
-DATA 4 0x020E04B0 0x00020000
-DATA 4 0x020E0498 0x00000030
-DATA 4 0x020E04A4 0x00000030
-DATA 4 0x020E0244 0x00000030
-DATA 4 0x020E0248 0x00000030
-
-DATA 4 0x021B001C 0x00008000
-DATA 4 0x021B0800 0xA1390003
-DATA 4 0x021B080C 0x0013000F
-DATA 4 0x021B083C 0x415D0159
-DATA 4 0x021B0848 0x4040484F
-DATA 4 0x021B0850 0x40405247
-DATA 4 0x021B081C 0x33333333
-DATA 4 0x021B0820 0x33333333
-DATA 4 0x021B082C 0xf3333333
-DATA 4 0x021B0830 0xf3333333
-DATA 4 0x021B08C0 0x00922012
-DATA 4 0x021B08b8 0x00000800
-DATA 4 0x021B0004 0x0002002D
-DATA 4 0x021B0008 0x1B333000
-DATA 4 0x021B000C 0x676B54B3
-DATA 4 0x021B0010 0xB68E0A83
-DATA 4 0x021B0014 0x01FF00DB
-DATA 4 0x021B0018 0x00211740
-DATA 4 0x021B001C 0x00008000
-DATA 4 0x021B002C 0x000026D2
-DATA 4 0x021B0030 0x006B1023
-DATA 4 0x021B0040 0x0000005F
-DATA 4 0x021B0000 0x85180000
-DATA 4 0x021B001C 0x02008032
-DATA 4 0x021B001C 0x00008033
-DATA 4 0x021B001C 0x00048031
-DATA 4 0x021B001C 0x15208030
-DATA 4 0x021B001C 0x04008040
-DATA 4 0x021B0020 0x00000800
-DATA 4 0x021B0818 0x00000227
-DATA 4 0x021B0004 0x0002552D
-DATA 4 0x021B0404 0x00011006
-DATA 4 0x021B001C 0x00000000
-#endif
diff --git a/board/freescale/mx6ul_ddr3_arm2/mx6ul_ddr3_arm2.c b/board/freescale/mx6ul_ddr3_arm2/mx6ul_ddr3_arm2.c
deleted file mode 100644
index e2cc28e..0000000
--- a/board/freescale/mx6ul_ddr3_arm2/mx6ul_ddr3_arm2.c
+++ /dev/null
@@ -1,1025 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <asm/arch/clock.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/iomux.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/mx6-pins.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/gpio.h>
-#include <asm/imx-common/iomux-v3.h>
-#include <asm/imx-common/boot_mode.h>
-#include <asm/imx-common/mxc_i2c.h>
-#include <asm/io.h>
-#include <common.h>
-#include <fsl_esdhc.h>
-#include <i2c.h>
-#include <linux/sizes.h>
-#include <linux/fb.h>
-#include <miiphy.h>
-#include <mmc.h>
-#include <mxsfb.h>
-#include <netdev.h>
-#include <power/pmic.h>
-#include <power/pfuze100_pmic.h>
-#include "../common/pfuze.h"
-#include <usb.h>
-#include <usb/ehci-fsl.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
-	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
-	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
-	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
-	PAD_CTL_SPEED_HIGH   |                                   \
-	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
-
-#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
-	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
-
-#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
-	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
-
-#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
-	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
-	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
-	PAD_CTL_ODE)
-
-#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
-	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
-
-#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
-#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
-			PAD_CTL_SRE_FAST)
-#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
-
-#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
-		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
-		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
-
-#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
-	PAD_CTL_SPEED_MED |		\
-	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
-
-#ifdef CONFIG_SYS_I2C_MXC
-#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
-/* I2C1 for PMIC and EEPROM */
-struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		/* conflict with usb_otg2_pwr */
-		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
-		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
-		.gp = IMX_GPIO_NR(1, 2),
-	},
-	.sda = {
-		/* conflict with usb_otg2_oc */
-		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
-		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
-		.gp = IMX_GPIO_NR(1, 3),
-	},
-};
-#endif
-
-int dram_init(void)
-{
-	gd->ram_size = PHYS_SDRAM_SIZE;
-
-	return 0;
-}
-
-static iomux_v3_cfg_t const uart1_pads[] = {
-	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
-};
-
-#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
-static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
-	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	/*
-	 * The following 4 pins conflicts with qspi.
-	 * You can comment out the following 4 pins and  change
-	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
-	 * to make emmc and qspi coexists.
-	 */
-	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-
-	/* Default NO WP for emmc, since we use pull down */
-	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
-	/* RST_B */
-	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-#else
-static iomux_v3_cfg_t const usdhc1_pads[] = {
-	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-
-	/* VSELECT */
-	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	/* CD */
-	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* RST_B */
-	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-#endif
-
-#if !defined(CONFIG_SYS_USE_NAND)
-static iomux_v3_cfg_t const usdhc2_pads[] = {
-	MX6_PAD_CSI_VSYNC__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_HSYNC__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-#ifdef CONFIG_MX6UL_DDR3_ARM2_USDHC2_REWORK
-#if defined(CONFIG_SYS_USE_EIMNOR) || defined(CONFIG_SYS_USE_SPINOR)
-#error "Pin conflicts!"
-#endif
-	/* conflict with eimnor/spinor */
-	MX6_PAD_CSI_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_CSI_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-#endif
-	/* VSELECT */
-	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	/* CD */
-	MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/*
-	 * Pin conflicts with NAND ALE, if want to test nand,
-	 * Connect R169(B), disconnect R169(A).
-	 *
-	 * RST_B
-	 */
-	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-static iomux_v3_cfg_t const nand_pads[] = {
-	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-};
-
-static void setup_gpmi_nand(void)
-{
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-
-	/* config gpmi nand iomux */
-	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
-
-	clrbits_le32(&mxc_ccm->CCGR4,
-		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
-
-	/*
-	 * config gpmi and bch clock to 100 MHz
-	 * bch/gpmi select PLL2 PFD2 400M
-	 * 100M = 400M / 4
-	 */
-	clrbits_le32(&mxc_ccm->cscmr1,
-		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
-		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
-	clrsetbits_le32(&mxc_ccm->cscdr1,
-			MXC_CCM_CSCDR1_BCH_PODF_MASK |
-			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
-			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
-			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
-
-	/* enable gpmi and bch clock gating */
-	setbits_le32(&mxc_ccm->CCGR4,
-		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
-
-	/* enable apbh clock gating */
-	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
-}
-#endif
-
-#ifdef CONFIG_SYS_USE_SPINOR
-/* pin conflicts with eim nor */
-static iomux_v3_cfg_t const ecspi1_pads[] = {
-	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
-
-	/* CS Pin */
-	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static void setup_spinor(void)
-{
-	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
-	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
-}
-
-int board_spi_cs_gpio(unsigned bus, unsigned cs)
-{
-	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
-}
-#endif
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-/* pin conflicts with nand usdhc2 lcd enet */
-static iomux_v3_cfg_t const eimnor_pads[] = {
-	MX6_PAD_CSI_DATA00__EIM_AD00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA01__EIM_AD01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA02__EIM_AD02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA03__EIM_AD03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA04__EIM_AD04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA05__EIM_AD05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA06__EIM_AD06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_DATA07__EIM_AD07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA00__EIM_AD08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA01__EIM_AD09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA02__EIM_AD10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA03__EIM_AD11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA04__EIM_AD12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA05__EIM_AD13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA06__EIM_AD14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DATA07__EIM_AD15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_CLE__EIM_ADDR16 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_ALE__EIM_ADDR17 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_CE1_B__EIM_ADDR18 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_CMD__EIM_ADDR19 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_CLK__EIM_ADDR20 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_DATA0__EIM_ADDR21 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_DATA1__EIM_ADDR22 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_DATA2__EIM_ADDR23 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_SD1_DATA3__EIM_ADDR24 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_ENET2_RX_ER__EIM_ADDR25 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_ENET2_RX_EN__EIM_ADDR26 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-
-	MX6_PAD_CSI_PIXCLK__EIM_OE | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_CSI_VSYNC__EIM_RW | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-
-	MX6_PAD_LCD_DATA08__EIM_DATA00 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA09__EIM_DATA01 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA10__EIM_DATA02 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA11__EIM_DATA03 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA12__EIM_DATA04 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA13__EIM_DATA05 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA14__EIM_DATA06 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA15__EIM_DATA07 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA16__EIM_DATA08 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA17__EIM_DATA09 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA18__EIM_DATA10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA19__EIM_DATA11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA20__EIM_DATA12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA21__EIM_DATA13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA22__EIM_DATA14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_LCD_DATA23__EIM_DATA15 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-
-	MX6_PAD_CSI_MCLK__EIM_CS0_B | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_NAND_DQS__EIM_WAIT | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static void eimnor_cs_setup(void)
-{
-	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
-	writel(0x00010181, WEIM_BASE_ADDR + 0x000);
-	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
-	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
-	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
-	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
-}
-
-static void setup_eimnor(void)
-{
-	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
-
-	eimnor_cs_setup();
-}
-#endif
-
-#ifdef CONFIG_FEC_MXC
-/*
- * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
- * be used for ENET1 or ENET2, cannot be used for both.
- */
-static iomux_v3_cfg_t const fec1_pads[] = {
-	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
-	/* Pin conflicts with LCD PWM1 */
-	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	/*
-	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
-	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
-	 *
-	 * ENET1_RST
-	 */
-	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const fec2_pads[] = {
-	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
-
-	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
-	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-
-	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
-
-	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static void setup_iomux_fec(int fec_id)
-{
-	if (fec_id == 0) {
-		imx_iomux_v3_setup_multiple_pads(fec1_pads,
-						 ARRAY_SIZE(fec1_pads));
-		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
-		udelay(50);
-		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
-	} else {
-		imx_iomux_v3_setup_multiple_pads(fec2_pads,
-						 ARRAY_SIZE(fec2_pads));
-		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
-		udelay(50);
-		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
-	}
-}
-#endif
-
-static void setup_iomux_uart(void)
-{
-	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
-}
-
-#ifdef CONFIG_SYS_USE_QSPI
-
-#define QSPI_PAD_CTRL1	\
-	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
-	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
-
-static iomux_v3_cfg_t const quadspi_pads[] = {
-	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-
-	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-};
-
-int board_qspi_init(void)
-{
-	/* Set the iomux */
-	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
-					 ARRAY_SIZE(quadspi_pads));
-
-	/* Set the clock */
-	enable_qspi_clk(0);
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-static struct fsl_esdhc_cfg usdhc_cfg[2] = {
-#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
-	/* If want to use qspi, should change to 4 bit width */
-	{USDHC1_BASE_ADDR, 0, 8},
-#else
-	{USDHC1_BASE_ADDR, 0, 4},
-#endif
-#if !defined(CONFIG_SYS_USE_NAND)
-	{USDHC2_BASE_ADDR, 0, 4},
-#endif
-};
-
-#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
-#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
-#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
-#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 17)
-#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
-
-int mmc_get_env_devno(void)
-{
-	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
-	int dev_no;
-	u32 bootsel;
-
-	bootsel = (soc_sbmr & 0x000000FF) >> 6;
-
-	/* If not boot from sd/mmc, use default value */
-	if (bootsel != 1)
-		return CONFIG_SYS_MMC_ENV_DEV;
-
-	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
-	dev_no = (soc_sbmr & 0x00001800) >> 11;
-
-	return dev_no;
-}
-
-int mmc_map_to_kernel_blk(int dev_no)
-{
-	return dev_no;
-}
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
-	int ret = 0;
-
-	switch (cfg->esdhc_base) {
-	case USDHC1_BASE_ADDR:
-#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
-		ret = 1;
-#else
-		ret = !gpio_get_value(USDHC1_CD_GPIO);
-#endif
-		break;
-#if !defined(CONFIG_SYS_USE_NAND)
-	case USDHC2_BASE_ADDR:
-		ret = !gpio_get_value(USDHC2_CD_GPIO);
-		break;
-#endif
-	}
-
-	return ret;
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int i;
-
-	/*
-	 * According to the board_mmc_init() the following map is done:
-	 * (U-boot device node)    (Physical Port)
-	 * mmc0                    USDHC1
-	 * mmc1                    USDHC2
-	 */
-	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
-		switch (i) {
-		case 0:
-#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
-#else
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
-			gpio_direction_input(USDHC1_CD_GPIO);
-#endif
-			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
-			/* 3.3V */
-			gpio_direction_output(USDHC1_VSELECT, 0);
-			gpio_direction_output(USDHC1_PWR_GPIO, 1);
-			break;
-#if !defined(CONFIG_SYS_USE_NAND)
-		case 1:
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
-			gpio_direction_input(USDHC2_CD_GPIO);
-			gpio_direction_output(USDHC2_PWR_GPIO, 1);
-			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
-			break;
-#endif
-		default:
-			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
-			return 0;
-			}
-
-			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
-				printf("Warning: failed to initialize mmc dev %d\n", i);
-	}
-
-	return 0;
-}
-
-int check_mmc_autodetect(void)
-{
-	char *autodetect_str = getenv("mmcautodetect");
-
-	if ((autodetect_str != NULL) && (strcmp(autodetect_str, "yes") == 0))
-		return 1;
-
-	return 0;
-}
-
-void board_late_mmc_init(void)
-{
-	char cmd[32];
-	char mmcblk[32];
-	u32 dev_no = mmc_get_env_devno();
-
-	if (!check_mmc_autodetect())
-		return;
-
-	setenv_ulong("mmcdev", dev_no);
-
-	/* Set mmcblk env */
-	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
-		mmc_map_to_kernel_blk(dev_no));
-	setenv("mmcroot", mmcblk);
-
-	sprintf(cmd, "mmc dev %d", dev_no);
-	run_command(cmd, 0);
-}
-#endif
-
-#ifdef CONFIG_VIDEO_MXS
-static iomux_v3_cfg_t const lcd_pads[] = {
-	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
-
-	/*
-	 * PWM1, pin conflicts with ENET1_RX_DATA0
-	 * Use GPIO for Brightness adjustment, duty cycle = period.
-	 */
-	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
-};
-
-struct lcd_panel_info_t {
-	unsigned int lcdif_base_addr;
-	int depth;
-	void (*enable)(struct lcd_panel_info_t const *dev);
-	struct fb_videomode mode;
-};
-
-void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
-{
-	enable_lcdif_clock(dev->lcdif_base_addr);
-
-	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
-
-	/* Power up the LCD */
-	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
-
-	/* Set Brightness to high */
-	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
-}
-
-static struct lcd_panel_info_t const displays[] = {{
-	.lcdif_base_addr = LCDIF1_BASE_ADDR,
-	.depth = 24,
-	.enable	= do_enable_parallel_lcd,
-	.mode	= {
-		.name		= "MCIMX28LCD",
-		.xres           = 800,
-		.yres           = 480,
-		.pixclock       = 29850,
-		.left_margin    = 89,
-		.right_margin   = 164,
-		.upper_margin   = 23,
-		.lower_margin   = 10,
-		.hsync_len      = 10,
-		.vsync_len      = 10,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} } };
-
-int board_video_skip(void)
-{
-	int i;
-	int ret;
-	char const *panel = getenv("panel");
-	if (!panel) {
-		panel = displays[0].mode.name;
-		printf("No panel detected: default to %s\n", panel);
-		i = 0;
-	} else {
-		for (i = 0; i < ARRAY_SIZE(displays); i++) {
-			if (!strcmp(panel, displays[i].mode.name))
-				break;
-		}
-	}
-	if (i < ARRAY_SIZE(displays)) {
-		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
-				    displays[i].lcdif_base_addr);
-		if (!ret) {
-			if (displays[i].enable)
-				displays[i].enable(displays+i);
-			printf("Display: %s (%ux%u)\n",
-			       displays[i].mode.name,
-			       displays[i].mode.xres,
-			       displays[i].mode.yres);
-		} else
-			printf("LCD %s cannot be configured: %d\n",
-			       displays[i].mode.name, ret);
-	} else {
-		printf("unsupported panel %s\n", panel);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FEC_MXC
-int board_eth_init(bd_t *bis)
-{
-	int ret;
-
-	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
-
-	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
-	if (ret)
-		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
-
-	return 0;
-}
-
-static int setup_fec(int fec_id)
-{
-	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
-		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
-	int ret;
-
-	if (0 == fec_id) {
-		/*
-		 * Use 50M anatop loopback REF_CLK1 for ENET1,
-		 * clear gpr1[13], set gpr1[17]
-		 */
-		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
-				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
-		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
-		if (ret)
-			return ret;
-
-	} else {
-		/* clk from phy, set gpr1[14], clear gpr1[18]*/
-		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
-				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
-	}
-
-	enable_enet_clk(1);
-
-	return 0;
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-	if (CONFIG_FEC_ENET_DEV == 0) {
-		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
-		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
-	} else if (CONFIG_FEC_ENET_DEV == 1) {
-		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
-		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
-	}
-
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_POWER
-#define I2C_PMIC	0
-static struct pmic *pfuze;
-int power_init_board(void)
-{
-	int ret;
-	u32 rev_id, value;
-
-	ret = power_pfuze100_init(I2C_PMIC);
-	if (ret)
-		return ret;
-
-	pfuze = pmic_get("PFUZE100");
-	if (!pfuze)
-		return -ENODEV;
-
-	ret = pmic_probe(pfuze);
-	if (ret)
-		return ret;
-
-	ret = pfuze_mode_init(pfuze, APS_PFM);
-	if (ret < 0)
-		return ret;
-
-	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
-	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
-	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
-
-	/*
-	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
-	 * Configuration is F0.
-	 * Default VOLT:
-	 * VSNVS_VOLT	|	3.0V
-	 * SW1AB	|	1.375V
-	 * SW2		|	3.3V
-	 * SW3A		|	1.5V
-	 * SW3B		|	1.5V
-	 * VGEN1	|	1.5V
-	 * VGEN2	|	1.5V
-	 * VGEN3	|	2.5V
-	 * VGEN4	|	1.8V
-	 * VGEN5	|	2.8V
-	 * VGEN6	|	3.3V
-	 *
-	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
-	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
-	 * VGEN5 3.3V, VGEN6 3.0V.
-	 *
-	 * Here we just use the default VOLT, but not configure
-	 * them, when needed, configure them to our requested voltage.
-	 */
-
-	/* set SW1AB standby volatage 1.3V */
-	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
-	value &= ~0x3f;
-	value |= PFUZE100_SW1ABC_SETP(13000);
-	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
-
-	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
-	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
-	value &= ~0xc0;
-	value |= 0x40;
-	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
-
-	/* Enable power of VGEN5 3V3 */
-	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
-	value &= ~0x1F;
-	value |= 0x1F;
-	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
-
-	return 0;
-}
-
-#ifdef CONFIG_LDO_BYPASS_CHECK
-void ldo_mode_set(int ldo_bypass)
-{
-	unsigned int value;
-	int is_400M;
-	u32 vddarm;
-
-	struct pmic *p = pfuze;
-
-	if (!p) {
-		printf("No PMIC found!\n");
-		return;
-	}
-
-	/* switch to ldo_bypass mode */
-	if (ldo_bypass) {
-		prep_anatop_bypass();
-		/* decrease VDDARM to 1.275V */
-		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
-		value &= ~0x3f;
-		value |= PFUZE100_SW1ABC_SETP(12750);
-		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
-
-		is_400M = set_anatop_bypass(1);
-		if (is_400M)
-			vddarm = PFUZE100_SW1ABC_SETP(10750);
-		else
-			vddarm = PFUZE100_SW1ABC_SETP(11750);
-
-		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
-		value &= ~0x3f;
-		value |= vddarm;
-		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
-
-		finish_anatop_bypass();
-
-		printf("switch to ldo_bypass mode!\n");
-	}
-}
-#endif
-#endif
-
-int board_early_init_f(void)
-{
-	setup_iomux_uart();
-
-	return 0;
-}
-
-int board_init(void)
-{
-	/* Address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-	/*
-	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
-	 * framwork now and wdog reset will be triggered once set WDOG_B mux
-	 * with default pad setting, we set pad setting here to workaround this.
-	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
-	 * as GPIO mux firstly here to workaround it.
-	 *
-	 * Here we can not set this, since SD1_RST_B conflicts with GWDOG.
-	 * We use SD1, so will not set WDOG pads, also GWDOG default is
-	 * DNP.
-	 */
-
-#ifdef CONFIG_SYS_I2C_MXC
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-#endif
-
-#ifdef CONFIG_FEC_MXC
-	setup_fec(CONFIG_FEC_ENET_DEV);
-#endif
-
-#ifdef CONFIG_SYS_USE_SPINOR
-	setup_spinor();
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-	setup_gpmi_nand();
-#endif
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-	setup_eimnor();
-#endif
-
-#ifdef CONFIG_SYS_USE_QSPI
-	board_qspi_init();
-#endif
-
-	return 0;
-}
-
-#ifdef CONFIG_CMD_BMODE
-static const struct boot_mode board_boot_modes[] = {
-	/* 4 bit bus width */
-	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
-	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
-	{NULL,	 0},
-};
-#endif
-
-int board_late_init(void)
-{
-#ifdef CONFIG_CMD_BMODE
-	add_board_boot_modes(board_boot_modes);
-#endif
-
-#ifdef CONFIG_ENV_IS_IN_MMC
-	board_late_mmc_init();
-#endif
-
-	return 0;
-}
-
-u32 get_board_rev(void)
-{
-	return get_cpu_rev();
-}
-
-int checkboard(void)
-{
-	puts("Board: MX6UL DDR3 ARM2\n");
-
-	return 0;
-}
-
-#ifdef CONFIG_USB_EHCI_MX6
-#define USB_OTHERREGS_OFFSET	0x800
-#define UCTRL_PWR_POL		(1 << 9)
-iomux_v3_cfg_t const usb_otg1_pads[] = {
-	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-/*
- * Leave it here, but default configuration only supports 1 port now,
- * because we need sd1 and i2c1
- */
-iomux_v3_cfg_t const usb_otg2_pads[] = {
-	/* conflict with i2c1_scl */
-	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* conflict with sd1_vselect */
-	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-int board_usb_phy_mode(int port)
-{
-	return usb_phy_mode(port);
-}
-
-int board_ehci_hcd_init(int port)
-{
-	u32 *usbnc_usb_ctrl;
-
-	if (port > 1)
-		return -EINVAL;
-
-	switch (port) {
-	case 0:
-		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
-						 ARRAY_SIZE(usb_otg1_pads));
-		break;
-	case 1:
-		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
-						 ARRAY_SIZE(usb_otg2_pads));
-		break;
-	default:
-		printf("MXC USB port %d not yet supported\n", port);
-		return 1;
-	}
-
-	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
-				 port * 4);
-
-	/* Set Power polarity */
-	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
-
-	return 0;
-}
-#endif
diff --git a/board/freescale/mx6ul_ddr3_arm2/plugin.S b/board/freescale/mx6ul_ddr3_arm2/plugin.S
deleted file mode 100644
index 3ce00da..0000000
--- a/board/freescale/mx6ul_ddr3_arm2/plugin.S
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <config.h>
-
-/* DDR script */
-.macro imx6ul_ddr3_arm2_setting
-	ldr r0, =IOMUXC_BASE_ADDR
-	ldr r1, =0x000C0000
-	str r1, [r0, #0x4B4]
-	ldr r1, =0x00000000
-	str r1, [r0, #0x4AC]
-	ldr r1, =0x00000030
-	str r1, [r0, #0x27C]
-	str r1, [r0, #0x250]
-	str r1, [r0, #0x24C]
-	str r1, [r0, #0x490]
-	str r1, [r0, #0x288]
-
-	ldr r1, =0x00000000
-	str r1, [r0, #0x270]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x260]
-	str r1, [r0, #0x264]
-	str r1, [r0, #0x4A0]
-
-	ldr r1, =0x00020000
-	str r1, [r0, #0x494]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x280]
-	str r1, [r0, #0x284]
-
-	ldr r1, =0x00020000
-	str r1, [r0, #0x4B0]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x498]
-	str r1, [r0, #0x4A4]
-	str r1, [r0, #0x244]
-	str r1, [r0, #0x248]
-
-	ldr r0, =MMDC_P0_BASE_ADDR
-	ldr r1, =0x00008000
-	str r1, [r0, #0x1C]
-	ldr r1, =0xA1390003
-	str r1, [r0, #0x800]
-	ldr r1, =0x0013000F
-	str r1, [r0, #0x80C]
-	ldr r1, =0x415D0159
-	str r1, [r0, #0x83C]
-	ldr r1, =0x4040484F
-	str r1, [r0, #0x848]
-	ldr r1, =0x40405247
-	str r1, [r0, #0x850]
-	ldr r1, =0x33333333
-	str r1, [r0, #0x81C]
-	str r1, [r0, #0x820]
-	ldr r1, =0xF3333333
-	str r1, [r0, #0x82C]
-	str r1, [r0, #0x830]
-	ldr r1, =0x00922012
-	str r1, [r0, #0x8C0]
-	ldr r1, =0x00000800
-	str r1, [r0, #0x8B8]
-	ldr r1, =0x0002002D
-	str r1, [r0, #0x004]
-	ldr r1, =0x1B333000
-	str r1, [r0, #0x008]
-	ldr r1, =0x676B54B3
-	str r1, [r0, #0x00C]
-	ldr r1, =0xB68E0A83
-	str r1, [r0, #0x010]
-	ldr r1, =0x01FF00DB
-	str r1, [r0, #0x014]
-	ldr r1, =0x00211740
-	str r1, [r0, #0x018]
-	ldr r1, =0x00008000
-	str r1, [r0, #0x01C]
-	ldr r1, =0x000026D2
-	str r1, [r0, #0x02C]
-	ldr r1, =0x006B1023
-	str r1, [r0, #0x030]
-	ldr r1, =0x0000005F
-	str r1, [r0, #0x040]
-	ldr r1, =0x85180000
-	str r1, [r0, #0x000]
-	ldr r1, =0x02008032
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00008033
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00048031
-	str r1, [r0, #0x01C]
-	ldr r1, =0x15208030
-	str r1, [r0, #0x01C]
-	ldr r1, =0x04008040
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00000800
-	str r1, [r0, #0x020]
-	ldr r1, =0x00000227
-	str r1, [r0, #0x818]
-	ldr r1, =0x0002552D
-	str r1, [r0, #0x004]
-	ldr r1, =0x00011006
-	str r1, [r0, #0x404]
-	ldr r1, =0x00000000
-	str r1, [r0, #0x01C]
-.endm
-
-.macro imx6_clock_gating
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #0x68]
-	str r1, [r0, #0x6C]
-	str r1, [r0, #0x70]
-	str r1, [r0, #0x74]
-	str r1, [r0, #0x78]
-	str r1, [r0, #0x7C]
-	str r1, [r0, #0x80]
-	str r1, [r0, #0x84]
-.endm
-
-.macro imx6_qos_setting
-.endm
-
-.macro imx6_ddr_setting
-	imx6ul_ddr3_arm2_setting
-.endm
-
-/* include the common plugin code here */
-#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6ulevk/Kconfig b/board/freescale/mx6ulevk/Kconfig
deleted file mode 100644
index 8b0b9d4..0000000
--- a/board/freescale/mx6ulevk/Kconfig
+++ /dev/null
@@ -1,15 +0,0 @@
-if TARGET_MX6ULEVK
-
-config SYS_BOARD
-	default "mx6ulevk"
-
-config SYS_VENDOR
-	default "freescale"
-
-config SYS_SOC
-	default "mx6"
-
-config SYS_CONFIG_NAME
-	default "mx6ulevk"
-
-endif
diff --git a/board/freescale/mx6ulevk/MAINTAINERS b/board/freescale/mx6ulevk/MAINTAINERS
deleted file mode 100644
index fe65153..0000000
--- a/board/freescale/mx6ulevk/MAINTAINERS
+++ /dev/null
@@ -1,6 +0,0 @@
-MX6ULEVK BOARD
-M:	Fabio Estevam <fabio.estevam@freescale.com>
-S:	Maintained
-F:	board/freescale/mx6ulevk/
-F:	include/configs/mx6ulevk.h
-F:	configs/mx6ulevk_defconfig
diff --git a/board/freescale/mx6ulevk/Makefile b/board/freescale/mx6ulevk/Makefile
deleted file mode 100644
index 23f5d80..0000000
--- a/board/freescale/mx6ulevk/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# (C) Copyright 2015 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y  := mx6ulevk.o
-
-extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
-$(obj)/plugin.bin: $(obj)/plugin.o
-	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ulevk/imximage.cfg b/board/freescale/mx6ulevk/imximage.cfg
deleted file mode 100644
index 2af4d86..0000000
--- a/board/freescale/mx6ulevk/imximage.cfg
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Refer docs/README.imxmage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-
-#define __ASSEMBLY__
-#include <config.h>
-
-/* image version */
-
-IMAGE_VERSION 2
-
-/*
- * Boot Device : one of
- * spi/sd/nand/onenand, qspi/nor
- */
-
-#ifdef CONFIG_SYS_BOOT_QSPI
-BOOT_FROM	qspi
-#elif defined(CONFIG_SYS_BOOT_EIMNOR)
-BOOT_FROM	nor
-#else
-BOOT_FROM	sd
-#endif
-
-#ifdef CONFIG_USE_PLUGIN
-/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
-PLUGIN	board/freescale/mx6ulevk/plugin.bin 0x00907000
-#else
-
-#ifdef CONFIG_SECURE_BOOT
-CSF 0x2000
-#endif
-
-/*
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *	Addr-type register length (1,2 or 4 bytes)
- *	Address	  absolute address of the register
- *	value	  value to be stored in the register
- */
-
-/* Enable all clocks */
-DATA 4 0x020c4068 0xffffffff
-DATA 4 0x020c406c 0xffffffff
-DATA 4 0x020c4070 0xffffffff
-DATA 4 0x020c4074 0xffffffff
-DATA 4 0x020c4078 0xffffffff
-DATA 4 0x020c407c 0xffffffff
-DATA 4 0x020c4080 0xffffffff
-DATA 4 0x020c4084 0xffffffff
-
-DATA 4 0x020E04B4 0x000C0000
-DATA 4 0x020E04AC 0x00000000
-DATA 4 0x020E027C 0x00000030
-DATA 4 0x020E0250 0x00000030
-DATA 4 0x020E024C 0x00000030
-DATA 4 0x020E0490 0x00000030
-DATA 4 0x020E0288 0x00000030
-DATA 4 0x020E0270 0x00000000
-DATA 4 0x020E0260 0x00000030
-DATA 4 0x020E0264 0x00000030
-DATA 4 0x020E04A0 0x00000030
-DATA 4 0x020E0494 0x00020000
-DATA 4 0x020E0280 0x00000030
-DATA 4 0x020E0284 0x00000030
-DATA 4 0x020E04B0 0x00020000
-DATA 4 0x020E0498 0x00000030
-DATA 4 0x020E04A4 0x00000030
-DATA 4 0x020E0244 0x00000030
-DATA 4 0x020E0248 0x00000030
-
-DATA 4 0x021B001C 0x00008000
-DATA 4 0x021B0800 0xA1390003
-DATA 4 0x021B080C 0x00000000
-DATA 4 0x021B083C 0x41490145
-DATA 4 0x021B0848 0x40404546
-DATA 4 0x021B0850 0x4040524D
-DATA 4 0x021B081C 0x33333333
-DATA 4 0x021B0820 0x33333333
-DATA 4 0x021B082C 0xf3333333
-DATA 4 0x021B0830 0xf3333333
-DATA 4 0x021B08C0 0x00922012
-DATA 4 0x021B08b8 0x00000800
-DATA 4 0x021B0004 0x0002002D
-DATA 4 0x021B0008 0x1B333000
-DATA 4 0x021B000C 0x676B54F3
-DATA 4 0x021B0010 0xB68E0A83
-DATA 4 0x021B0014 0x01FF00DB
-DATA 4 0x021B0018 0x00211740
-DATA 4 0x021B001C 0x00008000
-DATA 4 0x021B002C 0x000026D2
-DATA 4 0x021B0030 0x006B1023
-DATA 4 0x021B0040 0x0000004F
-DATA 4 0x021B0000 0x84180000
-DATA 4 0x021B001C 0x02008032
-DATA 4 0x021B001C 0x00008033
-DATA 4 0x021B001C 0x00048031
-DATA 4 0x021B001C 0x15208030
-DATA 4 0x021B001C 0x04008040
-DATA 4 0x021B0020 0x00000800
-DATA 4 0x021B0818 0x00000227
-DATA 4 0x021B0004 0x0002552D
-DATA 4 0x021B0404 0x00011006
-DATA 4 0x021B001C 0x00000000
-#endif
diff --git a/board/freescale/mx6ulevk/mx6ulevk.c b/board/freescale/mx6ulevk/mx6ulevk.c
deleted file mode 100644
index 6b1370e..0000000
--- a/board/freescale/mx6ulevk/mx6ulevk.c
+++ /dev/null
@@ -1,988 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <asm/arch/clock.h>
-#include <asm/arch/iomux.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/mx6-pins.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/gpio.h>
-#include <asm/imx-common/iomux-v3.h>
-#include <asm/imx-common/boot_mode.h>
-#include <asm/imx-common/mxc_i2c.h>
-#include <asm/io.h>
-#include <common.h>
-#include <fsl_esdhc.h>
-#include <i2c.h>
-#include <linux/sizes.h>
-#include <linux/fb.h>
-#include <miiphy.h>
-#include <mmc.h>
-#include <mxsfb.h>
-#include <netdev.h>
-#include <usb.h>
-#include <usb/ehci-fsl.h>
-
-#ifdef CONFIG_FASTBOOT
-#include <fastboot.h>
-#ifdef CONFIG_ANDROID_RECOVERY
-#include <recovery.h>
-#endif
-#endif /*CONFIG_FASTBOOT*/
-
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
-	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
-	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define USDHC_DAT3_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
-	PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
-	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-
-#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
-	PAD_CTL_SPEED_HIGH   |                                   \
-	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
-
-#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
-	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
-
-
-#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
-
-#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
-	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
-
-#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
-	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
-	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
-	PAD_CTL_ODE)
-
-#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
-	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
-
-#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
-#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
-			PAD_CTL_SRE_FAST)
-#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
-
-#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
-		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
-		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
-
-#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
-	PAD_CTL_SPEED_MED |		\
-	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
-
-
-#define IOX_SDI IMX_GPIO_NR(5, 10)
-#define IOX_STCP IMX_GPIO_NR(5, 7)
-#define IOX_SHCP IMX_GPIO_NR(5, 11)
-#define IOX_OE IMX_GPIO_NR(5, 18)
-
-static iomux_v3_cfg_t const iox_pads[] = {
-	/* IOX_SDI */
-	MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* IOX_SHCP */
-	MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* IOX_STCP */
-	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* IOX_nOE */
-	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-/*
- * HDMI_nRST --> Q0
- * ENET1_nRST --> Q1
- * ENET2_nRST --> Q2
- * CAN1_2_STBY --> Q3
- * BT_nPWD --> Q4
- * CSI_RST --> Q5
- * CSI_PWDN --> Q6
- * LCD_nPWREN --> Q7
- */
-enum qn {
-	HDMI_nRST,
-	ENET1_nRST,
-	ENET2_nRST,
-	CAN1_2_STBY,
-	BT_nPWD,
-	CSI_RST,
-	CSI_PWDN,
-	LCD_nPWREN,
-};
-
-enum qn_func {
-	qn_reset,
-	qn_enable,
-	qn_disable,
-};
-
-enum qn_level {
-	qn_low = 0,
-	qn_high = 1,
-};
-
-static enum qn_level seq[3][2] = {
-	{0, 1}, {1, 1}, {0, 0}
-};
-
-static enum qn_func qn_output[8] = {
-	qn_reset, qn_reset, qn_reset, qn_enable, qn_disable, qn_reset, qn_disable,
-	qn_enable
-};
-
-void iox74lv_init(void)
-{
-	int i;
-
-	gpio_direction_output(IOX_OE, 0);
-
-	for (i = 7; i >= 0; i--) {
-		gpio_direction_output(IOX_SHCP, 0);
-		gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
-		udelay(500);
-		gpio_direction_output(IOX_SHCP, 1);
-		udelay(500);
-	}
-
-	gpio_direction_output(IOX_STCP, 0);
-	udelay(500);
-	/*
-	  * shift register will be output to pins
-	  */
-	gpio_direction_output(IOX_STCP, 1);
-
-	for (i = 7; i >= 0; i--) {
-		gpio_direction_output(IOX_SHCP, 0);
-		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
-		udelay(500);
-		gpio_direction_output(IOX_SHCP, 1);
-		udelay(500);
-	}
-	gpio_direction_output(IOX_STCP, 0);
-	udelay(500);
-	/*
-	  * shift register will be output to pins
-	  */
-	gpio_direction_output(IOX_STCP, 1);
-
-	gpio_direction_output(IOX_OE, 1);
-};
-
-void iox74lv_set(int index)
-{
-	int i;
-
-	gpio_direction_output(IOX_OE, 0);
-
-	for (i = 7; i >= 0; i--) {
-		gpio_direction_output(IOX_SHCP, 0);
-
-		if (i == index)
-			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
-		else
-			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
-		udelay(500);
-		gpio_direction_output(IOX_SHCP, 1);
-		udelay(500);
-	}
-
-	gpio_direction_output(IOX_STCP, 0);
-	udelay(500);
-	/*
-	  * shift register will be output to pins
-	  */
-	gpio_direction_output(IOX_STCP, 1);
-
-	for (i = 7; i >= 0; i--) {
-		gpio_direction_output(IOX_SHCP, 0);
-		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
-		udelay(500);
-		gpio_direction_output(IOX_SHCP, 1);
-		udelay(500);
-	}
-
-	gpio_direction_output(IOX_STCP, 0);
-	udelay(500);
-	/*
-	  * shift register will be output to pins
-	  */
-	gpio_direction_output(IOX_STCP, 1);
-
-	gpio_direction_output(IOX_OE, 1);
-};
-
-
-
-#ifdef CONFIG_SYS_I2C_MXC
-#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
-/* I2C1 for PMIC and EEPROM */
-struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode =  MX6_PAD_UART4_TX_DATA__I2C1_SCL | PC,
-		.gpio_mode = MX6_PAD_UART4_TX_DATA__GPIO1_IO28 | PC,
-		.gp = IMX_GPIO_NR(1, 28),
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_UART4_RX_DATA__I2C1_SDA | PC,
-		.gpio_mode = MX6_PAD_UART4_RX_DATA__GPIO1_IO29 | PC,
-		.gp = IMX_GPIO_NR(1, 29),
-	},
-};
-#endif
-
-int dram_init(void)
-{
-	gd->ram_size = PHYS_SDRAM_SIZE;
-
-	return 0;
-}
-
-static iomux_v3_cfg_t const uart1_pads[] = {
-	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usdhc1_pads[] = {
-	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-
-	/* VSELECT */
-	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	/* CD */
-	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* RST_B */
-	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
-static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
-	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-
-	/*
-	 * RST_B
-	 */
-	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-#else
-static iomux_v3_cfg_t const usdhc2_pads[] = {
-	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usdhc2_cd_pads[] = {
-
-	/* The evk board uses DAT3 to detect CD card plugin, in u-boot we mux the pin to
-	  * GPIO when doing board_mmc_getcd.
-	  */
-	MX6_PAD_NAND_DATA03__GPIO4_IO05 | MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usdhc2_dat3_pads[] = {
-	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_DAT3_CD_PAD_CTRL),
-};
-
-
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-static iomux_v3_cfg_t const nand_pads[] = {
-	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-};
-
-static void setup_gpmi_nand(void)
-{
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-
-	/* config gpmi nand iomux */
-	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
-
-	clrbits_le32(&mxc_ccm->CCGR4,
-		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
-
-	/*
-	 * config gpmi and bch clock to 100 MHz
-	 * bch/gpmi select PLL2 PFD2 400M
-	 * 100M = 400M / 4
-	 */
-	clrbits_le32(&mxc_ccm->cscmr1,
-		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
-		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
-	clrsetbits_le32(&mxc_ccm->cscdr1,
-			MXC_CCM_CSCDR1_BCH_PODF_MASK |
-			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
-			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
-			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
-
-	/* enable gpmi and bch clock gating */
-	setbits_le32(&mxc_ccm->CCGR4,
-		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
-		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
-		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
-
-	/* enable apbh clock gating */
-	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
-}
-#endif
-
-#ifdef CONFIG_FEC_MXC
-/*
- * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
- * be used for ENET1 or ENET2, cannot be used for both.
- */
-static iomux_v3_cfg_t const fec1_pads[] = {
-	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
-	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
-	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const fec2_pads[] = {
-	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
-	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
-
-	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
-	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-
-	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
-};
-
-static void setup_iomux_fec(int fec_id)
-{
-	if (fec_id == 0)
-		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
-	else
-		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
-}
-#endif
-
-static void setup_iomux_uart(void)
-{
-	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
-}
-
-#ifdef CONFIG_FSL_QSPI
-
-#define QSPI_PAD_CTRL1	\
-	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
-	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
-
-static iomux_v3_cfg_t const quadspi_pads[] = {
-	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
-};
-
-int board_qspi_init(void)
-{
-	/* Set the iomux */
-	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
-
-	/* Set the clock */
-	enable_qspi_clk(0);
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-static struct fsl_esdhc_cfg usdhc_cfg[2] = {
-	{USDHC1_BASE_ADDR, 0, 4},
-#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
-	{USDHC2_BASE_ADDR, 0, 8},
-#else
-	{USDHC2_BASE_ADDR, 0, 4},
-#endif
-};
-
-#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
-#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
-#define USDHC2_CD_GPIO	IMX_GPIO_NR(4, 5)
-#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
-
-int mmc_get_env_devno(void)
-{
-	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
-	int dev_no;
-	u32 bootsel;
-
-	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
-
-	/* If not boot from sd/mmc, use default value */
-	if (bootsel != 1)
-		return CONFIG_SYS_MMC_ENV_DEV;
-
-	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
-	dev_no = (soc_sbmr & 0x00001800) >> 11;
-
-	return dev_no;
-}
-
-int mmc_map_to_kernel_blk(int dev_no)
-{
-	return dev_no;
-}
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
-	int ret = 0;
-
-	switch (cfg->esdhc_base) {
-	case USDHC1_BASE_ADDR:
-		ret = !gpio_get_value(USDHC1_CD_GPIO);
-		break;
-	case USDHC2_BASE_ADDR:
-#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
-		ret = 1;
-#else
-		imx_iomux_v3_setup_multiple_pads(
-				usdhc2_cd_pads, ARRAY_SIZE(usdhc2_cd_pads));
-		gpio_direction_input(USDHC2_CD_GPIO);
-
-		/* Since it is the DAT3 pin, this pin is pulled to a low voltage if no card */
-		ret = gpio_get_value(USDHC2_CD_GPIO);
-
-		imx_iomux_v3_setup_multiple_pads(
-				usdhc2_dat3_pads, ARRAY_SIZE(usdhc2_dat3_pads));
-#endif
-		break;
-	}
-
-	return ret;
-
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int i, ret;
-
-	/*
-	 * According to the board_mmc_init() the following map is done:
-	 * (U-boot device node)    (Physical Port)
-	 * mmc0                    USDHC1
-	 * mmc1                    USDHC2
-	 */
-	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
-		switch (i) {
-		case 0:
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
-			gpio_direction_input(USDHC1_CD_GPIO);
-			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
-
-			gpio_direction_output(USDHC1_PWR_GPIO, 0);
-			udelay(500);
-			gpio_direction_output(USDHC1_PWR_GPIO, 1);
-			break;
-		case 1:
-#if defined(CONFIG_MX6UL_EVK_EMMC_REWORK)
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
-#else
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
-#endif
-			gpio_direction_output(USDHC2_PWR_GPIO, 0);
-			udelay(500);
-			gpio_direction_output(USDHC2_PWR_GPIO, 1);
-			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
-			break;
-		default:
-			printf("Warning: you configured more USDHC controllers"
-				"(%d) than supported by the board\n", i + 1);
-			return -EINVAL;
-			}
-
-			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
-			if (ret) {
-				printf("Warning: failed to initialize mmc dev %d\n", i);
-				return ret;
-			}
-	}
-
-	return 0;
-}
-
-int check_mmc_autodetect(void)
-{
-	char *autodetect_str = getenv("mmcautodetect");
-
-	if ((autodetect_str != NULL) &&
-		(strcmp(autodetect_str, "yes") == 0)) {
-		return 1;
-	}
-
-	return 0;
-}
-
-void board_late_mmc_init(void)
-{
-	char cmd[32];
-	char mmcblk[32];
-	u32 dev_no = mmc_get_env_devno();
-
-	if (!check_mmc_autodetect())
-		return;
-
-	setenv_ulong("mmcdev", dev_no);
-
-	/* Set mmcblk env */
-	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
-		mmc_map_to_kernel_blk(dev_no));
-	setenv("mmcroot", mmcblk);
-
-	sprintf(cmd, "mmc dev %d", dev_no);
-	run_command(cmd, 0);
-}
-#endif
-
-#ifdef CONFIG_VIDEO_MXS
-static iomux_v3_cfg_t const lcd_pads[] = {
-	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
-
-	/* LCD_RST */
-	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09	| MUX_PAD_CTRL(NO_PAD_CTRL),
-
-	/*
-	 * Use GPIO for Brightness adjustment, duty cycle = period.
-	 */
-	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-struct lcd_panel_info_t {
-	unsigned int lcdif_base_addr;
-	int depth;
-	void (*enable)(struct lcd_panel_info_t const *dev);
-	struct fb_videomode mode;
-};
-
-void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
-{
-	enable_lcdif_clock(dev->lcdif_base_addr);
-
-	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
-
-	/* Reset the LCD */
-	gpio_direction_output(IMX_GPIO_NR(5, 9) , 0);
-	udelay(500);
-	gpio_direction_output(IMX_GPIO_NR(5, 9) , 1);
-
-	/* Set Brightness to high */
-	gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
-}
-
-static struct lcd_panel_info_t const displays[] = {{
-	.lcdif_base_addr = LCDIF1_BASE_ADDR,
-	.depth = 24,
-	.enable	= do_enable_parallel_lcd,
-	.mode	= {
-		.name			= "TFT43AB",
-		.xres           = 480,
-		.yres           = 272,
-		.pixclock       = 108695,
-		.left_margin    = 8,
-		.right_margin   = 4,
-		.upper_margin   = 2,
-		.lower_margin   = 4,
-		.hsync_len      = 41,
-		.vsync_len      = 10,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} } };
-
-int board_video_skip(void)
-{
-	int i;
-	int ret;
-	char const *panel = getenv("panel");
-	if (!panel) {
-		panel = displays[0].mode.name;
-		printf("No panel detected: default to %s\n", panel);
-		i = 0;
-	} else {
-		for (i = 0; i < ARRAY_SIZE(displays); i++) {
-			if (!strcmp(panel, displays[i].mode.name))
-				break;
-		}
-	}
-	if (i < ARRAY_SIZE(displays)) {
-		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
-				    displays[i].lcdif_base_addr);
-		if (!ret) {
-			if (displays[i].enable)
-				displays[i].enable(displays+i);
-			printf("Display: %s (%ux%u)\n",
-			       displays[i].mode.name,
-			       displays[i].mode.xres,
-			       displays[i].mode.yres);
-		} else
-			printf("LCD %s cannot be configured: %d\n",
-			       displays[i].mode.name, ret);
-	} else {
-		printf("unsupported panel %s\n", panel);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FEC_MXC
-int board_eth_init(bd_t *bis)
-{
-	int ret;
-
-	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
-
-	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
-	if (ret)
-		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
-
-	return 0;
-}
-
-static int setup_fec(int fec_id)
-{
-	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
-		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
-	int ret;
-
-	if (0 == fec_id) {
-		/* Use 50M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], set gpr1[17]*/
-		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
-				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
-	} else {
-		/* Use 50M anatop loopback REF_CLK2 for ENET2, clear gpr1[14], set gpr1[18]*/
-		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
-				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
-	}
-
-	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
-	if (ret)
-		return ret;
-
-	enable_enet_clk(1);
-
-	return 0;
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-
-	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
-
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_USB_EHCI_MX6
-#define USB_OTHERREGS_OFFSET	0x800
-#define UCTRL_PWR_POL		(1 << 9)
-
-static iomux_v3_cfg_t const usb_otg_pads[] = {
-	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-/* At default the 3v3 enables the MIC2026 for VBUS power */
-static void setup_usb(void)
-{
-	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
-					 ARRAY_SIZE(usb_otg_pads));
-}
-
-int board_usb_phy_mode(int port)
-{
-	if (port == 1)
-		return USB_INIT_HOST;
-	else
-		return usb_phy_mode(port);
-}
-
-int board_ehci_hcd_init(int port)
-{
-	u32 *usbnc_usb_ctrl;
-
-	if (port > 1)
-		return -EINVAL;
-
-	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
-				 port * 4);
-
-	/* Set Power polarity */
-	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
-
-	return 0;
-}
-#endif
-
-int board_early_init_f(void)
-{
-	setup_iomux_uart();
-
-	return 0;
-}
-
-int board_init(void)
-{
-	/* Address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
-
-	iox74lv_init();
-
-#ifdef CONFIG_SYS_I2C_MXC
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-#endif
-
-#ifdef	CONFIG_FEC_MXC
-	setup_fec(CONFIG_FEC_ENET_DEV);
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-	setup_gpmi_nand();
-#endif
-
-#ifdef CONFIG_USB_EHCI_MX6
-	setup_usb();
-#endif
-
-#ifdef CONFIG_FSL_QSPI
-	board_qspi_init();
-#endif
-
-	return 0;
-}
-
-#ifdef CONFIG_CMD_BMODE
-static const struct boot_mode board_boot_modes[] = {
-	/* 4 bit bus width */
-	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
-	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
-	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
-	{NULL,	 0},
-};
-#endif
-
-int board_late_init(void)
-{
-#ifdef CONFIG_CMD_BMODE
-	add_board_boot_modes(board_boot_modes);
-#endif
-
-#ifdef CONFIG_ENV_IS_IN_MMC
-	board_late_mmc_init();
-#endif
-
-	return 0;
-}
-
-u32 get_board_rev(void)
-{
-	return get_cpu_rev();
-}
-
-int checkboard(void)
-{
-	puts("Board: MX6UL EVK\n");
-
-	return 0;
-}
-
-#ifdef CONFIG_FASTBOOT
-
-void board_fastboot_setup(void)
-{
-	switch (get_boot_device()) {
-#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
-	case SD1_BOOT:
-	case MMC1_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "mmc0");
-		if (!getenv("bootcmd"))
-			setenv("bootcmd", "booti mmc0");
-		break;
-	case SD2_BOOT:
-	case MMC2_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "mmc1");
-		if (!getenv("bootcmd"))
-			setenv("bootcmd", "booti mmc1");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
-#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-	case NAND_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "nand");
-		if (!getenv("fbparts"))
-			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
-		if (!getenv("bootcmd"))
-			setenv("bootcmd",
-				"nand read ${loadaddr} ${boot_nand_offset} "
-				"${boot_nand_size};booti ${loadaddr}");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
-
-	default:
-		printf("unsupported boot devices\n");
-		break;
-	}
-}
-
-#ifdef CONFIG_ANDROID_RECOVERY
-int check_recovery_cmd_file(void)
-{
-	int recovery_mode = 0;
-
-	recovery_mode = recovery_check_and_clean_flag();
-
-	return recovery_mode;
-}
-
-void board_recovery_setup(void)
-{
-	int bootdev = get_boot_device();
-
-	switch (bootdev) {
-#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
-	case SD1_BOOT:
-	case MMC1_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery", "booti mmc0 recovery");
-		break;
-	case SD2_BOOT:
-	case MMC2_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery", "booti mmc1 recovery");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
-#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-	case NAND_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery",
-				"nand read ${loadaddr} ${recovery_nand_offset} "
-				"${recovery_nand_size};booti ${loadaddr}");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
-
-	default:
-		printf("Unsupported bootup device for recovery: dev: %d\n",
-			bootdev);
-		return;
-	}
-
-	printf("setup env for recovery..\n");
-	setenv("bootcmd", "run bootcmd_android_recovery");
-}
-#endif /*CONFIG_ANDROID_RECOVERY*/
-
-#endif /*CONFIG_FASTBOOT*/
-
-#ifdef CONFIG_IMX_UDC
-static iomux_v3_cfg_t const otg_udc_pads[] = {
-	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-void udc_pins_setting(void)
-{
-	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
-		ARRAY_SIZE(otg_udc_pads));
-}
-
-#endif /*CONFIG_IMX_UDC*/
diff --git a/board/freescale/mx6ulevk/plugin.S b/board/freescale/mx6ulevk/plugin.S
deleted file mode 100644
index 13b6963..0000000
--- a/board/freescale/mx6ulevk/plugin.S
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <config.h>
-
-/* DDR script */
-.macro imx6ul_ddr3_arm2_setting
-	ldr r0, =IOMUXC_BASE_ADDR
-	ldr r1, =0x000C0000
-	str r1, [r0, #0x4B4]
-	ldr r1, =0x00000000
-	str r1, [r0, #0x4AC]
-	ldr r1, =0x00000030
-	str r1, [r0, #0x27C]
-	str r1, [r0, #0x250]
-	str r1, [r0, #0x24C]
-	str r1, [r0, #0x490]
-	str r1, [r0, #0x288]
-
-	ldr r1, =0x00000000
-	str r1, [r0, #0x270]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x260]
-	str r1, [r0, #0x264]
-	str r1, [r0, #0x4A0]
-
-	ldr r1, =0x00020000
-	str r1, [r0, #0x494]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x280]
-	str r1, [r0, #0x284]
-
-	ldr r1, =0x00020000
-	str r1, [r0, #0x4B0]
-
-	ldr r1, =0x00000030
-	str r1, [r0, #0x498]
-	str r1, [r0, #0x4A4]
-	str r1, [r0, #0x244]
-	str r1, [r0, #0x248]
-
-	ldr r0, =MMDC_P0_BASE_ADDR
-	ldr r1, =0x00008000
-	str r1, [r0, #0x1C]
-	ldr r1, =0xA1390003
-	str r1, [r0, #0x800]
-	ldr r1, =0x00000000
-	str r1, [r0, #0x80C]
-	ldr r1, =0x41490145
-	str r1, [r0, #0x83C]
-	ldr r1, =0x40404546
-	str r1, [r0, #0x848]
-	ldr r1, =0x4040524D
-	str r1, [r0, #0x850]
-	ldr r1, =0x33333333
-	str r1, [r0, #0x81C]
-	str r1, [r0, #0x820]
-	ldr r1, =0xF3333333
-	str r1, [r0, #0x82C]
-	str r1, [r0, #0x830]
-	ldr r1, =0x00922012
-	str r1, [r0, #0x8C0]
-	ldr r1, =0x00000800
-	str r1, [r0, #0x8B8]
-	ldr r1, =0x0002002D
-	str r1, [r0, #0x004]
-	ldr r1, =0x1B333000
-	str r1, [r0, #0x008]
-	ldr r1, =0x676B54F3
-	str r1, [r0, #0x00C]
-	ldr r1, =0xB68E0A83
-	str r1, [r0, #0x010]
-	ldr r1, =0x01FF00DB
-	str r1, [r0, #0x014]
-	ldr r1, =0x00211740
-	str r1, [r0, #0x018]
-	ldr r1, =0x00008000
-	str r1, [r0, #0x01C]
-	ldr r1, =0x000026D2
-	str r1, [r0, #0x02C]
-	ldr r1, =0x006B1023
-	str r1, [r0, #0x030]
-	ldr r1, =0x0000004F
-	str r1, [r0, #0x040]
-	ldr r1, =0x84180000
-	str r1, [r0, #0x000]
-	ldr r1, =0x02008032
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00008033
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00048031
-	str r1, [r0, #0x01C]
-	ldr r1, =0x15208030
-	str r1, [r0, #0x01C]
-	ldr r1, =0x04008040
-	str r1, [r0, #0x01C]
-	ldr r1, =0x00000800
-	str r1, [r0, #0x020]
-	ldr r1, =0x00000227
-	str r1, [r0, #0x818]
-	ldr r1, =0x0002552D
-	str r1, [r0, #0x004]
-	ldr r1, =0x00011006
-	str r1, [r0, #0x404]
-	ldr r1, =0x00000000
-	str r1, [r0, #0x01C]
-.endm
-
-.macro imx6_clock_gating
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #0x68]
-	str r1, [r0, #0x6C]
-	str r1, [r0, #0x70]
-	str r1, [r0, #0x74]
-	str r1, [r0, #0x78]
-	str r1, [r0, #0x7C]
-	str r1, [r0, #0x80]
-	str r1, [r0, #0x84]
-.endm
-
-.macro imx6_qos_setting
-.endm
-
-.macro imx6_ddr_setting
-	imx6ul_ddr3_arm2_setting
-.endm
-
-/* include the common plugin code here */
-#include <asm/arch/mx6_plugin.S>
diff --git a/configs/mx6ul_14x14_ddr3_arm2_defconfig b/configs/mx6ul_14x14_ddr3_arm2_defconfig
new file mode 100644
index 0000000..0828836
--- /dev/null
+++ b/configs/mx6ul_14x14_ddr3_arm2_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig b/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig
new file mode 100644
index 0000000..686f05c
--- /dev/null
+++ b/configs/mx6ul_14x14_ddr3_arm2_eimnor_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_EIMNOR"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig b/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig
new file mode 100644
index 0000000..71fdbd4
--- /dev/null
+++ b/configs/mx6ul_14x14_ddr3_arm2_nand_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_NAND"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig b/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig
new file mode 100644
index 0000000..d893762
--- /dev/null
+++ b/configs/mx6ul_14x14_ddr3_arm2_qspi1_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig b/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig
new file mode 100644
index 0000000..f137e01
--- /dev/null
+++ b/configs/mx6ul_14x14_ddr3_arm2_spinor_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_SPINOR"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_android_defconfig b/configs/mx6ul_14x14_evk_android_defconfig
new file mode 100644
index 0000000..53f39d5
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_android_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,ANDROID_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_defconfig b/configs/mx6ul_14x14_evk_defconfig
new file mode 100644
index 0000000..98d01c6
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_qspi1_defconfig b/configs/mx6ul_14x14_evk_qspi1_defconfig
new file mode 100644
index 0000000..6344e88
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_qspi1_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_ddr3_arm2_defconfig b/configs/mx6ul_ddr3_arm2_defconfig
deleted file mode 100644
index 8903a45..0000000
--- a/configs/mx6ul_ddr3_arm2_defconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_ddr3_arm2/imximage.cfg,MX6UL"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_DDR3_ARM2=y
-CONFIG_SYS_MALLOC_F=y
-CONFIG_SYS_MALLOC_F_LEN=0x400
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_ddr3_arm2_eimnor_defconfig b/configs/mx6ul_ddr3_arm2_eimnor_defconfig
deleted file mode 100644
index ba65814..0000000
--- a/configs/mx6ul_ddr3_arm2_eimnor_defconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_EIMNOR"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_DDR3_ARM2=y
-CONFIG_SYS_MALLOC_F=y
-CONFIG_SYS_MALLOC_F_LEN=0x400
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_ddr3_arm2_nand_defconfig b/configs/mx6ul_ddr3_arm2_nand_defconfig
deleted file mode 100644
index 0d31e69..0000000
--- a/configs/mx6ul_ddr3_arm2_nand_defconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_NAND"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_DDR3_ARM2=y
-CONFIG_SYS_MALLOC_F=y
-CONFIG_SYS_MALLOC_F_LEN=0x400
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_ddr3_arm2_qspi1_defconfig b/configs/mx6ul_ddr3_arm2_qspi1_defconfig
deleted file mode 100644
index 1d59f3a..0000000
--- a/configs/mx6ul_ddr3_arm2_qspi1_defconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_QSPI"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_DDR3_ARM2=y
-CONFIG_SYS_MALLOC_F=y
-CONFIG_SYS_MALLOC_F_LEN=0x400
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_ddr3_arm2_spinor_defconfig b/configs/mx6ul_ddr3_arm2_spinor_defconfig
deleted file mode 100644
index 0672e0b..0000000
--- a/configs/mx6ul_ddr3_arm2_spinor_defconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_ddr3_arm2/imximage.cfg,MX6UL,SYS_BOOT_SPINOR"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_DDR3_ARM2=y
-CONFIG_SYS_MALLOC_F=y
-CONFIG_SYS_MALLOC_F_LEN=0x400
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ulevk_defconfig b/configs/mx6ulevk_defconfig
deleted file mode 100644
index 282e86d..0000000
--- a/configs/mx6ulevk_defconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ulevk/imximage.cfg,MX6UL"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6ULEVK=y
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ulevk_qspi1_defconfig b/configs/mx6ulevk_qspi1_defconfig
deleted file mode 100644
index a826ca5..0000000
--- a/configs/mx6ulevk_qspi1_defconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ulevk/imximage.cfg,MX6UL,SYS_BOOT_QSPI"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6ULEVK=y
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ulevkandroid_defconfig b/configs/mx6ulevkandroid_defconfig
deleted file mode 100644
index 69b241d..0000000
--- a/configs/mx6ulevkandroid_defconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ulevk/imximage.cfg,MX6UL,ANDROID_SUPPORT"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6ULEVK=y
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/include/configs/mx6ul_14x14_ddr3_arm2.h b/include/configs/mx6ul_14x14_ddr3_arm2.h
new file mode 100644
index 0000000..0148f6c
--- /dev/null
+++ b/include/configs/mx6ul_14x14_ddr3_arm2.h
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 DDR3 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6UL_14X14_DDR3_ARM2_CONFIG_H
+#define __MX6UL_14X14_DDR3_ARM2_CONFIG_H
+
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_NET
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+#endif
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_VIDEO
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=MCIMX28LCD\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6ul-14x14-ddr3-arm2.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 26)<<8))
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE	(128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 1024   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_USDHC
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+
+#endif
diff --git a/include/configs/mx6ul_14x14_evk.h b/include/configs/mx6ul_14x14_evk.h
new file mode 100644
index 0000000..dde1463
--- /dev/null
+++ b/include/configs/mx6ul_14x14_evk.h
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6UL_14X14_EVK_CONFIG_H
+#define __MX6UL_14X14_EVK_CONFIG_H
+
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* DCDC used on EVK, no PMIC */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_USDHC
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#endif
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_NET
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1  /* need board rework */
+#define CONFIG_FEC_XCV_TYPE             RMII
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+#endif
+
+#define PHYS_SDRAM_SIZE			SZ_512M
+
+#define CONFIG_VIDEO
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=TFT43AB\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6ul-14x14-evk.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6ul_14x14_evk_android.h"
+#endif
+
+#endif
diff --git a/include/configs/mx6ul_14x14_evk_android.h b/include/configs/mx6ul_14x14_evk_android.h
new file mode 100644
index 0000000..f44145a
--- /dev/null
+++ b/include/configs/mx6ul_14x14_evk_android.h
@@ -0,0 +1,62 @@
+
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6UL_EVK_ANDROID_H
+#define __MX6UL_EVK_ANDROID_H
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_USB_DEVICE
+#define CONFIG_IMX_UDC		       1
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_FASTBOOT		       1
+#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
+#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
+#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
+#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
+#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.MX6UL EVK Board"
+#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
+#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
+#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
+#define CONFIG_FASTBOOT_SATA_NO		 0
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+
+/*  For system.img growing up more than 256MB, more buffer needs
+*   to receive the system.img*/
+#define CONFIG_FASTBOOT_TRANSFER_BUF	0x84000000
+#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
+
+
+#define CONFIG_CMD_BOOTI
+#define CONFIG_ANDROID_RECOVERY
+/* which mmc bus is your main storage ? */
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#endif
diff --git a/include/configs/mx6ul_ddr3_arm2.h b/include/configs/mx6ul_ddr3_arm2.h
deleted file mode 100644
index 318c3c8..0000000
--- a/include/configs/mx6ul_ddr3_arm2.h
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * Configuration settings for the Freescale i.MX7.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#ifndef __MX6UL_DDR3_ARM2_CONFIG_H
-#define __MX6UL_DDR3_ARM2_CONFIG_H
-
-
-#include <asm/arch/imx-regs.h>
-#include <linux/sizes.h>
-#include "mx6_common.h"
-#include <asm/imx-common/gpio.h>
-
-#define CONFIG_MX6
-#define CONFIG_ROM_UNIFIED_SECTIONS
-#define CONFIG_SYS_GENERIC_BOARD
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-/* uncomment for PLUGIN mode support */
-/* #define CONFIG_USE_PLUGIN */
-
-/* uncomment for SECURE mode support */
-/* #define CONFIG_SECURE_BOOT */
-
-#define CONFIG_CMDLINE_TAG
-#define CONFIG_SETUP_MEMORY_TAGS
-#define CONFIG_INITRD_TAG
-#define CONFIG_REVISION_TAG
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
-
-#define CONFIG_BOARD_EARLY_INIT_F
-#define CONFIG_BOARD_LATE_INIT
-#define CONFIG_MXC_GPIO
-
-#define CONFIG_MXC_UART
-#define CONFIG_MXC_UART_BASE		UART1_BASE
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-#define CONFIG_BAUDRATE			115200
-
-#define CONFIG_CMD_FUSE
-#ifdef CONFIG_CMD_FUSE
-#define CONFIG_MXC_OCOTP
-#endif
-
-#undef CONFIG_BOOTM_NETBSD
-#undef CONFIG_BOOTM_PLAN9
-#undef CONFIG_BOOTM_RTEMS
-
-#undef CONFIG_CMD_EXPORTENV
-#undef CONFIG_CMD_IMPORTENV
-
-#define CONFIG_CMD_NET
-#ifdef CONFIG_CMD_NET
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define CONFIG_FEC_ENET_DEV 1
-
-#if (CONFIG_FEC_ENET_DEV == 0)
-#define IMX_FEC_BASE			ENET_BASE_ADDR
-#define CONFIG_FEC_MXC_PHYADDR          0x1
-#define CONFIG_FEC_XCV_TYPE             RMII
-#elif (CONFIG_FEC_ENET_DEV == 1)
-#define IMX_FEC_BASE			ENET2_BASE_ADDR
-#define CONFIG_FEC_MXC_PHYADDR          0x2
-#define CONFIG_FEC_XCV_TYPE             MII100
-#endif
-#define CONFIG_ETHPRIME                 "FEC"
-
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_MICREL
-#define CONFIG_FEC_DMA_MINALIGN		64
-#endif
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-
-/* I2C configs */
-#define CONFIG_CMD_I2C
-#ifdef CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_SPEED		100000
-
-/* PMIC */
-#define CONFIG_POWER
-#define CONFIG_POWER_I2C
-#define CONFIG_POWER_PFUZE100
-#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
-#endif
-
-#define PHYS_SDRAM_SIZE			SZ_1G
-
-#define CONFIG_VIDEO
-
-/* Command definition */
-#include <config_cmd_default.h>
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_BOOTDELAY		3
-
-#define CONFIG_LOADADDR			0x80800000
-#define CONFIG_SYS_TEXT_BASE		0x87800000
-
-#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
-#ifdef CONFIG_SYS_BOOT_NAND
-#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
-#else
-#define CONFIG_MFG_NAND_PARTITION ""
-#endif
-
-#ifdef CONFIG_VIDEO
-#define CONFIG_VIDEO_MODE \
-	"panel=MCIMX28LCD\0"
-#else
-#define CONFIG_VIDEO_MODE ""
-#endif
-
-#define CONFIG_MFG_ENV_SETTINGS \
-	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
-		"rdinit=/linuxrc " \
-		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
-		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
-		"g_mass_storage.iSerialNumber=\"\" "\
-		CONFIG_MFG_NAND_PARTITION \
-		"clk_ignore_unused "\
-		"\0" \
-	"initrd_addr=0x83800000\0" \
-	"initrd_high=0xffffffff\0" \
-	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
-
-#if defined(CONFIG_SYS_BOOT_NAND)
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	CONFIG_MFG_ENV_SETTINGS \
-	CONFIG_VIDEO_MODE \
-	"fdt_addr=0x83000000\0" \
-	"fdt_high=0xffffffff\0"	  \
-	"console=ttymxc0\0" \
-	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
-		"root=ubi0:rootfs rootfstype=ubifs "		     \
-		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
-	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
-		"nand read ${fdt_addr} 0x5000000 0x100000;"\
-		"bootz ${loadaddr} - ${fdt_addr}\0"
-
-#else
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	CONFIG_MFG_ENV_SETTINGS \
-	CONFIG_VIDEO_MODE \
-	"script=boot.scr\0" \
-	"image=zImage\0" \
-	"console=ttymxc0\0" \
-	"fdt_high=0xffffffff\0" \
-	"initrd_high=0xffffffff\0" \
-	"fdt_file=imx6ul-ddr3-arm2.dtb\0" \
-	"fdt_addr=0x83000000\0" \
-	"boot_fdt=try\0" \
-	"ip_dyn=yes\0" \
-	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
-	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
-	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
-	"mmcautodetect=yes\0" \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
-		"root=${mmcroot}\0" \
-	"loadbootscript=" \
-		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
-	"bootscript=echo Running bootscript from mmc ...; " \
-		"source\0" \
-	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
-	"mmcboot=echo Booting from mmc ...; " \
-		"run mmcargs; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootz; " \
-		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
-		"root=/dev/nfs " \
-	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
-		"netboot=echo Booting from net ...; " \
-		"run netargs; " \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"${get_cmd} ${image}; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootz; " \
-		"fi;\0"
-
-#define CONFIG_BOOTCOMMAND \
-	   "mmc dev ${mmcdev};" \
-	   "mmc dev ${mmcdev}; if mmc rescan; then " \
-		   "if run loadbootscript; then " \
-			   "run bootscript; " \
-		   "else " \
-			   "if run loadimage; then " \
-				   "run mmcboot; " \
-			   "else run netboot; " \
-			   "fi; " \
-		   "fi; " \
-	   "else run netboot; fi"
-#endif
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP
-#define CONFIG_SYS_HUSH_PARSER
-#define CONFIG_SYS_PROMPT		"=> "
-#define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		1024
-
-/* Print Buffer Size */
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		256
-#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
-
-#define CONFIG_CMD_MEMTEST
-#define CONFIG_SYS_MEMTEST_START	0x80000000
-#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-#define CONFIG_SYS_HZ			1000
-
-#define CONFIG_CMDLINE_EDITING
-#define CONFIG_STACKSIZE		SZ_128K
-
-/* Physical Memory Map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
-
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* FLASH and environment organization */
-#define CONFIG_SYS_NO_FLASH
-
-#define CONFIG_ENV_SIZE			SZ_8K
-
-#ifdef CONFIG_SYS_BOOT_QSPI
-#define CONFIG_SYS_USE_QSPI
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#elif defined CONFIG_SYS_BOOT_SPINOR
-#define CONFIG_SYS_USE_SPINOR
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#elif defined CONFIG_SYS_BOOT_EIMNOR
-#define CONFIG_SYS_USE_EIMNOR
-#define CONFIG_ENV_IS_IN_FLASH
-#elif defined CONFIG_SYS_BOOT_NAND
-#define CONFIG_SYS_USE_NAND
-#define CONFIG_ENV_IS_IN_NAND
-#else
-#define CONFIG_SYS_USE_QSPI
-#define CONFIG_ENV_IS_IN_MMC
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-#define CONFIG_CMD_NAND
-#define CONFIG_CMD_NAND_TRIMFFS
-
-/* NAND stuff */
-#define CONFIG_NAND_MXS
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_SYS_NAND_BASE		0x40000000
-#define CONFIG_SYS_NAND_5_ADDR_CYCLE
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* DMA stuff, needed for GPMI/MXS NAND support */
-#define CONFIG_APBH_DMA
-#define CONFIG_APBH_DMA_BURST
-#define CONFIG_APBH_DMA_BURST8
-#endif
-
-#ifdef CONFIG_SYS_USE_SPINOR
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
-#define CONFIG_MXC_SPI
-#define CONFIG_SF_DEFAULT_BUS  0
-#define CONFIG_SF_DEFAULT_SPEED 20000000
-#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
-#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 26)<<8))
-#endif
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-#undef CONFIG_SYS_NO_FLASH
-#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
-#define CONFIG_SYS_FLASH_SECT_SIZE	(128 * 1024)
-#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
-#define CONFIG_SYS_MAX_FLASH_SECT 1024   /* max number of sectors on one chip */
-#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
-#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#endif
-
-#ifdef CONFIG_SYS_USE_QSPI
-#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
-#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
-#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
-
-#define CONFIG_CMD_SF
-#define	CONFIG_SPI_FLASH
-#define	CONFIG_SPI_FLASH_STMICRO
-#define	CONFIG_SPI_FLASH_BAR
-#define	CONFIG_SF_DEFAULT_BUS		0
-#define	CONFIG_SF_DEFAULT_CS		0
-#define	CONFIG_SF_DEFAULT_SPEED		40000000
-#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#endif
-
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
-#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
-#define CONFIG_ENV_OFFSET		(768 * 1024)
-#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
-#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
-#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
-#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
-#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
-#elif defined(CONFIG_ENV_IS_IN_FLASH)
-#undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
-#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
-#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
-#elif defined(CONFIG_ENV_IS_IN_NAND)
-#undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(8 << 20)
-#define CONFIG_ENV_SECT_SIZE		(128 << 10)
-#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
-#endif
-
-/* MMC Configs */
-#define CONFIG_FSL_USDHC
-#ifdef CONFIG_FSL_USDHC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR	0
-
-#ifdef CONFIG_SYS_USE_NAND
-#define CONFIG_SYS_FSL_USDHC_NUM	1
-#else
-#define CONFIG_SYS_FSL_USDHC_NUM	2
-#endif
-
-#define CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
-#endif
-
-#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
-#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
-#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
-
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
-
-#define CONFIG_CMD_BMODE
-
-#ifndef CONFIG_SYS_DCACHE_OFF
-#define CONFIG_CMD_CACHE
-#endif
-
-#ifdef CONFIG_VIDEO
-#define	CONFIG_CFB_CONSOLE
-#define	CONFIG_VIDEO_MXS
-#define	CONFIG_VIDEO_LOGO
-#define	CONFIG_VIDEO_SW_CURSOR
-#define	CONFIG_VGA_AS_SINGLE_DEVICE
-#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define	CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define	CONFIG_CMD_BMP
-#define	CONFIG_BMP_16BPP
-#define	CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_VIDEO_BMP_LOGO
-#endif
-
-/* USB Configs */
-#define CONFIG_CMD_USB
-#ifdef CONFIG_CMD_USB
-#define CONFIG_USB_EHCI
-#define CONFIG_USB_EHCI_MX6
-#define CONFIG_USB_STORAGE
-#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
-#define CONFIG_USB_HOST_ETHER
-#define CONFIG_USB_ETHER_ASIX
-#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
-#define CONFIG_MXC_USB_FLAGS   0
-#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
-#endif
-
-#endif
diff --git a/include/configs/mx6ulevk.h b/include/configs/mx6ulevk.h
deleted file mode 100644
index 4dce52c..0000000
--- a/include/configs/mx6ulevk.h
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * Configuration settings for the Freescale i.MX6UL EVK board.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#ifndef __MX6UL_EVK_CONFIG_H
-#define __MX6UL_EVK_CONFIG_H
-
-
-#include <asm/arch/imx-regs.h>
-#include <linux/sizes.h>
-#include "mx6_common.h"
-#include <asm/imx-common/gpio.h>
-
-#define CONFIG_MX6
-#define CONFIG_ROM_UNIFIED_SECTIONS
-#define CONFIG_SYS_GENERIC_BOARD
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-/* DCDC used on EVK, no PMIC */
-#undef CONFIG_LDO_BYPASS_CHECK
-
-/* uncomment for PLUGIN mode support */
-/* #define CONFIG_USE_PLUGIN */
-
-/* uncomment for SECURE mode support */
-/* #define CONFIG_SECURE_BOOT */
-
-#define CONFIG_CMDLINE_TAG
-#define CONFIG_SETUP_MEMORY_TAGS
-#define CONFIG_INITRD_TAG
-#define CONFIG_REVISION_TAG
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
-
-#define CONFIG_BOARD_EARLY_INIT_F
-#define CONFIG_BOARD_LATE_INIT
-#define CONFIG_MXC_GPIO
-
-#define CONFIG_MXC_UART
-#define CONFIG_MXC_UART_BASE		UART1_BASE
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-#define CONFIG_BAUDRATE			115200
-
-#define CONFIG_CMD_FUSE
-#ifdef CONFIG_CMD_FUSE
-#define CONFIG_MXC_OCOTP
-#endif
-
-/* MMC Configs */
-#define CONFIG_FSL_USDHC
-#ifdef CONFIG_FSL_USDHC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
-
-#ifdef CONFIG_SYS_USE_NAND
-#define CONFIG_SYS_FSL_USDHC_NUM	1
-#else
-#define CONFIG_SYS_FSL_USDHC_NUM	2
-#endif
-
-#define CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
-#endif
-
-#undef CONFIG_BOOTM_NETBSD
-#undef CONFIG_BOOTM_PLAN9
-#undef CONFIG_BOOTM_RTEMS
-
-#undef CONFIG_CMD_EXPORTENV
-#undef CONFIG_CMD_IMPORTENV
-
-#define CONFIG_CMD_NET
-#ifdef CONFIG_CMD_NET
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define CONFIG_FEC_ENET_DEV 1
-
-#if (CONFIG_FEC_ENET_DEV == 0)
-#define IMX_FEC_BASE			ENET_BASE_ADDR
-#define CONFIG_FEC_MXC_PHYADDR          0x2
-#define CONFIG_FEC_XCV_TYPE             RMII
-#elif (CONFIG_FEC_ENET_DEV == 1)
-#define IMX_FEC_BASE			ENET2_BASE_ADDR
-#define CONFIG_FEC_MXC_PHYADDR          0x1  /* need board rework */
-#define CONFIG_FEC_XCV_TYPE             RMII
-#endif
-#define CONFIG_ETHPRIME                 "FEC"
-
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_MICREL
-#define CONFIG_FEC_DMA_MINALIGN		64
-#endif
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-
-/* I2C configs */
-#define CONFIG_CMD_I2C
-#ifdef CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_SPEED		100000
-#endif
-
-#define PHYS_SDRAM_SIZE			SZ_512M
-
-#define CONFIG_VIDEO
-
-/* Command definition */
-#include <config_cmd_default.h>
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_BOOTDELAY		3
-
-#define CONFIG_LOADADDR			0x80800000
-#define CONFIG_SYS_TEXT_BASE		0x87800000
-
-#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
-#ifdef CONFIG_SYS_BOOT_NAND
-#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
-#else
-#define CONFIG_MFG_NAND_PARTITION ""
-#endif
-
-#ifdef CONFIG_VIDEO
-#define CONFIG_VIDEO_MODE \
-	"panel=TFT43AB\0"
-#else
-#define CONFIG_VIDEO_MODE ""
-#endif
-
-#define CONFIG_MFG_ENV_SETTINGS \
-	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
-		"rdinit=/linuxrc " \
-		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
-		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
-		"g_mass_storage.iSerialNumber=\"\" "\
-		CONFIG_MFG_NAND_PARTITION \
-		"clk_ignore_unused "\
-		"\0" \
-	"initrd_addr=0x83800000\0" \
-	"initrd_high=0xffffffff\0" \
-	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
-
-#if defined(CONFIG_SYS_BOOT_NAND)
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	CONFIG_MFG_ENV_SETTINGS \
-	CONFIG_VIDEO_MODE \
-	"fdt_addr=0x83000000\0" \
-	"fdt_high=0xffffffff\0"	  \
-	"console=ttymxc0\0" \
-	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
-		"root=ubi0:rootfs rootfstype=ubifs "		     \
-		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
-	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
-		"nand read ${fdt_addr} 0x5000000 0x100000;"\
-		"bootz ${loadaddr} - ${fdt_addr}\0"
-
-#else
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	CONFIG_MFG_ENV_SETTINGS \
-	CONFIG_VIDEO_MODE \
-	"script=boot.scr\0" \
-	"image=zImage\0" \
-	"console=ttymxc0\0" \
-	"fdt_high=0xffffffff\0" \
-	"initrd_high=0xffffffff\0" \
-	"fdt_file=imx6ul-evk.dtb\0" \
-	"fdt_addr=0x83000000\0" \
-	"boot_fdt=try\0" \
-	"ip_dyn=yes\0" \
-	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
-	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
-	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
-	"mmcautodetect=yes\0" \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
-		"root=${mmcroot}\0" \
-	"loadbootscript=" \
-		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
-	"bootscript=echo Running bootscript from mmc ...; " \
-		"source\0" \
-	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
-	"mmcboot=echo Booting from mmc ...; " \
-		"run mmcargs; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootz; " \
-		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
-		"root=/dev/nfs " \
-	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
-		"netboot=echo Booting from net ...; " \
-		"run netargs; " \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"${get_cmd} ${image}; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootz; " \
-		"fi;\0"
-
-#define CONFIG_BOOTCOMMAND \
-	   "mmc dev ${mmcdev};" \
-	   "mmc dev ${mmcdev}; if mmc rescan; then " \
-		   "if run loadbootscript; then " \
-			   "run bootscript; " \
-		   "else " \
-			   "if run loadimage; then " \
-				   "run mmcboot; " \
-			   "else run netboot; " \
-			   "fi; " \
-		   "fi; " \
-	   "else run netboot; fi"
-#endif
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP
-#define CONFIG_SYS_HUSH_PARSER
-#define CONFIG_SYS_PROMPT		"=> "
-#define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		1024
-
-/* Print Buffer Size */
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		256
-#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
-
-#define CONFIG_CMD_MEMTEST
-#define CONFIG_SYS_MEMTEST_START	0x80000000
-#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000000)
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-#define CONFIG_SYS_HZ			1000
-
-#define CONFIG_CMDLINE_EDITING
-#define CONFIG_STACKSIZE		SZ_128K
-
-/* Physical Memory Map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
-
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* FLASH and environment organization */
-#define CONFIG_SYS_NO_FLASH
-
-#define CONFIG_ENV_SIZE			SZ_8K
-
-#ifdef CONFIG_SYS_BOOT_QSPI
-#define CONFIG_FSL_QSPI
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#elif defined CONFIG_SYS_BOOT_NAND
-#define CONFIG_SYS_USE_NAND
-#define CONFIG_ENV_IS_IN_NAND
-#else
-#define CONFIG_FSL_QSPI
-#define CONFIG_ENV_IS_IN_MMC
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-#define CONFIG_CMD_NAND
-#define CONFIG_CMD_NAND_TRIMFFS
-
-/* NAND stuff */
-#define CONFIG_NAND_MXS
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_SYS_NAND_BASE		0x40000000
-#define CONFIG_SYS_NAND_5_ADDR_CYCLE
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* DMA stuff, needed for GPMI/MXS NAND support */
-#define CONFIG_APBH_DMA
-#define CONFIG_APBH_DMA_BURST
-#define CONFIG_APBH_DMA_BURST8
-#endif
-
-#ifdef CONFIG_FSL_QSPI
-#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
-#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
-
-#define CONFIG_CMD_SF
-#define	CONFIG_SPI_FLASH
-#define	CONFIG_SPI_FLASH_STMICRO
-#define	CONFIG_SPI_FLASH_BAR
-#define	CONFIG_SF_DEFAULT_BUS		0
-#define	CONFIG_SF_DEFAULT_CS		0
-#define	CONFIG_SF_DEFAULT_SPEED		40000000
-#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#endif
-
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
-#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
-#define CONFIG_ENV_OFFSET		(768 * 1024)
-#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
-#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
-#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
-#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
-#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
-#elif defined(CONFIG_ENV_IS_IN_NAND)
-#undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(8 << 20)
-#define CONFIG_ENV_SECT_SIZE		(128 << 10)
-#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
-#endif
-
-#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
-#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
-#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
-
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
-
-#define CONFIG_CMD_BMODE
-
-#ifndef CONFIG_SYS_DCACHE_OFF
-#define CONFIG_CMD_CACHE
-#endif
-
-#ifdef CONFIG_VIDEO
-#define	CONFIG_CFB_CONSOLE
-#define	CONFIG_VIDEO_MXS
-#define	CONFIG_VIDEO_LOGO
-#define	CONFIG_VIDEO_SW_CURSOR
-#define	CONFIG_VGA_AS_SINGLE_DEVICE
-#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define	CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define	CONFIG_CMD_BMP
-#define	CONFIG_BMP_16BPP
-#define	CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_VIDEO_BMP_LOGO
-#endif
-
-/* USB Configs */
-#define CONFIG_CMD_USB
-#ifdef CONFIG_CMD_USB
-#define CONFIG_USB_EHCI
-#define CONFIG_USB_EHCI_MX6
-#define CONFIG_USB_STORAGE
-#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
-#define CONFIG_USB_HOST_ETHER
-#define CONFIG_USB_ETHER_ASIX
-#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
-#define CONFIG_MXC_USB_FLAGS   0
-#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
-#endif
-
-#if defined(CONFIG_ANDROID_SUPPORT)
-#include "mx6ulevkandroid.h"
-#endif
-
-#endif
diff --git a/include/configs/mx6ulevkandroid.h b/include/configs/mx6ulevkandroid.h
deleted file mode 100644
index f44145a..0000000
--- a/include/configs/mx6ulevkandroid.h
+++ /dev/null
@@ -1,62 +0,0 @@
-
-/*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __MX6UL_EVK_ANDROID_H
-#define __MX6UL_EVK_ANDROID_H
-
-#define CONFIG_SERIAL_TAG
-
-#define CONFIG_USB_DEVICE
-#define CONFIG_IMX_UDC		       1
-
-#define CONFIG_CMD_FASTBOOT
-#define CONFIG_FASTBOOT		       1
-#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
-#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
-#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
-#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
-#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.MX6UL EVK Board"
-#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
-#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
-#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
-#define CONFIG_FASTBOOT_SATA_NO		 0
-
-#if defined CONFIG_SYS_BOOT_NAND
-#define CONFIG_FASTBOOT_STORAGE_NAND
-#else
-#define CONFIG_FASTBOOT_STORAGE_MMC
-#endif
-
-
-/*  For system.img growing up more than 256MB, more buffer needs
-*   to receive the system.img*/
-#define CONFIG_FASTBOOT_TRANSFER_BUF	0x84000000
-#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
-
-
-#define CONFIG_CMD_BOOTI
-#define CONFIG_ANDROID_RECOVERY
-/* which mmc bus is your main storage ? */
-#define CONFIG_ANDROID_MAIN_MMC_BUS 2
-#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
-#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
-#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
-#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
-
-#undef CONFIG_EXTRA_ENV_SETTINGS
-#undef CONFIG_BOOTCOMMAND
-
-#define CONFIG_EXTRA_ENV_SETTINGS					\
-	"splashpos=m,m\0"	  \
-	"fdt_high=0xffffffff\0"	  \
-	"initrd_high=0xffffffff\0" \
-
-#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
-#endif
-
-#endif
-- 
1.8.0

