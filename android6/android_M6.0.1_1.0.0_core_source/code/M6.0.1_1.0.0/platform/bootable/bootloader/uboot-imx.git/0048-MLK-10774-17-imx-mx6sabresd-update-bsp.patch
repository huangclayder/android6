From b2ac7bfeb29bd3e84af7fd95c1d0cb43e381bc8d Mon Sep 17 00:00:00 2001
From: Peng Fan <Peng.Fan@freescale.com>
Date: Tue, 28 Apr 2015 13:54:23 +0800
Subject: [PATCH] MLK-10774-17 imx:mx6sabresd update bsp

Update bsp and add configuration file

Signed-off-by: Peng Fan <Peng.Fan@freescale.com>
---
 board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg    |  239 +++--
 board/freescale/mx6sabresd/mx6sabresd.c            | 1002 ++++++++++++--------
 board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg |  124 +++
 configs/mx6qsabresd_sata_defconfig                 |    7 +
 configs/mx6solosabresd_defconfig                   |    7 +
 include/configs/mx6sabre_common.h                  |  200 +++-
 include/configs/mx6sabresd.h                       |   36 +-
 7 files changed, 1033 insertions(+), 582 deletions(-)

diff --git a/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg b/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg
index bb6c60b..aa897e9 100644
--- a/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg
+++ b/board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,15 +10,31 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
 /* image version */
 IMAGE_VERSION 2
 
 /*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
  */
+
+/* the same flash_offset as sd */
 BOOT_FROM      sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -30,132 +46,104 @@ BOOT_FROM      sd
  *      Address   absolute address of the register
  *      value     value to be stored in the register
  */
-DATA 4 0x020e05a8 0x00000030
-DATA 4 0x020e05b0 0x00000030
-DATA 4 0x020e0524 0x00000030
-DATA 4 0x020e051c 0x00000030
-
-DATA 4 0x020e0518 0x00000030
-DATA 4 0x020e050c 0x00000030
-DATA 4 0x020e05b8 0x00000030
-DATA 4 0x020e05c0 0x00000030
-
-DATA 4 0x020e05ac 0x00020030
-DATA 4 0x020e05b4 0x00020030
-DATA 4 0x020e0528 0x00020030
-DATA 4 0x020e0520 0x00020030
-
-DATA 4 0x020e0514 0x00020030
-DATA 4 0x020e0510 0x00020030
-DATA 4 0x020e05bc 0x00020030
-DATA 4 0x020e05c4 0x00020030
-
-DATA 4 0x020e056c 0x00020030
-DATA 4 0x020e0578 0x00020030
-DATA 4 0x020e0588 0x00020030
-DATA 4 0x020e0594 0x00020030
-
-DATA 4 0x020e057c 0x00020030
-DATA 4 0x020e0590 0x00003000
-DATA 4 0x020e0598 0x00003000
-DATA 4 0x020e058c 0x00000000
-
-DATA 4 0x020e059c 0x00003030
-DATA 4 0x020e05a0 0x00003030
-DATA 4 0x020e0784 0x00000030
-DATA 4 0x020e0788 0x00000030
-
-DATA 4 0x020e0794 0x00000030
-DATA 4 0x020e079c 0x00000030
-DATA 4 0x020e07a0 0x00000030
-DATA 4 0x020e07a4 0x00000030
-
-DATA 4 0x020e07a8 0x00000030
-DATA 4 0x020e0748 0x00000030
-DATA 4 0x020e074c 0x00000030
-DATA 4 0x020e0750 0x00020000
-
-DATA 4 0x020e0758 0x00000000
-DATA 4 0x020e0774 0x00020000
-DATA 4 0x020e078c 0x00000030
-DATA 4 0x020e0798 0x000C0000
-
-DATA 4 0x021b081c 0x33333333
-DATA 4 0x021b0820 0x33333333
-DATA 4 0x021b0824 0x33333333
-DATA 4 0x021b0828 0x33333333
-
-DATA 4 0x021b481c 0x33333333
-DATA 4 0x021b4820 0x33333333
-DATA 4 0x021b4824 0x33333333
-DATA 4 0x021b4828 0x33333333
-
-DATA 4 0x021b0018 0x00081740
-
-DATA 4 0x021b001c 0x00008000
-DATA 4 0x021b000c 0x555A7974
-DATA 4 0x021b0010 0xDB538F64
-DATA 4 0x021b0014 0x01FF00DB
-DATA 4 0x021b002c 0x000026D2
-
-DATA 4 0x021b0030 0x005A1023
-DATA 4 0x021b0008 0x09444040
-DATA 4 0x021b0004 0x00025576
-DATA 4 0x021b0040 0x00000027
-DATA 4 0x021b0000 0x831A0000
-
-DATA 4 0x021b001c 0x04088032
-DATA 4 0x021b001c 0x0408803A
-DATA 4 0x021b001c 0x00008033
-DATA 4 0x021b001c 0x0000803B
-DATA 4 0x021b001c 0x00428031
-DATA 4 0x021b001c 0x00428039
-DATA 4 0x021b001c 0x19308030
-DATA 4 0x021b001c 0x19308038
-
-DATA 4 0x021b001c 0x04008040
-DATA 4 0x021b001c 0x04008048
-DATA 4 0x021b0800 0xA1380003
-DATA 4 0x021b4800 0xA1380003
-DATA 4 0x021b0020 0x00005800
-DATA 4 0x021b0818 0x00022227
-DATA 4 0x021b4818 0x00022227
-
-DATA 4 0x021b083c 0x434B0350
-DATA 4 0x021b0840 0x034C0359
-DATA 4 0x021b483c 0x434B0350
-DATA 4 0x021b4840 0x03650348
-DATA 4 0x021b0848 0x4436383B
-DATA 4 0x021b4848 0x39393341
-DATA 4 0x021b0850 0x35373933
-DATA 4 0x021b4850 0x48254A36
-
-DATA 4 0x021b080c 0x001F001F
-DATA 4 0x021b0810 0x001F001F
-
-DATA 4 0x021b480c 0x00440044
-DATA 4 0x021b4810 0x00440044
-
-DATA 4 0x021b08b8 0x00000800
-DATA 4 0x021b48b8 0x00000800
-
-DATA 4 0x021b001c 0x00000000
-DATA 4 0x021b0404 0x00011006
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43270338
+DATA 4, 0x021b0840, 0x03200314
+DATA 4, 0x021b483c, 0x431A032F
+DATA 4, 0x021b4840, 0x03200263
+DATA 4, 0x021b0848, 0x4B434748
+DATA 4, 0x021b4848, 0x4445404C
+DATA 4, 0x021b0850, 0x38444542
+DATA 4, 0x021b4850, 0x4935493A
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A7975
+DATA 4, 0x021b0010, 0xFF538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
 
 /* set the default clock gate to save power */
-DATA 4 0x020c4068 0x00C03F3F
-DATA 4 0x020c406c 0x0030FC03
-DATA 4 0x020c4070 0x0FFFC000
-DATA 4 0x020c4074 0x3FF00000
-DATA 4 0x020c4078 0x00FFF300
-DATA 4 0x020c407c 0x0F0000C3
-DATA 4 0x020c4080 0x000003FF
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
 
 /* enable AXI cache for VDOA/VPU/IPU */
-DATA 4 0x020e0010 0xF00000CF
+DATA 4, 0x020e0010, 0xF00000CF
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
-DATA 4 0x020e0018 0x007F007F
-DATA 4 0x020e001c 0x007F007F
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
 
 /*
  * Setup CCM_CCOSR register as follows:
@@ -166,4 +154,5 @@ DATA 4 0x020e001c 0x007F007F
  *
  * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
  */
-DATA 4 0x020c4060 0x000000fb
+DATA 4, 0x020c4060, 0x000000fb
+#endif
diff --git a/board/freescale/mx6sabresd/mx6sabresd.c b/board/freescale/mx6sabresd/mx6sabresd.c
index 562355d..0a6c29e 100644
--- a/board/freescale/mx6sabresd/mx6sabresd.c
+++ b/board/freescale/mx6sabresd/mx6sabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -30,12 +30,22 @@
 #include <asm/io.h>
 #include <asm/arch/sys_proto.h>
 #include <i2c.h>
+#include <ipu_pixfmt.h>
+#include <linux/fb.h>
 #include <power/pmic.h>
 #include <power/pfuze100_pmic.h>
 #include "../common/pfuze.h"
 #include <asm/arch/mx6-ddr.h>
 #include <usb.h>
 
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
@@ -56,6 +66,9 @@ DECLARE_GLOBAL_DATA_PTR;
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
 	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
 
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
 #define I2C_PMIC	1
 
 #define I2C_PAD MUX_PAD_CTRL(I2C_PAD_CTRL)
@@ -146,6 +159,7 @@ static iomux_v3_cfg_t const usdhc4_pads[] = {
 	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 };
 
+#ifdef CONFIG_MXC_SPI
 static iomux_v3_cfg_t const ecspi1_pads[] = {
 	MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
 	MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
@@ -153,6 +167,17 @@ static iomux_v3_cfg_t const ecspi1_pads[] = {
 	MX6_PAD_KEY_ROW1__GPIO4_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 9)) : -1;
+}
+#endif
+
 static iomux_v3_cfg_t const rgb_pads[] = {
 	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL),
 	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL),
@@ -205,11 +230,6 @@ static struct i2c_pads_info i2c_pad_info1 = {
 	}
 };
 
-static void setup_spi(void)
-{
-	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
-}
-
 iomux_v3_cfg_t const pcie_pads[] = {
 	MX6_PAD_EIM_D19__GPIO3_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* POWER */
 	MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* RESET */
@@ -228,49 +248,49 @@ iomux_v3_cfg_t const di0_pads[] = {
 
 #if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
 static iomux_v3_cfg_t const epdc_enable_pads[] = {
-	MX6_PAD_EIM_A16__EPDC_SDDO_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA10__EPDC_SDDO_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA12__EPDC_SDDO_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA11__EPDC_SDDO_3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_LBA__EPDC_SDDO_4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_EB2__EPDC_SDDO_5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_CS0__EPDC_SDDO_6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_RW__EPDC_SDDO_7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A16__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA12__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_LBA__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB2__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_RW__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_A21__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_A22__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_A23__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_A24__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_D31__EPDC_SDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D31__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_D27__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_DA1__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 	MX6_PAD_EIM_EB1__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA2__EPDC_BDR_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA4__EPDC_SDCE_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA5__EPDC_SDCE_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
-	MX6_PAD_EIM_DA6__EPDC_SDCE_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EPDC_BDR0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EPDC_SDCE0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EPDC_SDCE1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EPDC_SDCE2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
 };
 
 static iomux_v3_cfg_t const epdc_disable_pads[] = {
-	MX6_PAD_EIM_A16__GPIO_2_22,
-	MX6_PAD_EIM_DA10__GPIO_3_10,
-	MX6_PAD_EIM_DA12__GPIO_3_12,
-	MX6_PAD_EIM_DA11__GPIO_3_11,
-	MX6_PAD_EIM_LBA__GPIO_2_27,
-	MX6_PAD_EIM_EB2__GPIO_2_30,
-	MX6_PAD_EIM_CS0__GPIO_2_23,
-	MX6_PAD_EIM_RW__GPIO_2_26,
-	MX6_PAD_EIM_A21__GPIO_2_17,
-	MX6_PAD_EIM_A22__GPIO_2_16,
-	MX6_PAD_EIM_A23__GPIO_6_6,
-	MX6_PAD_EIM_A24__GPIO_5_4,
-	MX6_PAD_EIM_D31__GPIO_3_31,
-	MX6_PAD_EIM_D27__GPIO_3_27,
-	MX6_PAD_EIM_DA1__GPIO_3_1,
-	MX6_PAD_EIM_EB1__GPIO_2_29,
-	MX6_PAD_EIM_DA2__GPIO_3_2,
-	MX6_PAD_EIM_DA4__GPIO_3_4,
-	MX6_PAD_EIM_DA5__GPIO_3_5,
-	MX6_PAD_EIM_DA6__GPIO_3_6,
+	MX6_PAD_EIM_A16__GPIO2_IO22,
+	MX6_PAD_EIM_DA10__GPIO3_IO10,
+	MX6_PAD_EIM_DA12__GPIO3_IO12,
+	MX6_PAD_EIM_DA11__GPIO3_IO11,
+	MX6_PAD_EIM_LBA__GPIO2_IO27,
+	MX6_PAD_EIM_EB2__GPIO2_IO30,
+	MX6_PAD_EIM_CS0__GPIO2_IO23,
+	MX6_PAD_EIM_RW__GPIO2_IO26,
+	MX6_PAD_EIM_A21__GPIO2_IO17,
+	MX6_PAD_EIM_A22__GPIO2_IO16,
+	MX6_PAD_EIM_A23__GPIO6_IO06,
+	MX6_PAD_EIM_A24__GPIO5_IO04,
+	MX6_PAD_EIM_D31__GPIO3_IO31,
+	MX6_PAD_EIM_D27__GPIO3_IO27,
+	MX6_PAD_EIM_DA1__GPIO3_IO01,
+	MX6_PAD_EIM_EB1__GPIO2_IO29,
+	MX6_PAD_EIM_DA2__GPIO3_IO02,
+	MX6_PAD_EIM_DA4__GPIO3_IO04,
+	MX6_PAD_EIM_DA5__GPIO3_IO05,
+	MX6_PAD_EIM_DA6__GPIO3_IO06,
 };
 #endif
 
@@ -286,6 +306,35 @@ struct fsl_esdhc_cfg usdhc_cfg[3] = {
 	{USDHC4_BASE_ADDR},
 };
 
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
 #define USDHC2_CD_GPIO	IMX_GPIO_NR(2, 2)
 #define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
 
@@ -395,382 +444,143 @@ int board_mmc_init(bd_t *bis)
 }
 #endif
 
-int mx6_rgmii_rework(struct phy_device *phydev)
+int check_mmc_autodetect(void)
 {
-	unsigned short val;
-
-	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
-
-	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
-	val &= 0xffe3;
-	val |= 0x18;
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+	char *autodetect_str = getenv("mmcautodetect");
 
-	/* introduce tx clock delay */
-	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
-	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
-	val |= 0x0100;
-	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
 
 	return 0;
 }
 
-int board_phy_config(struct phy_device *phydev)
+void board_late_mmc_env_init(void)
 {
-	mx6_rgmii_rework(phydev);
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
 
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
+	if (!check_mmc_autodetect())
+		return;
 
-	return 0;
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
 }
 
-#if defined(CONFIG_VIDEO_IPUV3)
-static void disable_lvds(struct display_info_t const *dev)
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
 {
-	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
 
-	int reg = readl(&iomux->gpr[2]);
+	s = getenv("splashimage");
 
-	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
-		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
 
-	writel(reg, &iomux->gpr[2]);
-}
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
 
-static void do_enable_hdmi(struct display_info_t const *dev)
-{
-	disable_lvds(dev);
-	imx_enable_hdmi_phy();
-}
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
 
-static void enable_lvds(struct display_info_t const *dev)
-{
-	struct iomuxc *iomux = (struct iomuxc *)
-				IOMUXC_BASE_ADDR;
-	u32 reg = readl(&iomux->gpr[2]);
-	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
-	       IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT;
-	writel(reg, &iomux->gpr[2]);
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+					blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
 }
+#endif
 
-struct display_info_t const displays[] = {{
-	.bus	= -1,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB666,
-	.detect	= NULL,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "Hannstar-XGA",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= -1,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= detect_hdmi,
-	.enable	= do_enable_hdmi,
-	.mode	= {
-		.name           = "HDMI",
-		.refresh        = 60,
-		.xres           = 640,
-		.yres           = 480,
-		.pixclock       = 39721,
-		.left_margin    = 48,
-		.right_margin   = 16,
-		.upper_margin   = 33,
-		.lower_margin   = 10,
-		.hsync_len      = 96,
-		.vsync_len      = 2,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= NULL,
-	.enable	= enable_rgb,
-	.mode	= {
-		.name           = "SEIKO-WVGA",
-		.refresh        = 60,
-		.xres           = 800,
-		.yres           = 480,
-		.pixclock       = 29850,
-		.left_margin    = 89,
-		.right_margin   = 164,
-		.upper_margin   = 23,
-		.lower_margin   = 10,
-		.hsync_len      = 10,
-		.vsync_len      = 10,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} } };
-size_t display_count = ARRAY_SIZE(displays);
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
 
-static void setup_display(void)
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
 {
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
-	int reg;
+	/* Setup epdc voltage */
 
-	/* Setup HSYNC, VSYNC, DISP_CLK for debugging purposes */
-	imx_iomux_v3_setup_multiple_pads(di0_pads, ARRAY_SIZE(di0_pads));
+	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as input */
+	gpio_direction_input(IMX_GPIO_NR(2, 21));
 
-	enable_ipu_clock();
-	imx_setup_hdmi();
+	/* EIM_D17 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
 
-	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
-	reg = readl(&mxc_ccm->CCGR3);
-	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
-	writel(reg, &mxc_ccm->CCGR3);
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
 
-	/* set LDB0, LDB1 clk select to 011/011 */
-	reg = readl(&mxc_ccm->cs2cdr);
-	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
-		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
-	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
-	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->cs2cdr);
+	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
 
-	reg = readl(&mxc_ccm->cscmr2);
-	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
-	writel(reg, &mxc_ccm->cscmr2);
-
-	reg = readl(&mxc_ccm->chsccdr);
-	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
-		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
-	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
-		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->chsccdr);
-
-	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
-	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
-	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
-	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
-	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
-	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
-	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
-	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
-	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
-	writel(reg, &iomux->gpr[2]);
-
-	reg = readl(&iomux->gpr[3]);
-	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
-			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
-	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
-	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
-	writel(reg, &iomux->gpr[3]);
-}
-#endif /* CONFIG_VIDEO_IPUV3 */
-
-/*
- * Do not overwrite the console
- * Use always serial for U-Boot console
- */
-int overwrite_console(void)
-{
-	return 1;
-}
-
-int board_eth_init(bd_t *bis)
-{
-	setup_iomux_enet();
-	setup_pcie();
-
-	return cpu_eth_init(bis);
-}
-
-#ifdef CONFIG_USB_EHCI_MX6
-#define USB_OTHERREGS_OFFSET	0x800
-#define UCTRL_PWR_POL		(1 << 9)
-
-static iomux_v3_cfg_t const usb_otg_pads[] = {
-	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usb_hc1_pads[] = {
-	MX6_PAD_ENET_TXD1__GPIO1_IO29 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static void setup_usb(void)
-{
-	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
-					 ARRAY_SIZE(usb_otg_pads));
-
-	/*
-	 * set daisy chain for otg_pin_id on 6q.
-	 * for 6dl, this bit is reserved
-	 */
-	imx_iomux_set_gpr_register(1, 13, 1, 0);
-
-	imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
-					 ARRAY_SIZE(usb_hc1_pads));
-}
-
-int board_ehci_hcd_init(int port)
-{
-	u32 *usbnc_usb_ctrl;
-
-	if (port > 1)
-		return -EINVAL;
-
-	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
-				 port * 4);
-
-	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
-
-	return 0;
-}
-
-int board_ehci_power(int port, int on)
-{
-	switch (port) {
-	case 0:
-		break;
-	case 1:
-		if (on)
-			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
-		else
-			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
-		break;
-	default:
-		printf("MXC USB port %d not yet supported\n", port);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-#endif
-
-int board_early_init_f(void)
-{
-	setup_iomux_uart();
-#if defined(CONFIG_VIDEO_IPUV3)
-	setup_display();
-#endif
-
-	return 0;
-}
-
-#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
-#ifdef CONFIG_SPLASH_SCREEN
-extern int mmc_get_env_devno(void);
-int setup_splash_img(void)
-{
-#ifdef CONFIG_SPLASH_IS_IN_MMC
-	int mmc_dev = mmc_get_env_devno();
-	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
-	ulong size = CONFIG_SPLASH_IMG_SIZE;
-	ulong addr = 0;
-	char *s = NULL;
-	struct mmc *mmc = find_mmc_device(mmc_dev);
-	uint blk_start, blk_cnt, n;
-
-	s = getenv("splashimage");
-
-	if (NULL == s) {
-		puts("env splashimage not found!\n");
-		return -1;
-	}
-	addr = simple_strtoul(s, NULL, 16);
-
-	if (!mmc) {
-		printf("MMC Device %d not found\n", mmc_dev);
-		return -1;
-	}
-
-	if (mmc_init(mmc)) {
-		puts("MMC init failed\n");
-		return -1;
-	}
-
-	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
-	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
-	n = mmc->block_dev.block_read(mmc_dev, blk_start,
-					blk_cnt, (u_char *)addr);
-	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
-
-	return (n == blk_cnt) ? 0 : -1;
-#endif
-
-	return 0;
-}
-#endif
-
-vidinfo_t panel_info = {
-	.vl_refresh = 85,
-	.vl_col = 800,
-	.vl_row = 600,
-	.vl_pixclock = 26666667,
-	.vl_left_margin = 8,
-	.vl_right_margin = 100,
-	.vl_upper_margin = 4,
-	.vl_lower_margin = 8,
-	.vl_hsync = 4,
-	.vl_vsync = 1,
-	.vl_sync = 0,
-	.vl_mode = 0,
-	.vl_flag = 0,
-	.vl_bpix = 3,
-	.cmap = 0,
-};
-
-struct epdc_timing_params panel_timings = {
-	.vscan_holdoff = 4,
-	.sdoed_width = 10,
-	.sdoed_delay = 20,
-	.sdoez_width = 10,
-	.sdoez_delay = 20,
-	.gdclk_hp_offs = 419,
-	.gdsp_offs = 20,
-	.gdoe_offs = 0,
-	.gdclk_offs = 5,
-	.num_ce = 1,
-};
-
-static void setup_epdc_power(void)
-{
-	/* Setup epdc voltage */
-
-	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO_2_21 |
-				MUX_PAD_CTRL(EPDC_PAD_CTRL));
-	/* Set as input */
-	gpio_direction_input(IMX_GPIO_NR(2, 21));
-
-	/* EIM_D17 - GPIO3[17] for VCOM control */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO_3_17 |
-				MUX_PAD_CTRL(EPDC_PAD_CTRL));
-
-	/* Set as output */
-	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
-
-	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO_3_20 |
-				MUX_PAD_CTRL(EPDC_PAD_CTRL));
-	/* Set as output */
-	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
-
-	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO_2_20 |
-				MUX_PAD_CTRL(EPDC_PAD_CTRL));
-	/* Set as output */
-	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
-}
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
+}
 
 int setup_waveform_file(void)
 {
@@ -821,54 +631,55 @@ static void epdc_disable_pins(void)
 static void setup_epdc(void)
 {
 	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
 
 	/*** epdc Maxim PMIC settings ***/
 
 	/* EPDC PWRSTAT - GPIO2[21] for PWR_GOOD status */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO_2_21 |
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
 				MUX_PAD_CTRL(EPDC_PAD_CTRL));
 
 	/* EPDC VCOM0 - GPIO3[17] for VCOM control */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO_3_17 |
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
 				MUX_PAD_CTRL(EPDC_PAD_CTRL));
 
 	/* UART4 TXD - GPIO3[20] for EPD PMIC WAKEUP */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO_3_20 |
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
 				MUX_PAD_CTRL(EPDC_PAD_CTRL));
 
 	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
-	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO_2_20 |
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
 				MUX_PAD_CTRL(EPDC_PAD_CTRL));
 
 	/*** Set pixel clock rates for EPDC ***/
 
 	/* EPDC AXI clk (IPU2_CLK) from PFD_400M, set to 396/2 = 198MHz */
-	reg = readl(CCM_BASE_ADDR + CLKCTL_CSCDR3);
+	reg = readl(&ccm_regs->cscdr3);
 	reg &= ~0x7C000;
 	reg |= (1 << 16) | (1 << 14);
-	writel(reg, CCM_BASE_ADDR + CLKCTL_CSCDR3);
+	writel(reg, &ccm_regs->cscdr3);
 
 	/* EPDC AXI clk enable */
-	reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR3);
+	reg = readl(&ccm_regs->CCGR3);
 	reg |= 0x00C0;
-	writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR3);
+	writel(reg, &ccm_regs->CCGR3);
 
 	/* EPDC PIX clk (IPU2_DI1_CLK) from PLL5, set to 650/4/6 = ~27MHz */
-	reg = readl(CCM_BASE_ADDR + CLKCTL_CSCDR2);
+	reg = readl(&ccm_regs->cscdr2);
 	reg &= ~0x3FE00;
 	reg |= (2 << 15) | (5 << 12);
-	writel(reg, CCM_BASE_ADDR + CLKCTL_CSCDR2);
+	writel(reg, &ccm_regs->cscdr2);
 
 	/* PLL5 enable (defaults to 650) */
-	reg = readl(ANATOP_BASE_ADDR + ANATOP_PLL_VIDEO);
+	reg = readl(&ccm_regs->analog_pll_video);
 	reg &= ~((1 << 16) | (1 << 12));
 	reg |= (1 << 13);
-	writel(reg, ANATOP_BASE_ADDR + ANATOP_PLL_VIDEO);
+	writel(reg, &ccm_regs->analog_pll_video);
 
 	/* EPDC PIX clk enable */
-	reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR3);
+	reg = readl(&ccm_regs->CCGR3);
 	reg |= 0x0C00;
-	writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR3);
+	writel(reg, &ccm_regs->CCGR3);
 
 	panel_info.epdc_data.working_buf_addr = CONFIG_WORKING_BUF_ADDR;
 	panel_info.epdc_data.waveform_buf_addr = CONFIG_WAVEFORM_BUF_ADDR;
@@ -891,6 +702,7 @@ static void setup_epdc(void)
 void epdc_power_on(void)
 {
 	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
 
 	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
 	gpio_set_value(IMX_GPIO_NR(2, 20), 1);
@@ -904,7 +716,7 @@ void epdc_power_on(void)
 
 	/* Wait for PWRGOOD == 1 */
 	while (1) {
-		reg = readl(GPIO2_BASE_ADDR + GPIO_PSR);
+		reg = readl(&gpio_regs->gpio_psr);
 		if (!(reg & (1 << 21)))
 			break;
 
@@ -932,6 +744,277 @@ void epdc_power_off(void)
 }
 #endif
 
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+	u32 reg = readl(&iomux->gpr[2]);
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
+	       IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT;
+	writel(reg, &iomux->gpr[2]);
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= enable_lvds,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= 0,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= enable_rgb,
+	.mode	= {
+		.name           = "SEIKO-WVGA",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	/* Setup HSYNC, VSYNC, DISP_CLK for debugging purposes */
+	imx_iomux_v3_setup_multiple_pads(di0_pads, ARRAY_SIZE(di0_pads));
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	setup_pcie();
+
+	return cpu_eth_init(bis);
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_ENET_TXD1__GPIO1_IO29 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+
+	/*
+	 * set daisy chain for otg_pin_id on 6q.
+	 * for 6dl, this bit is reserved
+	 */
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+
+	imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+					 ARRAY_SIZE(usb_hc1_pads));
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+	return 0;
+}
+
 int board_init(void)
 {
 	/* address of boot parameters */
@@ -950,41 +1033,126 @@ int board_init(void)
 	setup_epdc();
 #endif
 
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
 	return 0;
 }
 
+static struct pmic *pfuze;
 int power_init_board(void)
 {
-	struct pmic *p;
 	unsigned int reg, ret;
 
-	p = pfuze_common_init(I2C_PMIC);
-	if (!p)
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
 		return -ENODEV;
 
-	ret = pfuze_mode_init(p, APS_PFM);
+	ret = pfuze_mode_init(pfuze, APS_PFM);
 	if (ret < 0)
 		return ret;
 
 	/* Increase VGEN3 from 2.5 to 2.8V */
-	pmic_reg_read(p, PFUZE100_VGEN3VOL, &reg);
+	pmic_reg_read(pfuze, PFUZE100_VGEN3VOL, &reg);
 	reg &= ~LDO_VOL_MASK;
 	reg |= LDOB_2_80V;
-	pmic_reg_write(p, PFUZE100_VGEN3VOL, reg);
+	pmic_reg_write(pfuze, PFUZE100_VGEN3VOL, reg);
 
 	/* Increase VGEN5 from 2.8 to 3V */
-	pmic_reg_read(p, PFUZE100_VGEN5VOL, &reg);
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &reg);
 	reg &= ~LDO_VOL_MASK;
 	reg |= LDOB_3_00V;
-	pmic_reg_write(p, PFUZE100_VGEN5VOL, reg);
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, reg);
 
 	return 0;
 }
 
-#ifdef CONFIG_MXC_SPI
-int board_spi_cs_gpio(unsigned bus, unsigned cs)
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
 {
-	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 9)) : -1;
+	unsigned int value;
+	int is_400M;
+	unsigned char vddarm;
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+#if defined(CONFIG_MX6DL)
+		value |= 0x27;
+#else
+		value |= 0x20;
+#endif
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* increase VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x28;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		/*
+		 * MX6Q:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 * MX6DL:
+		 * VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:1.075V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_400M)
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x1f;
+#else
+			vddarm = 0x1b;
+#endif
+		else
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x23;
+#else
+			vddarm = 0x22;
+#endif
+
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.175V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
 }
 #endif
 
@@ -1004,6 +1172,10 @@ int board_late_init(void)
 #ifdef CONFIG_CMD_BMODE
 	add_board_boot_modes(board_boot_modes);
 #endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
 	return 0;
 }
 
diff --git a/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg b/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg
new file mode 100644
index 0000000..6526db4
--- /dev/null
+++ b/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000030
+DATA 4, 0x020e04c0, 0x00000030
+DATA 4, 0x020e04c4, 0x00000030
+DATA 4, 0x020e04c8, 0x00000030
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000030
+DATA 4, 0x020e0770, 0x00000030
+DATA 4, 0x020e0778, 0x00000030
+DATA 4, 0x020e077c, 0x00000030
+DATA 4, 0x020e0470, 0x00000030
+DATA 4, 0x020e0474, 0x00000030
+DATA 4, 0x020e0478, 0x00000030
+DATA 4, 0x020e047c, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b083c, 0x42190219
+DATA 4, 0x021b0840, 0x017B0177
+DATA 4, 0x021b0848, 0x4B4D4E4D
+DATA 4, 0x021b0850, 0x3F3E2D36
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b0004, 0x0002002D
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x3F435313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x00431023
+DATA 4, 0x021b0040, 0x00000017
+DATA 4, 0x021b0000, 0x83190000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b0004, 0x0002556D
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/configs/mx6qsabresd_sata_defconfig b/configs/mx6qsabresd_sata_defconfig
new file mode 100644
index 0000000..6fe0722
--- /dev/null
+++ b/configs/mx6qsabresd_sata_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6q_4x_mt41j128.cfg,MX6Q,SYS_USE_SPINOR,SYS_BOOT_SATA"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6solosabresd_defconfig b/configs/mx6solosabresd_defconfig
new file mode 100644
index 0000000..9dbee56
--- /dev/null
+++ b/configs/mx6solosabresd_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg,MX6SOLO,SYS_USE_SPINOR,SYS_NOSMP="nosmp""
+CONFIG_ARM=y
+CONFIG_TARGET_MX6SABRESD=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
index e4165c2..4790be0 100644
--- a/include/configs/mx6sabre_common.h
+++ b/include/configs/mx6sabre_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -11,6 +11,16 @@
 
 #define CONFIG_MX6
 
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
 #include "mx6_common.h"
 #include <linux/sizes.h>
 
@@ -58,6 +68,8 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -72,17 +84,6 @@
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_ATHEROS
 
-#define CONFIG_CMD_SF
-#ifdef CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
-#define CONFIG_MXC_SPI
-#define CONFIG_SF_DEFAULT_BUS		0
-#define CONFIG_SF_DEFAULT_CS		0
-#define CONFIG_SF_DEFAULT_SPEED		20000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#endif
-
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
 #define CONFIG_CONS_INDEX              1
@@ -100,24 +101,26 @@
 
 #define CONFIG_LOADADDR                        0x12000000
 #define CONFIG_SYS_TEXT_BASE           0x17800000
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
 #ifdef CONFIG_SYS_BOOT_NAND
-#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:16m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
 #else
 #define CONFIG_MFG_NAND_PARTITION ""
 #endif
 
 #define CONFIG_MFG_ENV_SETTINGS \
-       "mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
-               "rdinit=/linuxrc " \
-               "g_mass_storage.stall=0 g_mass_storage.removable=1 " \
-               "g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
-               "g_mass_storage.iSerialNumber=\"\" "\
-               "enable_wait_mode=off "\
-               CONFIG_MFG_NAND_PARTITION \
-               "\0" \
-               "initrd_addr=0x12C00000\0" \
-               "initrd_high=0xffffffff\0" \
-               "bootcmd_mfg=run mfgtool_args;bootm ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
 
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 #define EMMC_ENV \
@@ -139,6 +142,42 @@
 #define EMMC_ENV ""
 #endif
 
+#if defined(CONFIG_SYS_BOOT_NAND)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	CONFIG_MFG_ENV_SETTINGS \
 	"script=boot.scr\0" \
@@ -151,8 +190,9 @@
 	"fdt_high=0xffffffff\0"	  \
 	"initrd_high=0xffffffff\0" \
 	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
-	"mmcpart=1\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"update_sd_firmware=" \
 		"if test ${ip_dyn} = yes; then " \
 			"setenv get_cmd dhcp; " \
@@ -167,7 +207,8 @@
 			"fi; "	\
 		"fi\0" \
 	EMMC_ENV	  \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
 		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
@@ -190,7 +231,7 @@
 		"else " \
 			"bootz; " \
 		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=/dev/nfs " \
 		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
 	"netboot=echo Booting from net ...; " \
@@ -227,6 +268,7 @@
 			"fi; " \
 		"fi; " \
 	"else run netboot; fi"
+#endif
 
 #define CONFIG_ARP_TIMEOUT     200UL
 
@@ -235,10 +277,14 @@
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
 #define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE              256
-#define CONFIG_SYS_MAXARGS             16
+#define CONFIG_SYS_CBSIZE              1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS             256
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
 
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START       0x10000000
 #define CONFIG_SYS_MEMTEST_END         0x10010000
 #define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
@@ -266,10 +312,97 @@
 
 #define CONFIG_ENV_SIZE			(8 * 1024)
 
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
 #define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE     (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (8 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
 #endif
 
 #define CONFIG_OF_LIBFDT
@@ -278,6 +411,12 @@
 #define CONFIG_CMD_CACHE
 #endif
 
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		  100000
+
 /* Framebuffer */
 #define CONFIG_VIDEO
 #define CONFIG_VIDEO_IPUV3
@@ -315,4 +454,7 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 #endif
 
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#endif
 #endif                         /* __MX6QSABRE_COMMON_CONFIG_H */
diff --git a/include/configs/mx6sabresd.h b/include/configs/mx6sabresd.h
index 72ba245..d44a9cb 100644
--- a/include/configs/mx6sabresd.h
+++ b/include/configs/mx6sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -21,24 +21,40 @@
 #define CONFIG_MACH_TYPE	3980
 #define CONFIG_MXC_UART_BASE	UART1_BASE
 #define CONFIG_CONSOLE_DEV		"ttymxc0"
-#define CONFIG_MMCROOT			"/dev/mmcblk1p2"
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
 #if defined(CONFIG_MX6Q)
 #define CONFIG_DEFAULT_FDT_FILE	"imx6q-sabresd.dtb"
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
 #elif defined(CONFIG_MX6DL)
 #define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabresd.dtb"
-#endif
 #define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
-
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#elif defined(CONFIG_MX6SOLO)
+#define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabresd.dtb"
+#define PHYS_SDRAM_SIZE		(512u * 1024 * 1024)
+#endif
 
 #include "mx6sabre_common.h"
 
 #define CONFIG_SYS_FSL_USDHC_NUM	3
-#if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 9)<<8))
 #endif
 
-#define CONFIG_CMD_PCI
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
 #ifdef CONFIG_CMD_PCI
 #define CONFIG_PCI
 #define CONFIG_PCI_PNP
@@ -48,12 +64,6 @@
 #define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
 #endif
 
-/* I2C Configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_SPEED		  100000
-
 /* PMIC */
 #define CONFIG_POWER
 #define CONFIG_POWER_I2C
-- 
1.8.0

