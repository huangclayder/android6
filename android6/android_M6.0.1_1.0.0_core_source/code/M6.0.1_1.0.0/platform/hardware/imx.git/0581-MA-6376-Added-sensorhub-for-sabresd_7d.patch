From 7b4d053190fa4dfe4bf36ca04694894a50b344a4 Mon Sep 17 00:00:00 2001
From: Haoran Wang <b50027@freescale.com>
Date: Tue, 5 May 2015 11:09:33 +0800
Subject: [PATCH 581/635] MA-6376 Added sensorhub for sabresd_7d

Added sensor hub for sabresd_7d.
Added PressSensor HAL for mpl3115.

Signed-off-by: Haoran Wang <b50027@freescale.com>
---
 Android.mk                                |   3 +
 libsensors_sensorhub/Android.mk           |  41 +++
 libsensors_sensorhub/FSLSensorsHub.cpp    | 515 ++++++++++++++++++++++++++++++
 libsensors_sensorhub/FSLSensorsHub.h      |  74 +++++
 libsensors_sensorhub/InputEventReader.cpp |  89 ++++++
 libsensors_sensorhub/InputEventReader.h   |  48 +++
 libsensors_sensorhub/PressSensor.cpp      | 319 ++++++++++++++++++
 libsensors_sensorhub/PressSensor.h        |  68 ++++
 libsensors_sensorhub/SensorBase.cpp       | 205 ++++++++++++
 libsensors_sensorhub/SensorBase.h         |  71 ++++
 libsensors_sensorhub/sensors.cpp          | 375 ++++++++++++++++++++++
 libsensors_sensorhub/sensors.h            | 116 +++++++
 12 files changed, 1924 insertions(+)
 create mode 100755 libsensors_sensorhub/Android.mk
 create mode 100755 libsensors_sensorhub/FSLSensorsHub.cpp
 create mode 100755 libsensors_sensorhub/FSLSensorsHub.h
 create mode 100755 libsensors_sensorhub/InputEventReader.cpp
 create mode 100755 libsensors_sensorhub/InputEventReader.h
 create mode 100755 libsensors_sensorhub/PressSensor.cpp
 create mode 100755 libsensors_sensorhub/PressSensor.h
 create mode 100755 libsensors_sensorhub/SensorBase.cpp
 create mode 100755 libsensors_sensorhub/SensorBase.h
 create mode 100755 libsensors_sensorhub/sensors.cpp
 create mode 100755 libsensors_sensorhub/sensors.h

diff --git a/Android.mk b/Android.mk
index 661aeae..0f06016 100644
--- a/Android.mk
+++ b/Android.mk
@@ -17,6 +17,9 @@ else
     else
       mx7_dirs += mx6/libcamera
     endif
+	ifeq ($(BOARD_USE_SENSOR_FUSION),true)
+		mx7_dirs += libsensors_sensorhub
+	endif
     include $(call all-named-subdir-makefiles,$(mx7_dirs))
   else
     ifeq ($(TARGET_BOARD_PLATFORM),imx5x)
diff --git a/libsensors_sensorhub/Android.mk b/libsensors_sensorhub/Android.mk
new file mode 100755
index 0000000..2991b7b
--- /dev/null
+++ b/libsensors_sensorhub/Android.mk
@@ -0,0 +1,41 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(BOARD_USE_SENSOR_FUSION),true)
+LOCAL_PATH := $(call my-dir)
+
+ifneq ($(TARGET_SIMULATOR),true)
+
+# HAL module implemenation, not prelinked, and stored in
+# hw/<SENSORS_HARDWARE_MODULE_ID>.<ro.product.board>.so
+include $(CLEAR_VARS)
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE := sensors.$(TARGET_BOOTLOADER_BOARD_NAME)
+LOCAL_MODULE_TAGS := eng
+
+LOCAL_SRC_FILES := 						\
+				sensors.cpp 			\
+				SensorBase.cpp			\
+				FSLSensorsHub.cpp		\
+				PressSensor.cpp			\
+				InputEventReader.cpp
+
+LOCAL_SHARED_LIBRARIES := liblog libcutils libdl
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif # !TARGET_SIMULATOR
+
+endif #
diff --git a/libsensors_sensorhub/FSLSensorsHub.cpp b/libsensors_sensorhub/FSLSensorsHub.cpp
new file mode 100755
index 0000000..dabd136
--- /dev/null
+++ b/libsensors_sensorhub/FSLSensorsHub.cpp
@@ -0,0 +1,515 @@
+/*
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <dlfcn.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include "FSLSensorsHub.h"
+
+#define FSL_SENS_CTRL_NAME   	"FSL_SENS_HUB"
+#define FSL_SENS_DATA_NAME    	"FSL_SENS_HUB" 
+#define FSL_SENS_SYSFS_PATH   	"/sys/class/misc"
+#define FSL_SENS_SYSFS_DELAY  	"poll_delay"
+#define FSL_SENS_SYSFS_ENABLE 	"enable"
+#define FSL_ACC_DEVICE_NAME	    "FreescaleAccelerometer"
+#define FSL_MAG_DEVICE_NAME 	"FreescaleMagnetometer"
+#define FSL_GYRO_DEVICE_NAME	"FreescaleGyroscope"
+
+#define EVENT_ACC_X			REL_X
+#define EVENT_ACC_Y	   		REL_Y
+#define EVENT_ACC_Z			REL_Z		
+
+#define EVENT_MAG_X			REL_RX
+#define EVENT_MAG_Y			REL_RY
+#define EVENT_MAG_Z			REL_RZ
+#define EVENT_MAG_STATUS	REL_MISC
+
+#define EVENT_GYRO_X		(REL_MISC + 1)	/*0x0A*/
+#define EVENT_GYRO_Y		(REL_MISC + 2)	/*0x0B*/
+#define EVENT_GYRO_Z		(REL_MISC + 3)	/*0x0C*/
+
+#define EVENT_STEP_DETECTED	 	REL_DIAL	
+#define EVENT_STEP_COUNT_HIGH	REL_HWHEEL 
+#define EVENT_STEP_COUNT_LOW	REL_WHEEL  
+
+#define EVENT_ORNT_X		ABS_X 
+#define EVENT_ORNT_Y		ABS_Y 
+#define EVENT_ORNT_Z		ABS_Z 
+#define EVENT_ORNT_STATUS	EVENT_MAG_STATUS 	/*0x0A*/
+
+#define EVENT_LINEAR_ACC_X	ABS_RX 
+#define EVENT_LINEAR_ACC_Y	ABS_RY 
+#define EVENT_LINEAR_ACC_Z	ABS_RZ 
+
+#define EVENT_GRAVITY_X		ABS_HAT0X
+#define EVENT_GRAVITY_Y		ABS_HAT1X
+#define EVENT_GRAVITY_Z		ABS_HAT2X
+
+#define EVENT_ROTATION_VECTOR_W		ABS_MISC
+#define EVENT_ROTATION_VECTOR_A		ABS_HAT0Y
+#define EVENT_ROTATION_VECTOR_B		ABS_HAT1Y
+#define EVENT_ROTATION_VECTOR_C		ABS_HAT2Y
+
+
+
+#define ACC_DATA_CONVERSION(value)  ((float)value * GRAVITY_EARTH/0x4000  )
+#define MAG_DATA_CONVERSION(value)  ((float)value/10.0f)
+#define ORNT_DATA_CONVERSION(value) ((float)value/10.0f)
+#define GYRO_DATA_CONVERSION(value) ((float)value/1000.0f /180.0f * M_PI )
+#define RV_DATA_CONVERSION(value)   ((float)value /10000.0f)
+#define LA_DATA_CONVERSION(value)   ((float)value /10.0f)
+#define GRAVT_DATA_CONVERSION(value)((float)value /10.0f)
+
+
+
+FSLSensorsHub::FSLSensorsHub()
+: SensorBase(FSL_SENS_CTRL_NAME, FSL_SENS_DATA_NAME),
+  mPendingMask(0),
+  mInputReader(16)
+{
+    memset(&mPendingEvent[0], 0, sensors *sizeof(sensors_event_t));
+
+	mEnabled[accel] = 0;
+	mDelay[accel] = 0;
+	mPendingEvent[accel].version = sizeof(sensors_event_t);
+    mPendingEvent[accel].sensor  = ID_A;
+    mPendingEvent[accel].type    = SENSOR_TYPE_ACCELEROMETER;
+    mPendingEvent[accel].magnetic.status = SENSOR_STATUS_ACCURACY_LOW;
+    mPendingEvent[accel].version = sizeof(sensors_event_t);
+
+	mEnabled[mag] = 0;
+	mDelay[mag] = 0;
+    mPendingEvent[mag].version = sizeof(sensors_event_t);
+    mPendingEvent[mag].sensor  = ID_M;
+    mPendingEvent[mag].type    = SENSOR_TYPE_MAGNETIC_FIELD;
+    mPendingEvent[mag].magnetic.status = SENSOR_STATUS_ACCURACY_LOW;
+    mPendingEvent[mag].version = sizeof(sensors_event_t);
+
+	mEnabled[orn] = 0;
+	mDelay[orn] = 0;
+    mPendingEvent[orn].sensor  = ID_O;
+    mPendingEvent[orn].type    = SENSOR_TYPE_ORIENTATION;
+    mPendingEvent[orn].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[orn].version = sizeof(sensors_event_t);
+
+	mEnabled[gyro] = 0;
+	mDelay[gyro] = 0;
+    mPendingEvent[gyro].sensor  = ID_GY;
+    mPendingEvent[gyro].type    = SENSOR_TYPE_GYROSCOPE;
+    mPendingEvent[gyro].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[gyro].version = sizeof(sensors_event_t);
+
+	mEnabled[rv] = 0;
+	mDelay[rv] = 0;
+    mPendingEvent[rv].sensor  = ID_RV;
+    mPendingEvent[rv].type    = SENSOR_TYPE_ROTATION_VECTOR;
+    mPendingEvent[rv].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[rv].version = sizeof(sensors_event_t);
+
+	mEnabled[la] = 0;
+	mDelay[la] = 0;
+    mPendingEvent[la].sensor  = ID_LA;
+    mPendingEvent[la].type    = SENSOR_TYPE_LINEAR_ACCELERATION;
+    mPendingEvent[la].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[la].version = sizeof(sensors_event_t);
+
+	mEnabled[gravt] = 0;
+	mDelay[gravt] = 0;
+    mPendingEvent[gravt].sensor  = ID_GR;
+    mPendingEvent[gravt].type    = SENSOR_TYPE_GRAVITY;
+    mPendingEvent[gravt].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[gravt].version = sizeof(sensors_event_t);
+	
+	mEnabled[sd] = 0;
+	mDelay[sd] = 0;
+    mPendingEvent[sd].sensor  = ID_SD;
+    mPendingEvent[sd].type    = SENSOR_TYPE_STEP_DETECTOR;
+    mPendingEvent[sd].orientation.status = SENSOR_STATUS_ACCURACY_HIGH;
+	mPendingEvent[sd].version = sizeof(sensors_event_t);
+
+	mEnabled[sc] = 0;
+	mDelay[sc] = 0;
+    mPendingEvent[sc].sensor  = ID_SC;
+    mPendingEvent[sc].type    = SENSOR_TYPE_STEP_COUNTER;
+    mPendingEvent[sc].orientation.status = SENSOR_STATUS_ACCURACY_LOW;
+	mPendingEvent[sc].version = sizeof(sensors_event_t);
+
+	sprintf(mClassPath[accel],"%s/%s",FSL_SENS_SYSFS_PATH,FSL_ACC_DEVICE_NAME);
+	sprintf(mClassPath[mag],"%s/%s",FSL_SENS_SYSFS_PATH,FSL_MAG_DEVICE_NAME);
+	sprintf(mClassPath[gyro],"%s/%s",FSL_SENS_SYSFS_PATH,FSL_GYRO_DEVICE_NAME);
+
+}
+
+FSLSensorsHub::~FSLSensorsHub()
+{
+}
+
+int FSLSensorsHub::setEnable(int32_t handle, int en)
+{
+	int err = 0;
+	int what = accel;
+	bool isHaveSensorRun = 0;
+    switch(handle){
+		case ID_A : what = accel; break;
+		case ID_M : what = mag;   break;
+		case ID_O : what = orn;   break;
+		case ID_GY: what = gyro;  break; 
+		case ID_RV: what = rv;	  break;
+		case ID_LA: what = la;	  break;
+		case ID_GR: what = gravt; break;
+		case ID_SD: what = sd;    break;
+		case ID_SC: what = sc;    break;
+		
+    }
+
+    if(en)
+		mEnabled[what]++;
+	else
+		mEnabled[what]--;
+	
+	if(mEnabled[what] < 0)
+		mEnabled[what] = 0;
+
+	for(int i = 0; i < sensors; i++ ){
+		if(mEnabled[i] > 0)
+		{
+			isHaveSensorRun = 1;
+			break;
+		}
+	}
+	if(isHaveSensorRun){
+		if(mEnabled[rv] > 0 || mEnabled[gravt] > 0 ||mEnabled[la] > 0 || mEnabled[mag]> 0  || mEnabled[orn] > 0 || mEnabled[gyro]> 0) //need fusion run
+		{
+			enable_sensor(accel);
+			enable_sensor(mag);
+			enable_sensor(gyro);
+		}else if(mEnabled[accel] > 0)  //only accel enable
+		{ 
+			enable_sensor(accel);
+			disable_sensor(mag);
+			disable_sensor(gyro);
+		}
+	}else
+	{
+		disable_sensor(accel);
+		disable_sensor(mag);
+		disable_sensor(gyro);
+	}
+	ALOGD("FSLSensorsHub sensor waht = %d , enable = %d",what,mEnabled[what]);
+    return err;
+}
+
+int FSLSensorsHub::setDelay(int32_t handle, int64_t ns)
+{
+    if (ns < 0)
+        return -EINVAL;
+	int what = accel;
+    switch(handle){
+		case ID_A : what = accel; break;
+		case ID_M : what = mag;   break;
+		case ID_O : what = orn;   break;
+		case ID_GY: what = gyro;  break; 
+		case ID_RV: what = rv;	  break;
+		case ID_LA: what = la;	  break;
+		case ID_GR: what = gravt; break;
+		case ID_SD: what = sd;	  break;
+		case ID_SC: what = sc;    break;
+    }
+
+    mDelay[what] = ns;
+	if(what == accel)
+		update_delay(accel,mDelay[accel]);
+	else if(what == mag || what == orn)
+		update_delay(mag,mDelay[mag]);
+	else if(what == gyro)
+		update_delay(gyro,mDelay[gyro]);
+	else{
+		update_delay(accel,mDelay[accel]);
+		update_delay(mag,mDelay[mag]);
+		update_delay(gyro,mDelay[gyro]);
+	}
+    return 0;
+}
+
+int FSLSensorsHub::update_delay(int sensor_type , int64_t ns)
+{
+    return writeDelay(sensor_type,ns);
+}
+
+int FSLSensorsHub::readEvents(sensors_event_t* data, int count)
+{
+	int i;
+    if (count < 1)
+        return -EINVAL;
+
+    ssize_t n = mInputReader.fill(data_fd);
+    if (n < 0)
+        return n;
+
+    int numEventReceived = 0;
+    input_event const* event;
+
+    while (count && mInputReader.readEvent(&event)) {
+        int type = event->type;
+        if ((type == EV_ABS) || (type == EV_REL) || (type == EV_KEY)) {
+            processEvent(type,event->code, event->value);
+            mInputReader.next();
+        } else if (type == EV_SYN) {
+            int64_t time = timevalToNano(event->time);
+			for(i = 0 ; i< sensors && mPendingMask && count ;i++){
+			  	 	if(mPendingMask & (1 << i)){
+						mPendingMask &= ~(1 << i);
+						mPendingEvent[i].timestamp = time;
+						if (mEnabled[i]) {
+							*data++ = mPendingEvent[i];
+							count--;
+							numEventReceived++;
+						}
+			  	 	}
+	       }
+		   if (!mPendingMask) {
+		       mInputReader.next();
+		   }
+        } else {
+            mInputReader.next();
+        }
+    }
+
+    return numEventReceived;
+}
+
+void FSLSensorsHub::processEvent(int code, int value)
+{
+
+}
+void FSLSensorsHub::processEvent(int type ,int code, int value){
+	static uint64_t steps_high = 0,steps_low = 0;
+	if(type == EV_REL){
+		 switch (code) {
+		 case EVENT_ACC_X :
+            mPendingMask |= 1 << accel;
+            mPendingEvent[accel].acceleration.x = ACC_DATA_CONVERSION(value);
+            break;
+        case EVENT_ACC_Y:
+            mPendingMask |= 1 << accel;
+            mPendingEvent[accel].acceleration.y = ACC_DATA_CONVERSION(value);
+            break;
+        case EVENT_ACC_Z:
+            mPendingMask |=  1 << accel;
+            mPendingEvent[accel].acceleration.z = ACC_DATA_CONVERSION(value);
+            break;
+        case EVENT_MAG_X :
+            mPendingMask |= 1 << mag;
+            mPendingEvent[mag].magnetic.x = MAG_DATA_CONVERSION(value);
+            break;
+        case EVENT_MAG_Y:
+            mPendingMask |= 1 << mag;
+            mPendingEvent[mag].magnetic.y = MAG_DATA_CONVERSION(value);
+            break;
+        case EVENT_MAG_Z:
+            mPendingMask |=  1 << mag;
+            mPendingEvent[mag].magnetic.z = MAG_DATA_CONVERSION(value);
+            break;
+		case EVENT_MAG_STATUS:
+			mPendingMask |=  1 << mag;
+			mPendingEvent[mag].magnetic.status 	= value;
+			mPendingEvent[orn].orientation.status	= value;
+			break;
+		case EVENT_GYRO_X :
+            mPendingMask |=  1 << gyro;
+            mPendingEvent[gyro].gyro.x= GYRO_DATA_CONVERSION(value);
+            break;
+        case EVENT_GYRO_Y :
+            mPendingMask |=  1 << gyro;
+            mPendingEvent[gyro].gyro.y = GYRO_DATA_CONVERSION(value);
+            break;
+        case EVENT_GYRO_Z :
+            mPendingMask |=  1 << gyro;
+            mPendingEvent[gyro].gyro.z	= GYRO_DATA_CONVERSION(value);
+            break;
+		case EVENT_STEP_DETECTED:
+            mPendingMask |=  1 << sd;
+            mPendingEvent[sd].data[0] = 1.0f;
+            break;
+		case EVENT_STEP_COUNT_HIGH:
+			steps_high = (uint64_t)(value & 0xffffffff);
+            break;
+		case EVENT_STEP_COUNT_LOW:
+            mPendingMask |=  1 << sc;
+			steps_low = (uint64_t)(value & 0xffffffff);
+            mPendingEvent[sc].u64.step_counter = ((steps_high << 32) | steps_low);
+            break;
+		}
+    
+	}else if(type == EV_ABS){
+	 switch(code){
+	 	case EVENT_ORNT_X :
+            mPendingMask |=  1 << orn;
+            mPendingEvent[orn].orientation.azimuth	= ORNT_DATA_CONVERSION(value);
+            break;
+        case EVENT_ORNT_Y :
+            mPendingMask |=  1 << orn;
+            mPendingEvent[orn].orientation.pitch = ORNT_DATA_CONVERSION(value);
+            break;
+        case EVENT_ORNT_Z :
+            mPendingMask |=  1 << orn;
+            mPendingEvent[orn].orientation.roll	= ORNT_DATA_CONVERSION(value);
+            break;
+		case EVENT_LINEAR_ACC_X :
+            mPendingMask |= 1 << la;
+            mPendingEvent[la].data[0] = LA_DATA_CONVERSION(value);
+            break;
+        case EVENT_LINEAR_ACC_Y:
+            mPendingMask |= 1 << la;
+            mPendingEvent[la].data[1] = LA_DATA_CONVERSION(value);
+            break;
+        case EVENT_LINEAR_ACC_Z:
+            mPendingMask |=  1 << la;
+            mPendingEvent[la].data[2] = LA_DATA_CONVERSION(value);
+            break;
+
+		case EVENT_GRAVITY_X :
+            mPendingMask |= 1 << gravt;
+            mPendingEvent[gravt].data[0] = GRAVT_DATA_CONVERSION(value);
+            break;
+        case EVENT_GRAVITY_Y:
+            mPendingMask |= 1 << gravt;
+            mPendingEvent[gravt].data[1] = GRAVT_DATA_CONVERSION(value);
+            break;
+        case EVENT_GRAVITY_Z:
+            mPendingMask |=  1 << gravt;
+            mPendingEvent[gravt].data[2] = GRAVT_DATA_CONVERSION(value);
+            break;
+			
+		case EVENT_ROTATION_VECTOR_W :
+            mPendingMask |= 1 << rv;
+            mPendingEvent[rv].data[3] = RV_DATA_CONVERSION(value);
+            break;
+        case EVENT_ROTATION_VECTOR_A:
+            mPendingMask |= 1 << rv;
+            mPendingEvent[rv].data[0] = RV_DATA_CONVERSION(value);
+            break;
+        case EVENT_ROTATION_VECTOR_B:
+            mPendingMask |=  1 << rv;
+            mPendingEvent[rv].data[1] = RV_DATA_CONVERSION(value);
+            break;
+		 case EVENT_ROTATION_VECTOR_C:
+            mPendingMask |=  1 << rv;
+            mPendingEvent[rv].data[2] = RV_DATA_CONVERSION(value);
+            break;
+	  }
+	}
+}
+
+
+int FSLSensorsHub::writeEnable(int what ,int isEnable) {
+	char attr[PATH_MAX] = {'\0'};
+	int err = 0;
+	if(mClassPath[0] == '\0')
+		return -1;
+
+	strcpy(attr, mClassPath[what]);
+	strcat(attr,"/");
+	strcat(attr,FSL_SENS_SYSFS_ENABLE);
+
+	int fd = open(attr, O_RDWR);
+	if (0 > fd) {
+		ALOGE("Could not open (write-only) SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+		return -errno;
+	}
+
+	char buf[16];
+	sprintf(buf,"%d",isEnable);
+	err = write(fd, buf, sizeof(buf));
+	if (0 > err) {
+		err = -errno;
+		ALOGE("Could not write SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+	} else {
+		err = 0;
+	}
+
+	close(fd);
+
+	return err;
+}
+
+int FSLSensorsHub::writeDelay(int what,int64_t ns) {
+	char attr[PATH_MAX] = {'\0'};
+	int delay;
+	if(mClassPath[0] == '\0')
+		return -1;
+
+	strcpy(attr, mClassPath[what]);
+	strcat(attr,"/");
+	strcat(attr,FSL_SENS_SYSFS_DELAY);
+
+	int fd = open(attr, O_RDWR);
+	if (0 > fd) {
+		ALOGE("Could not open (write-only) SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+		return -errno;
+	}
+	if (ns > 10240000000LL) {
+		ns = 10240000000LL; /* maximum delay in nano second. */
+	}
+	if (ns < 312500LL) {
+		ns = 312500LL; /* minimum delay in nano second. */
+	}
+
+    char buf[80];
+	delay = ns/1000/1000;
+    sprintf(buf, "%d",delay);
+	ALOGD("FSL_SENS write delay %s\n",buf);
+    write(fd, buf, strlen(buf)+1);
+    close(fd);
+    return 0;
+
+}
+
+int FSLSensorsHub::enable_sensor(int what) {
+	return writeEnable(what,1);
+}
+
+int FSLSensorsHub::disable_sensor(int what) {
+	return writeEnable(what,0);
+}
+int FSLSensorsHub::getEnable(int32_t handle) {
+	int what = accel;
+	switch(handle){
+		case ID_A : what = accel; break;
+		case ID_M : what = mag;   break;
+		case ID_O : what = orn;   break;
+		case ID_GY: what = gyro;  break; 
+		case ID_RV: what = rv;	  break;
+		case ID_LA: what = la;	  break;
+		case ID_GR: what = gravt; break;
+		case ID_SD: what = sd;	  break;
+		case ID_SC: what = sc;    break;
+    }
+
+	return mEnabled[what];
+}
+
+/*****************************************************************************/
+
diff --git a/libsensors_sensorhub/FSLSensorsHub.h b/libsensors_sensorhub/FSLSensorsHub.h
new file mode 100755
index 0000000..f8aa6f6
--- /dev/null
+++ b/libsensors_sensorhub/FSLSensorsHub.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_FSL_SENSORS_HUB_H
+#define ANDROID_FSL_SENSORS_HUB_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+class FSLSensorsHub : public SensorBase {
+public:
+    FSLSensorsHub();
+    virtual ~FSLSensorsHub();
+    virtual int setDelay(int32_t handle, int64_t ns);
+    virtual int setEnable(int32_t handle, int enabled);
+    virtual int getEnable(int32_t handle);
+    virtual int readEvents(sensors_event_t* data, int count);
+    void processEvent(int code, int value);
+	void processEvent(int type ,int code, int value);
+
+private:
+	  enum {
+	  	accel		= 1,
+        mag     	= 2,
+        gyro		= 3,
+        orn 		= 4,
+        rv			= 5,
+        la			= 6,
+        gravt		= 7,
+        sd 			= 8,
+		sc			= 9,
+        sensors,			
+    };
+	int is_sensor_enabled();
+	int enable_sensor(int what);
+	int disable_sensor(int what);
+	int update_delay(int sensor_type,int64_t ns);
+	int readDisable();
+	int writeEnable(int what,int isEnable);
+	int writeDelay(int what,int64_t ns);
+	int mEnabled[sensors];
+	int mPendingMask;
+	char mClassPath[sensors][PATH_MAX];
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent[sensors];
+	int64_t mDelay[sensors];
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_FSL_ACCEL_SENSOR_H
diff --git a/libsensors_sensorhub/InputEventReader.cpp b/libsensors_sensorhub/InputEventReader.cpp
new file mode 100755
index 0000000..733ca46
--- /dev/null
+++ b/libsensors_sensorhub/InputEventReader.cpp
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+
+#include <cutils/log.h>
+
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+InputEventCircularReader::InputEventCircularReader(size_t numEvents)
+    : mBuffer(new input_event[numEvents * 2]),
+      mBufferEnd(mBuffer + numEvents),
+      mHead(mBuffer),
+      mCurr(mBuffer),
+      mFreeSpace(numEvents)
+{
+}
+
+InputEventCircularReader::~InputEventCircularReader()
+{
+    delete [] mBuffer;
+}
+
+ssize_t InputEventCircularReader::fill(int fd)
+{
+    size_t numEventsRead = 0;
+    if (mFreeSpace) {
+        const ssize_t nread = read(fd, mHead, mFreeSpace * sizeof(input_event));
+        if (nread<0 || nread % sizeof(input_event)) {
+            // we got a partial event!!
+            return nread<0 ? -errno : -EINVAL;
+        }
+
+        numEventsRead = nread / sizeof(input_event);
+        if (numEventsRead) {
+            mHead += numEventsRead;
+            mFreeSpace -= numEventsRead;
+            if (mHead > mBufferEnd) {
+                size_t s = mHead - mBufferEnd;
+                memcpy(mBuffer, mBufferEnd, s * sizeof(input_event));
+                mHead = mBuffer + s;
+            }
+        }
+    }
+
+    return numEventsRead;
+}
+
+ssize_t InputEventCircularReader::readEvent(input_event const** events)
+{
+    *events = mCurr;
+    ssize_t available = (mBufferEnd - mBuffer) - mFreeSpace;
+    return available ? 1 : 0;
+}
+
+void InputEventCircularReader::next()
+{
+    mCurr++;
+    mFreeSpace++;
+    if (mCurr >= mBufferEnd) {
+        mCurr = mBuffer;
+    }
+}
diff --git a/libsensors_sensorhub/InputEventReader.h b/libsensors_sensorhub/InputEventReader.h
new file mode 100755
index 0000000..59377b9
--- /dev/null
+++ b/libsensors_sensorhub/InputEventReader.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_INPUT_EVENT_READER_H
+#define ANDROID_INPUT_EVENT_READER_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+/*****************************************************************************/
+
+struct input_event;
+
+class InputEventCircularReader
+{
+    struct input_event* const mBuffer;
+    struct input_event* const mBufferEnd;
+    struct input_event* mHead;
+    struct input_event* mCurr;
+    ssize_t mFreeSpace;
+
+public:
+    InputEventCircularReader(size_t numEvents);
+    ~InputEventCircularReader();
+    ssize_t fill(int fd);
+    ssize_t readEvent(input_event const** events);
+    void next();
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_INPUT_EVENT_READER_H
diff --git a/libsensors_sensorhub/PressSensor.cpp b/libsensors_sensorhub/PressSensor.cpp
new file mode 100755
index 0000000..5056579
--- /dev/null
+++ b/libsensors_sensorhub/PressSensor.cpp
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <dlfcn.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include "PressSensor.h"
+
+#define PRESS_DATA_NAME    "mpl3115" 
+#define PRESS_SYSFS_PATH   "/sys/class/input"
+#define PRESS_SYSFS_DELAY  "poll"
+#define PRESS_SYSFS_ENABLE "enable"
+#define PRESS_EVENT 		ABS_PRESSURE
+#define TEMPERATURE_EVENT 	ABS_MISC
+#define PRESS_DATA_CONVERSION(value) (float)((float)(((int)value)/(4.0f*100)))
+#define TEMPERATURE_DATA_CONVERSION(value) (float)((float)(((int)value)/(16.0f)))
+
+PressSensor::PressSensor()
+: SensorBase(NULL, PRESS_DATA_NAME),
+  mPendingMask(0),
+  mInputReader(4)
+{
+    ALOGD("sendrolon press sensor init");
+    memset(&mPendingEvent[0], 0, sensors *sizeof(sensors_event_t));
+	memset(mClassPath, '\0', sizeof(mClassPath));
+
+	mEnabled[press] = 0;
+	mDelay[press] = 0;
+    mPendingEvent[press].version = sizeof(sensors_event_t);
+    mPendingEvent[press].sensor  = ID_P;
+    mPendingEvent[press].type    = SENSOR_TYPE_PRESSURE;
+    mPendingEvent[press].magnetic.status = SENSOR_STATUS_ACCURACY_HIGH;
+    mPendingEvent[press].version = sizeof(sensors_event_t);
+
+	mEnabled[temperature] = 0;
+	mDelay[temperature] = 0;
+    mPendingEvent[temperature].sensor  = ID_T;
+    mPendingEvent[temperature].type    = SENSOR_TYPE_TEMPERATURE;
+    mPendingEvent[temperature].orientation.status = SENSOR_STATUS_ACCURACY_HIGH;
+	mPendingEvent[temperature].version = sizeof(sensors_event_t);
+	
+	if(sensor_get_class_path(mClassPath))
+	{
+		ALOGE("Can`t find the press sensor!");
+	}
+}
+
+PressSensor::~PressSensor()
+{
+}
+
+int PressSensor::setEnable(int32_t handle, int en)
+{
+	int err = 0;
+	int what = press;
+    switch(handle){
+		case ID_P : what = press; break;
+		case ID_T : what = temperature; break;
+    }
+
+    if(en)
+		mEnabled[what]++;
+	else
+		mEnabled[what]--;
+	if(mEnabled[what] < 0)
+		mEnabled[what] = 0;
+	if(mEnabled[press] > 0 || mEnabled[temperature] > 0)
+		err = enable_sensor();
+	else
+		err = disable_sensor();
+	if (!err) {
+            update_delay(what);
+    }
+	ALOGD("PressSensor mEnabled %d, Temperature mEnabled %d\n",mEnabled[press],mEnabled[temperature]);
+    return err;
+}
+
+int PressSensor::setDelay(int32_t handle, int64_t ns)
+{
+    if (ns < 0)
+        return -EINVAL;
+	int what = press;
+    switch(handle){
+		case ID_P : what = press; break;
+		case ID_T : what = temperature; break;
+    }
+
+    mDelay[what] = ns;
+    return update_delay(what);
+}
+
+int PressSensor::update_delay(int sensor_type)
+{
+    if (mEnabled[sensor_type]) {
+        return set_delay(mDelay[sensor_type]);
+    }
+    else
+	    return 0;
+}
+
+int PressSensor::readEvents(sensors_event_t* data, int count)
+{
+	int i;
+    if (count < 1)
+        return -EINVAL;
+
+    ssize_t n = mInputReader.fill(data_fd);
+    if (n < 0)
+        return n;
+
+    int numEventReceived = 0;
+    input_event const* event;
+
+    while (count && mInputReader.readEvent(&event)) {
+        int type = event->type;
+        if ((type == EV_ABS) || (type == EV_REL) || (type == EV_KEY)) {
+            processEvent(event->code, event->value);
+            mInputReader.next();
+        } else if (type == EV_SYN) {
+            int64_t time = timevalToNano(event->time);
+			for(i = 0 ; i< sensors && mPendingMask && count ;i++){
+			  	 	if(mPendingMask & (1 << i)){
+						mPendingMask &= ~(1 << i);
+						mPendingEvent[i].timestamp = time;
+						if (mEnabled[i]) {
+							*data++ = mPendingEvent[i];
+							count--;
+							numEventReceived++;
+						}
+			  	 	}
+	       }
+		   if (!mPendingMask) {
+		       mInputReader.next();
+		   }
+        } else {
+            mInputReader.next();
+        }
+    }
+
+    return numEventReceived;
+}
+
+void PressSensor::processEvent(int code, int value)
+{
+
+    switch (code) {
+        case PRESS_EVENT:
+            mPendingMask |= 1 << press;
+            mPendingEvent[press].pressure = PRESS_DATA_CONVERSION(value);
+            break;
+        case TEMPERATURE_EVENT:
+            mPendingMask |= 1 << temperature;
+            mPendingEvent[temperature].temperature = TEMPERATURE_DATA_CONVERSION(value);
+			break;
+    }
+}
+
+int PressSensor::writeEnable(int isEnable) {
+	char attr[PATH_MAX] = {'\0'};
+	if(mClassPath[0] == '\0')
+		return -1;
+
+	strcpy(attr, mClassPath);
+	strcat(attr,"/");
+	strcat(attr,PRESS_SYSFS_ENABLE);
+
+	int fd = open(attr, O_RDWR);
+	if (0 > fd) {
+		ALOGE("Could not open (write-only) SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+		return -errno;
+	}
+
+	char buf[2];
+
+	if (isEnable) {
+		buf[0] = '1';
+	} else {
+		buf[0] = '0';
+	}
+	buf[1] = '\0';
+
+	int err = 0;
+	err = write(fd, buf, sizeof(buf));
+
+	if (0 > err) {
+		err = -errno;
+		ALOGE("Could not write SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+	} else {
+		err = 0;
+	}
+
+	close(fd);
+
+	return err;
+}
+
+int PressSensor::writeDelay(int64_t ns) {
+	char attr[PATH_MAX] = {'\0'};
+	if(mClassPath[0] == '\0')
+		return -1;
+
+	strcpy(attr, mClassPath);
+	strcat(attr,"/");
+	strcat(attr,PRESS_SYSFS_DELAY);
+
+	int fd = open(attr, O_RDWR);
+	if (0 > fd) {
+		ALOGE("Could not open (write-only) SysFs attribute \"%s\" (%s).", attr, strerror(errno));
+		return -errno;
+	}
+	if (ns > 10240000000LL) {
+		ns = 10240000000LL; /* maximum delay in nano second. */
+	}
+	if (ns < 312500LL) {
+		ns = 312500LL; /* minimum delay in nano second. */
+	}
+
+    char buf[80];
+    sprintf(buf, "%lld", ns/1000/1000);
+    write(fd, buf, strlen(buf)+1);
+    close(fd);
+    return 0;
+
+}
+
+int PressSensor::enable_sensor() {
+	return writeEnable(1);
+}
+
+int PressSensor::disable_sensor() {
+	return writeEnable(0);
+}
+
+int PressSensor::set_delay(int64_t ns) {
+	return writeDelay(ns);
+}
+
+int PressSensor::getEnable(int32_t handle) {
+	int what = press;
+	if(handle == ID_P)
+		what = press;
+	else if(handle == ID_T)
+		what = temperature;
+	return mEnabled[what];
+}
+
+int PressSensor::sensor_get_class_path(char *class_path)
+{
+	char dirname[] = PRESS_SYSFS_PATH;
+	char buf[256];
+	int res;
+	DIR *dir;
+	struct dirent *de;
+	int fd = -1;
+	int found = 0;
+
+	dir = opendir(dirname);
+	if (dir == NULL)
+		return -1;
+
+	while((de = readdir(dir))) {
+		if (strncmp(de->d_name, "input", strlen("input")) != 0) {
+		    continue;
+        	}
+
+		sprintf(class_path, "%s/%s", dirname, de->d_name);
+		snprintf(buf, sizeof(buf), "%s/name", class_path);
+
+		fd = open(buf, O_RDONLY);
+		if (fd < 0) {
+		    continue;
+		}
+		if ((res = read(fd, buf, sizeof(buf))) < 0) {
+		    close(fd);
+		    continue;
+		}
+		buf[res - 1] = '\0';
+		if (strcmp(buf, PRESS_DATA_NAME) == 0) {
+		    found = 1;
+		    close(fd);
+		    break;
+		}
+
+		close(fd);
+		fd = -1;
+	}
+	closedir(dir);
+	if (found) {
+		return 0;
+	}else {
+		*class_path = '\0';
+		return -1;
+	}
+}
+
+/*****************************************************************************/
+
diff --git a/libsensors_sensorhub/PressSensor.h b/libsensors_sensorhub/PressSensor.h
new file mode 100755
index 0000000..fb1b31c
--- /dev/null
+++ b/libsensors_sensorhub/PressSensor.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_FSL_PRESS_SENSOR_H
+#define ANDROID_FSL_PRESS_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+class PressSensor : public SensorBase {
+public:
+    PressSensor();
+    virtual ~PressSensor();
+    virtual int setDelay(int32_t handle, int64_t ns);
+    virtual int setEnable(int32_t handle, int enabled);
+    virtual int getEnable(int32_t handle);
+    virtual int readEvents(sensors_event_t* data, int count);
+    void processEvent(int code, int value);
+
+private:
+	  enum {
+        press     	= 0,
+        temperature	= 1,
+        sensors  	= 2,			
+    };
+	int sensor_get_class_path(char *class_path);
+	int is_sensor_enabled();
+	int enable_sensor();
+	int disable_sensor();
+	int set_delay(int64_t ns);
+	int update_delay(int sensor_type);
+	int readDisable();
+	int writeEnable(int isEnable);
+	int writeDelay(int64_t ns);
+	int mEnabled[sensors];
+	int mPendingMask;
+	char mClassPath[PATH_MAX];
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent[sensors];
+	int64_t mDelay[sensors];
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_FSL_ACCEL_SENSOR_H
diff --git a/libsensors_sensorhub/SensorBase.cpp b/libsensors_sensorhub/SensorBase.cpp
new file mode 100755
index 0000000..2d65537
--- /dev/null
+++ b/libsensors_sensorhub/SensorBase.cpp
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <stdlib.h>
+#include <cutils/log.h>
+
+#include <linux/input.h>
+
+#include "SensorBase.h"
+SensorBase::SensorBase(
+        const char* dev_name,
+        const char* data_name)
+    : dev_name(dev_name), data_name(data_name),
+      dev_fd(-1),
+      data_fd(-1)
+{
+
+    if (data_name) {
+        data_fd = openInput(data_name);
+    }
+	fifo_fd = -1;
+	fifo_name = NULL;
+	mBatchEnabled = false;
+}
+
+SensorBase::SensorBase(
+	const char* dev_name,
+	const char* data_name,
+	const char* fifo_name)
+	: dev_name(dev_name), data_name(data_name),fifo_name(fifo_name),
+     dev_fd(-1),
+     data_fd(-1),
+     fifo_fd(-1)
+{
+	if (data_name) {
+        data_fd = openInput(data_name);
+    }
+	if(fifo_name){
+		open_fifo_device();
+	}
+	mBatchEnabled = false;
+}
+
+SensorBase::~SensorBase() {
+    if (data_fd >= 0) {
+        close(data_fd);
+    }
+    if (dev_fd >= 0) {
+        close(dev_fd);
+    }
+	if(fifo_fd >= 0)
+	{
+		close(fifo_fd);
+	}
+}
+
+int SensorBase::open_device() {
+    if (dev_fd<0 && dev_name) {
+        dev_fd = open(dev_name, O_RDONLY);
+        ALOGE_IF(dev_fd<0, "Couldn't open %s (%s)", dev_name, strerror(errno));
+    }
+    return 0;
+}
+
+int SensorBase::close_device() {
+    if (dev_fd >= 0) {
+        close(dev_fd);
+        dev_fd = -1;
+    }
+    return 0;
+}
+
+int SensorBase::open_fifo_device(){
+	if (fifo_fd < 0 && fifo_name) {
+        fifo_fd = open(fifo_name, O_RDONLY);
+        ALOGE_IF(fifo_fd < 0, "Couldn't  open %s (%s)", fifo_name, strerror(errno));
+    }
+	return 0;
+}
+int SensorBase::close_fifo_device(){
+	if (fifo_fd >= 0) {
+        close(fifo_fd);
+        fifo_fd = -1;
+    }
+    return 0;
+}
+int SensorBase::getFd() const 
+{    
+	if(mBatchEnabled){
+		return fifo_fd;    
+	}else{       
+		return data_fd;    
+	}
+}
+int SensorBase::setEnable(int32_t handle, int enabled)
+{
+	return 0;
+}
+int SensorBase::getEnable(int32_t handle)
+{
+	return 0;
+}
+
+int SensorBase::setDelay(int32_t handle, int64_t ns) {
+    return 0;
+}
+
+bool SensorBase::hasPendingEvents() const {
+	return false;
+}
+void  processEvent(int code, int value) 
+{
+
+}
+
+int64_t SensorBase::getTimestamp() {
+    struct timespec t;
+    t.tv_sec = t.tv_nsec = 0;
+    clock_gettime(CLOCK_MONOTONIC, &t);
+    return int64_t(t.tv_sec)*1000000000LL + t.tv_nsec;
+}
+
+int SensorBase::openInput(const char* inputName) {
+    int fd = -1;
+	int input_id = -1;
+    const char *dirname = "/dev/input";
+	const char *inputsysfs = "/sys/class/input";
+    char devname[PATH_MAX];
+    char *filename;
+    DIR *dir;
+    struct dirent *de;
+
+    dir = opendir(dirname);
+    if(dir == NULL)
+        return -1;
+    strcpy(devname, dirname);
+    filename = devname + strlen(devname);
+    *filename++ = '/';
+    while((de = readdir(dir))) {
+        if(de->d_name[0] == '.' &&
+                (de->d_name[1] == '\0' ||
+                        (de->d_name[1] == '.' && de->d_name[2] == '\0')))
+            continue;
+        strcpy(filename, de->d_name);
+        fd = open(devname, O_RDONLY);
+
+        if (fd>=0) {
+            char name[80];
+            if (ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
+                name[0] = '\0';
+            }
+
+            if (!strcmp(name, inputName)) {
+                strcpy(input_name, filename);			
+                break;
+            } else {
+                close(fd);
+                fd = -1;
+            }
+        }
+    }
+    closedir(dir);
+    ALOGE_IF(fd<0, "couldn't find '%s' input device", inputName);
+    return fd;
+}
+int SensorBase::readEvents(sensors_event_t* data, int count)
+{
+  	return 0;
+}
+int SensorBase::batch(int handle, int flags, int64_t period_ns, int64_t timeout){
+	
+	/*default , not support batch mode or SENSORS_BATCH_WAKE_UPON_FIFO_FULL */
+	if(timeout > 0 || flags & SENSORS_BATCH_WAKE_UPON_FIFO_FULL) 
+		return -EINVAL;
+	if(!(flags & SENSORS_BATCH_DRY_RUN)){
+		setDelay(handle,period_ns);
+	}
+	return 0;
+}
+int SensorBase::flush(int handle){
+	return  -EINVAL;
+}
+
+
diff --git a/libsensors_sensorhub/SensorBase.h b/libsensors_sensorhub/SensorBase.h
new file mode 100755
index 0000000..881856e
--- /dev/null
+++ b/libsensors_sensorhub/SensorBase.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SENSOR_BASE_H
+#define ANDROID_SENSOR_BASE_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include "InputEventReader.h"
+#include "sensors.h"
+
+#define SENSORS_MAX  20
+
+/*****************************************************************************/
+class SensorBase {
+protected:
+    const char* dev_name;
+    const char* data_name;
+	const char* fifo_name;
+    char        input_name[PATH_MAX];
+    int         dev_fd;
+    int         data_fd;
+	int 		fifo_fd;
+	bool 		mBatchEnabled;
+    int openInput(const char* inputName);
+    static int64_t getTimestamp();
+
+
+    static int64_t timevalToNano(timeval const& t) {
+        return t.tv_sec*1000000000LL + t.tv_usec*1000;
+    }
+
+    int open_device();
+    int close_device();
+	int open_fifo_device();
+    int close_fifo_device();
+    
+public:
+    SensorBase(const char* dev_name,const char* data_name);
+	SensorBase(const char* dev_name,const char* data_name,const char* fifo_name);
+    virtual ~SensorBase();
+	virtual bool hasPendingEvents() const;
+    virtual int getFd() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+    virtual int setEnable(int32_t handle, int enabled);
+    virtual int getEnable(int32_t handle);
+    virtual int readEvents(sensors_event_t* data, int count);
+    virtual void processEvent(int code, int value) = 0;
+	virtual int batch(int handle, int flags, int64_t period_ns, int64_t timeout);
+	virtual int flush(int handle);
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_SENSOR_BASE_H
diff --git a/libsensors_sensorhub/sensors.cpp b/libsensors_sensorhub/sensors.cpp
new file mode 100755
index 0000000..eaeebc2
--- /dev/null
+++ b/libsensors_sensorhub/sensors.cpp
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Sensors"
+
+#include <hardware/sensors.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <math.h>
+#include <poll.h>
+#include <pthread.h>
+#include <stdlib.h>
+
+#include <linux/input.h>
+
+#include <utils/Atomic.h>
+#include <utils/Log.h>
+
+#include "sensors.h"
+#include "PressSensor.h"
+
+#include "FSLSensorsHub.h"
+
+/*****************************************************************************/
+
+#define DELAY_OUT_TIME 0x7FFFFFFF
+
+#define LIGHT_SENSOR_POLLTIME    2000000000
+
+#define SENSORS_ACCELERATION_HANDLE     ID_A
+#define SENSORS_MAGNETIC_FIELD_HANDLE   ID_M
+#define SENSORS_ORIENTATION_HANDLE      ID_O
+#define SENSORS_GYROSCOPE_HANDLE        ID_GY
+#define SENSORS_LIGHT_HANDLE            ID_L
+#define SENSORS_PRESSURE_HANDLE         ID_P
+#define SENSORS_TEMPERATURE_HANDLE      ID_T
+#define SENSORS_PROXIMITY_HANDLE        ID_PX
+#define SENSORS_GRAVITY_HANDLE			ID_GR
+#define SENSORS_LINEAR_ACCEL_HANDLE		ID_LA
+#define SENSORS_ROTATION_VECTOR_HANDLE  ID_RV
+#define SENSORS_STEP_DETECTOR_HANDLE  	ID_SD
+#define SENSORS_STEP_COUNTER_HANDLE  	ID_SC
+
+
+/*****************************************************************************/
+
+/* The SENSORS Module */
+static const struct sensor_t sSensorList[] = {
+        { "Freescale Sensor Hub Accelerometer",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_ACCELERATION_HANDLE,
+          SENSOR_TYPE_ACCELEROMETER, RANGE_A, CONVERT_A, 0.30f, 20000, 0, 0, "" },
+          
+        { "Freescale Sensor Hub Magnetic field sensor",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_MAGNETIC_FIELD_HANDLE,
+          SENSOR_TYPE_MAGNETIC_FIELD, 1500.0f, CONVERT_M, 0.50f, 100000, 0, 0, "" },
+          
+        { "Freescale Sensor Hub Orientation sensor",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_ORIENTATION_HANDLE,
+          SENSOR_TYPE_ORIENTATION, 360.0f, CONVERT_O, 0.50f, 100000, 0, 0, "" },
+          
+        { "Freescale Sensor Hub Gyroscope sensor",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_GYROSCOPE_HANDLE,
+          SENSOR_TYPE_GYROSCOPE, 4000.0f, 0.0035, 0.50f, 100000, 0, 0, "" },
+
+		 { "Freescale Sensor Hub Rotation Vector",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_ROTATION_VECTOR_HANDLE,
+          SENSOR_TYPE_ROTATION_VECTOR,10240.0f, 1.0f, 0.50f, 100000, 0, 0, "" },
+		
+        { "Freescale Sensor Hub Gravity",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_GRAVITY_HANDLE,
+          SENSOR_TYPE_GRAVITY, 10240.0f, 1.0f, 0.50f, 100000, 0, 0, "" },
+          
+        { "Freescale Sensor Hub Linear Accelerometer",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_LINEAR_ACCEL_HANDLE,
+          SENSOR_TYPE_LINEAR_ACCELERATION,10240.0f, 1.0f, 0.50f, 100000, 0, 0, "" },
+        { "Freescale Sensor Hub Step Detect",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_STEP_DETECTOR_HANDLE,
+          SENSOR_TYPE_STEP_DETECTOR, 1.0, 1.0f, 0.50f, 100000, 0, 0, "" }, 
+        { "Freescale Sensor Hub Step Count",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_STEP_COUNTER_HANDLE,
+          SENSOR_TYPE_STEP_COUNTER, 360.0f, CONVERT_O, 0.50f, 100000, 0, 0, "" },
+        { "Freescale Pressure Sensor ",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_PRESSURE_HANDLE,
+          SENSOR_TYPE_PRESSURE, 110.0f, 1.5, 0.50f, 100000, 0, 0, "" },
+        { "Freescale Temperature Sensor ",
+          "Freescale Semiconductor Inc.",
+          1, SENSORS_TEMPERATURE_HANDLE,
+          SENSOR_TYPE_TEMPERATURE, 110.0f, 1.5, 0.50f, 100000, 0, 0, "" },
+};
+
+
+static int open_sensors(const struct hw_module_t* module, const char* id,
+                        struct hw_device_t** device);
+
+
+static int sensors__get_sensors_list(struct sensors_module_t* module,
+                                     struct sensor_t const** list)
+{
+        *list = sSensorList;
+        return ARRAY_SIZE(sSensorList);
+}
+
+static struct hw_module_methods_t sensors_module_methods = {
+        open: open_sensors
+};
+
+struct sensors_module_t HAL_MODULE_INFO_SYM = {
+        common: {
+                tag: HARDWARE_MODULE_TAG,
+                version_major: 1,
+                version_minor: 1,
+                id: SENSORS_HARDWARE_MODULE_ID,
+                name: "Freescale Sensor module",
+                author: "Freescale Semiconductor Inc.",
+                methods: &sensors_module_methods,
+        },
+        get_sensors_list: sensors__get_sensors_list,
+};
+struct sensors_poll_context_t {
+    struct sensors_poll_device_1 device; // must be first
+
+        sensors_poll_context_t();
+        ~sensors_poll_context_t();
+	int fillPollFd();
+    int activate(int handle, int enabled);
+    int setDelay(int handle, int64_t ns);
+    int pollEvents(sensors_event_t* data, int count);
+	int batch(int handle, int flags, int64_t period_ns, int64_t timeout);
+	int flush(int handle);
+	int magRunTimes;
+private:
+    enum {
+        fsl_sens           = 0,
+        press,
+        temperature,
+        numSensorDrivers,
+        numFds,
+    };
+    static const size_t wake = numFds - 1;
+    static const char WAKE_MESSAGE = 'W';
+    struct pollfd mPollFds[numFds];
+    int mWritePipeFd;
+    SensorBase* mSensors[numSensorDrivers];
+
+    int handleToDriver(int handle) const {
+        switch (handle) {
+            case ID_P:
+                return press;
+                break;
+            case ID_T:
+                return temperature;
+                break;
+            case ID_A:
+          	case ID_M:
+          	case ID_O:
+			case ID_GY:
+			case ID_GR:
+			case ID_LA:
+			case ID_RV:
+			case ID_SD:
+			case ID_SC:
+			  return fsl_sens;
+        }
+        return -EINVAL;
+    }
+};
+
+/*****************************************************************************/
+int sensors_poll_context_t::fillPollFd(){
+	int i = 0;
+	for(i = 0 ; i < numSensorDrivers; i++){
+		if(mSensors[i] != NULL)
+			 mPollFds[i].fd = mSensors[i]->getFd();
+   			 mPollFds[i].events = POLLIN;
+    		 mPollFds[i].revents = 0;
+	}
+	return 0;
+}
+sensors_poll_context_t::sensors_poll_context_t()
+{
+    mSensors[fsl_sens] = new FSLSensorsHub();
+    mSensors[press] = new PressSensor();
+    mSensors[temperature] = new PressSensor();
+	fillPollFd();
+	magRunTimes = 0;
+    int wakeFds[2];
+    int result = pipe(wakeFds);
+    ALOGE_IF(result<0, "error creating wake pipe (%s)", strerror(errno));
+    fcntl(wakeFds[0], F_SETFL, O_NONBLOCK);
+    fcntl(wakeFds[1], F_SETFL, O_NONBLOCK);
+    mWritePipeFd = wakeFds[1];
+
+    mPollFds[wake].fd = wakeFds[0];
+    mPollFds[wake].events = POLLIN;
+    mPollFds[wake].revents = 0;
+}
+
+sensors_poll_context_t::~sensors_poll_context_t() {
+    for (int i=0 ; i<numSensorDrivers ; i++) {
+        delete mSensors[i];
+    }
+    close(mPollFds[wake].fd);
+    close(mWritePipeFd);
+}
+
+int sensors_poll_context_t::activate(int handle, int enabled) {
+    int index = handleToDriver(handle);
+    if (index < 0) return index;
+    int err = 0 ;
+	err =  mSensors[index]->setEnable(handle, enabled);
+    if (enabled && !err) {
+        const char wakeMessage(WAKE_MESSAGE);
+        int result = write(mWritePipeFd, &wakeMessage, 1);
+        ALOGE_IF(result<0, "error sending wake message (%s)", strerror(errno));
+    }
+    return err;
+}
+
+int sensors_poll_context_t::setDelay(int handle, int64_t ns) {
+    int index = handleToDriver(handle);
+    if (index < 0) return index;
+    return mSensors[index]->setDelay(handle, ns);
+}
+
+int sensors_poll_context_t::pollEvents(sensors_event_t* data, int count)
+{
+    int nbEvents = 0;
+    int n = 0;
+    do {
+        // see if we have some leftover from the last poll()
+        for (int i=0 ; count && i<numSensorDrivers ; i++) {
+            SensorBase* const sensor(mSensors[i]);
+
+	   if ((mPollFds[i].revents & POLLIN) || (sensor->hasPendingEvents())) {
+                int nb = sensor->readEvents(data, count);
+                if (nb < count) {
+                    // no more data for this sensor
+                    mPollFds[i].revents = 0;
+                }
+                count -= nb;
+                nbEvents += nb;
+                data += nb;
+            }
+        }
+
+        if (count) {
+            // we still have some room, so try to see if we can get
+            // some events immediately or just wait if we don't have
+            // anything to return
+            //n = poll(mPollFds, numFds, nbEvents ? 0 : -1);
+			do {
+				//fillPollFd(); /*reset poll fd , if sensor change between batch mode and continuous mode*/
+			 	n = poll(mPollFds, numFds, nbEvents ? 0 : -1);            
+			} while (n < 0 && errno == EINTR);
+            if (n<0) {
+                ALOGE("poll() failed (%s)", strerror(errno));
+                return -errno;
+            }
+            if (mPollFds[wake].revents & POLLIN) {
+                char msg;
+                int result = read(mPollFds[wake].fd, &msg, 1);
+                ALOGE_IF(result<0, "error reading from wake pipe (%s)", strerror(errno));
+                ALOGE_IF(msg != WAKE_MESSAGE, "unknown message on wake queue (0x%02x)", int(msg));
+                mPollFds[wake].revents = 0;
+            }
+        }
+        // if we have events and space, go read them
+    } while (n && count);
+
+    return nbEvents;
+}
+int sensors_poll_context_t::batch(int handle, int flags, int64_t period_ns, int64_t timeout){
+	 int ret;
+	 int index = handleToDriver(handle);
+     if (index < 0) return index;
+	 ret = mSensors[index]->batch(handle,flags,period_ns,timeout);
+	 const char wakeMessage(WAKE_MESSAGE); 
+     int result = write(mWritePipeFd, &wakeMessage, 1);
+     ALOGE_IF(result<0, "error batch sending wake message (%s)", strerror(errno));
+	 return ret;
+}
+int sensors_poll_context_t::flush(int handle){
+	int index = handleToDriver(handle);
+    if (index < 0) return index;
+    return mSensors[index]->flush(handle);
+}
+
+/*****************************************************************************/
+
+static int poll__close(struct hw_device_t *dev)
+{
+    sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+    if (ctx) {
+        delete ctx;
+    }
+    return 0;
+}
+
+static int poll__activate(struct sensors_poll_device_t *dev,
+        int handle, int enabled) {
+    sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+    return ctx->activate(handle, enabled);
+}
+
+static int poll__setDelay(struct sensors_poll_device_t *dev,
+        int handle, int64_t ns) {
+    sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+    return ctx->setDelay(handle, ns);
+}
+
+static int poll__poll(struct sensors_poll_device_t *dev,
+        sensors_event_t* data, int count) {
+    sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+    return ctx->pollEvents(data, count);
+}
+static int poll__batch(struct sensors_poll_device_1* dev,
+            int handle, int flags, int64_t period_ns, int64_t timeout){
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->batch(handle,flags,period_ns,timeout);
+}
+
+static int poll__flush(struct sensors_poll_device_1* dev, int handle){
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->flush(handle);
+}
+/*****************************************************************************/
+
+/** Open a new instance of a sensor device using name */
+static int open_sensors(const struct hw_module_t* module, const char* id,
+                        struct hw_device_t** device)
+{
+        int status = -EINVAL;
+        sensors_poll_context_t *dev = new sensors_poll_context_t();
+
+        memset(&dev->device, 0, sizeof(sensors_poll_device_1));
+
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version  = SENSORS_DEVICE_API_VERSION_1_1;
+        dev->device.common.module   = const_cast<hw_module_t*>(module);
+        dev->device.common.close    = poll__close;
+        dev->device.activate        = poll__activate;
+        dev->device.setDelay        = poll__setDelay;
+        dev->device.poll            = poll__poll;
+		dev->device.batch			= poll__batch;
+		dev->device.flush			= poll__flush;
+        *device = &dev->device.common;
+        status = 0;
+
+        return status;
+}
diff --git a/libsensors_sensorhub/sensors.h b/libsensors_sensorhub/sensors.h
new file mode 100755
index 0000000..f5aedde
--- /dev/null
+++ b/libsensors_sensorhub/sensors.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SENSORS_H
+#define ANDROID_SENSORS_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+
+#include <hardware/hardware.h>
+#include <hardware/sensors.h>
+
+__BEGIN_DECLS
+
+/*****************************************************************************/
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+#define ID_A  (0)
+#define ID_M  (1)
+#define ID_O  (2)
+#define ID_GY (3)
+#define ID_L  (4)
+#define ID_P  (5)
+#define ID_T  (6)
+#define ID_PX (7)
+#define ID_GR (9)
+#define ID_LA (10)
+#define ID_RV (11)
+#define ID_SD (12)		/*step detect*/
+#define ID_SC (13)	    /*step count*/
+
+
+#define HWROTATION_0   (0)
+#define HWROTATION_90  (1)
+#define HWROTATION_180 (2)
+#define HWROTATION_270 (3)
+
+/*****************************************************************************/
+
+/*
+ * The SENSORS Module
+ */
+
+/*****************************************************************************/
+
+#define EVENT_TYPE_ACCEL_X          ABS_X
+#define EVENT_TYPE_ACCEL_Y          ABS_Y
+#define EVENT_TYPE_ACCEL_Z          ABS_Z
+
+#define EVENT_TYPE_YAW              ABS_RX
+#define EVENT_TYPE_PITCH            ABS_RY
+#define EVENT_TYPE_ROLL             ABS_RZ
+#define EVENT_TYPE_ORIENT_STATUS    ABS_WHEEL
+
+#define EVENT_TYPE_MAGV_X           ABS_X
+#define EVENT_TYPE_MAGV_Y           ABS_Y
+#define EVENT_TYPE_MAGV_Z           ABS_Z
+
+#define EVENT_TYPE_LIGHT            ABS_MISC
+
+#define EVENT_TYPE_PRESSURE	        ABS_PRESSURE
+
+#define EVENT_TYPE_TEMPERATURE		ABS_MISC
+
+#define LSG                         (0x4000) // 
+
+// conversion of acceleration data to SI units (m/s^2)
+#define RANGE_A                     (2*GRAVITY_EARTH)
+#define CONVERT_A                   (GRAVITY_EARTH / LSG)
+#define CONVERT_A_X                 (CONVERT_A)
+#define CONVERT_A_Y                 (CONVERT_A)
+#define CONVERT_A_Z                 (CONVERT_A)
+
+// conversion of magnetic data to uT units
+#define CONVERT_M                   (1.0f/20.0f)
+#define CONVERT_M_X                 (CONVERT_M)
+#define CONVERT_M_Y                 (CONVERT_M)
+#define CONVERT_M_Z                 (CONVERT_M)
+
+/* conversion of orientation data to degree units */
+#define CONVERT_O                   (1.0f/100.0f)
+#define CONVERT_O_Y                 (CONVERT_O)
+#define CONVERT_O_P                 (CONVERT_O)
+#define CONVERT_O_R                 (CONVERT_O)
+
+#define CONVERT_PRESSURE            (1.0f/(4.0f*100)) // hpa
+
+#define CONVERT_TEMPERATURE		    (1.0f/16.0f)     //Celsius
+
+
+#define SENSOR_STATE_MASK           (0x7FFF)
+
+/*****************************************************************************/
+
+__END_DECLS
+
+#endif  // ANDROID_SENSORS_H
-- 
1.8.0

