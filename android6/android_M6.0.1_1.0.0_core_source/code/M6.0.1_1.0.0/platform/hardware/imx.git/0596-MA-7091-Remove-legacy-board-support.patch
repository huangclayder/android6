From eb157f9d4eb154faf96ea34d793bb7071dbba071 Mon Sep 17 00:00:00 2001
From: "guoyin.chen" <guoyin.chen@freescale.com>
Date: Sat, 10 Oct 2015 11:44:20 +0800
Subject: [PATCH 596/635] MA-7091 Remove legacy board support

Remove mx5x HAL and intel wifi sdk

Signed-off-by: guoyin.chen <guoyin.chen@freescale.com>
---
 mx5x/audio/Android.mk                              |   33 -
 mx5x/audio/audio_hw.c                              | 1272 -----------
 mx5x/audio/audio_route.c                           |  495 ----
 mx5x/audio/audio_route.h                           |   34 -
 mx5x/hwcomposer/Android.mk                         |   33 -
 mx5x/hwcomposer/hwc_context.h                      |   53 -
 mx5x/hwcomposer/hwc_vsync.cpp                      |   86 -
 mx5x/hwcomposer/hwc_vsync.h                        |   61 -
 mx5x/hwcomposer/hwcomposer.cpp                     |  285 ---
 mx5x/libcamera/Android.mk                          |   79 -
 mx5x/libcamera/CameraHal.cpp                       | 2394 --------------------
 mx5x/libcamera/CameraHal.h                         |  408 ----
 mx5x/libcamera/CameraModule.cpp                    |  744 ------
 mx5x/libcamera/Camera_pmem.cpp                     |  163 --
 mx5x/libcamera/Camera_pmem.h                       |   53 -
 mx5x/libcamera/Camera_utils.h                      |   78 -
 mx5x/libcamera/CaptureDeviceInterface.cpp          |   37 -
 mx5x/libcamera/CaptureDeviceInterface.h            |  116 -
 mx5x/libcamera/JpegEncoderInterface.cpp            |   34 -
 mx5x/libcamera/JpegEncoderInterface.h              |  173 --
 mx5x/libcamera/JpegEncoderSoftware.cpp             |  662 ------
 mx5x/libcamera/JpegEncoderSoftware.h               |   84 -
 mx5x/libcamera/PP_ipulib.cpp                       |  138 --
 mx5x/libcamera/PP_ipulib.h                         |   47 -
 mx5x/libcamera/PostProcessDeviceInterface.cpp      |   26 -
 mx5x/libcamera/PostProcessDeviceInterface.h        |   78 -
 mx5x/libcamera/V4l2CapDeviceBase.cpp               |  715 ------
 mx5x/libcamera/V4l2CapDeviceBase.h                 |   84 -
 mx5x/libcamera/V4l2CsiDevice.cpp                   |  414 ----
 mx5x/libcamera/V4l2CsiDevice.h                     |   59 -
 mx5x/libcamera/V4l2UVCDevice.cpp                   |  716 ------
 mx5x/libcamera/V4l2UVCDevice.h                     |   99 -
 mx5x/libcamera/messageQueue.cpp                    |  143 --
 mx5x/libcamera/messageQueue.h                      |  104 -
 mx5x/libcopybit/Android.mk                         |   46 -
 mx5x/libcopybit/c2d_api.h                          |  543 -----
 mx5x/libcopybit/copybit.cpp                        |  510 -----
 mx5x/libgralloc/Android.mk                         |   40 -
 mx5x/libgralloc/framebuffer.cpp                    |  455 ----
 mx5x/libgralloc/gr.h                               |   48 -
 mx5x/libgralloc/gralloc.cpp                        |  488 ----
 mx5x/libgralloc/gralloc_priv.h                     |  153 --
 mx5x/libgralloc/mapper.cpp                         |  274 ---
 mx5x/power/Android.mk                              |   28 -
 mx5x/power/power.c                                 |   84 -
 wlan/intel/Android.mk                              |    3 -
 wlan/intel/wpa_supplicant_8_lib/Android.mk         |   65 -
 wlan/intel/wpa_supplicant_8_lib/NOTICE             |   43 -
 .../intel/wpa_supplicant_8_lib/driver_cmd_common.h |   58 -
 .../wpa_supplicant_8_lib/driver_cmd_nl80211.c      |  366 ---
 wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.c  |  392 ----
 wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.h  |   38 -
 wlan/intel/wpa_supplicant_8_lib/driver_nl80211.h   |  150 --
 53 files changed, 13784 deletions(-)
 delete mode 100644 mx5x/audio/Android.mk
 delete mode 100644 mx5x/audio/audio_hw.c
 delete mode 100644 mx5x/audio/audio_route.c
 delete mode 100644 mx5x/audio/audio_route.h
 delete mode 100755 mx5x/hwcomposer/Android.mk
 delete mode 100755 mx5x/hwcomposer/hwc_context.h
 delete mode 100755 mx5x/hwcomposer/hwc_vsync.cpp
 delete mode 100755 mx5x/hwcomposer/hwc_vsync.h
 delete mode 100755 mx5x/hwcomposer/hwcomposer.cpp
 delete mode 100755 mx5x/libcamera/Android.mk
 delete mode 100755 mx5x/libcamera/CameraHal.cpp
 delete mode 100755 mx5x/libcamera/CameraHal.h
 delete mode 100644 mx5x/libcamera/CameraModule.cpp
 delete mode 100755 mx5x/libcamera/Camera_pmem.cpp
 delete mode 100755 mx5x/libcamera/Camera_pmem.h
 delete mode 100755 mx5x/libcamera/Camera_utils.h
 delete mode 100755 mx5x/libcamera/CaptureDeviceInterface.cpp
 delete mode 100755 mx5x/libcamera/CaptureDeviceInterface.h
 delete mode 100755 mx5x/libcamera/JpegEncoderInterface.cpp
 delete mode 100755 mx5x/libcamera/JpegEncoderInterface.h
 delete mode 100755 mx5x/libcamera/JpegEncoderSoftware.cpp
 delete mode 100755 mx5x/libcamera/JpegEncoderSoftware.h
 delete mode 100755 mx5x/libcamera/PP_ipulib.cpp
 delete mode 100755 mx5x/libcamera/PP_ipulib.h
 delete mode 100755 mx5x/libcamera/PostProcessDeviceInterface.cpp
 delete mode 100755 mx5x/libcamera/PostProcessDeviceInterface.h
 delete mode 100755 mx5x/libcamera/V4l2CapDeviceBase.cpp
 delete mode 100755 mx5x/libcamera/V4l2CapDeviceBase.h
 delete mode 100755 mx5x/libcamera/V4l2CsiDevice.cpp
 delete mode 100755 mx5x/libcamera/V4l2CsiDevice.h
 delete mode 100644 mx5x/libcamera/V4l2UVCDevice.cpp
 delete mode 100755 mx5x/libcamera/V4l2UVCDevice.h
 delete mode 100644 mx5x/libcamera/messageQueue.cpp
 delete mode 100644 mx5x/libcamera/messageQueue.h
 delete mode 100755 mx5x/libcopybit/Android.mk
 delete mode 100755 mx5x/libcopybit/c2d_api.h
 delete mode 100755 mx5x/libcopybit/copybit.cpp
 delete mode 100644 mx5x/libgralloc/Android.mk
 delete mode 100644 mx5x/libgralloc/framebuffer.cpp
 delete mode 100644 mx5x/libgralloc/gr.h
 delete mode 100644 mx5x/libgralloc/gralloc.cpp
 delete mode 100644 mx5x/libgralloc/gralloc_priv.h
 delete mode 100644 mx5x/libgralloc/mapper.cpp
 delete mode 100644 mx5x/power/Android.mk
 delete mode 100644 mx5x/power/power.c
 delete mode 100644 wlan/intel/Android.mk
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/Android.mk
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/MODULE_LICENSE_BSD
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/NOTICE
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/driver_cmd_common.h
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/driver_cmd_nl80211.c
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.c
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.h
 delete mode 100644 wlan/intel/wpa_supplicant_8_lib/driver_nl80211.h

diff --git a/mx5x/audio/Android.mk b/mx5x/audio/Android.mk
deleted file mode 100644
index 86f0ed7..0000000
--- a/mx5x/audio/Android.mk
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright (C) 2012 The Android Open Source Project
-# Copyright (C) 2012 Freescale Semiconductor, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := audio.primary.$(TARGET_BOARD_PLATFORM)
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SRC_FILES := \
-	audio_hw.c \
-	audio_route.c
-LOCAL_C_INCLUDES += \
-	external/tinyalsa/include \
-	external/expat/lib \
-	$(call include-path-for, audio-utils)
-LOCAL_SHARED_LIBRARIES := liblog libcutils libtinyalsa libaudioutils libexpat
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_SHARED_LIBRARY)
-
diff --git a/mx5x/audio/audio_hw.c b/mx5x/audio/audio_hw.c
deleted file mode 100644
index 8fa4012..0000000
--- a/mx5x/audio/audio_hw.c
+++ /dev/null
@@ -1,1272 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "audio_hw_primary"
-/*#define LOG_NDEBUG 0*/
-
-#include <errno.h>
-#include <pthread.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <sys/time.h>
-
-#include <cutils/log.h>
-#include <cutils/properties.h>
-#include <cutils/str_parms.h>
-
-#include <hardware/audio.h>
-#include <hardware/hardware.h>
-
-#include <system/audio.h>
-
-#include <tinyalsa/asoundlib.h>
-
-#include <audio_utils/resampler.h>
-
-#include "audio_route.h"
-
-#define PCM_CARD 0
-#define PCM_DEVICE 0
-#define PCM_DEVICE_SCO 2
-
-#define OUT_PERIOD_SIZE 512
-#define OUT_SHORT_PERIOD_COUNT 2
-#define OUT_LONG_PERIOD_COUNT 8
-#define OUT_SAMPLING_RATE 44100
-
-#define IN_PERIOD_SIZE 1024
-#define IN_PERIOD_COUNT 4
-#define IN_SAMPLING_RATE 44100
-
-#define SCO_PERIOD_SIZE 256
-#define SCO_PERIOD_COUNT 4
-#define SCO_SAMPLING_RATE 8000
-
-/* minimum sleep time in out_write() when write threshold is not reached */
-#define MIN_WRITE_SLEEP_US 2000
-#define MAX_WRITE_SLEEP_US ((OUT_PERIOD_SIZE * OUT_SHORT_PERIOD_COUNT * 1000000) \
-                                / OUT_SAMPLING_RATE)
-
-enum {
-    OUT_BUFFER_TYPE_UNKNOWN,
-    OUT_BUFFER_TYPE_SHORT,
-    OUT_BUFFER_TYPE_LONG,
-};
-
-struct pcm_config pcm_config_out = {
-    .channels = 2,
-    .rate = OUT_SAMPLING_RATE,
-    .period_size = OUT_PERIOD_SIZE,
-    .period_count = OUT_LONG_PERIOD_COUNT,
-    .format = PCM_FORMAT_S16_LE,
-    .start_threshold = OUT_PERIOD_SIZE * OUT_SHORT_PERIOD_COUNT,
-};
-
-struct pcm_config pcm_config_in = {
-    .channels = 2,
-    .rate = IN_SAMPLING_RATE,
-    .period_size = IN_PERIOD_SIZE,
-    .period_count = IN_PERIOD_COUNT,
-    .format = PCM_FORMAT_S16_LE,
-    .start_threshold = 1,
-    .stop_threshold = (IN_PERIOD_SIZE * IN_PERIOD_COUNT),
-};
-
-struct pcm_config pcm_config_sco = {
-    .channels = 1,
-    .rate = SCO_SAMPLING_RATE,
-    .period_size = SCO_PERIOD_SIZE,
-    .period_count = SCO_PERIOD_COUNT,
-    .format = PCM_FORMAT_S16_LE,
-};
-
-struct audio_device {
-    struct audio_hw_device hw_device;
-
-    pthread_mutex_t lock; /* see note below on mutex acquisition order */
-    unsigned int out_device;
-    unsigned int in_device;
-    bool standby;
-    bool mic_mute;
-    struct audio_route *ar;
-    int orientation;
-    bool screen_off;
-
-    struct stream_out *active_out;
-    struct stream_in *active_in;
-};
-
-struct stream_out {
-    struct audio_stream_out stream;
-
-    pthread_mutex_t lock; /* see note below on mutex acquisition order */
-    struct pcm *pcm;
-    struct pcm_config *pcm_config;
-    bool standby;
-
-    struct resampler_itfe *resampler;
-    int16_t *buffer;
-    size_t buffer_frames;
-
-    int write_threshold;
-    int cur_write_threshold;
-    int buffer_type;
-
-    struct audio_device *dev;
-};
-
-struct stream_in {
-    struct audio_stream_in stream;
-
-    pthread_mutex_t lock; /* see note below on mutex acquisition order */
-    struct pcm *pcm;
-    struct pcm_config *pcm_config;
-    bool standby;
-
-    unsigned int requested_rate;
-    struct resampler_itfe *resampler;
-    struct resampler_buffer_provider buf_provider;
-    int16_t *buffer;
-    size_t buffer_size;
-    size_t frames_in;
-    int read_status;
-
-    struct audio_device *dev;
-};
-
-enum {
-    ORIENTATION_LANDSCAPE,
-    ORIENTATION_PORTRAIT,
-    ORIENTATION_SQUARE,
-    ORIENTATION_UNDEFINED,
-};
-
-static uint32_t out_get_sample_rate(const struct audio_stream *stream);
-static size_t out_get_buffer_size(const struct audio_stream *stream);
-static audio_format_t out_get_format(const struct audio_stream *stream);
-static uint32_t in_get_sample_rate(const struct audio_stream *stream);
-static size_t in_get_buffer_size(const struct audio_stream *stream);
-static audio_format_t in_get_format(const struct audio_stream *stream);
-static int get_next_buffer(struct resampler_buffer_provider *buffer_provider,
-                                   struct resampler_buffer* buffer);
-static void release_buffer(struct resampler_buffer_provider *buffer_provider,
-                                  struct resampler_buffer* buffer);
-
-/*
- * NOTE: when multiple mutexes have to be acquired, always take the
- * audio_device mutex first, followed by the stream_in and/or
- * stream_out mutexes.
- */
-
-/* Helper functions */
-
-static void select_devices(struct audio_device *adev)
-{
-    int headphone_on;
-    int speaker_on;
-    int main_mic_on;
-
-    headphone_on = adev->out_device & (AUDIO_DEVICE_OUT_WIRED_HEADSET |
-                                    AUDIO_DEVICE_OUT_WIRED_HEADPHONE);
-    speaker_on = adev->out_device & AUDIO_DEVICE_OUT_SPEAKER;
-    main_mic_on = adev->in_device & AUDIO_DEVICE_IN_BUILTIN_MIC;
-
-    reset_mixer_state(adev->ar);
-
-    if (speaker_on)
-        audio_route_apply_path(adev->ar, "speaker");
-    if (headphone_on)
-        audio_route_apply_path(adev->ar, "headphone");
-    if (main_mic_on) {
-            audio_route_apply_path(adev->ar, "main-mic");
-    }
-    update_mixer_state(adev->ar);
-
-    ALOGV("hp=%c speaker=%c main-mic=%c", headphone_on ? 'y' : 'n',
-          speaker_on ? 'y' : 'n', main_mic_on ? 'y' : 'n');
-}
-
-/* must be called with hw device and output stream mutexes locked */
-static void do_out_standby(struct stream_out *out)
-{
-    struct audio_device *adev = out->dev;
-
-    if (!out->standby) {
-        pcm_close(out->pcm);
-        out->pcm = NULL;
-        adev->active_out = NULL;
-        if (out->resampler) {
-            release_resampler(out->resampler);
-            out->resampler = NULL;
-        }
-        if (out->buffer) {
-            free(out->buffer);
-            out->buffer = NULL;
-        }
-        out->standby = true;
-    }
-}
-
-/* must be called with hw device and input stream mutexes locked */
-static void do_in_standby(struct stream_in *in)
-{
-    struct audio_device *adev = in->dev;
-
-    if (!in->standby) {
-        pcm_close(in->pcm);
-        in->pcm = NULL;
-        adev->active_in = NULL;
-        if (in->resampler) {
-            release_resampler(in->resampler);
-            in->resampler = NULL;
-        }
-        if (in->buffer) {
-            free(in->buffer);
-            in->buffer = NULL;
-        }
-        in->standby = true;
-    }
-}
-
-/* must be called with hw device and output stream mutexes locked */
-static int start_output_stream(struct stream_out *out)
-{
-    struct audio_device *adev = out->dev;
-    unsigned int device;
-    int ret;
-    //ALOGE("%s (), %s:%d", __FUNCTION__, __FILE__, __LINE__);
-    /*
-     * Due to the lack of sample rate converters in the SoC,
-     * it greatly simplifies things to have only the main
-     * (speaker/headphone) PCM or the BC SCO PCM open at
-     * the same time.
-     */
-    if (adev->out_device & AUDIO_DEVICE_OUT_ALL_SCO) {
-        device = PCM_DEVICE_SCO;
-        out->pcm_config = &pcm_config_sco;
-    } else {
-        device = PCM_DEVICE;
-        out->pcm_config = &pcm_config_out;
-        out->buffer_type = OUT_BUFFER_TYPE_UNKNOWN;
-    }
-
-    /*
-     * All open PCMs can only use a single group of rates at once:
-     * Group 1: 11.025, 22.05, 44.1
-     * Group 2: 8, 16, 32, 48
-     * Group 1 is used for digital audio playback since 44.1 is
-     * the most common rate, but group 2 is required for SCO.
-     */
-    if (adev->active_in) {
-        struct stream_in *in = adev->active_in;
-        pthread_mutex_lock(&in->lock);
-        if (((out->pcm_config->rate % 8000 == 0) &&
-                 (in->pcm_config->rate % 8000) != 0) ||
-                 ((out->pcm_config->rate % 11025 == 0) &&
-                 (in->pcm_config->rate % 11025) != 0))
-            do_in_standby(in);
-        pthread_mutex_unlock(&in->lock);
-    }
-
-    out->pcm = pcm_open(PCM_CARD, device, PCM_OUT | PCM_NORESTART, out->pcm_config);
-
-    if (out->pcm && !pcm_is_ready(out->pcm)) {
-        ALOGE("pcm_open(out) failed: %s", pcm_get_error(out->pcm));
-        pcm_close(out->pcm);
-        return -ENOMEM;
-    }
-
-    /*
-     * If the stream rate differs from the PCM rate, we need to
-     * create a resampler.
-     */
-    if (out_get_sample_rate(&out->stream.common) != out->pcm_config->rate) {
-        ret = create_resampler(out_get_sample_rate(&out->stream.common),
-                               out->pcm_config->rate,
-                               out->pcm_config->channels,
-                               RESAMPLER_QUALITY_DEFAULT,
-                               NULL,
-                               &out->resampler);
-        out->buffer_frames = (pcm_config_out.period_size * out->pcm_config->rate) /
-                out_get_sample_rate(&out->stream.common) + 1;
-
-        out->buffer = malloc(pcm_frames_to_bytes(out->pcm, out->buffer_frames));
-    }
-
-    adev->active_out = out;
-
-    return 0;
-}
-
-/* must be called with hw device and input stream mutexes locked */
-static int start_input_stream(struct stream_in *in)
-{
-    struct audio_device *adev = in->dev;
-    unsigned int device;
-    int ret;
-
-    /*
-     * Due to the lack of sample rate converters in the SoC,
-     * it greatly simplifies things to have only the main
-     * mic PCM or the BC SCO PCM open at the same time.
-     */
-    if (adev->in_device & AUDIO_DEVICE_IN_ALL_SCO) {
-        device = PCM_DEVICE_SCO;
-        in->pcm_config = &pcm_config_sco;
-    } else {
-        device = PCM_DEVICE;
-        in->pcm_config = &pcm_config_in;
-    }
-
-    /*
-     * All open PCMs can only use a single group of rates at once:
-     * Group 1: 11.025, 22.05, 44.1
-     * Group 2: 8, 16, 32, 48
-     * Group 1 is used for digital audio playback since 44.1 is
-     * the most common rate, but group 2 is required for SCO.
-     */
-    if (adev->active_out) {
-        struct stream_out *out = adev->active_out;
-        pthread_mutex_lock(&out->lock);
-        if (((in->pcm_config->rate % 8000 == 0) &&
-                 (out->pcm_config->rate % 8000) != 0) ||
-                 ((in->pcm_config->rate % 11025 == 0) &&
-                 (out->pcm_config->rate % 11025) != 0))
-            do_out_standby(out);
-        pthread_mutex_unlock(&out->lock);
-    }
-
-    in->pcm = pcm_open(PCM_CARD, device, PCM_IN, in->pcm_config);
-
-    if (in->pcm && !pcm_is_ready(in->pcm)) {
-        ALOGE("pcm_open(in) failed: %s", pcm_get_error(in->pcm));
-        pcm_close(in->pcm);
-        return -ENOMEM;
-    }
-
-    /*
-     * If the stream rate differs from the PCM rate, we need to
-     * create a resampler.
-     */
-    if (in_get_sample_rate(&in->stream.common) != in->pcm_config->rate) {
-        in->buf_provider.get_next_buffer = get_next_buffer;
-        in->buf_provider.release_buffer = release_buffer;
-
-        ret = create_resampler(in->pcm_config->rate,
-                               in_get_sample_rate(&in->stream.common),
-                               1,
-                               RESAMPLER_QUALITY_DEFAULT,
-                               &in->buf_provider,
-                               &in->resampler);
-    }
-    in->buffer_size = pcm_frames_to_bytes(in->pcm,
-                                          in->pcm_config->period_size);
-    in->buffer = malloc(in->buffer_size);
-    in->frames_in = 0;
-
-    adev->active_in = in;
-
-    return 0;
-}
-
-static int get_next_buffer(struct resampler_buffer_provider *buffer_provider,
-                                   struct resampler_buffer* buffer)
-{
-    struct stream_in *in;
-
-    if (buffer_provider == NULL || buffer == NULL)
-        return -EINVAL;
-
-    in = (struct stream_in *)((char *)buffer_provider -
-                                   offsetof(struct stream_in, buf_provider));
-
-    if (in->pcm == NULL) {
-        buffer->raw = NULL;
-        buffer->frame_count = 0;
-        in->read_status = -ENODEV;
-        return -ENODEV;
-    }
-
-    if (in->frames_in == 0) {
-        in->read_status = pcm_read(in->pcm,
-                                   (void*)in->buffer,
-                                   in->buffer_size);
-        if (in->read_status != 0) {
-            ALOGE("get_next_buffer() pcm_read error %d", in->read_status);
-            buffer->raw = NULL;
-            buffer->frame_count = 0;
-            return in->read_status;
-        }
-        in->frames_in = in->pcm_config->period_size;
-        if (in->pcm_config->channels == 2) {
-            unsigned int i;
-
-            /* Discard right channel */
-            for (i = 1; i < in->frames_in; i++)
-                in->buffer[i] = in->buffer[i * 2];
-        }
-    }
-
-    buffer->frame_count = (buffer->frame_count > in->frames_in) ?
-                                in->frames_in : buffer->frame_count;
-    buffer->i16 = in->buffer + (in->pcm_config->period_size - in->frames_in);
-
-    return in->read_status;
-
-}
-
-static void release_buffer(struct resampler_buffer_provider *buffer_provider,
-                                  struct resampler_buffer* buffer)
-{
-    struct stream_in *in;
-
-    if (buffer_provider == NULL || buffer == NULL)
-        return;
-
-    in = (struct stream_in *)((char *)buffer_provider -
-                                   offsetof(struct stream_in, buf_provider));
-
-    in->frames_in -= buffer->frame_count;
-}
-
-/* read_frames() reads frames from kernel driver, down samples to capture rate
- * if necessary and output the number of frames requested to the buffer specified */
-static ssize_t read_frames(struct stream_in *in, void *buffer, ssize_t frames)
-{
-    ssize_t frames_wr = 0;
-
-    while (frames_wr < frames) {
-        size_t frames_rd = frames - frames_wr;
-        if (in->resampler != NULL) {
-            in->resampler->resample_from_provider(in->resampler,
-                    (int16_t *)((char *)buffer +
-                            frames_wr * audio_stream_frame_size(&in->stream.common)),
-                    &frames_rd);
-        } else {
-            struct resampler_buffer buf = {
-                    { raw : NULL, },
-                    frame_count : frames_rd,
-            };
-            get_next_buffer(&in->buf_provider, &buf);
-            if (buf.raw != NULL) {
-                memcpy((char *)buffer +
-                           frames_wr * audio_stream_frame_size(&in->stream.common),
-                        buf.raw,
-                        buf.frame_count * audio_stream_frame_size(&in->stream.common));
-                frames_rd = buf.frame_count;
-            }
-            release_buffer(&in->buf_provider, &buf);
-        }
-        /* in->read_status is updated by getNextBuffer() also called by
-         * in->resampler->resample_from_provider() */
-        if (in->read_status != 0)
-            return in->read_status;
-
-        frames_wr += frames_rd;
-    }
-    return frames_wr;
-}
-
-/* API functions */
-
-static uint32_t out_get_sample_rate(const struct audio_stream *stream)
-{
-    return pcm_config_out.rate;
-}
-
-static int out_set_sample_rate(struct audio_stream *stream, uint32_t rate)
-{
-    return -ENOSYS;
-}
-
-static size_t out_get_buffer_size(const struct audio_stream *stream)
-{
-    return pcm_config_out.period_size *
-               audio_stream_frame_size((struct audio_stream *)stream);
-}
-
-static uint32_t out_get_channels(const struct audio_stream *stream)
-{
-    return AUDIO_CHANNEL_OUT_STEREO;
-}
-
-static audio_format_t out_get_format(const struct audio_stream *stream)
-{
-    return AUDIO_FORMAT_PCM_16_BIT;
-}
-
-static int out_set_format(struct audio_stream *stream, audio_format_t format)
-{
-    return -ENOSYS;
-}
-
-static int out_standby(struct audio_stream *stream)
-{
-    struct stream_out *out = (struct stream_out *)stream;
-
-    pthread_mutex_lock(&out->dev->lock);
-    pthread_mutex_lock(&out->lock);
-    do_out_standby(out);
-    pthread_mutex_unlock(&out->lock);
-    pthread_mutex_unlock(&out->dev->lock);
-
-    return 0;
-}
-
-static int out_dump(const struct audio_stream *stream, int fd)
-{
-    return 0;
-}
-
-static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
-{
-    struct stream_out *out = (struct stream_out *)stream;
-    struct audio_device *adev = out->dev;
-    struct str_parms *parms;
-    char value[32];
-    int ret;
-    unsigned int val;
-
-    parms = str_parms_create_str(kvpairs);
-
-    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING,
-                            value, sizeof(value));
-    pthread_mutex_lock(&adev->lock);
-    if (ret >= 0) {
-        val = atoi(value);
-        if ((adev->out_device != val) && (val != 0)) {
-            /*
-             * If SCO is turned on/off, we need to put audio into standby
-             * because SCO uses a different PCM.
-             */
-            if ((val & AUDIO_DEVICE_OUT_ALL_SCO) ^
-                    (adev->out_device & AUDIO_DEVICE_OUT_ALL_SCO)) {
-                pthread_mutex_lock(&out->lock);
-                do_out_standby(out);
-                pthread_mutex_unlock(&out->lock);
-            }
-
-            adev->out_device = val;
-            select_devices(adev);
-        }
-    }
-    pthread_mutex_unlock(&adev->lock);
-
-    str_parms_destroy(parms);
-    return ret;
-}
-
-static char * out_get_parameters(const struct audio_stream *stream, const char *keys)
-{
-    return strdup("");
-}
-
-static uint32_t out_get_latency(const struct audio_stream_out *stream)
-{
-    struct stream_out *out = (struct stream_out *)stream;
-    struct audio_device *adev = out->dev;
-    size_t period_count;
-
-    pthread_mutex_lock(&adev->lock);
-
-    if (adev->screen_off && !adev->active_in && !(adev->out_device & AUDIO_DEVICE_OUT_ALL_SCO))
-        period_count = OUT_LONG_PERIOD_COUNT;
-    else
-        period_count = OUT_SHORT_PERIOD_COUNT;
-
-    pthread_mutex_unlock(&adev->lock);
-
-    return (pcm_config_out.period_size * period_count * 1000) / pcm_config_out.rate;
-}
-
-static int out_set_volume(struct audio_stream_out *stream, float left,
-                          float right)
-{
-    return -ENOSYS;
-}
-
-static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
-                         size_t bytes)
-{
-    int ret = 0;
-    struct stream_out *out = (struct stream_out *)stream;
-    struct audio_device *adev = out->dev;
-    size_t frame_size = audio_stream_frame_size(&out->stream.common);
-    int16_t *in_buffer = (int16_t *)buffer;
-    size_t in_frames = bytes / frame_size;
-    size_t out_frames;
-    int buffer_type;
-    int kernel_frames;
-    bool sco_on;
-    //ALOGE("%s (), %s:%d", __FUNCTION__, __FILE__, __LINE__);
-
-    /*
-     * acquiring hw device mutex systematically is useful if a low
-     * priority thread is waiting on the output stream mutex - e.g.
-     * executing out_set_parameters() while holding the hw device
-     * mutex
-     */
-    pthread_mutex_lock(&adev->lock);
-    pthread_mutex_lock(&out->lock);
-    if (out->standby) {
-        ret = start_output_stream(out);
-        if (ret != 0) {
-            pthread_mutex_unlock(&adev->lock);
-            goto exit;
-        }
-        out->standby = false;
-    }
-    buffer_type = (adev->screen_off && !adev->active_in) ?
-            OUT_BUFFER_TYPE_LONG : OUT_BUFFER_TYPE_SHORT;
-    sco_on = (adev->out_device & AUDIO_DEVICE_OUT_ALL_SCO);
-    pthread_mutex_unlock(&adev->lock);
-
-    /* detect changes in screen ON/OFF state and adapt buffer size
-     * if needed. Do not change buffer size when routed to SCO device. */
-    if (!sco_on && (buffer_type != out->buffer_type)) {
-        size_t period_count;
-
-        if (buffer_type == OUT_BUFFER_TYPE_LONG)
-            period_count = OUT_LONG_PERIOD_COUNT;
-        else
-            period_count = OUT_SHORT_PERIOD_COUNT;
-
-        out->write_threshold = out->pcm_config->period_size * period_count;
-        /* reset current threshold if exiting standby */
-        if (out->buffer_type == OUT_BUFFER_TYPE_UNKNOWN)
-            out->cur_write_threshold = out->write_threshold;
-        out->buffer_type = buffer_type;
-    }
-
-    /* Reduce number of channels, if necessary */
-    if (popcount(out_get_channels(&stream->common)) >
-                 (int)out->pcm_config->channels) {
-        unsigned int i;
-
-        /* Discard right channel */
-        for (i = 1; i < in_frames; i++)
-            in_buffer[i] = in_buffer[i * 2];
-
-        /* The frame size is now half */
-        frame_size /= 2;
-    }
-
-    /* Change sample rate, if necessary */
-    if (out_get_sample_rate(&stream->common) != out->pcm_config->rate) {
-        out_frames = out->buffer_frames;
-        out->resampler->resample_from_input(out->resampler,
-                                            in_buffer, &in_frames,
-                                            out->buffer, &out_frames);
-        in_buffer = out->buffer;
-    } else {
-        out_frames = in_frames;
-    }
-
-    if (!sco_on) {
-        int total_sleep_time_us = 0;
-        size_t period_size = out->pcm_config->period_size;
-
-        /* do not allow more than out->cur_write_threshold frames in kernel
-         * pcm driver buffer */
-        do {
-            struct timespec time_stamp;
-            if (pcm_get_htimestamp(out->pcm,
-                                   (unsigned int *)&kernel_frames,
-                                   &time_stamp) < 0)
-                break;
-            kernel_frames = pcm_get_buffer_size(out->pcm) - kernel_frames;
-
-            if (kernel_frames > out->cur_write_threshold) {
-                int sleep_time_us =
-                    (int)(((int64_t)(kernel_frames - out->cur_write_threshold)
-                                    * 1000000) / out->pcm_config->rate);
-                if (sleep_time_us < MIN_WRITE_SLEEP_US)
-                    break;
-                total_sleep_time_us += sleep_time_us;
-                if (total_sleep_time_us > MAX_WRITE_SLEEP_US) {
-                    ALOGW("out_write() limiting sleep time %d to %d",
-                          total_sleep_time_us, MAX_WRITE_SLEEP_US);
-                    sleep_time_us = MAX_WRITE_SLEEP_US -
-                                        (total_sleep_time_us - sleep_time_us);
-                }
-                usleep(sleep_time_us);
-            }
-
-        } while ((kernel_frames > out->cur_write_threshold) &&
-                (total_sleep_time_us <= MAX_WRITE_SLEEP_US));
-
-        /* do not allow abrupt changes on buffer size. Increasing/decreasing
-         * the threshold by steps of 1/4th of the buffer size keeps the write
-         * time within a reasonable range during transitions.
-         * Also reset current threshold just above current filling status when
-         * kernel buffer is really depleted to allow for smooth catching up with
-         * target threshold.
-         */
-        if (out->cur_write_threshold > out->write_threshold) {
-            out->cur_write_threshold -= period_size / 4;
-            if (out->cur_write_threshold < out->write_threshold) {
-                out->cur_write_threshold = out->write_threshold;
-            }
-        } else if (out->cur_write_threshold < out->write_threshold) {
-            out->cur_write_threshold += period_size / 4;
-            if (out->cur_write_threshold > out->write_threshold) {
-                out->cur_write_threshold = out->write_threshold;
-            }
-        } else if ((kernel_frames < out->write_threshold) &&
-            ((out->write_threshold - kernel_frames) >
-                (int)(period_size * OUT_SHORT_PERIOD_COUNT))) {
-            out->cur_write_threshold = (kernel_frames / period_size + 1) * period_size;
-            out->cur_write_threshold += period_size / 4;
-        }
-    }
-
-    ret = pcm_write(out->pcm, in_buffer, out_frames * frame_size);
-    if (ret == -EPIPE) {
-        /* In case of underrun, don't sleep since we want to catch up asap */
-        pthread_mutex_unlock(&out->lock);
-        return ret;
-    }
-
-exit:
-    pthread_mutex_unlock(&out->lock);
-
-    if (ret != 0) {
-        usleep(bytes * 1000000 / audio_stream_frame_size(&stream->common) /
-               out_get_sample_rate(&stream->common));
-    }
-
-    return bytes;
-}
-
-static int out_get_render_position(const struct audio_stream_out *stream,
-                                   uint32_t *dsp_frames)
-{
-    return -EINVAL;
-}
-
-static int out_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
-{
-    return 0;
-}
-
-static int out_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
-{
-    return 0;
-}
-
-static int out_get_next_write_timestamp(const struct audio_stream_out *stream,
-                                        int64_t *timestamp)
-{
-    return -EINVAL;
-}
-
-/** audio_stream_in implementation **/
-static uint32_t in_get_sample_rate(const struct audio_stream *stream)
-{
-    struct stream_in *in = (struct stream_in *)stream;
-
-    return in->requested_rate;
-}
-
-static int in_set_sample_rate(struct audio_stream *stream, uint32_t rate)
-{
-    return 0;
-}
-
-static size_t in_get_buffer_size(const struct audio_stream *stream)
-{
-    struct stream_in *in = (struct stream_in *)stream;
-    size_t size;
-
-    /*
-     * take resampling into account and return the closest majoring
-     * multiple of 16 frames, as audioflinger expects audio buffers to
-     * be a multiple of 16 frames
-     */
-    size = (in->pcm_config->period_size * in_get_sample_rate(stream)) /
-            in->pcm_config->rate;
-    size = ((size + 15) / 16) * 16;
-
-    return size * audio_stream_frame_size((struct audio_stream *)stream);
-}
-
-static uint32_t in_get_channels(const struct audio_stream *stream)
-{
-    return AUDIO_CHANNEL_IN_MONO;
-}
-
-static audio_format_t in_get_format(const struct audio_stream *stream)
-{
-    return AUDIO_FORMAT_PCM_16_BIT;
-}
-
-static int in_set_format(struct audio_stream *stream, audio_format_t format)
-{
-    return -ENOSYS;
-}
-
-static int in_standby(struct audio_stream *stream)
-{
-    struct stream_in *in = (struct stream_in *)stream;
-
-    pthread_mutex_lock(&in->dev->lock);
-    pthread_mutex_lock(&in->lock);
-    do_in_standby(in);
-    pthread_mutex_unlock(&in->lock);
-    pthread_mutex_unlock(&in->dev->lock);
-
-    return 0;
-}
-
-static int in_dump(const struct audio_stream *stream, int fd)
-{
-    return 0;
-}
-
-static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
-{
-    struct stream_in *in = (struct stream_in *)stream;
-    struct audio_device *adev = in->dev;
-    struct str_parms *parms;
-    char value[32];
-    int ret;
-    unsigned int val;
-
-    parms = str_parms_create_str(kvpairs);
-
-    ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING,
-                            value, sizeof(value));
-    pthread_mutex_lock(&adev->lock);
-    if (ret >= 0) {
-        val = atoi(value) & ~AUDIO_DEVICE_BIT_IN;
-        if ((adev->in_device != val) && (val != 0)) {
-            /*
-             * If SCO is turned on/off, we need to put audio into standby
-             * because SCO uses a different PCM.
-             */
-            if ((val & AUDIO_DEVICE_IN_ALL_SCO) ^
-                    (adev->in_device & AUDIO_DEVICE_IN_ALL_SCO)) {
-                pthread_mutex_lock(&in->lock);
-                do_in_standby(in);
-                pthread_mutex_unlock(&in->lock);
-            }
-
-            adev->in_device = val;
-            select_devices(adev);
-        }
-    }
-    pthread_mutex_unlock(&adev->lock);
-
-    str_parms_destroy(parms);
-    return ret;
-}
-
-static char * in_get_parameters(const struct audio_stream *stream,
-                                const char *keys)
-{
-    return strdup("");
-}
-
-static int in_set_gain(struct audio_stream_in *stream, float gain)
-{
-    return 0;
-}
-
-static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
-                       size_t bytes)
-{
-    int ret = 0;
-    struct stream_in *in = (struct stream_in *)stream;
-    struct audio_device *adev = in->dev;
-    size_t frames_rq = bytes / audio_stream_frame_size(&stream->common);
-
-    /*
-     * acquiring hw device mutex systematically is useful if a low
-     * priority thread is waiting on the input stream mutex - e.g.
-     * executing in_set_parameters() while holding the hw device
-     * mutex
-     */
-    pthread_mutex_lock(&adev->lock);
-    pthread_mutex_lock(&in->lock);
-    if (in->standby) {
-        ret = start_input_stream(in);
-        if (ret == 0)
-            in->standby = 0;
-    }
-    pthread_mutex_unlock(&adev->lock);
-
-    if (ret < 0)
-        goto exit;
-
-    /*if (in->num_preprocessors != 0) {
-        ret = process_frames(in, buffer, frames_rq);
-    } else */if (in->resampler != NULL) {
-        ret = read_frames(in, buffer, frames_rq);
-    } else if (in->pcm_config->channels == 2) {
-        /*
-         * If the PCM is stereo, capture twice as many frames and
-         * discard the right channel.
-         */
-        unsigned int i;
-        int16_t *in_buffer = (int16_t *)buffer;
-
-        ret = pcm_read(in->pcm, in->buffer, bytes * 2);
-
-        /* Discard right channel */
-        for (i = 0; i < frames_rq; i++)
-            in_buffer[i] = in->buffer[i * 2];
-    } else {
-        ret = pcm_read(in->pcm, buffer, bytes);
-    }
-
-    if (ret > 0)
-        ret = 0;
-
-    /*
-     * Instead of writing zeroes here, we could trust the hardware
-     * to always provide zeroes when muted.
-     */
-    if (ret == 0 && adev->mic_mute)
-        memset(buffer, 0, bytes);
-
-exit:
-    if (ret < 0)
-        usleep(bytes * 1000000 / audio_stream_frame_size(&stream->common) /
-               in_get_sample_rate(&stream->common));
-
-    pthread_mutex_unlock(&in->lock);
-    return bytes;
-}
-
-static uint32_t in_get_input_frames_lost(struct audio_stream_in *stream)
-{
-    return 0;
-}
-
-static int in_add_audio_effect(const struct audio_stream *stream,
-                               effect_handle_t effect)
-{
-    return 0;
-}
-
-static int in_remove_audio_effect(const struct audio_stream *stream,
-                                  effect_handle_t effect)
-{
-    return 0;
-}
-
-
-static int adev_open_output_stream(struct audio_hw_device *dev,
-                                   audio_io_handle_t handle,
-                                   audio_devices_t devices,
-                                   audio_output_flags_t flags,
-                                   struct audio_config *config,
-                                   struct audio_stream_out **stream_out)
-{
-    struct audio_device *adev = (struct audio_device *)dev;
-    struct stream_out *out;
-    int ret;
-    ALOGE("%s (), %s:%d", __FUNCTION__, __FILE__, __LINE__);
-
-    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));
-    if (!out)
-        return -ENOMEM;
-
-    out->stream.common.get_sample_rate = out_get_sample_rate;
-    out->stream.common.set_sample_rate = out_set_sample_rate;
-    out->stream.common.get_buffer_size = out_get_buffer_size;
-    out->stream.common.get_channels = out_get_channels;
-    out->stream.common.get_format = out_get_format;
-    out->stream.common.set_format = out_set_format;
-    out->stream.common.standby = out_standby;
-    out->stream.common.dump = out_dump;
-    out->stream.common.set_parameters = out_set_parameters;
-    out->stream.common.get_parameters = out_get_parameters;
-    out->stream.common.add_audio_effect = out_add_audio_effect;
-    out->stream.common.remove_audio_effect = out_remove_audio_effect;
-    out->stream.get_latency = out_get_latency;
-    out->stream.set_volume = out_set_volume;
-    out->stream.write = out_write;
-    out->stream.get_render_position = out_get_render_position;
-    out->stream.get_next_write_timestamp = out_get_next_write_timestamp;
-
-    out->dev = adev;
-
-    config->format = out_get_format(&out->stream.common);
-    config->channel_mask = out_get_channels(&out->stream.common);
-    config->sample_rate = out_get_sample_rate(&out->stream.common);
-
-    out->standby = true;
-
-    *stream_out = &out->stream;
-    return 0;
-
-err_open:
-    free(out);
-    *stream_out = NULL;
-    return ret;
-}
-
-static void adev_close_output_stream(struct audio_hw_device *dev,
-                                     struct audio_stream_out *stream)
-{
-    out_standby(&stream->common);
-    free(stream);
-}
-
-static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
-{
-    struct audio_device *adev = (struct audio_device *)dev;
-    struct str_parms *parms;
-    char *str;
-    char value[32];
-    int ret;
-
-    parms = str_parms_create_str(kvpairs);
-#if 0
-    ret = str_parms_get_str(parms, "orientation", value, sizeof(value));
-    if (ret >= 0) {
-        int orientation;
-
-        if (strcmp(value, "landscape") == 0)
-            orientation = ORIENTATION_LANDSCAPE;
-        else if (strcmp(value, "portrait") == 0)
-            orientation = ORIENTATION_PORTRAIT;
-        else if (strcmp(value, "square") == 0)
-            orientation = ORIENTATION_SQUARE;
-        else
-            orientation = ORIENTATION_UNDEFINED;
-
-        pthread_mutex_lock(&adev->lock);
-        if (orientation != adev->orientation) {
-            adev->orientation = orientation;
-            /*
-             * Orientation changes can occur with the input device
-             * closed so we must call select_devices() here to set
-             * up the mixer. This is because select_devices() will
-             * not be called when the input device is opened if no
-             * other input parameter is changed.
-             */
-            select_devices(adev);
-        }
-        pthread_mutex_unlock(&adev->lock);
-    }
-#endif
-    ret = str_parms_get_str(parms, "screen_state", value, sizeof(value));
-    if (ret >= 0) {
-        if (strcmp(value, AUDIO_PARAMETER_VALUE_ON) == 0)
-            adev->screen_off = false;
-        else
-            adev->screen_off = true;
-    }
-
-    str_parms_destroy(parms);
-    return ret;
-}
-
-static char * adev_get_parameters(const struct audio_hw_device *dev,
-                                  const char *keys)
-{
-    return strdup("");
-}
-
-static int adev_init_check(const struct audio_hw_device *dev)
-{
-    return 0;
-}
-
-static int adev_set_voice_volume(struct audio_hw_device *dev, float volume)
-{
-    return -ENOSYS;
-}
-
-static int adev_set_master_volume(struct audio_hw_device *dev, float volume)
-{
-    return -ENOSYS;
-}
-
-static int adev_set_mode(struct audio_hw_device *dev, audio_mode_t mode)
-{
-    return 0;
-}
-
-static int adev_set_mic_mute(struct audio_hw_device *dev, bool state)
-{
-    struct audio_device *adev = (struct audio_device *)dev;
-
-    adev->mic_mute = state;
-
-    return 0;
-}
-
-static int adev_get_mic_mute(const struct audio_hw_device *dev, bool *state)
-{
-    struct audio_device *adev = (struct audio_device *)dev;
-
-    *state = adev->mic_mute;
-
-    return 0;
-}
-
-static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,
-                                         const struct audio_config *config)
-{
-    size_t size;
-
-    /*
-     * take resampling into account and return the closest majoring
-     * multiple of 16 frames, as audioflinger expects audio buffers to
-     * be a multiple of 16 frames
-     */
-    size = (pcm_config_in.period_size * config->sample_rate) / pcm_config_in.rate;
-    size = ((size + 15) / 16) * 16;
-
-    return (size * popcount(config->channel_mask) *
-                audio_bytes_per_sample(config->format));
-}
-
-static int adev_open_input_stream(struct audio_hw_device *dev,
-                                  audio_io_handle_t handle,
-                                  audio_devices_t devices,
-                                  struct audio_config *config,
-                                  struct audio_stream_in **stream_in)
-{
-    struct audio_device *adev = (struct audio_device *)dev;
-    struct stream_in *in;
-    int ret;
-
-    *stream_in = NULL;
-
-    /* Respond with a request for mono if a different format is given. */
-    if (config->channel_mask != AUDIO_CHANNEL_IN_MONO) {
-        config->channel_mask = AUDIO_CHANNEL_IN_MONO;
-        return -EINVAL;
-    }
-
-    in = (struct stream_in *)calloc(1, sizeof(struct stream_in));
-    if (!in)
-        return -ENOMEM;
-
-    in->stream.common.get_sample_rate = in_get_sample_rate;
-    in->stream.common.set_sample_rate = in_set_sample_rate;
-    in->stream.common.get_buffer_size = in_get_buffer_size;
-    in->stream.common.get_channels = in_get_channels;
-    in->stream.common.get_format = in_get_format;
-    in->stream.common.set_format = in_set_format;
-    in->stream.common.standby = in_standby;
-    in->stream.common.dump = in_dump;
-    in->stream.common.set_parameters = in_set_parameters;
-    in->stream.common.get_parameters = in_get_parameters;
-    in->stream.common.add_audio_effect = in_add_audio_effect;
-    in->stream.common.remove_audio_effect = in_remove_audio_effect;
-    in->stream.set_gain = in_set_gain;
-    in->stream.read = in_read;
-    in->stream.get_input_frames_lost = in_get_input_frames_lost;
-
-    in->dev = adev;
-    in->standby = true;
-    in->requested_rate = config->sample_rate;
-    in->pcm_config = &pcm_config_in; /* default PCM config */
-
-    *stream_in = &in->stream;
-    return 0;
-}
-
-static void adev_close_input_stream(struct audio_hw_device *dev,
-                                   struct audio_stream_in *stream)
-{
-    struct stream_in *in = (struct stream_in *)stream;
-
-    in_standby(&stream->common);
-    free(stream);
-}
-
-static int adev_dump(const audio_hw_device_t *device, int fd)
-{
-    return 0;
-}
-
-static int adev_close(hw_device_t *device)
-{
-    struct audio_device *adev = (struct audio_device *)device;
-
-    audio_route_free(adev->ar);
-
-    free(device);
-    return 0;
-}
-
-static int adev_open(const hw_module_t* module, const char* name,
-                     hw_device_t** device)
-{
-    struct audio_device *adev;
-    int ret;
-    ALOGE("%s (), %s:%d", __FUNCTION__, __FILE__, __LINE__);
-    if (strcmp(name, AUDIO_HARDWARE_INTERFACE) != 0)
-        return -EINVAL;
-
-    adev = calloc(1, sizeof(struct audio_device));
-    if (!adev)
-        return -ENOMEM;
-
-    adev->hw_device.common.tag = HARDWARE_DEVICE_TAG;
-    adev->hw_device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
-    adev->hw_device.common.module = (struct hw_module_t *) module;
-    adev->hw_device.common.close = adev_close;
-
-    adev->hw_device.init_check = adev_init_check;
-    adev->hw_device.set_voice_volume = adev_set_voice_volume;
-    adev->hw_device.set_master_volume = adev_set_master_volume;
-    adev->hw_device.set_mode = adev_set_mode;
-    adev->hw_device.set_mic_mute = adev_set_mic_mute;
-    adev->hw_device.get_mic_mute = adev_get_mic_mute;
-    adev->hw_device.set_parameters = adev_set_parameters;
-    adev->hw_device.get_parameters = adev_get_parameters;
-    adev->hw_device.get_input_buffer_size = adev_get_input_buffer_size;
-    adev->hw_device.open_output_stream = adev_open_output_stream;
-    adev->hw_device.close_output_stream = adev_close_output_stream;
-    adev->hw_device.open_input_stream = adev_open_input_stream;
-    adev->hw_device.close_input_stream = adev_close_input_stream;
-    adev->hw_device.dump = adev_dump;
-
-    adev->ar = audio_route_init();
-    adev->orientation = ORIENTATION_UNDEFINED;
-    adev->out_device = AUDIO_DEVICE_OUT_SPEAKER;
-    adev->in_device = AUDIO_DEVICE_IN_BUILTIN_MIC & ~AUDIO_DEVICE_BIT_IN;
-
-    *device = &adev->hw_device.common;
-
-    return 0;
-}
-
-static struct hw_module_methods_t hal_module_methods = {
-    .open = adev_open,
-};
-
-struct audio_module HAL_MODULE_INFO_SYM = {
-    .common = {
-        .tag = HARDWARE_MODULE_TAG,
-        .module_api_version = AUDIO_MODULE_API_VERSION_0_1,
-        .hal_api_version = HARDWARE_HAL_API_VERSION,
-        .id = AUDIO_HARDWARE_MODULE_ID,
-        .name = "Freescale i.MX Audio HW HAL",
-        .author = "The Android Open Source Project",
-        .methods = &hal_module_methods,
-    },
-};
-
-
diff --git a/mx5x/audio/audio_route.c b/mx5x/audio/audio_route.c
deleted file mode 100644
index cebc443..0000000
--- a/mx5x/audio/audio_route.c
+++ /dev/null
@@ -1,495 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- * Inspired by TinyHW, written by Mark Brown at Wolfson Micro
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "audio_hw_primary"
-/*#define LOG_NDEBUG 0*/
-
-#include <errno.h>
-#include <expat.h>
-#include <stdbool.h>
-#include <stdio.h>
-
-#include <cutils/log.h>
-
-#include <tinyalsa/asoundlib.h>
-
-#define BUF_SIZE 1024
-#define MIXER_XML_PATH "/system/etc/mixer_paths.xml"
-#define INITIAL_MIXER_PATH_SIZE 8
-
-#define MIXER_CARD 0
-
-struct mixer_state {
-    struct mixer_ctl *ctl;
-    int old_value;
-    int new_value;
-    int reset_value;
-};
-
-struct mixer_setting {
-    struct mixer_ctl *ctl;
-    int value;
-};
-
-struct mixer_path {
-    char *name;
-    unsigned int size;
-    unsigned int length;
-    struct mixer_setting *setting;
-};
-
-struct audio_route {
-    struct mixer *mixer;
-    unsigned int num_mixer_ctls;
-    struct mixer_state *mixer_state;
-
-    unsigned int mixer_path_size;
-    unsigned int num_mixer_paths;
-    struct mixer_path *mixer_path;
-};
-
-struct config_parse_state {
-    struct audio_route *ar;
-    struct mixer_path *path;
-    int level;
-};
-
-/* path functions */
-
-static void path_free(struct audio_route *ar)
-{
-    unsigned int i;
-
-    for (i = 0; i < ar->num_mixer_paths; i++) {
-        if (ar->mixer_path[i].name)
-            free(ar->mixer_path[i].name);
-        if (ar->mixer_path[i].setting)
-            free(ar->mixer_path[i].setting);
-    }
-    free(ar->mixer_path);
-}
-
-static struct mixer_path *path_get_by_name(struct audio_route *ar,
-                                           const char *name)
-{
-    unsigned int i;
-
-    for (i = 0; i < ar->num_mixer_paths; i++)
-        if (strcmp(ar->mixer_path[i].name, name) == 0)
-            return &ar->mixer_path[i];
-
-    return NULL;
-}
-
-static struct mixer_path *path_create(struct audio_route *ar, const char *name)
-{
-    struct mixer_path *new_mixer_path = NULL;
-
-    if (path_get_by_name(ar, name)) {
-        ALOGE("Path name '%s' already exists", name);
-        return NULL;
-    }
-
-    /* check if we need to allocate more space for mixer paths */
-    if (ar->mixer_path_size <= ar->num_mixer_paths) {
-        if (ar->mixer_path_size == 0)
-            ar->mixer_path_size = INITIAL_MIXER_PATH_SIZE;
-        else
-            ar->mixer_path_size *= 2;
-
-        new_mixer_path = realloc(ar->mixer_path, ar->mixer_path_size *
-                                 sizeof(struct mixer_path));
-        if (new_mixer_path == NULL) {
-            ALOGE("Unable to allocate more paths");
-            return NULL;
-        } else {
-            ar->mixer_path = new_mixer_path;
-        }
-    }
-
-    /* initialise the new mixer path */
-    ar->mixer_path[ar->num_mixer_paths].name = strdup(name);
-    ar->mixer_path[ar->num_mixer_paths].size = 0;
-    ar->mixer_path[ar->num_mixer_paths].length = 0;
-    ar->mixer_path[ar->num_mixer_paths].setting = NULL;
-
-    /* return the mixer path just added, then increment number of them */
-    return &ar->mixer_path[ar->num_mixer_paths++];
-}
-
-static bool path_setting_exists(struct mixer_path *path,
-                                struct mixer_setting *setting)
-{
-    unsigned int i;
-
-    for (i = 0; i < path->length; i++)
-        if (path->setting[i].ctl == setting->ctl)
-            return true;
-
-    return false;
-}
-
-static int path_add_setting(struct mixer_path *path,
-                            struct mixer_setting *setting)
-{
-    struct mixer_setting *new_path_setting;
-
-    if (path_setting_exists(path, setting)) {
-        ALOGE("Duplicate path  setting '%s'", 
-              mixer_ctl_get_name(setting->ctl));
-        return -1;
-    }
-
-    /* check if we need to allocate more space for path settings */
-    if (path->size <= path->length) {
-        if (path->size == 0)
-            path->size = INITIAL_MIXER_PATH_SIZE;
-        else
-            path->size *= 2;
-
-        new_path_setting = realloc(path->setting,
-                                   path->size * sizeof(struct mixer_setting));
-        if (new_path_setting == NULL) {
-            ALOGE("Unable to allocate more path settings");
-            return -1;
-        } else {
-            path->setting = new_path_setting;
-        }
-    }
-
-    /* initialise the new path setting */
-    path->setting[path->length].ctl = setting->ctl;
-    path->setting[path->length].value = setting->value;
-    path->length++;
-
-    return 0;
-}
-
-static int path_add_path(struct mixer_path *path, struct mixer_path *sub_path)
-{
-    unsigned int i;
-
-    for (i = 0; i < sub_path->length; i++)
-        if (path_add_setting(path, &sub_path->setting[i]) < 0)
-            return -1;
-
-    return 0;
-}
-
-static void path_print(struct mixer_path *path)
-{
-    unsigned int i;
-
-    ALOGV("Path: %s, length: %d", path->name, path->length);
-    for (i = 0; i < path->length; i++)
-        ALOGV("  %d: %s -> %d", i, mixer_ctl_get_name(path->setting[i].ctl),
-              path->setting[i].value);
-}
-
-static int path_apply(struct audio_route *ar, struct mixer_path *path)
-{
-    unsigned int i;
-    unsigned int j;
-
-    for (i = 0; i < path->length; i++) {
-        struct mixer_ctl *ctl = path->setting[i].ctl;
-
-        /* locate the mixer ctl in the list */
-        for (j = 0; j < ar->num_mixer_ctls; j++) {
-            if (ar->mixer_state[j].ctl == ctl)
-                break;
-        }
-
-        /* apply the new value */
-        ar->mixer_state[j].new_value = path->setting[i].value;
-    }
-
-    return 0;
-}
-
-/* mixer helper function */
-static int mixer_enum_string_to_value(struct mixer_ctl *ctl, const char *string)
-{
-    unsigned int i;
-
-    /* Search the enum strings for a particular one */
-    for (i = 0; i < mixer_ctl_get_num_enums(ctl); i++) {
-        if (strcmp(mixer_ctl_get_enum_string(ctl, i), string) == 0)
-            break;
-    }
-
-    return i;
-}
-
-static void start_tag(void *data, const XML_Char *tag_name,
-                      const XML_Char **attr)
-{
-    const XML_Char *attr_name = NULL;
-    const XML_Char *attr_value = NULL;
-    struct config_parse_state *state = data;
-    struct audio_route *ar = state->ar;
-    unsigned int i;
-    struct mixer_ctl *ctl;
-    int value;
-    struct mixer_setting mixer_setting;
-
-    /* Get name, type and value attributes (these may be empty) */
-    for (i = 0; attr[i]; i += 2) {
-        if (strcmp(attr[i], "name") == 0)
-            attr_name = attr[i + 1];
-        else if (strcmp(attr[i], "value") == 0)
-            attr_value = attr[i + 1];
-    }
-
-    /* Look at tags */
-    if (strcmp(tag_name, "path") == 0) {
-        if (attr_name == NULL) {
-            ALOGE("Unnamed path!");
-        } else {
-            if (state->level == 1) {
-                /* top level path: create and stash the path */
-                state->path = path_create(ar, (char *)attr_name);
-            } else {
-                /* nested path */
-                struct mixer_path *sub_path = path_get_by_name(ar, attr_name);
-                path_add_path(state->path, sub_path);
-            }
-        }
-    }
-
-    else if (strcmp(tag_name, "ctl") == 0) {
-        /* Obtain the mixer ctl and value */
-        ctl = mixer_get_ctl_by_name(ar->mixer, attr_name);
-        switch (mixer_ctl_get_type(ctl)) {
-        case MIXER_CTL_TYPE_BOOL:
-        case MIXER_CTL_TYPE_INT:
-            value = atoi((char *)attr_value);
-            break;
-        case MIXER_CTL_TYPE_ENUM:
-            value = mixer_enum_string_to_value(ctl, (char *)attr_value);
-            break;
-        default:
-            value = 0;
-            break;
-        }
-
-        if (state->level == 1) {
-            /* top level ctl (initial setting) */
-
-            /* locate the mixer ctl in the list */
-            for (i = 0; i < ar->num_mixer_ctls; i++) {
-                if (ar->mixer_state[i].ctl == ctl)
-                    break;
-            }
-
-            /* apply the new value */
-            ar->mixer_state[i].new_value = value;
-        } else {
-            /* nested ctl (within a path) */
-            mixer_setting.ctl = ctl;
-            mixer_setting.value = value;
-            path_add_setting(state->path, &mixer_setting);
-        }
-    }
-
-    state->level++;
-}
-
-static void end_tag(void *data, const XML_Char *tag_name)
-{
-    struct config_parse_state *state = data;
-
-    state->level--;
-}
-
-static int alloc_mixer_state(struct audio_route *ar)
-{
-    unsigned int i;
-
-    ar->num_mixer_ctls = mixer_get_num_ctls(ar->mixer);
-    ar->mixer_state = malloc(ar->num_mixer_ctls * sizeof(struct mixer_state));
-    if (!ar->mixer_state)
-        return -1;
-
-    for (i = 0; i < ar->num_mixer_ctls; i++) {
-        ar->mixer_state[i].ctl = mixer_get_ctl(ar->mixer, i);
-        /* only get value 0, assume multiple ctl values are the same */
-        ar->mixer_state[i].old_value = mixer_ctl_get_value(ar->mixer_state[i].ctl, 0);
-        ar->mixer_state[i].new_value = ar->mixer_state[i].old_value;
-    }
-
-    return 0;
-}
-
-static void free_mixer_state(struct audio_route *ar)
-{
-    free(ar->mixer_state);
-    ar->mixer_state = NULL;
-}
-
-void update_mixer_state(struct audio_route *ar)
-{
-    unsigned int i;
-    unsigned int j;
-
-    for (i = 0; i < ar->num_mixer_ctls; i++) {
-        /* if the value has changed, update the mixer */
-        if (ar->mixer_state[i].old_value != ar->mixer_state[i].new_value) {
-            /* set all ctl values the same */
-            for (j = 0; j < mixer_ctl_get_num_values(ar->mixer_state[i].ctl); j++)
-                mixer_ctl_set_value(ar->mixer_state[i].ctl, j,
-                                    ar->mixer_state[i].new_value);
-            ar->mixer_state[i].old_value = ar->mixer_state[i].new_value;
-        }
-    }
-}
-
-/* saves the current state of the mixer, for resetting all controls */
-static void save_mixer_state(struct audio_route *ar)
-{
-    unsigned int i;
-
-    for (i = 0; i < ar->num_mixer_ctls; i++) {
-        /* only get value 0, assume multiple ctl values are the same */
-        ar->mixer_state[i].reset_value = mixer_ctl_get_value(ar->mixer_state[i].ctl, 0);
-    }
-}
-
-/* this resets all mixer settings to the saved values */
-void reset_mixer_state(struct audio_route *ar)
-{
-    unsigned int i;
-
-    /* load all of the saved values */
-    for (i = 0; i < ar->num_mixer_ctls; i++)
-        ar->mixer_state[i].new_value = ar->mixer_state[i].reset_value;
-}
-
-void audio_route_apply_path(struct audio_route *ar, const char *name)
-{
-    struct mixer_path *path;
-
-    if (!ar) {
-        ALOGE("invalid audio_route");
-        return;
-    }
-
-    path = path_get_by_name(ar, name);
-    if (!path) {
-        ALOGE("unable to find path '%s'", name);
-        return;
-    }
-
-    path_apply(ar, path);
-}
-
-struct audio_route *audio_route_init(void)
-{
-    struct config_parse_state state;
-    XML_Parser parser;
-    FILE *file;
-    int bytes_read;
-    void *buf;
-    int i;
-    struct mixer_path *path;
-    struct audio_route *ar;
-
-    ar = calloc(1, sizeof(struct audio_route));
-    if (!ar)
-        goto err_calloc;
-
-    ar->mixer = mixer_open(MIXER_CARD);
-    if (!ar->mixer) {
-        ALOGE("Unable to open the mixer, aborting.");
-        goto err_mixer_open;
-    }
-
-    ar->mixer_path = NULL;
-    ar->mixer_path_size = 0;
-    ar->num_mixer_paths = 0;
-
-    /* allocate space for and read current mixer settings */
-    if (alloc_mixer_state(ar) < 0)
-        goto err_mixer_state;
-
-    file = fopen(MIXER_XML_PATH, "r");
-    if (!file) {
-        ALOGE("Failed to open %s", MIXER_XML_PATH);
-        goto err_fopen;
-    }
-
-    parser = XML_ParserCreate(NULL);
-    if (!parser) {
-        ALOGE("Failed to create XML parser");
-        goto err_parser_create;
-    }
-
-    memset(&state, 0, sizeof(state));
-    state.ar = ar;
-    XML_SetUserData(parser, &state);
-    XML_SetElementHandler(parser, start_tag, end_tag);
-
-    for (;;) {
-        buf = XML_GetBuffer(parser, BUF_SIZE);
-        if (buf == NULL)
-            goto err_parse;
-
-        bytes_read = fread(buf, 1, BUF_SIZE, file);
-        if (bytes_read < 0)
-            goto err_parse;
-
-        if (XML_ParseBuffer(parser, bytes_read,
-                            bytes_read == 0) == XML_STATUS_ERROR) {
-            ALOGE("Error in mixer xml (%s)", MIXER_XML_PATH);
-            goto err_parse;
-        }
-
-        if (bytes_read == 0)
-            break;
-    }
-
-    /* apply the initial mixer values, and save them so we can reset the
-       mixer to the original values */
-    update_mixer_state(ar);
-    save_mixer_state(ar);
-
-    XML_ParserFree(parser);
-    fclose(file);
-    return ar;
-
-err_parse:
-    XML_ParserFree(parser);
-err_parser_create:
-    fclose(file);
-err_fopen:
-    free_mixer_state(ar);
-err_mixer_state:
-    mixer_close(ar->mixer);
-err_mixer_open:
-    free(ar);
-    ar = NULL;
-err_calloc:
-    return NULL;
-}
-
-void audio_route_free(struct audio_route *ar)
-{
-    free_mixer_state(ar);
-    mixer_close(ar->mixer);
-    free(ar);
-}
diff --git a/mx5x/audio/audio_route.h b/mx5x/audio/audio_route.h
deleted file mode 100644
index d67a1ea..0000000
--- a/mx5x/audio/audio_route.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef AUDIO_ROUTE_H
-#define AUDIO_ROUTE_H
-
-/* Initialises and frees the audio routes */
-struct audio_route *audio_route_init(void);
-void audio_route_free(struct audio_route *ar);
-
-/* Applies an audio route path by name */
-void audio_route_apply_path(struct audio_route *ar, const char *name);
-
-/* Resets the mixer back to its initial state */
-void reset_mixer_state(struct audio_route *ar);
-
-/* Updates the mixer with any changed values */
-void update_mixer_state(struct audio_route *ar);
-
-#endif
diff --git a/mx5x/hwcomposer/Android.mk b/mx5x/hwcomposer/Android.mk
deleted file mode 100755
index 2ebf180..0000000
--- a/mx5x/hwcomposer/Android.mk
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-ifeq ($(TARGET_HAVE_IMX_HWCOMPOSER),true)
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libEGL libcutils libutils libui libhardware libhardware_legacy libGLESv1_CM
-LOCAL_SRC_FILES := hwcomposer.cpp hwc_vsync.cpp
-LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
-LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
-LOCAL_CFLAGS:= -DLOG_TAG=\"hwcomposer\"
-#LOCAL_CFLAGS += -DDEBUG_HWC_VSYNC_TIMING
-
-LOCAL_MODULE_TAGS := optional
-include $(BUILD_SHARED_LIBRARY)
-endif
diff --git a/mx5x/hwcomposer/hwc_context.h b/mx5x/hwcomposer/hwc_context.h
deleted file mode 100755
index babada7..0000000
--- a/mx5x/hwcomposer/hwc_context.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HWC_CONTEXT_H_
-#define HWC_CONTEXT_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-#include <utils/threads.h>
-#include <hardware/hwcomposer.h>
-#include <utils/StrongPointer.h>
-
-#include <linux/mxcfb.h>
-#include <linux/ioctl.h>
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_vsync.h"
-/*****************************************************************************/
-#define HWC_MAIN_FB "/dev/graphics/fb0"
-
-class VSyncThread;
-
-struct hwc_context_t {
-    hwc_composer_device_1_t device;
-    /* our private state goes below here */
-
-    int m_mainfb_fd;
-    float m_mainfb_fps;
-    nsecs_t m_frame_period_ns;
-    hwc_procs_t* m_callback;
-    bool m_vsync_enable;
-    sp<VSyncThread> m_vsync_thread;
-};
-
-#endif
diff --git a/mx5x/hwcomposer/hwc_vsync.cpp b/mx5x/hwcomposer/hwc_vsync.cpp
deleted file mode 100755
index e46fda9..0000000
--- a/mx5x/hwcomposer/hwc_vsync.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <sys/time.h>
-#include <cutils/log.h>
-
-#include "hwc_context.h"
-#include "hwc_vsync.h"
-
-/*****************************************************************************/
-
-using namespace android;
-
-VSyncThread::VSyncThread(hwc_context_t *ctx)
-: Thread(false), mCtx(ctx)
-{
-}
-
-void VSyncThread::onFirstRef()
-{
-    run("vsyncThread", PRIORITY_URGENT_DISPLAY + ANDROID_PRIORITY_LESS_FAVORABLE);
-}
-
-void VSyncThread::setEnabled(bool enabled) {
-    Mutex::Autolock _l(mLock);
-    mEnabled = enabled;
-    mCondition.signal();
-}
-
-status_t VSyncThread::readyToRun()
-{
-    return NO_ERROR;
-}
-
-bool VSyncThread::threadLoop()
-{
-    { // scope for lock
-        Mutex::Autolock _l(mLock);
-        while (!mEnabled) {
-            mCondition.wait(mLock);
-        }
-    }
-
-    uint64_t timestamp = 0;
-    uint32_t crt = (uint32_t)&timestamp;
-
-    int err = ioctl(mCtx->m_mainfb_fd, MXCFB_WAIT_FOR_VSYNC, crt);
-    if ( err < 0 ) {
-        ALOGE("FBIO_WAITFORVSYNC error: %s\n", strerror(errno));
-    } else {
-#ifdef DEBUG_HWC_VSYNC_TIMING
-        static nsecs_t last_time_ns;
-        nsecs_t cur_time_ns;
-
-        cur_time_ns  = systemTime(SYSTEM_TIME_MONOTONIC);
-        mCtx->m_callback->vsync(mCtx->m_callback, 0, timestamp);
-        ALOGE("Vsync %llu, %llu\n", cur_time_ns - last_time_ns, cur_time_ns - timestamp);
-        last_time_ns = cur_time_ns;
-#else
-        mCtx->m_callback->vsync(mCtx->m_callback, 0, timestamp);
-#endif
-        {
-            struct timespec tm;
-            struct timespec ts;
-            const nsecs_t wake_up = 400000;
-
-            ts.tv_nsec =  (timestamp + mCtx->m_frame_period_ns) - (systemTime(SYSTEM_TIME_MONOTONIC) + wake_up );
-            ts.tv_sec = 0;
-            nanosleep( &ts, &tm);
-        }
-    }
-    return true;
-}
-
diff --git a/mx5x/hwcomposer/hwc_vsync.h b/mx5x/hwcomposer/hwc_vsync.h
deleted file mode 100755
index e024ebc..0000000
--- a/mx5x/hwcomposer/hwc_vsync.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HWC_VSYNC_H_
-#define HWC_VSYNC_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-#include <utils/threads.h>
-
-#include <hardware/hwcomposer.h>
-#include <utils/StrongPointer.h>
-
-#include <linux/mxcfb.h>
-#include <linux/ioctl.h>
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_context.h"
-/*****************************************************************************/
-
-using namespace android;
-
-struct hwc_context_t;
-
-class VSyncThread : public Thread
-{
-public:
-    VSyncThread(hwc_context_t *ctx);
-    void setEnabled(bool enabled);
-
-private:
-    virtual void onFirstRef();
-    virtual status_t readyToRun();
-    virtual bool threadLoop();
-    void handleUevent(const char *buff, int len);
-
-    hwc_context_t *mCtx;
-    mutable Mutex mLock;
-    Condition mCondition;
-    bool mEnabled;
-};
-
-#endif /* if !defined(HWC_VSYNC_H_)*/
diff --git a/mx5x/hwcomposer/hwcomposer.cpp b/mx5x/hwcomposer/hwcomposer.cpp
deleted file mode 100755
index bd4f594..0000000
--- a/mx5x/hwcomposer/hwcomposer.cpp
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * Copyright (C) 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-#include <utils/threads.h>
-#include <hardware/hwcomposer.h>
-#include <utils/StrongPointer.h>
-
-#include <linux/mxcfb.h>
-#include <linux/ioctl.h>
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-
-#include "gralloc_priv.h"
-#include "hwc_context.h"
-#include "hwc_vsync.h"
-
-/*****************************************************************************/
-static int hwc_device_open(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device);
-
-static struct hw_module_methods_t hwc_module_methods = {
-    open: hwc_device_open
-};
-
-hwc_module_t HAL_MODULE_INFO_SYM = {
-    common: {
-        tag: HARDWARE_MODULE_TAG,
-        version_major: 2,
-        version_minor: 0,
-        id: HWC_HARDWARE_MODULE_ID,
-        name: "Freescale i.MX hwcomposer module",
-        author: "Freescale Semiconductor, Inc.",
-        methods: &hwc_module_methods,
-        dso: NULL,
-        reserved: {0}
-    }
-};
-
-/*****************************************************************************/
-
-static void dump_layer(hwc_layer_1_t const* l) {
-    ALOGD("\ttype=%d, flags=%08x, handle=%p, tr=%02x, blend=%04x, {%d,%d,%d,%d}, {%d,%d,%d,%d}",
-            l->compositionType, l->flags, l->handle, l->transform, l->blending,
-            l->sourceCrop.left,
-            l->sourceCrop.top,
-            l->sourceCrop.right,
-            l->sourceCrop.bottom,
-            l->displayFrame.left,
-            l->displayFrame.top,
-            l->displayFrame.right,
-            l->displayFrame.bottom);
-}
-
-/***********************************************************************/
-
-static int hwc_prepare(hwc_composer_device_1_t *dev,
-        size_t numDisplays, hwc_display_contents_1_t** displays)
-{
-    return 0;
-}
-
-static int hwc_set(hwc_composer_device_1_t *dev,
-        size_t numDisplays, hwc_display_contents_1_t** displays)
-{
-    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
-    bool clear_needed = false;
-    EGLBoolean success = EGL_TRUE;
-    unsigned int i;
-
-    if (displays[0]->dpy !=NULL && displays[0]->sur !=NULL) {
-        success = eglSwapBuffers((EGLDisplay)displays[0]->dpy,
-            (EGLSurface)displays[0]->sur);;
-    }
-
-    if ( displays != NULL) {
-        for (i =0 ; i < displays[0]->numHwLayers; i++)
-        {
-            private_handle_t *handle = (private_handle_t *)(displays[0]->hwLayers[i].handle);
-            if (handle)
-            {
-                if ((handle->format == HAL_PIXEL_FORMAT_YV12) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCbCr_422_SP) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCrCb_420_SP) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCrCb_420_SP) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCbCr_422_I) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCbCr_422_P) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCbCr_420_P) ||
-                    (handle->format == HAL_PIXEL_FORMAT_CbYCrY_422_I) ||
-                    (handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) )
-                {
-                    clear_needed = true;
-                }
-            }
-        }
-    }
-
-    if (clear_needed)
-    {
-        glClearColor(0, 0, 0, 0);
-        glClear(GL_COLOR_BUFFER_BIT);
-    }
-
-    if (!success) {
-        return HWC_EGL_ERROR;
-    }
-
-    return 0;
-}
-
-static int hwc_device_close(struct hw_device_t *dev)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-    if (ctx) {
-        if(ctx->m_vsync_thread != NULL) {
-            ctx->m_vsync_thread->requestExitAndWait();
-        }
-        free(ctx);
-    }
-    return 0;
-}
-
-static void hwc_registerProcs(struct hwc_composer_device_1 *dev,
-            hwc_procs_t const* procs) {
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-    if(ctx) {
-        ctx->m_callback = (hwc_procs_t*)procs;
-    }
-}
-
-static int hwc_eventControl(struct hwc_composer_device_1* dev, int disp, int event, int enabled)
-{
-     hwc_context_t *ctx = (hwc_context_t *) dev;
-#ifdef DEBUG_HWC_VSYNC_TIMING
-     static nsecs_t start_time_ns = systemTime(SYSTEM_TIME_MONOTONIC);
-#endif
-     switch (event) {
-     case HWC_EVENT_VSYNC:
-         {
-             ctx->m_vsync_thread->setEnabled(enabled);
-#ifdef DEBUG_HWC_VSYNC_TIMING
-             if ( enabled )
-             {
-                 ALOGV("<%s,%d> paused time: %lld \n",__FUNCTION__, __LINE__, systemTime(SYSTEM_TIME_MONOTONIC)- start_time_ns);
-             } else {
-                 start_time_ns  = systemTime(SYSTEM_TIME_MONOTONIC);
-             }
-#endif /* if defined DEBUG_HWC_VSYNC_TIMING */
-             return 0;
-         }
-     default:
-         return -EINVAL;
-     }
-}
-
-static int hwc_blank(struct hwc_composer_device_1* dev, int disp, int blank)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-
-    if (!ctx || disp < 0 || disp >= HWC_NUM_DISPLAY_TYPES) {
-        return 0;
-    }
-
-    int fb_blank = blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK;
-    int err = ioctl(ctx->m_mainfb_fd, FBIOBLANK, fb_blank);
-    if (err < 0) {
-        ALOGE("blank ioctl failed");
-        return -errno;
-    }
-
-    return 0;
-}
-
-static int hwc_query(struct hwc_composer_device_1 *dev,
-        int what, int* value)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-
-    switch (what) {
-    case HWC_BACKGROUND_LAYER_SUPPORTED:
-        // we don't support the background layer yet
-        value[0] = 0;
-        break;
-    case HWC_VSYNC_PERIOD:
-        // vsync period in nanosecond
-        value[0] = 1000000000.0 / ctx->m_mainfb_fps;
-        break;
-    default:
-        // unsupported query
-        return -EINVAL;
-    }
-    return 0;
-}
-
-static int hwc_get_framebuffer_info(struct hwc_context_t* ctx)
-{
-    struct fb_var_screeninfo info;
-    if (ioctl(ctx->m_mainfb_fd, FBIOGET_VSCREENINFO, &info) == -1) {
-        ALOGE("<%s,%d> FBIOGET_VSCREENINFO failed", __FUNCTION__, __LINE__);
-        return -errno;
-    }
-
-    int refreshRate = 1000000000000000LLU / (uint64_t(info.upper_margin +
-                                                      info.lower_margin +
-                                                      info.yres +
-                                                      info.vsync_len) *
-                                             (info.left_margin  +
-                                              info.right_margin +
-                                              info.xres +
-                                              info.hsync_len) * info.pixclock);
-    if (refreshRate == 0)
-        refreshRate = 60 * 1000;  // 60 Hz
-
-    ctx->m_mainfb_fps = refreshRate / 1000.0f;
-    ctx->m_frame_period_ns = (1.0f / ctx->m_mainfb_fps) * 1000000000.0f;
-    ALOGI("<%s,%d> Vsync rate %0.6f fps, frame time %llu ns", __FUNCTION__, __LINE__,
-          ctx->m_mainfb_fps, ctx->m_frame_period_ns);
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int hwc_device_open(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device)
-{
-    int status = -EINVAL;
-    if (!strcmp(name, HWC_HARDWARE_COMPOSER)) {
-        struct hwc_context_t *dev;
-        dev = (hwc_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = hwc_device_close;
-
-        dev->device.prepare = hwc_prepare;
-        dev->device.set = hwc_set;
-        dev->device.blank = hwc_blank;
-        dev->device.common.version = HWC_DEVICE_API_VERSION_1_0;
-        dev->device.registerProcs = hwc_registerProcs;
-        dev->device.eventControl = hwc_eventControl;
-        dev->device.query = hwc_query;
-
-        /* our private state goes below here */
-        dev->m_mainfb_fd = open(HWC_MAIN_FB, O_RDWR);
-        dev->m_vsync_thread = new VSyncThread(dev);
-        hwc_get_framebuffer_info(dev);
-
-nor_exit:
-
-        *device = &dev->device.common;
-	ALOGI("<%s,%d>", __FUNCTION__, __LINE__);
-        return 0;
-err_exit:
-	if(dev){
-	    free(dev);
-	}
-        /****************************************/
-    }
-    return status;
-}
diff --git a/mx5x/libcamera/Android.mk b/mx5x/libcamera/Android.mk
deleted file mode 100755
index 13b156b..0000000
--- a/mx5x/libcamera/Android.mk
+++ /dev/null
@@ -1,79 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-ifeq ($(BOARD_SOC_CLASS),IMX5X)
-LOCAL_PATH:= $(call my-dir)
-
-ifeq ($(BOARD_HAVE_IMX_CAMERA),true)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=    \
-	CameraHal.cpp    \
-	CameraModule.cpp \
-	CaptureDeviceInterface.cpp \
-	V4l2CsiDevice.cpp \
-	V4l2CapDeviceBase.cpp  \
-	JpegEncoderInterface.cpp \
-    JpegEncoderSoftware.cpp \
-    messageQueue.cpp \
-    V4l2UVCDevice.cpp
-
-LOCAL_CPPFLAGS +=
-
-LOCAL_SHARED_LIBRARIES:= \
-    libcamera_client \
-    libui \
-    libutils \
-    libcutils \
-    libbinder \
-    libmedia \
-    libhardware_legacy \
-    libion \
-    libdl \
-    libc
-
-LOCAL_C_INCLUDES += \
-	frameworks/base/include/binder \
-	frameworks/base/include/ui \
-	frameworks/base/camera/libcameraservice \
-	hardware/imx/mx5x/libgralloc
-
-ifeq ($(HAVE_FSL_IMX_CODEC),true)
-    LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
-    LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
-    LOCAL_C_INCLUDES += device/fsl-proprietary/codec/ghdr
-endif
-ifeq ($(BOARD_CAMERA_NV12),true)
-    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
-else
-    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_YUV420
-endif
-
-#Define this for switch the Camera through V4L2 MXC IOCTL
-#LOCAL_CPPFLAGS += -DV4L2_CAMERA_SWITCH
-
-LOCAL_CPPFLAGS += -Werror
-
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_MODULE:= camera.$(TARGET_BOARD_PLATFORM)
-
-LOCAL_CFLAGS += -fno-short-enums
-LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-endif
-
-endif
diff --git a/mx5x/libcamera/CameraHal.cpp b/mx5x/libcamera/CameraHal.cpp
deleted file mode 100755
index 1be1c8b..0000000
--- a/mx5x/libcamera/CameraHal.cpp
+++ /dev/null
@@ -1,2394 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-
-#include <cutils/properties.h>
-#include "CameraHal.h"
-#include <time.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dlfcn.h>
-#include <hardware_legacy/power.h>
-#include <ui/GraphicBufferMapper.h>
-#include <ui/Rect.h>
-#include "gralloc_priv.h"
-
-#include <ion/ion.h>
-
-using namespace android;
-
-    CameraHal::CameraHal(int cameraid)
-        :
-        mCaptureRunning(0),
-        mExitCaptureThread(false),
-        mPreviewRunning(0),
-        mExitPreviewThread(false),
-        mExitEncodeThread(false),
-        mTakePictureInProcess(false),
-        mTakePictureAllocBuffer(false),
-        mParameters(),
-        mCallbackCookie(NULL),
-        mNotifyCb(NULL),
-        mDataCb(NULL),
-        mDataCbTimestamp(NULL),
-        mCaptureFrameThread(NULL),
-        mPreviewShowFrameThread(NULL),
-        mEncodeFrameThread(NULL),
-        mAutoFocusThread(NULL),
-        mTakePicThread(NULL),
-        mLock(),
-        mSupportedPictureSizes(NULL),
-        mSupportedPreviewSizes(NULL),
-        mSupportedFPS(NULL),
-        mSupprotedThumbnailSizes(NULL),
-        mSupportPreviewFormat(NULL),
-        mNativeWindow(NULL),
-        mMsgEnabled(0),
-        mPreviewMemory(NULL),
-        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
-        mVideoMemory(NULL),
-        mDefaultPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
-        mPreviewFrameSize(0),
-        mTakePicFlag(false),
-        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
-        mCaptureFrameSize(0),
-        mCaptureBufNum(0),
-        mEnqueuedBufs(0),
-        mRecordRunning(0),
-        mCurrentRecordFrame(0),
-        nCameraBuffersQueued(0),
-        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
-        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
-        mCameraReady(false),
-        mCaptureDeviceOpen(false),
-        mIsCaptureBufsAllocated(0),
-        mPowerLock(false),
-        mDirectInput(false),
-        mCameraid(cameraid),
-        mPreviewRotate(CAMERA_PREVIEW_BACK_REF),
-        mIonFd(-1),
-        mUseIon(true)
-   {
-        CAMERA_LOG_FUNC;
-
-        if(mUseIon) {
-            mIonFd = ion_open();
-            if(mIonFd <= 0) {
-                CAMERA_LOG_INFO("open ion failed.");
-            }
-        }
-        preInit();
-    }
-
-    CameraHal :: ~CameraHal()
-    {
-        CAMERA_LOG_FUNC;
-        if(mUseIon) {
-            ion_close(mIonFd);
-        }
-        CameraMiscDeInit();
-        CloseCaptureDevice();
-        FreeInterBuf();
-        postDestroy();
-        if(mVideoMemory != NULL) {
-            mVideoMemory->release(mVideoMemory);
-        }
-        if(mPreviewMemory != NULL) {
-            mPreviewMemory->release(mPreviewMemory);
-        }
-        status_t err;
-
-    }
-
-    void CameraHal :: release()
-    {
-        CAMERA_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
-
-        mCameraReady = false;
-        CameraHALStopPreview();
-        UnLockWakeLock();
-        return;
-    }
-
-    void CameraHal :: preInit()
-    {
-        CAMERA_LOG_FUNC;
-        mVpuSupportFmt[0] = v4l2_fourcc('N','V','1','2');
-        mVpuSupportFmt[1] = v4l2_fourcc('Y','U','1','2');
-    }
-    void CameraHal :: postDestroy()
-    {
-        CAMERA_LOG_FUNC;
-    }
-
-    CAMERA_HAL_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mCaptureDevice = capturedevice;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mJpegEncoder = jpegencoder;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_RET CameraHal::Init()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        mCameraReady == true;
-        mCaptureDevice->GetDevType(&mSensorType);
-
-        if ((ret = AllocInterBuf())<0)
-            return ret;
-        if ((ret = InitCameraHalParam()) < 0)
-            return ret;
-        if ((ret = CameraMiscInit()) < 0)
-            return ret;
-
-        return ret;
-    }
-    void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
-    {
-        CAMERA_LOG_FUNC;
-        mPreviewRotate = previewRotate;
-        return ;
-    }
-
-    CAMERA_HAL_RET  CameraHal :: AllocInterBuf()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        mSupportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportPreviewFormat = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-
-        if (mSupportedPictureSizes == NULL ||
-                mSupportedPreviewSizes == NULL ||
-                mSupportedFPS          == NULL ||
-                mSupprotedThumbnailSizes == NULL ||
-                mSupportPreviewFormat == NULL)
-            ret = CAMERA_HAL_ERR_ALLOC_BUF;
-
-        return ret;
-    }
-    void  CameraHal :: FreeInterBuf()
-    {
-        CAMERA_LOG_FUNC;
-        if (mSupportedPictureSizes)
-            free(mSupportedPictureSizes);
-        if (mSupportedPreviewSizes)
-            free(mSupportedPreviewSizes);
-        if (mSupportedFPS)
-            free(mSupportedFPS);
-        if (mSupprotedThumbnailSizes)
-            free(mSupprotedThumbnailSizes);
-    }
-
-    CAMERA_HAL_RET CameraHal :: InitCameraHalParam()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        if ((ret = InitCameraBaseParam(&mParameters)) < 0)
-            return ret;
-
-        if ((ret = InitPictureExifParam(&mParameters)) < 0)
-            return ret;
-
-        return ret;
-    }
-
-    CAMERA_HAL_RET CameraHal::CameraMiscInit()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        mPreviewRunning = false;
-        mCaptureRunning = false;
-        mWaitForTakingPicture = false;
-        sem_init(&mCaptureStoppedCondition, 0, 0);
-        sem_init(&mPreviewStoppedCondition, 0, 0);
-        //sem_init(&mEncodeStoppedCondition, 0, 0);
-        sem_init(&mTakingPicture, 0, 0);
-        //mPostProcessRunning = false;
-        //mEncodeRunning = false;
-        mCaptureFrameThread = new CaptureFrameThread(this);
-        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
-        mEncodeFrameThread = new EncodeFrameThread(this);
-        mTakePicThread= new TakePicThread(this);
-
-        if (mCaptureFrameThread == NULL || mPreviewShowFrameThread == NULL ||
-                mEncodeFrameThread == NULL || mTakePicThread == NULL){
-            return CAMERA_HAL_ERR_INIT;
-        }
-        return ret;
-    }
-    CAMERA_HAL_RET CameraHal::CameraMiscDeInit()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        mCaptureThreadQueue.postQuitMessage();
-        //Make sure all thread been exit, in case they still
-        //access the message queue
-        if(mCaptureFrameThread != NULL)
-            mCaptureFrameThread->requestExitAndWait();
-
-        //Post Quite message to make sure the thread can be exited
-        //In case mCaptureFrameThread not been started yet in CTS test
-        mPreviewThreadQueue.postQuitMessage();
-        if(mPreviewShowFrameThread != NULL)
-            mPreviewShowFrameThread->requestExitAndWait();
-        mEncodeThreadQueue.postQuitMessage();
-        if(mEncodeFrameThread != NULL)
-            mEncodeFrameThread->requestExitAndWait();
-        if(mTakePicThread != NULL)
-            mTakePicThread->requestExitAndWait();
-        return ret;
-    }
-
-    CAMERA_HAL_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
-    {
-        CAMERA_LOG_FUNC;
-        int i, n;
-        unsigned int uFormat[MAX_QUERY_FMT_TIMES];
-        char fmtStr[40];
-
-        memset(fmtStr, 0, 40);
-        convertPreviewFormatToString(fmtStr, 40, mPreviewCapturedFormat);
-        mParameters.setPreviewFormat(fmtStr);
-        mParameters.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, fmtStr);
-
-        memset(uFormat, 0, sizeof(uFormat));
-        for(n = 0; n < nFmt; n++) {
-            uFormat[n] = mSensorSupportFmt[n];
-        }
-
-        memset(fmtStr, 0, 40);
-        for(i = 0; i < n; i++) {
-            for (int j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
-                //should report VPU support format.
-                if(uFormat[i] == mVpuSupportFmt[j]) {
-                    if(uFormat[i] == v4l2_fourcc('Y','U','1','2')) {
-                        strcat(fmtStr, "yuv420p");
-                        strcat(fmtStr, ",");
-                    }
-                    else if(uFormat[i] == v4l2_fourcc('N','V','1','2')) {
-                        strcat(fmtStr, "yuv420sp");
-                        strcat(fmtStr, ",");
-                    }
-                    //else if(mSensorSupportFmt[i] == v4l2_fourcc('Y','U','Y','V')) {
-                    //    strcat(fmtStr, "yuv422i-yuyv");
-                    //    strcat(fmtStr, ",");
-                    //}
-                }
-            }
-        }
-
-        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
-        return CAMERA_HAL_ERR_NONE;
-    }
-
-    CAMERA_HAL_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
-    {
-        CAMERA_LOG_FUNC;
-        char TmpStr[20];
-        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
-        struct capture_config_t CaptureSizeFps;
-        int  previewCnt= 0, pictureCnt = 0, i;
-        char previewFmt[20] = {0};
-
-        //the Camera Open here will not be close immediately, for later preview.
-        if (OpenCaptureDevice() < 0)
-            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
-
-        memset(mSensorSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mSensorSupportFmt[i])) < 0)
-                break;
-        }
-        if (i == 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        //InitCameraPreviewFormatToParam(i);
-
-        if (NegotiateCaptureFmt(false) < 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        //mCaptureDeviceCfg.fmt stores format related to driver.
-        CaptureSizeFps.fmt = mCaptureDeviceCfg.fmt;//mPreviewCapturedFormat;
-
-        //mPreviewCapturedFormat stores format report to app.
-        InitCameraPreviewFormatToParam(i);
-        //memset(TmpStr, 0, 20);
-        //mPreviewCapturedFormat stores format report to app.
-        //convertPreviewFormatToString(TmpStr, 20, mPreviewCapturedFormat);
-        //convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
-        //mParameters.setPreviewFormat(TmpStr);
-
-        CAMERA_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
-
-        for(;;){
-            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
-                CAMERA_LOG_RUNTIME("get the frame size and time interval error");
-                break;
-            }
-            memset(TmpStr, 0, 20);
-            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
-            CAMERA_LOG_INFO("Size: %s , Framerate: %d supported", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
-            if (pictureCnt == 0)
-                strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            else{
-                strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                strncat(mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            }
-            pictureCnt ++;
-
-            //Limite the FPS and resolution for preview setting
-            //Typically only max to 1080p for mipi, 720p for csi,
-            //and minum 15 fps need for preview.
-            unsigned int max_preview_w, max_preview_h;
-            char device_name[CAMERA_SENSOR_LENGTH];
-            memset(device_name, 0, CAMERA_SENSOR_LENGTH);
-            mCaptureDevice->GetDevName(device_name);
-            if(strstr(device_name, "mipi")) {
-                max_preview_w = MAX_MIPI_PREVIEW_W;
-                max_preview_h = MAX_MIPI_PREVIEW_H;
-            } else {
-                max_preview_w = MAX_CSI_PREVIEW_W;
-                max_preview_h = MAX_CSI_PREVIEW_H;
-            }
-
-            if ((CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator >= 15)&&
-                (CaptureSizeFps.width <= max_preview_w)&&(CaptureSizeFps.height <= max_preview_h)){
-                if (previewCnt == 0)
-                    strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                else{
-                    strncat(mSupportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                    strncat(mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                }
-                previewCnt ++;
-            }
-        }
-
-        /*hard code here*/
-        strcpy(mSupportedFPS, "15,30");
-        CAMERA_LOG_INFO("SupportedPictureSizes is %s", mSupportedPictureSizes);
-        CAMERA_LOG_INFO("SupportedPreviewSizes is %s", mSupportedPreviewSizes);
-        CAMERA_LOG_INFO("SupportedFPS is %s", mSupportedFPS);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(12000,17000),(25000,33000)");
-        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
-
-        pParam->setPreviewSize(DEFAULT_PREVIEW_W, DEFAULT_PREVIEW_H);
-        pParam->setPictureSize(DEFAULT_PICTURE_W, DEFAULT_PICTURE_H);
-        pParam->setPreviewFrameRate(DEFAULT_PREVIEW_FPS);
-
-        return CAMERA_HAL_ERR_NONE;
-
-    }
-
-    status_t CameraHal :: OpenCaptureDevice()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDeviceOpen){
-            CAMERA_LOG_INFO("The capture device already open");
-            return NO_ERROR;
-        }
-        else if (mCaptureDevice != NULL){
-            if ( mCaptureDevice->DevOpen(mCameraid)<0 )
-                return INVALID_OPERATION;
-            mCaptureDeviceOpen = true;
-        }else{
-            CAMERA_LOG_ERR("no capture device assigned");
-            return INVALID_OPERATION;
-        }
-        return ret;
-    }
-    void CameraHal ::CloseCaptureDevice()
-    {
-        CAMERA_LOG_FUNC;
-        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
-            mCaptureDevice->DevClose();
-            mCaptureDeviceOpen = false;
-        }
-    }
-
-    CAMERA_HAL_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
-    {
-        CAMERA_LOG_FUNC;
-        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE+1];
-
-        /*hard code here*/
-        pParam->set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
-        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
-        strcpy(mSupprotedThumbnailSizes, "0x0,128x128,96x96");
-        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, mSupprotedThumbnailSizes);
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
-        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
-        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
-        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
-        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
-        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
-        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
-        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
-        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
-        // default zoom should be 0 as CTS defined
-        pParam->set(CameraParameters::KEY_ZOOM, "0");
-        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-        //returned as 320. The number of elements is {@link
-        //#getMaxZoom} + 1. The list is sorted from small to large. The
-        //first element is always 100. The last element is the zoom
-        //ratio of the maximum zoom value.
-        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
-
-        return CAMERA_HAL_ERR_NONE;
-    }
-
-    sp<IMemoryHeap> CameraHal::getRawHeap() const
-    {
-        return NULL;
-    }
-
-    status_t CameraHal::dump(int fd) const
-    {
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
-            int32_t arg2)
-    {
-        return BAD_VALUE;
-    }
-
-    void CameraHal::setCallbacks(camera_notify_callback notify_cb,
-            camera_data_callback data_cb,
-            camera_data_timestamp_callback data_cb_timestamp,
-            camera_request_memory get_memory,
-            void* user)
-    {
-        Mutex::Autolock lock(mLock);
-        mNotifyCb = notify_cb;
-        mDataCb = data_cb;
-        mDataCbTimestamp = data_cb_timestamp;
-        mRequestMemory = get_memory;
-        mCallbackCookie = user;
-    }
-
-    void CameraHal::enableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_LOG_INFO("enableMsgType 0x%x", msgType);
-        mMsgEnabled |= msgType;
-    }
-
-    void CameraHal::disableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_LOG_INFO("disableMsgType 0x%x", msgType);
-        mMsgEnabled &= ~msgType;
-    }
-    bool CameraHal::msgTypeEnabled(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        return (mMsgEnabled & msgType);
-    }
-
-    void CameraHal::putParameters(char *params)
-    {
-        free(params);
-    }
-
-    char* CameraHal::getParameters() const
-    {
-        CAMERA_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-        char* params_string;
-        String8 params_str8;
-        CameraParameters mParams = mParameters;
-
-        params_str8 = mParams.flatten();
-        params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
-        strcpy(params_string, params_str8.string());
-        return params_string;
-    }
-
-    status_t  CameraHal:: setParameters(const char* params)
-    {
-        CAMERA_LOG_FUNC;
-        CameraParameters parameters;
-        String8 str_params(params);
-
-        parameters.unflatten(str_params);
-        return setParameters(parameters);
-    }
-
-    status_t  CameraHal:: setParameters(CameraParameters& params)
-    {
-        CAMERA_LOG_FUNC;
-        int w, h;
-        int framerate, local_framerate;
-        int max_zoom,zoom, max_fps, min_fps;
-        char tmp[128];
-        Mutex::Autolock lock(mLock);
-
-        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
-        zoom = params.getInt(CameraParameters::KEY_ZOOM);
-        if(zoom > max_zoom){
-            CAMERA_LOG_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
-            return BAD_VALUE;
-        }
-        if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)// || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)
-                )) {
-            CAMERA_LOG_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
-            return BAD_VALUE;
-        }
-
-        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
-            CAMERA_LOG_ERR("Only jpeg still pictures are supported");
-            return BAD_VALUE;
-        }
-
-        params.getPreviewSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_LOG_INFO("Set preview size: %s", tmp);
-        if (strstr(mSupportedPreviewSizes, tmp) == NULL){
-            CAMERA_LOG_ERR("The preview size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        params.getPictureSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_LOG_INFO("Set picture size: %s", tmp);
-        if (strstr(mSupportedPictureSizes, tmp) == NULL){
-            CAMERA_LOG_ERR("The picture size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        params.getPreviewFpsRange(&min_fps, &max_fps);
-        CAMERA_LOG_INFO("FPS range: %d - %d",min_fps, max_fps);
-        if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-            CAMERA_LOG_ERR("The fps range from %d to %d is error", min_fps, max_fps);
-            return BAD_VALUE;
-        }
-
-        local_framerate = mParameters.getPreviewFrameRate();
-        CAMERA_LOG_INFO("get local frame rate:%d FPS", local_framerate);
-        if ((local_framerate > 30) || (local_framerate < 0) ){
-            CAMERA_LOG_ERR("The framerate is not corrected");
-            local_framerate = 15;
-        }
-
-        framerate = params.getPreviewFrameRate();
-        CAMERA_LOG_INFO("Set frame rate:%d FPS", framerate);
-        if ((framerate > 30) || (framerate < 0) ){
-            CAMERA_LOG_ERR("The framerate is not corrected");
-            return BAD_VALUE;
-        }
-        else if(local_framerate != framerate) {
-            if(framerate == 15) {
-                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "12000,17000");
-            }
-            else if (framerate == 30) {
-                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
-            }
-        }
-
-        const char *pFlashStr;
-        pFlashStr = params.get(CameraParameters::KEY_FLASH_MODE);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0
-                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) != 0
-                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) != 0) {
-            CAMERA_LOG_ERR("The flash mode is not corrected");
-            return BAD_VALUE;
-        }
-
-        const char *pFocusStr;
-        pFocusStr = params.get(CameraParameters::KEY_FOCUS_MODE);
-        if(strcmp(pFocusStr, CameraParameters::FOCUS_MODE_AUTO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_INFINITY) != 0
-                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_MACRO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_FIXED) != 0
-                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_EDOF) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) != 0) {
-            CAMERA_LOG_ERR("The focus mode is not corrected");
-            return BAD_VALUE;
-        }
-        mParameters = params;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
-    {
-        CAMERA_LOG_FUNC;
-        if(window == NULL) {
-            mIsCaptureBufsAllocated = 0;
-            CAMERA_LOG_INFO("PreviewWindow is null");
-        }
-        else {
-            CAMERA_LOG_ERR("PreviewWindow is valid");
-        }
-        mNativeWindow = window;
-        if((mNativeWindow != NULL) && !mIsCaptureBufsAllocated && mCaptureBufNum) {
-            if(PrepareCaptureBufs() < 0) {
-                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
-                return BAD_VALUE;
-            }
-            if(CameraHALPreviewStart() < 0) {
-                CAMERA_LOG_ERR("CameraHALPreviewStart() error");
-                return BAD_VALUE;
-            }
-        }
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::freeBuffersToNativeWindow()
-    {
-        CAMERA_LOG_FUNC;
-        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
-            status_t err = freeBufferToIon();
-            if(err == NO_ERROR) {
-                return err;
-            }
-        }
-
-
-        if (mNativeWindow == NULL){
-            CAMERA_LOG_ERR("the native window is null!");
-            return BAD_VALUE;
-        }
-
-        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
-        buffer_handle_t *handle;
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_DEQUEUED) {
-                handle = (buffer_handle_t *)mCaptureBuffers[i].native_buf;
-                if(handle != NULL) {
-                    if(mCaptureBuffers[i].virt_start != NULL) {
-                        mapper.unlock(*handle);
-                    }
-                    mNativeWindow->cancel_buffer(mNativeWindow, handle);
-                }
-            }
-            else
-                continue;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_INVALID;//WINDOW_BUFS_QUEUED;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].native_buf = NULL;
-            mCaptureBuffers[i].virt_start = NULL;
-            mCaptureBuffers[i].length = 0;
-            mCaptureBuffers[i].phy_offset = 0;
-        }
-        mCaptureBufNum = 0;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::freeBufferToIon()
-    {
-        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
-            CAMERA_LOG_ERR("try to free buffer from ion in preview or ion invalid");
-            return BAD_VALUE;
-        }
-
-        CAMERA_LOG_INFO("freeBufferToIon buffer num:%d", mCaptureBufNum);
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            struct ion_handle * ionHandle = (struct ion_handle *)mCaptureBuffers[i].native_buf;
-            ion_free(mIonFd, ionHandle);
-            munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-        }
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::allocateBufferFromIon()
-    {
-        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
-            CAMERA_LOG_ERR("try to allocate buffer from ion in preview or ion invalid");
-            return BAD_VALUE;
-        }
-
-        int width = 0, height = 0, size = 0;
-        width = mCaptureDeviceCfg.width;
-        height = mCaptureDeviceCfg.height;
-        if(width == 0 || height == 0) {
-            CAMERA_LOG_ERR("allocateBufferFromIon: width or height = 0");
-            return BAD_VALUE;
-        }
-
-        switch(mPreviewCapturedFormat) {
-            case v4l2_fourcc('N','V','1','2'):
-                size = width * height * 3/2;
-                break;
-            case v4l2_fourcc('Y','U','1','2'):
-                size = width * height * 3/2;
-                break;
-            case v4l2_fourcc('Y','U','Y','V'):
-                size = width * height * 2;
-                break;
-            default:
-                CAMERA_LOG_ERR("Error: format not supported int ion alloc");
-                return BAD_VALUE;
-        }
-
-        unsigned char *ptr = NULL;
-        int sharedFd;
-        int phyAddr;
-        struct ion_handle * ionHandle;
-
-        CAMERA_LOG_INFO("allocateBufferFromIon buffer num:%d", mCaptureBufNum);
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            ionHandle = NULL;
-            size = (size + PAGE_SIZE)&(~(PAGE_SIZE-1));
-            int err = ion_alloc(mIonFd, size, 8, 1, &ionHandle);
-            if(err) {
-                CAMERA_LOG_ERR("ion_alloc failed.");
-                return BAD_VALUE;
-            }
-
-            err = ion_map(mIonFd, ionHandle, size, PROT_READ|PROT_WRITE, MAP_SHARED, 0, &ptr, &sharedFd);
-            if(err) {
-                CAMERA_LOG_ERR("ion_map failed.");
-                return BAD_VALUE;
-            }
-            phyAddr = ion_phys(mIonFd, ionHandle);
-            if(phyAddr == 0) {
-                CAMERA_LOG_ERR("ion_phys failed.");
-                return BAD_VALUE;
-            }
-
-            mCaptureBuffers[i].virt_start = ptr;
-            mCaptureBuffers[i].phy_offset = phyAddr;
-            mCaptureBuffers[i].length =  size;
-            mCaptureBuffers[i].native_buf = (void*)ionHandle;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
-            close(sharedFd);
-        }
-        return NO_ERROR;
-    }
-
-    int CameraHal::convertPreviewFormatToPixelFormat(unsigned int format)
-    {
-        int nFormat = 0;
-        switch(format) {
-            case v4l2_fourcc('N','V','1','2'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP;
-                break;
-            case v4l2_fourcc('Y','U','1','2'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_P;
-                break;
-            case v4l2_fourcc('Y','U','Y','V'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_422_I;
-                break;
-            default:
-                CAMERA_LOG_ERR("Error: format not supported!");
-                break;
-        }
-        CAMERA_LOG_INFO("pixel format: 0x%x", nFormat);
-        return nFormat;
-    }
-
-    status_t CameraHal::allocateBuffersFromNativeWindow()
-    {
-        CAMERA_LOG_FUNC;
-
-        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
-            status_t err = allocateBufferFromIon();
-            if(err == NO_ERROR) {
-                return err;
-            }
-        }
-
-        status_t err;
-        if (mNativeWindow == NULL){
-            CAMERA_LOG_ERR("the native window is null!");
-            return NO_ERROR;//BAD_VALUE;
-        }
-
-        //Make sure the buffer be physical continuous
-        err = mNativeWindow->set_usage(mNativeWindow,
-                GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_FORCE_CONTIGUOUS | GRALLOC_USAGE_HW_TEXTURE);
-        if(err != 0){
-            CAMERA_LOG_ERR("native_window_set_usage failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        //should use mPreviewCapturedFormat here.
-        int uFormat = convertPreviewFormatToPixelFormat(mPreviewCapturedFormat);
-        err = mNativeWindow->set_buffers_geometry(mNativeWindow,
-                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height,
-                uFormat);
-        if(err != 0){
-            CAMERA_LOG_ERR("native_window_set_buffers_geometry failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        int minUndequeueBufs = 0;
-        err = mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow,
-                &minUndequeueBufs);
-        if(err != 0) {
-            CAMERA_LOG_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        if(mCaptureBufNum > PREVIEW_CAPTURE_BUFFER_NUM) {
-            CAMERA_LOG_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
-            return BAD_VALUE;
-        }
-
-        err = mNativeWindow->set_buffer_count(mNativeWindow, mCaptureBufNum);
-        if(err != 0) {
-            CAMERA_LOG_ERR("native_window_set_buffer_count failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        unsigned int i;
-        Rect bounds(mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-        void *pVaddr = NULL;
-        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
-        for(i = 0; i < mCaptureBufNum; i++) {
-            buffer_handle_t* buf_h = NULL;
-            pVaddr = NULL;
-            int stride;
-            err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
-            if((err != 0) || (buf_h == NULL)) {
-                CAMERA_LOG_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
-                return BAD_VALUE;
-            }
-            private_handle_t *handle = (private_handle_t *)(*buf_h);
-            mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
-            if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
-                 CAMERA_LOG_ERR("%s: dequeue invalide Buffer, phys=0x%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
-                 mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
-                 return BAD_VALUE;
-            }
-
-            mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
-            mCaptureBuffers[i].phy_offset = handle->phys;
-            //Calculate the buffer size, for GPU doesn't reply this value.
-            mCaptureBuffers[i].length =  handle->size;//mCaptureFrameSize
-            mCaptureBuffers[i].native_buf = (void *)buf_h;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
-            CAMERA_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%p, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-        }
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::startPreview()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-
-        if(mTakePictureInProcess) {
-            mWaitForTakingPicture = true;
-            sem_wait(&mTakingPicture);
-            mWaitForTakingPicture = false;
-        }
-        Mutex::Autolock lock(mLock);
-        mEnqueuedBufs = 0;
-
-        mPreviewLock.lock();
-        if (mPreviewRunning) {
-            // already running
-            CAMERA_LOG_RUNTIME("%s : preview thread already running", __func__);
-            mPreviewLock.unlock();
-            return NO_ERROR;//INVALID_OPERATION;
-        }
-
-        if ((ret == CameraHALStartPreview())<0) {
-            CAMERA_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
-            mPreviewLock.unlock();
-            return ret;
-        }
-
-        mPreviewRunning = true;
-        mPreviewLock.unlock();
-
-        mCaptureLock.lock();
-        if(mCaptureRunning) {
-            CAMERA_LOG_ERR("%s : preview thread already running", __func__);
-            mCaptureLock.unlock();
-            return NO_ERROR;
-        }
-        mCaptureRunning = true;
-        mCaptureLock.unlock();
-
-        LockWakeLock();
-        return ret;
-    }
-
-    void CameraHal::stopPreview()
-    {
-        CAMERA_LOG_FUNC;
-        struct timeval af_time, be_time;
-        Mutex::Autolock lock(mLock);
-        CameraHALStopPreview();
-        UnLockWakeLock();
-
-    }
-
-    bool CameraHal::previewEnabled()
-    {
-        CAMERA_LOG_FUNC;
-        return mPreviewRunning;
-    }
-
-    //update buffer for direct input in video recorder
-    status_t CameraHal::updateDirectInput(bool bDirect)
-    {
-        unsigned int i;
-        if (bDirect == true) {
-            if(mCaptureBufNum <= 0)
-                CAMERA_LOG_INFO("mCaptureBuf not allocated yet, will register it later");
-
-            for(i = 0 ; i < mCaptureBufNum; i ++) {
-                mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
-                CAMERA_LOG_INFO("Camera HAL physic address: %x", mCaptureBuffers[i].phy_offset);
-                mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
-                memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
-                        (void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-            }
-        }
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::storeMetaDataInBuffers(bool enable)
-    {
-        CAMERA_LOG_FUNC;
-        return -1;
-    }
-
-    status_t CameraHal::startRecording()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int i;
-
-        mEncodeLock.lock();
-        if (mRecordRunning == true ) {
-            CAMERA_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
-            mEncodeLock.unlock();
-            return ret;
-        }
-
-        for(i = 0; i < mVideoBufNume; i++) {
-            mVideoBufferUsing[i] = 0;
-        }
-
-        mRecordRunning = true;
-        mEncodeLock.unlock();
-
-        return NO_ERROR;
-    }
-
-    void CameraHal::stopRecording()
-    {
-        CAMERA_LOG_FUNC;
-
-        mEncodeLock.lock();
-        if(mRecordRunning) {
-            mRecordRunning = false;
-            mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_STOP, 0));
-            //stopRecording() will holde mLock in camera service,
-            //when encodeframeThread() is in the call back mDataCbTimestamp.
-            //That call back will make a call of releaseRecordingFrame, which
-            //also try to acquire the lock mLock. It will make a dead lock between the two thread
-            //sem_wait(&mEncodeStoppedCondition);
-            CAMERA_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
-        }
-        mEncodeLock.unlock();
-    }
-
-    void CameraHal::releaseRecordingFrame(const void* mem)
-    {
-        //CAMERA_LOG_FUNC;
-        int index;
-
-        index = ((size_t)mem - (size_t)mVideoMemory->data) / mPreviewFrameSize;
-        mVideoBufferUsing[index] = 0;
-
-        if(mCaptureBuffers[index].refCount == 0) {
-            CAMERA_LOG_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
-            return;
-        }
-        putBufferCount(&mCaptureBuffers[index]);
-    }
-
-    bool CameraHal::recordingEnabled()
-    {
-        CAMERA_LOG_FUNC;
-        return (mPreviewRunning && mRecordRunning);
-    }
-
-    status_t CameraHal::autoFocus()
-    {
-        CAMERA_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-
-        if (mAutoFocusThread != NULL)
-            mAutoFocusThread.clear();
-
-        mAutoFocusThread = new AutoFocusThread(this);
-        if (mAutoFocusThread == NULL)
-            return UNKNOWN_ERROR;
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::cancelAutoFocus()
-    {
-        CAMERA_LOG_FUNC;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::takePicture()
-    {
-        CAMERA_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
-
-        if(mTakePictureInProcess) {
-            CAMERA_LOG_ERR("%s: takePicture already in process", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
-
-        if(mTakePicThread->run("takepicThread", PRIORITY_URGENT_DISPLAY) != NO_ERROR) {
-            CAMERA_LOG_ERR("%s: could't run take picture thread", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
-        mTakePictureInProcess = true;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::cancelPicture()
-    {
-        CAMERA_LOG_FUNC;
-        mTakePicThread->requestExitAndWait();
-
-        return NO_ERROR;
-    }
-
-
-    int CameraHal::autoFocusThread()
-    {
-        CAMERA_LOG_FUNC;
-        int FocusFlag = 0;
-
-        if (mMsgEnabled & CAMERA_MSG_FOCUS)
-            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
-
-        return UNKNOWN_ERROR; //exit the thread
-    }
-
-    int CameraHal::takepicThread()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_LOG_INFO("Start taking picture!");
-
-        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
-        CameraHALStopPreview();
-        mTakePictureAllocBuffer = true;
-        cameraHALTakePicture();
-        mTakePictureAllocBuffer = false;
-        mTakePictureInProcess = false;
-
-        return UNKNOWN_ERROR;
-    }
-
-    int CameraHal :: cameraHALTakePicture()
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR;
-        unsigned int DeQueBufIdx = 0;
-        struct jpeg_encoding_conf JpegEncConf;
-        DMA_BUFFER *Buf_input, Buf_output;
-        camera_memory_t* JpegMemBase = NULL;
-        camera_memory_t *RawMemBase = NULL;
-
-        int  max_fps, min_fps;
-        int actual_fps = 15;
-
-        if (mJpegEncoder == NULL){
-            CAMERA_LOG_ERR("the jpeg encoder is NULL");
-            return BAD_VALUE;
-        }
-        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-        //Default setting is 15FPS
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDeviceCfg.tv.denominator = 15;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-            //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
-            if((strstr(mCameraSensorName, "mipi") == NULL)&&
-                (mCaptureDeviceCfg.width == 1920)&&
-                (mCaptureDeviceCfg.height == 1080)) {
-                //Workaround for 1080p setting for csi camera, which only 15fps is valid
-                mCaptureDeviceCfg.tv.denominator = 15;
-            } else {
-                mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-                if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-                    if (mParameters.getPreviewFrameRate() >= 15){
-                        mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-                        CAMERA_LOG_INFO("Set Capture Fps %d", mParameters.getPreviewFrameRate());
-                    }
-                }
-                else{
-                    CAMERA_LOG_INFO("Set Capture Fps Range %d - %d",min_fps, max_fps);
-                    actual_fps = min_fps > 15000? 30:15;
-                    mCaptureDeviceCfg.tv.denominator = actual_fps;
-                }
-            }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-
-        if(mUseIon) {
-            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
-        }
-        else {
-            //surface texture requires larger than 2 buffers to work.
-            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM + 1;
-        }
-        mTakePicFlag = true;
-        if ((ret = GetJpegEncoderParam()) < 0)
-            return ret;
-        if ((ret = NegotiateCaptureFmt(true)) < 0)
-            return ret;
-
-        if ((ret = PrepareCaptureDevices()) < 0)
-            return ret;
-
-        if ((ret = PrepareJpegEncoder()) < 0)
-            return ret;
-
-        JpegMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
-        if (JpegMemBase == NULL || JpegMemBase->data == NULL){
-            ret = NO_MEMORY;
-            goto Pic_out;
-        }
-
-        if (mCaptureDevice->DevStart()<0){
-            CAMERA_LOG_ERR("the capture start up failed !!!!");
-            return INVALID_OPERATION;
-        }
-
-        for (unsigned int i =0;;){
-            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
-                ALOGE("VIDIOC_DQBUF Failed!!!");
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-            if (++i == mCaptureDeviceCfg.picture_waite_number)
-                break;
-
-            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-        }
-
-        Buf_input = &mCaptureBuffers[DeQueBufIdx];
-
-        Buf_output.virt_start = (unsigned char *)(JpegMemBase->data);
-        CAMERA_LOG_INFO("Generated a picture with mMsgEnabled 0x%x", mMsgEnabled);
-
-        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
-            CAMERA_LOG_INFO("CAMERA_MSG_SHUTTER");
-            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
-        }
-
-        if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE) {
-            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE");
-            RawMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
-
-            if ( NULL == RawMemBase ) {
-                CAMERA_LOG_INFO("Raw buffer allocation failed!");
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-            void *dest = RawMemBase->data;
-
-            if (NULL != dest) {
-                void *src = &mCaptureBuffers[DeQueBufIdx];
-                memcpy(dest, src, mCaptureFrameSize);
-            }
-
-            mDataCb(CAMERA_MSG_RAW_IMAGE, RawMemBase, 0, NULL, mCallbackCookie);
-
-            RawMemBase->release(RawMemBase);
-        }
-
-        if ( mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY ) {
-            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE_NOTIFY");
-            if(mNotifyCb)
-                mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
-        }
-
-        if (mJpegEncoder->DoEncode(Buf_input,&Buf_output,&JpegEncConf) < 0){
-            ret = UNKNOWN_ERROR;
-            goto Pic_out;
-        }
-
-Pic_out:
-        freeBuffersToNativeWindow();
-        if ((JpegMemBase != NULL) &&(JpegMemBase->data != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-            CAMERA_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
-            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, 0, NULL, mCallbackCookie);
-        }
-
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        if(mSensorType == CAMERA_TYPE_UVC) {
-            CloseCaptureDevice();
-        }
-
-        if(JpegMemBase) {
-            JpegMemBase->release(JpegMemBase);
-        }
-        if(mWaitForTakingPicture) {
-            sem_post(&mTakingPicture);
-        }
-        return ret;
-
-    }
-
-    int CameraHal :: GetJpegEncoderParam()
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR, i = 0;
-        memset(mJpegEncoderSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mJpegEncoderSupportFmt[i])) < 0)
-                break;
-        }
-        if (i == 0){
-            CAMERA_LOG_ERR("Get the parameters error");
-            return UNKNOWN_ERROR;
-        }
-        return ret;
-    }
-    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR, i = 0, j = 0;
-        unsigned int nPickFormat = 0;
-
-        if(TakePicFlag){
-            //when take picture, only the mJpegEncoderSupportFmt impact it.
-            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
-                    if (mJpegEncoderSupportFmt[j] == 0)
-                        break;
-                    if (mSensorSupportFmt[i] == mJpegEncoderSupportFmt[j]){
-                        nPickFormat = mSensorSupportFmt[i];
-                        CAMERA_LOG_INFO("Get the Picture Encode Format :%c%c%c%c\n",
-                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
-                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
-                        break;
-                    }
-                }
-                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
-                    break;
-            }
-            if (nPickFormat == 0) {
-                CAMERA_LOG_ERR("NegotiateCaptureFmt failed");
-                return UNKNOWN_ERROR;
-            }
-            else {
-                mPictureEncodeFormat = nPickFormat;
-                mCaptureDeviceCfg.fmt = nPickFormat;
-            }
-            //should make mPictureEncodeFormat equal to mPreviewCapturedFormat.
-            //because allocate buffer should use it.
-            mPreviewCapturedFormat = mPictureEncodeFormat;
-        }//endif TakePicFlag
-        else{
-            //when preview or encoder, only mVpuSupportFmt impact it.
-            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                for (j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
-                    if(mVpuSupportFmt[j] == 0)
-                        break;
-                    if(mSensorSupportFmt[i] == mVpuSupportFmt[j]) {
-                        nPickFormat = mSensorSupportFmt[i];
-                        CAMERA_LOG_RUNTIME("get the priview format:%c%c%c%c\n",
-                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
-                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
-                        break;
-                    }
-                }//end for
-                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
-                    break;
-            }
-            if (nPickFormat == 0) {
-                CAMERA_LOG_ERR("NegotiateCaptureFmt2 failed");
-                return UNKNOWN_ERROR;
-            }
-            else {
-                mPreviewCapturedFormat = nPickFormat;
-                mCaptureDeviceCfg.fmt = nPickFormat;
-            }
-        }//end else
-
-        return ret;
-    }
-
-    int CameraHal :: PrepareJpegEncoder()
-    {
-        int ret = NO_ERROR;
-        struct jpeg_enc_make_info_t make_info;
-        struct jpeg_enc_makernote_info_t makernote_info;
-        struct jpeg_enc_model_info_t model_info;
-        struct jpeg_enc_datetime_info_t datetime_info;
-        struct jpeg_enc_focallength_t focallength_info;
-        struct jpeg_enc_gps_param gps_info;
-        int rotate_angle = 0;
-        JPEG_ENCODER_WHITEBALANCE whitebalance_info;
-        JPEG_ENCODER_FLASH flash_info;
-        const char * pWhiteBalanceStr, *pFlashStr;
-
-        char temp_string[30], gps_datetime_string[11];
-        char format[30] = "%Y:%m:%d %k:%M:%S";
-        time_t clock;
-        struct tm *tm, *temp_tm;
-        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
-        double dAltitude;
-
-        mJpegEncCfg.BufFmt = mPictureEncodeFormat;
-        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
-        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
-        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
-        CAMERA_LOG_INFO("pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
-        CAMERA_LOG_INFO("thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
-        //set focallength info
-        focallength_info.numerator=10001;
-        focallength_info.denominator=1000;  // hardcode here for the cts
-        mJpegEncCfg.pFoclLength = &focallength_info;
-
-        //set the make info
-        make_info.make_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)make_info.make, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeInfo = &make_info;
-
-        //set makernote info
-        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeNote = &makernote_info;
-
-        //set model info
-        model_info.model_bytes=strlen(EXIF_MODEL);
-        strcpy((char *)model_info.model,EXIF_MODEL);
-        mJpegEncCfg.pModelInfo = &model_info;
-
-        //set datetime
-        time(&clock);
-        tm = localtime(&clock);
-        time_t GpsUtcTime;
-        strftime(temp_string, sizeof(temp_string), format, tm);
-        CAMERA_LOG_INFO("date time: %s", temp_string);
-        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
-        mJpegEncCfg.pDatetimeInfo = &datetime_info;
-
-        rotate_angle = mParameters.getInt(CameraParameters::KEY_ROTATION);
-        if (rotate_angle == 0)
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL; //the android and the jpeg has the same define
-        else if (rotate_angle == 90)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_90;
-        else if (rotate_angle == 180)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_180;
-        else if (rotate_angle == 270)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
-        else
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
-        CAMERA_LOG_INFO("rotate: %d", rotate_angle);
-
-        pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
-        CAMERA_LOG_INFO("white balance: %s",pWhiteBalanceStr);
-        if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
-            whitebalance_info = WHITEBALANCE_AUTO;
-        }else{
-            whitebalance_info = WHITEBALANCE_MANUAL;
-        }
-        mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
-
-        pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
-        CAMERA_LOG_INFO("flash mode: %s", pFlashStr);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
-            flash_info = FLASH_NOT_FIRE;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
-            flash_info = FLASH_FIRED_AUTO;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) == 0){
-            flash_info = FLASH_FIRED;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) == 0){
-            flash_info = FLASH_FIRED_RED_EYE_REDUCE;
-        }
-        else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) == 0){
-            flash_info = FLASH_FIRED_COMPULOSORY;
-        }
-        else{
-            flash_info = FLASH_NOT_FIRE;
-        }
-        mJpegEncCfg.FlashInfo = flash_info;
-
-        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
-        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
-        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
-        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
-
-        if (cLatitude !=NULL && cLongtitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
-
-            gps_info.version=0x02020000;
-
-            //latitude: dd/1,mm/1,ss/1
-            gps_info.latitude_degree[1]=1;
-            gps_info.latitude_minute[1]=1;
-            gps_info.latitude_second[1]=1000;
-            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
-
-            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
-                //the ref is south
-                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
-            }
-
-            //longtitude: dd/1,mm/1,ss/1
-            gps_info.longtitude_degree[1]=1;
-            gps_info.longtitude_minute[1]=1;
-            gps_info.longtitude_second[1]=1000;
-            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
-
-            if (stringTodegree(cLongtitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
-                //the ref is Weston
-                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
-            }
-
-            //altitude(meters): aa/1
-            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
-            gps_info.altitude[0]=1000;
-            gps_info.altitude[1]=1;
-            if (cAltitude != NULL){
-                int intValue;
-                gps_info.altitude[1]=1000;	   // the precision is CM
-                dAltitude= atof(cAltitude);
-                CAMERA_LOG_RUNTIME("altitude: %s", cAltitude);
-                intValue = (int)(dAltitude * 1000.0);
-                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
-                gps_info.altitude[0] = (unsigned long) intValue;
-                CAMERA_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
-            }
-
-            //timestamp: hh/1,mm/1,ss/1
-            gps_info.hour[1]=1;
-            gps_info.minute[1]=1;
-            gps_info.seconds[1]=1;
-            if (cTimeStamp != NULL){
-
-                GpsUtcTime = atol(cTimeStamp);
-                CAMERA_LOG_INFO("Timestamp: %s", cTimeStamp);
-                temp_tm = gmtime((const time_t*)&GpsUtcTime);
-                if (temp_tm != NULL)
-                    tm = temp_tm;
-            }
-
-            gps_info.hour[0] = tm->tm_hour;
-            gps_info.minute[0] = tm->tm_min;
-            gps_info.seconds[0] = tm->tm_sec;
-
-            strcpy (format, "%Y:%m:%d ");
-
-
-            strftime((char *)temp_string, strlen(temp_string), format, tm);
-            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
-
-
-            char * processMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
-            if (processMehod == NULL){
-                CAMERA_LOG_INFO("processMethod is NULL, add a fake");
-                processMehod = (char *)"fsl_fake_method";
-            }
-
-            memcpy(gps_info.processmethod, processMehod, strlen(processMehod));
-
-            gps_info.processmethod_bytes=strlen(processMehod);
-
-            CAMERA_LOG_INFO("processmethod: %s", gps_info.processmethod);
-
-            mJpegEncCfg.pGps_info = &gps_info;
-        }else{
-            mJpegEncCfg.pGps_info = NULL;
-        }
-
-        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
-            CAMERA_LOG_ERR("Jpeg Encoder Init error !!!");
-            return UNKNOWN_ERROR;
-        }
-
-        return ret;
-    }
-
-    status_t CameraHal::convertPreviewFormatToString(char *pStr, int length, unsigned int format)
-    {
-        CAMERA_LOG_FUNC;
-        if(pStr == NULL || length < 10) {
-            CAMERA_LOG_ERR("%s: invalide parameters", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        if(format == v4l2_fourcc('Y','U','1','2')) {
-            strcpy(pStr, "yuv420p");
-        }
-        else if(format == v4l2_fourcc('N','V','1','2')) {
-            strcpy(pStr, "yuv420sp");
-        }
-        //else if(format == v4l2_fourcc('Y','U','Y','V')) {
-        //    strcpy(pStr, "yuv422i-yuyv");
-        //}
-        else {
-            CAMERA_LOG_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::convertStringToPreviewFormat(unsigned int *pFormat)
-    {
-        CAMERA_LOG_FUNC;
-        if(!strcmp(mParameters.getPreviewFormat(), "yuv420p")) {
-            *pFormat = v4l2_fourcc('Y','U','1','2');
-        }
-        else if(!strcmp(mParameters.getPreviewFormat(), "yuv420sp")) {
-            *pFormat = v4l2_fourcc('N','V','1','2');
-        }
-        //else if(!strcmp(mParameters.getPreviewFormat(), "yuv422i-yuyv")) {
-        //    *pFormat = v4l2_fourcc('Y','U','Y','V');
-        //}
-        else {
-            CAMERA_LOG_ERR("Only yuv420sp or yuv420p is supported");
-            return BAD_VALUE;
-        }
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::CameraHALStartPreview()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int  max_fps, min_fps;
-        int actual_fps = 15;
-
-        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-
-        if ((ret = convertStringToPreviewFormat(&mPreviewCapturedFormat)) != 0) {
-            CAMERA_LOG_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
-            return ret;
-        }
-
-        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
-
-        CAMERA_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
-        mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
-        //Default setting is 15FPS
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDeviceCfg.tv.denominator = 15;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-            //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
-            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-            if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-                if (mParameters.getPreviewFrameRate() >= 15){
-                    mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-                    CAMERA_LOG_INFO("Set Preview Fps %d", mParameters.getPreviewFrameRate());
-                }
-            }
-            else{
-                CAMERA_LOG_INFO("Set Preview Fps Range %d - %d",min_fps, max_fps);
-                actual_fps = min_fps > 15000? 30:15;
-                mCaptureDeviceCfg.tv.denominator = actual_fps;
-            }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
-        mTakePicFlag = false;
-
-        if(mCaptureDeviceCfg.fmt)
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
-            else
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
-
-        if ((ret = PrepareCaptureDevices()) < 0){
-            CAMERA_LOG_ERR("PrepareCaptureDevices error ");
-            return ret;
-        }
-        if ((ret = PreparePreviwBuf()) < 0){
-            CAMERA_LOG_ERR("PreparePreviwBuf error");
-            return ret;
-        }
-
-        if ((ret = PreparePreviwMisc()) < 0){
-            CAMERA_LOG_ERR("PreparePreviwMisc error");
-            return ret;
-        }
-
-        if(mNativeWindow != NULL) {
-            if ((ret = CameraHALPreviewStart()) < 0){
-                CAMERA_LOG_ERR("CameraHALPreviewStart error");
-                return ret;
-            }
-        }
-
-        return ret;
-    }
-    void CameraHal::CameraHALStopPreview()
-    {
-        CAMERA_LOG_FUNC;
-        if (mPreviewRunning != 0)	{
-            CameraHALStopThreads();
-            CameraHALStopMisc();
-            mCaptureBufNum = 0;
-            CAMERA_LOG_INFO("camera hal stop preview done");
-        }else{
-            CAMERA_LOG_INFO("Camera hal already stop preview");
-        }
-        return ;
-    }
-
-    void CameraHal :: CameraHALStopThreads()
-    {
-        CAMERA_LOG_FUNC;
-
-        mCaptureLock.lock();
-        if(mCaptureRunning) {
-            CAMERA_LOG_INFO("%s :capture run", __FUNCTION__);
-            mCaptureThreadQueue.postStopMessage();
-            mCaptureRunning = false;
-            if(gettid()!= mCaptureFrameThread->mTID)
-                sem_wait(&mCaptureStoppedCondition);
-            else
-                CAMERA_LOG_INFO("Stop CaptureFrameThread in itself");
-        }else {
-            CAMERA_LOG_INFO("%s :capture not run", __FUNCTION__);
-        }
-        mCaptureLock.unlock();
-        CAMERA_LOG_INFO("%s :---------", __FUNCTION__);
-
-        mPreviewLock.lock();
-        if(mPreviewRunning) {
-            CAMERA_LOG_INFO("%s :preview run", __FUNCTION__);
-            mPreviewThreadQueue.postStopMessage();
-            mPreviewRunning = false;
-            if(gettid()!= mPreviewShowFrameThread->mTID)
-                sem_wait(&mPreviewStoppedCondition);
-            else
-                CAMERA_LOG_INFO("Stop PreviewShowThread in itself");
-        }else {
-            CAMERA_LOG_INFO("%s :preview not run", __FUNCTION__);
-        }
-        mPreviewLock.unlock();
-        CAMERA_LOG_INFO("%s :exit", __FUNCTION__);
-
-        return ;
-    }
-
-    void CameraHal :: CameraHALStopMisc()
-    {
-        CAMERA_LOG_FUNC;
-
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        freeBuffersToNativeWindow();
-        if(mSensorType == CAMERA_TYPE_UVC) {
-            CloseCaptureDevice();
-        }
-    }
-
-    status_t CameraHal :: PrepareCaptureBufs()
-    {
-        CAMERA_LOG_FUNC;
-        unsigned int CaptureBufNum = mCaptureBufNum;
-
-        if(allocateBuffersFromNativeWindow() < 0) {
-            CAMERA_LOG_ERR("allocateBuffersFromNativeWindow error");
-            return BAD_VALUE;
-        }
-
-        if (mCaptureDevice->DevRegisterBufs(mCaptureBuffers,&CaptureBufNum)< 0){
-            CAMERA_LOG_ERR("capture device allocat buf error");
-            return BAD_VALUE;
-        }
-        if(mCaptureBufNum != CaptureBufNum){
-            CAMERA_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
-        }
-
-        mCaptureBufNum = CaptureBufNum;
-
-        if (mCaptureDevice->DevPrepare()< 0){
-            CAMERA_LOG_ERR("capture device prepare error");
-            return BAD_VALUE;
-        }
-        nCameraBuffersQueued = mCaptureBufNum;
-        mIsCaptureBufsAllocated = 1;
-
-        if((AllocateRecordVideoBuf())<0) {
-            CAMERA_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
-            return BAD_VALUE;
-        }
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal :: PrepareCaptureDevices()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int i =0;
-        struct capture_config_t *pCapcfg;
-        if ((ret = OpenCaptureDevice())<0)
-            return ret;
-
-        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
-            CAMERA_LOG_ERR("Dev config failed");
-            return BAD_VALUE;
-        }
-        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
-
-        if(mNativeWindow != 0) {
-            if(PrepareCaptureBufs() < 0) {
-                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
-                return BAD_VALUE;
-            }
-        }
-
-        return ret;
-    }
-
-    status_t CameraHal::PreparePreviwBuf()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int i =0;
-
-        //temply hard code here
-        if (mTakePicFlag == 0){
-            if(mPreviewMemory != NULL) {
-                mPreviewMemory->release(mPreviewMemory);
-            }
-
-            mPreviewMemory = mRequestMemory(-1, mPreviewFrameSize, mPreviewHeapBufNum, NULL);
-            if(mPreviewMemory == NULL) {
-                CAMERA_LOG_ERR("%s, allocate memory failed", __FUNCTION__);
-                return NO_MEMORY;
-            }
-        }
-        return ret;
-    }
-
-    status_t CameraHal ::PreparePreviwMisc()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        preview_heap_buf_head = 0;
-
-       return ret;
-    }
-
-    status_t CameraHal ::CameraHALPreviewStart()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDevice->DevStart()<0)
-            return INVALID_OPERATION;
-
-        mIsCaptureBufsAllocated = 1;
-
-        unsigned int bufIndex = 0;
-        //skip 10 frames when doing preview
-        if(mSensorType != CAMERA_TYPE_UVC) {
-            for (int k = 0; k < 10; k++) {
-                mCaptureDevice->DevDequeue(&bufIndex);
-                mCaptureDevice->DevQueue(bufIndex);
-            }
-        }
-
-        for(unsigned int i=0; i < mCaptureBufNum; i++) {
-            mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
-        }
-        return ret;
-    }
-
-    status_t CameraHal::putBufferCount(DMA_BUFFER *pBuf)
-    {
-        if(pBuf == NULL)
-            return INVALID_OPERATION;
-
-        unsigned int buf_index = pBuf - &mCaptureBuffers[0];
-
-        Mutex::Autolock _l(pBuf->mBufferLock);
-        if(!mRecordRunning &&  (mVideoBufferUsing[buf_index] == 1)
-                && (pBuf->refCount == 2)) {
-            pBuf->refCount --;
-            mVideoBufferUsing[buf_index] = 0;
-        }
-
-        pBuf->refCount --;
-        if(pBuf->refCount == 0) {
-            if(mCaptureRunning) {
-                if(buf_index < mCaptureBufNum) {
-                    if(mCaptureDevice->DevQueue(buf_index) <0){
-                        CAMERA_LOG_ERR("The Capture device queue buf %d error !!!!", buf_index);
-                        return INVALID_OPERATION;
-                    }
-                    //CAMERA_LOG_RUNTIME("Return buffer %d to Capture Device", buf_index);
-                    mCaptureBuffers[buf_index].refCount = 0;
-                    nCameraBuffersQueued++;
-                    mEnqueuedBufs --;
-                    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, buf_index));
-                }else {
-                    return INVALID_OPERATION;
-                }
-            }//end elseif
-        }
-        return NO_ERROR;
-    }
-
-    void CameraHal ::getBufferCount(DMA_BUFFER *pBuf)
-    {
-        if(pBuf == NULL)
-            return;
-        Mutex::Autolock _l(pBuf->mBufferLock);
-        pBuf->refCount ++;
-    }
-
-    int CameraHal ::captureframeThreadWrapper()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitCaptureThread) {
-                CAMERA_LOG_INFO("%s: exiting normally", __FUNCTION__);
-                return 0;
-            }
-            ret = captureframeThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: capture thread exit with exception", __FUNCTION__);
-                return ret;
-            }
-        }
-        return ret;
-    }
-
-    int CameraHal ::captureframeThread()
-    {
-        //CAMERA_LOG_FUNC;
-
-        unsigned int bufIndex = -1;
-        status_t ret = NO_ERROR;
-        sp<CMessage> msg = mCaptureThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;
-        }
-
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                ret = mCaptureDevice->DevDequeue(&bufIndex);
-                //handle the error return.
-                if(ret < 0) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer", __FUNCTION__);
-                    //mCaptureRunning = false;
-                    mCaptureThreadQueue.clearMessage();
-                    sem_post(&mCaptureStoppedCondition);
-                    return NO_ERROR;
-                }
-                //CAMERA_LOG_RUNTIME("Get buffer %d from Capture Device", bufIndex);
-                //handle the normal return.
-                getBufferCount(&mCaptureBuffers[bufIndex]);
-                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-
-                if(mRecordRunning) {
-                    getBufferCount(&mCaptureBuffers[bufIndex]);
-                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-                }
-                break;
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: capture thread stop", __FUNCTION__);
-                mCaptureThreadQueue.clearMessage();
-                sem_post(&mCaptureStoppedCondition);
-                CAMERA_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitCaptureThread = 1;
-                CAMERA_LOG_INFO("%s: receive QUITE message", __FUNCTION__);
-                if (mExitPreviewThread == 0)
-                    mPreviewThreadQueue.postQuitMessage();
-                if (mExitEncodeThread == 0)
-                    mEncodeThreadQueue.postQuitMessage();
-                break;
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }//end switch
-
-        return ret;
-    }
-
-    void CameraHal::SearchBuffer(void *pNativeBuf, int *pIndex)
-    {
-        //int index;
-        for(unsigned int i=0; i < mCaptureBufNum; i++){
-            if(mCaptureBuffers[i].native_buf == pNativeBuf) {
-                *pIndex = i;
-                return;
-            }
-        }
-
-        *pIndex = -1;
-        return;
-    }
-
-    int CameraHal ::previewshowFrameThreadWrapper()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitPreviewThread) {
-                CAMERA_LOG_INFO("%s: exiting", __FUNCTION__);
-                return 0;
-            }
-            ret = previewshowFrameThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: preview thread exit with exception", __FUNCTION__);
-                mExitPreviewThread = 1;
-                return ret;
-            }
-        }
-        return ret;
-    }
-
-    static void bufferDump(DMA_BUFFER *pBufs)
-    {
-#ifdef FSL_CAMERAHAL_DUMP
-            //for test code
-            char value[10] = {0};
-            static int vflg = 0;
-            property_get("rw.camera.test", value, "");
-            if(strcmp(value, "1") == 0)
-                vflg = 1;
-            if(vflg){
-                FILE *pf = NULL;
-                pf = fopen("/sdcard/camera_tst.data", "wb");
-                if(pf == NULL) {
-                    CAMERA_LOG_ERR("open /sdcard/camera_tst.data failed");
-                }
-                else {
-                    fwrite(pInBuf->virt_start, pInBuf->length, 1, pf);
-                    fclose(pf);
-                }
-                vflg = 0;
-            }
-#endif
-    }
-
-    int CameraHal ::previewshowFrameThread()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int display_index = -1;
-        DMA_BUFFER *pInBuf = NULL;
-        buffer_handle_t *buf_h = NULL;
-        int buf_index = -1;
-        int stride = 0, err = 0;
-
-        sp<CMessage> msg = mPreviewThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            mPreviewRunning = false;
-            return BAD_VALUE;
-        }
-
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                display_index = msg->arg0;
-                if(display_index < 0 || (unsigned int)display_index >= mCaptureBufNum) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return BAD_VALUE;
-                }
-                pInBuf = &mCaptureBuffers[display_index];
-
-                if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-                    //CAMERA_LOG_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
-                    convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
-                            (uint8_t*)((unsigned char*)mPreviewMemory->data + preview_heap_buf_head*mPreviewFrameSize),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-                    mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, preview_heap_buf_head, NULL, mCallbackCookie);
-                    preview_heap_buf_head ++;
-                    preview_heap_buf_head %= mPreviewHeapBufNum;
-                }
-
-                if (mNativeWindow != 0) {
-                    if (mNativeWindow->enqueue_buffer(mNativeWindow, (buffer_handle_t * )pInBuf->native_buf) < 0){
-                        CAMERA_LOG_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
-                        mPreviewRunning = false;
-                        mPreviewThreadQueue.clearMessage();
-                        sem_post(&mPreviewStoppedCondition);
-                        return BAD_VALUE;
-                    }
-                    pInBuf->buf_state = WINDOW_BUFS_QUEUED;
-                    mEnqueuedBufs ++;
-                    bufferDump(pInBuf);
-                    if (mEnqueuedBufs <= 2) {
-                        return NO_ERROR;
-                    }
-                }
-                else {
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return BAD_VALUE;
-                }
-
-                err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
-                if((err != 0) || buf_h == NULL) {
-                    CAMERA_LOG_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return INVALID_OPERATION;
-                }
-
-                SearchBuffer((void *)buf_h, &buf_index);
-
-                if(buf_index >= (int)mCaptureBufNum || (buf_index < 0)) {
-                    mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
-                    CAMERA_LOG_ERR("dequeue invalide buffer!!!!");
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return INVALID_OPERATION;
-                }
-
-                mCaptureBuffers[buf_index].buf_state = WINDOW_BUFS_DEQUEUED;
-                ret = putBufferCount(&mCaptureBuffers[buf_index]);
-                break;
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: preview thread stop", __FUNCTION__);
-                mPreviewThreadQueue.clearMessage();
-                sem_post(&mPreviewStoppedCondition);
-                CAMERA_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitPreviewThread = 1;
-                CAMERA_LOG_INFO("%s: receive QUIT message", __FUNCTION__);
-                break;
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }
-
-        return ret;
-    }
-
-    int CameraHal::encodeframeThreadWrapper()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitEncodeThread) {
-                return 0;
-            }
-            ret = encodeframeThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: encode thread exit with exception", __FUNCTION__);
-                mExitEncodeThread = 1;
-                return ret;
-            }
-        }
-        return ret;
-    }
-
-    int CameraHal::encodeframeThread()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int enc_index;
-        sp<CMessage> msg = mEncodeThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;
-        }
-
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                enc_index = msg->arg0;
-                unsigned int i;
-                if(enc_index < 0 || (unsigned int)enc_index >= mCaptureBufNum) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
-                    mRecordRunning = false;
-                    mEncodeThreadQueue.clearMessage();
-                    //sem_post(&mEncodeStoppedCondition);
-                    return BAD_VALUE;
-                }
-
-                struct timespec ts;
-                DMA_BUFFER *EncBuf;
-                EncBuf = &mCaptureBuffers[enc_index];
-
-                if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
-                    nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-                    if (mDirectInput == true) {
-	                    memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
-                            (void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
-                    } else {
-                        memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
-                                (void*)EncBuf->virt_start, mPreviewFrameSize);
-                    }
-
-                    mVideoBufferUsing[enc_index] = 1;
-                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, enc_index, mCallbackCookie);
-                    break;
-                }
-                break;
-
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: encode thread stop", __FUNCTION__);
-                mEncodeThreadQueue.clearMessage();
-                //sem_post(&mEncodeStoppedCondition);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitEncodeThread = 1;
-                break;
-
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }
-
-        return ret;
-    }
-
-    status_t CameraHal :: AllocateRecordVideoBuf()
-    {
-        status_t ret = NO_ERROR;
-        unsigned int i = 0;
-        if(mVideoMemory != NULL) {
-            mVideoMemory->release(mVideoMemory);
-        }
-
-        CAMERA_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
-        mVideoMemory = mRequestMemory(-1, mPreviewFrameSize, mVideoBufNume, NULL);
-        if(mVideoMemory == NULL) {
-            CAMERA_LOG_ERR("%s, request video buffer failed", __FUNCTION__);
-            return NO_MEMORY;
-        }
-
-        //Make sure the buffer been updated for direct input
-        updateDirectInput(mDirectInput);
-        return ret;
-    }
-
-
-    void CameraHal :: LockWakeLock()
-    {
-        if (!mPowerLock) {
-            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
-            mPowerLock = true;
-        }
-    }
-    void CameraHal :: UnLockWakeLock()
-    {
-        if (mPowerLock) {
-            release_wake_lock (V4LSTREAM_WAKE_LOCK);
-            mPowerLock = false;
-        }
-    }
-
-    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
-    {
-        /* Color space conversion from I420 to YUV420SP */
-        int Ysize = 0, UVsize = 0;
-        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
-
-        Ysize = width * height;
-        UVsize = width *  height >> 2;
-
-        Yin = inputBuffer;
-        Uin = Yin + Ysize;
-        Vin = Uin + 1;
-
-        Yout = outputBuffer;
-        Vout = Yout + Ysize;
-        Uout = Vout + 1;
-
-        memcpy(Yout, Yin, Ysize);
-
-        for(int k = 0; k < UVsize; k++) {
-            *Uout = *Uin;
-            *Vout = *Vin;
-            Uout += 2;
-            Vout += 2;
-            Uin  += 2;
-            Vin += 2;
-        }
-    }
-
-
-
-    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
-    {
-        double dAttribtute;
-        double eAttr;
-        long intAttribute;
-        int ret  = 0;
-        if (cAttribute == NULL){
-            return -1;
-        }
-
-        CAMERA_LOG_RUNTIME("the attribute is %s", cAttribute);
-
-        dAttribtute = atof(cAttribute);
-
-        CAMERA_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
-        intAttribute  = (long)(dAttribtute*(double)3600.0);
-        if (intAttribute < 0){
-            ret = 1;
-            intAttribute *=-1;
-            dAttribtute *=-1;
-            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
-            eAttr = eAttr * (double)3600.0 *(double)1000.0;
-        }else {
-            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
-            eAttr = eAttr * (double)3600.0 *(double)1000.0;
-        }
-
-        second = (unsigned int)(intAttribute%60);
-        minute = (unsigned int)((intAttribute%3600-second)/60);
-        degree = (unsigned int)(intAttribute/3600);
-        second = (unsigned int)eAttr + second * 1000;
-
-        CAMERA_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
-
-        return ret;
-
-    }
-
-//};
-
-
diff --git a/mx5x/libcamera/CameraHal.h b/mx5x/libcamera/CameraHal.h
deleted file mode 100755
index 03bbda5..0000000
--- a/mx5x/libcamera/CameraHal.h
+++ /dev/null
@@ -1,408 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAMERA_HAL_BASE_H
-#define CAMERA_HAL_BASE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <binder/MemoryBase.h>
-#include <binder/MemoryHeapBase.h>
-#include <camera/CameraParameters.h>
-#include <hardware/camera.h>
-#include <semaphore.h>
-
-#include "CaptureDeviceInterface.h"
-#include "JpegEncoderInterface.h"
-#include "messageQueue.h"
-
-
-#define EXIF_MAKENOTE "fsl_makernote"
-#define EXIF_MODEL    "fsl_model"
-
-#define CAMER_PARAM_BUFFER_SIZE 512
-#define MAX_QUERY_FMT_TIMES 20
-#define PARAMS_DELIMITER ","
-#define V4LSTREAM_WAKE_LOCK "V4LCapture"
-
-#define PREVIEW_HEAP_BUF_NUM    6
-#define VIDEO_OUTPUT_BUFFER_NUM 6
-#define POST_PROCESS_BUFFER_NUM 6
-#define TAKE_PIC_QUE_BUF_NUM 6
-
-#define PREVIEW_CAPTURE_BUFFER_NUM 6
-#define PICTURE_CAPTURE_BUFFER_NUM 2
-
-#define DEFAULT_PREVIEW_FPS (15)
-#define DEFAULT_PREVIEW_W   (640)
-#define DEFAULT_PREVIEW_H   (480)
-#define MAX_MIPI_PREVIEW_W       (1920)
-#define MAX_MIPI_PREVIEW_H       (1080)
-#define MAX_CSI_PREVIEW_W       (1280)
-#define MAX_CSI_PREVIEW_H       (720)
-#define DEFAULT_PICTURE_W   (640)
-#define DEFAULT_PICTURE_H   (480)
-
-#define MAX_VPU_SUPPORT_FORMAT 2
-using namespace android;
-//namespace android {
-
-    typedef enum{
-        CAMERA_HAL_ERR_NONE = 0,
-        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
-        CAMERA_HAL_ERR_GET_PARAM           = -2,
-        CAMERA_HAL_ERR_BAD_PARAM =-3,
-        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
-        CAMERA_HAL_ERR_INIT = -5,
-        CAMERA_HAL_ERR_ALLOC_BUF =-6,
-        CAMERA_HAL_ERR_PP_NULL = -7
-    }CAMERA_HAL_RET;
-
-	typedef enum{
-        CAMERA_PREVIEW_BACK_REF = 0,
-        CAMERA_PREVIEW_VERT_FLIP = 1,
-        CAMERA_PREVIEW_HORIZ_FLIP = 2,
-        CAMERA_PREVIEW_ROATE_180 = 3,
-        CAMERA_PREVIEW_ROATE_LAST = 3
-	}CAMERA_PREVIEW_ROTATE;
-
-#ifndef container_of
-#define container_of(ptr, type, member) ({                      \
-        const typeof(((type *) 0)->member) *__mptr = (ptr);     \
-        (type *) ((char *) __mptr - (char *)(&((type *)0)->member)); })
-#endif
-
-    class CameraHal {
-    public:
-        virtual sp<IMemoryHeap> getRawHeap() const;
-
-        virtual status_t setPreviewWindow(struct preview_stream_ops *window);
-        virtual void        setCallbacks(camera_notify_callback notify_cb,
-                camera_data_callback data_cb,
-                camera_data_timestamp_callback data_cb_timestamp,
-                camera_request_memory get_memory,
-                void* user);
-
-        virtual void        enableMsgType(int32_t msgType);
-        virtual void        disableMsgType(int32_t msgType);
-        virtual bool        msgTypeEnabled(int32_t msgType);
-
-        status_t freeBufferToIon();
-        status_t allocateBufferFromIon();
-        virtual status_t    startPreview();
-        virtual void        stopPreview();
-        virtual bool        previewEnabled();
-
-		virtual status_t  storeMetaDataInBuffers(bool enable);
-
-        virtual status_t    startRecording();
-        virtual void        stopRecording();
-        virtual bool        recordingEnabled();
-        virtual void        releaseRecordingFrame(const void*  mem);
-
-        virtual status_t    autoFocus();
-        virtual status_t    cancelAutoFocus();
-        virtual status_t    takePicture();
-        virtual status_t    cancelPicture();
-        virtual status_t    dump(int fd) const;
-        virtual status_t    setParameters(CameraParameters& params);
-        virtual status_t    setParameters(const char* params);
-        virtual char*  getParameters() const;
-        void putParameters(char *);
-        virtual status_t    sendCommand(int32_t command, int32_t arg1,
-                int32_t arg2);
-        virtual void release();
-
-        CAMERA_HAL_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
-        CAMERA_HAL_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
-        CAMERA_HAL_RET Init();
-        void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
-
-        CameraHal(int cameraid);
-        virtual             ~CameraHal();
-
-    private:
-
-        class CaptureFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            CaptureFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->captureframeThreadWrapper();
-                return false;
-            }
-            int mTID;
-        };
-
-        class PreviewShowFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            PreviewShowFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->previewshowFrameThreadWrapper();
-                return false;
-            }
-            int mTID;
-        };
-
-        class EncodeFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            EncodeFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->encodeframeThreadWrapper();
-                return true;
-            }
-            int mTID;
-        };
-
-        class AutoFocusThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            AutoFocusThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                if (mHardware->autoFocusThread()>=0)
-                    return true;
-                else
-                    return false;
-            }
-            int mTID;
-        };
-
-
-        class TakePicThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            TakePicThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0) { }
-#if 0
-            virtual void onFirstRef() {
-                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
-            }
-#endif
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->takepicThread();
-                return false;
-            }
-            int mTID;
-        };
-
-        void preInit();
-        void postDestroy();
-
-        status_t OpenCaptureDevice();
-        void CloseCaptureDevice();
-
-        CAMERA_HAL_RET AllocInterBuf();
-        void  FreeInterBuf();
-        CAMERA_HAL_RET InitCameraHalParam();
-        CAMERA_HAL_RET InitCameraBaseParam(CameraParameters *pParam);
-        CAMERA_HAL_RET InitPictureExifParam(CameraParameters *pParam);
-        CAMERA_HAL_RET CameraMiscInit();
-        CAMERA_HAL_RET CameraMiscDeInit();
-        status_t CameraHALPreviewStart();
-        int captureframeThread();
-        int previewshowFrameThread();
-        int encodeframeThread();
-        int captureframeThreadWrapper();
-        int previewshowFrameThreadWrapper();
-        int encodeframeThreadWrapper();
-        status_t AllocateRecordVideoBuf();
-
-        status_t CameraHALStartPreview();
-        void     CameraHALStopPreview();
-
-        status_t PreparePreviwBuf();
-        status_t PrepareCaptureDevices();
-        status_t PreparePreviwMisc();
-
-        void CameraHALStopThreads();
-        void LockWakeLock();
-        void UnLockWakeLock();
-
-        int autoFocusThread();
-        int takepicThread();
-
-        int GetJpegEncoderParam();
-        int NegotiateCaptureFmt(bool TakePicFlag);
-        int cameraHALTakePicture();
-        void CameraHALStopMisc();
-        int PrepareJpegEncoder();
-        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
-
-        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
-
-        status_t allocateBuffersFromNativeWindow();
-        void SearchBuffer(void *pNativeBuf, int *pIndex);
-        status_t freeBuffersToNativeWindow();
-        status_t PrepareCaptureBufs();
-        status_t updateDirectInput(bool bDirect);
-
-        status_t convertStringToPreviewFormat(unsigned int *pFormat);
-        status_t convertPreviewFormatToString(char *pStr, int length, unsigned int format);
-        int convertPreviewFormatToPixelFormat(unsigned int format);
-        status_t putBufferCount(DMA_BUFFER *pBuf);
-        void getBufferCount(DMA_BUFFER *pBuf);
-        CAMERA_HAL_RET InitCameraPreviewFormatToParam(int nFmt);
-
-        CMessageQueue mCaptureThreadQueue;
-        CMessageQueue mPreviewThreadQueue;
-        CMessageQueue mEncodeThreadQueue;
-
-        //For capture thread(queue/dequeue with v4l2 driver)
-        mutable Mutex mCaptureLock;
-        mutable sem_t mCaptureStoppedCondition;
-        bool mCaptureRunning;
-        bool mExitCaptureThread;
-
-        //For preview thread(queue/dequeue with NativeWindow)
-        mutable Mutex mPreviewLock;
-        mutable sem_t mPreviewStoppedCondition;
-        bool mPreviewRunning;
-        bool mExitPreviewThread;
-
-        //For video recording thread
-        mutable Mutex mEncodeLock;
-        mutable sem_t mEncodeStoppedCondition;
-        bool mExitEncodeThread;
-
-        //For picture taking thread
-        mutable sem_t mTakingPicture;
-        bool mWaitForTakingPicture;
-        bool mTakePictureInProcess;
-
-        bool mTakePictureAllocBuffer;
-        CameraParameters    mParameters;
-        void               *mCallbackCookie;
-        camera_notify_callback    mNotifyCb;
-        camera_data_callback      mDataCb;
-        camera_data_timestamp_callback mDataCbTimestamp;
-        camera_request_memory mRequestMemory;
-
-        sp<CaptureDeviceInterface> mCaptureDevice;
-        sp<JpegEncoderInterface> mJpegEncoder;
-
-
-        sp<CaptureFrameThread> mCaptureFrameThread;
-        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
-        sp<EncodeFrameThread> mEncodeFrameThread;
-        sp<AutoFocusThread>mAutoFocusThread;
-        sp<TakePicThread> mTakePicThread;
-
-        mutable Mutex       mLock;
-
-        char *mSupportedPictureSizes;
-        char *mSupportedPreviewSizes;
-        char *mSupportedFPS;
-        char *mSupprotedThumbnailSizes;
-        char *mSupportPreviewFormat;
-
-        preview_stream_ops_t*   mNativeWindow;
-        unsigned int        mMsgEnabled;
-
-        struct capture_config_t mCaptureDeviceCfg;
-        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
-
-        camera_memory_t* mPreviewMemory;
-
-        /* the buffer for recorder */
-        unsigned int        mVideoBufNume;
-        camera_memory_t* mVideoMemory;
-        int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
-		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
-
-        unsigned int        mDefaultPreviewFormat;
-        unsigned int 		mPreviewFrameSize;
-        unsigned int        mPreviewCapturedFormat;
-
-        bool                mTakePicFlag;
-        unsigned int        mJpegEncoderSupportFmt[MAX_QUERY_FMT_TIMES];
-        enc_cfg_param       mJpegEncCfg;
-
-        unsigned int        mUvcSpecialCaptureFormat;
-        unsigned int        mSensorSupportFmt[MAX_QUERY_FMT_TIMES];
-        unsigned int        mPictureEncodeFormat;
-        unsigned int        mCaptureFrameSize;
-        unsigned int        mCaptureBufNum;
-        unsigned int        mEnqueuedBufs;
-
-        bool                mRecordRunning;
-        int                 mCurrentRecordFrame;
-        int 		        nCameraBuffersQueued;
-
-        unsigned int        mPreviewHeapBufNum;
-        unsigned int        mTakePicBufQueNum;
-
-        char                mCameraSensorName[CAMERA_SENSOR_LENGTH];
-        bool mCameraReady;
-        bool mCaptureDeviceOpen;
-        bool mIsCaptureBufsAllocated;
-        bool mPreviewStopped;
-        bool mRecordStopped;
-        bool mPowerLock;
-        bool mDirectInput;
-        int mCameraid;
-
-        unsigned int preview_heap_buf_head;
-
-        CAMERA_PREVIEW_ROTATE mPreviewRotate;
-
-        unsigned int mVpuSupportFmt[MAX_VPU_SUPPORT_FORMAT];
-        CAMERA_TYPE mSensorType;
-        int mIonFd;
-        bool mUseIon;
-    };
-
-//}; // namespace android
-
-#endif
-
diff --git a/mx5x/libcamera/CameraModule.cpp b/mx5x/libcamera/CameraModule.cpp
deleted file mode 100644
index bd9cf3c..0000000
--- a/mx5x/libcamera/CameraModule.cpp
+++ /dev/null
@@ -1,744 +0,0 @@
-/*
- * Copyright (C) Freescale - http://www.Freescale.com/
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2013 Freescale Semiconductor, Inc.
- */
-
-#define LOG_TAG "CameraHAL"
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <utils/threads.h>
-#include <cutils/properties.h>
-#include "CameraHal.h"
-#include "Camera_utils.h"
-
-#define MAX_CAMERAS_SUPPORTED 2
-//static android::CameraProperties gCameraProperties;
-static CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
-static unsigned int gCamerasOpen = 0;
-static android::Mutex gCameraHalDeviceLock;
-
-static int camera_device_open(const hw_module_t* module, const char* name,
-                hw_device_t** device);
-static int camera_device_close(hw_device_t* device);
-static int camera_get_number_of_cameras(void);
-static int camera_get_camera_info(int camera_id, struct camera_info *info);
-
-static struct hw_module_methods_t camera_module_methods = {
-        open: camera_device_open
-};
-
-camera_module_t HAL_MODULE_INFO_SYM = {
-    common: {
-         tag: HARDWARE_MODULE_TAG,
-         version_major: 1,
-         version_minor: 0,
-         id: CAMERA_HARDWARE_MODULE_ID,
-         name: "Freescale CameraHal Module",
-         author: "Freescale",
-         methods: &camera_module_methods,
-         dso: NULL, /* remove compilation warnings */
-         reserved: {0}, /* remove compilation warnings */
-    },
-    get_number_of_cameras: camera_get_number_of_cameras,
-    get_camera_info: camera_get_camera_info,
-    set_callbacks: NULL,
-};
-
-typedef struct fsl_camera_device {
-    camera_device_t base;
-    int cameraid;
-} fsl_camera_device_t;
-
-
-/*******************************************************************
- * implementation of camera_device_ops functions
- *******************************************************************/
-
-int camera_set_preview_window(struct camera_device * device,
-        struct preview_stream_ops *window)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->setPreviewWindow(window);
-
-    return rv;
-}
-
-void camera_set_callbacks(struct camera_device * device,
-        camera_notify_callback notify_cb,
-        camera_data_callback data_cb,
-        camera_data_timestamp_callback data_cb_timestamp,
-        camera_request_memory get_memory,
-        void *user)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->setCallbacks(notify_cb, data_cb, data_cb_timestamp, get_memory, user);
-}
-
-void camera_enable_msg_type(struct camera_device * device, int32_t msg_type)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->enableMsgType(msg_type);
-}
-
-void camera_disable_msg_type(struct camera_device * device, int32_t msg_type)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->disableMsgType(msg_type);
-}
-
-int camera_msg_type_enabled(struct camera_device * device, int32_t msg_type)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return 0;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    return gCameraHals[fsl_dev->cameraid]->msgTypeEnabled(msg_type);
-}
-
-int camera_start_preview(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->startPreview();
-
-    return rv;
-}
-
-void camera_stop_preview(struct camera_device * device)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->stopPreview();
-}
-
-int camera_preview_enabled(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->previewEnabled();
-    return rv;
-}
-
-int camera_store_meta_data_in_buffers(struct camera_device * device, int enable)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    //  TODO: meta data buffer not current supported
-    rv = gCameraHals[fsl_dev->cameraid]->storeMetaDataInBuffers(enable);
-    return rv;
-    //return enable ? android::INVALID_OPERATION: android::OK;
-}
-
-int camera_start_recording(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->startRecording();
-    return rv;
-}
-
-void camera_stop_recording(struct camera_device * device)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->stopRecording();
-}
-
-int camera_recording_enabled(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->recordingEnabled();
-    return rv;
-}
-
-void camera_release_recording_frame(struct camera_device * device,
-                const void *opaque)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->releaseRecordingFrame(opaque);
-}
-
-int camera_auto_focus(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->autoFocus();
-    return rv;
-}
-
-int camera_cancel_auto_focus(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->cancelAutoFocus();
-    return rv;
-}
-
-int camera_take_picture(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->takePicture();
-    return rv;
-}
-
-int camera_cancel_picture(struct camera_device * device)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->cancelPicture();
-    return rv;
-}
-
-int camera_set_parameters(struct camera_device * device, const char *params)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->setParameters(params);
-    return rv;
-}
-
-char* camera_get_parameters(struct camera_device * device)
-{
-    char* param = NULL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return NULL;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    param = gCameraHals[fsl_dev->cameraid]->getParameters();
-
-    return param;
-}
-
-static void camera_put_parameters(struct camera_device *device, char *parms)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->putParameters(parms);
-}
-
-int camera_send_command(struct camera_device * device,
-            int32_t cmd, int32_t arg1, int32_t arg2)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->sendCommand(cmd, arg1, arg2);
-    return rv;
-}
-
-void camera_release(struct camera_device * device)
-{
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    if(!device)
-        return;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    gCameraHals[fsl_dev->cameraid]->release();
-}
-
-int camera_dump(struct camera_device * device, int fd)
-{
-    int rv = -EINVAL;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    if(!device)
-        return rv;
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    rv = gCameraHals[fsl_dev->cameraid]->dump(fd);
-    return rv;
-}
-
-extern "C" void heaptracker_free_leaked_memory(void);
-
-int camera_device_close(hw_device_t* device)
-{
-    int ret = 0;
-    fsl_camera_device_t* fsl_dev = NULL;
-
-    ALOGV("%s", __FUNCTION__);
-
-    android::Mutex::Autolock lock(gCameraHalDeviceLock);
-
-    if (!device) {
-        ret = -EINVAL;
-        goto done;
-    }
-
-    fsl_dev = (fsl_camera_device_t*) device;
-
-    if (fsl_dev) {
-        if (gCameraHals[fsl_dev->cameraid]) {
-            delete gCameraHals[fsl_dev->cameraid];
-            gCameraHals[fsl_dev->cameraid] = NULL;
-            gCamerasOpen--;
-        }
-
-        if (fsl_dev->base.ops) {
-            free(fsl_dev->base.ops);
-        }
-        free(fsl_dev);
-    }
-done:
-#ifdef HEAPTRACKER
-    heaptracker_free_leaked_memory();
-#endif
-    return ret;
-}
-
-#define FACE_BACK_CAMERA_NAME "back_camera_name"
-#define FACE_FRONT_CAMERA_NAME "front_camera_name"
-#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
-#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
-#define DEFAULT_ERROR_NAME '0'
-#define DEFAULT_ERROR_NAME_str "0"
-#define UVC_NAME "uvc"
-static struct camera_info sCameraInfo[2];
-//gCameraName[0]  for back camera name
-//gCameraName[1]  for front camera name
-static char gCameraName[2][CAMERA_SENSOR_LENGTH];
-static char gCameraDevPath[2][CAMAERA_FILENAME_LENGTH];
-static int gCameraNum = 0;
-
-/*******************************************************************
- * implementation of camera_module functions
- *******************************************************************/
-
-/* open device handle to one of the cameras
- *
- * assume camera service will keep singleton of each camera
- * so this function will always only be called once per camera instance
- */
-
-int camera_device_open(const hw_module_t* module, const char* name,
-                hw_device_t** device)
-{
-    int rv = 0;
-    int num_cameras = 0;
-    int cameraid;
-    fsl_camera_device_t* camera_device = NULL;
-    camera_device_ops_t* camera_ops = NULL;
-    CameraHal* camera = NULL;
-    char *SelectedCameraName;
-    android::sp<android::CaptureDeviceInterface> pCaptureDevice = NULL;
-    android::sp<android::JpegEncoderInterface>pJpegEncoder = NULL;
-    //android::CameraProperties::Properties* properties = NULL;
-
-    android::Mutex::Autolock lock(gCameraHalDeviceLock);
-
-    ALOGI("camera_device open: %s", name);
-
-    if (name != NULL) {
-        cameraid = atoi(name);
-        num_cameras = camera_get_number_of_cameras();//gCameraProperties.camerasSupported();
-
-        if(cameraid > num_cameras)
-        {
-            ALOGE("camera service provided cameraid out of bounds, "
-                    "cameraid = %d, num supported = %d",
-                    cameraid, num_cameras);
-            rv = -EINVAL;
-            goto fail;
-        }
-#if 0
-        if(gCamerasOpen >= MAX_SIMUL_CAMERAS_SUPPORTED)
-        {
-            ALOGE("maximum number of cameras already open");
-            rv = -ENOMEM;
-            goto fail;
-        }
-#endif
-        camera_device = (fsl_camera_device_t*)malloc(sizeof(*camera_device));
-        if(!camera_device)
-        {
-            ALOGE("camera_device allocation fail");
-            rv = -ENOMEM;
-            goto fail;
-        }
-
-        camera_ops = (camera_device_ops_t*)malloc(sizeof(*camera_ops));
-        if(!camera_ops)
-        {
-            ALOGE("camera_ops allocation fail");
-            rv = -ENOMEM;
-            goto fail;
-        }
-
-        memset(camera_device, 0, sizeof(*camera_device));
-        memset(camera_ops, 0, sizeof(*camera_ops));
-
-        camera_device->base.common.tag = HARDWARE_DEVICE_TAG;
-        camera_device->base.common.version = 0;
-        camera_device->base.common.module = (hw_module_t *)(module);
-        camera_device->base.common.close = camera_device_close;
-        camera_device->base.ops = camera_ops;
-
-        camera_ops->set_preview_window = camera_set_preview_window;
-        camera_ops->set_callbacks = camera_set_callbacks;
-        camera_ops->enable_msg_type = camera_enable_msg_type;
-        camera_ops->disable_msg_type = camera_disable_msg_type;
-        camera_ops->msg_type_enabled = camera_msg_type_enabled;
-        camera_ops->start_preview = camera_start_preview;
-        camera_ops->stop_preview = camera_stop_preview;
-        camera_ops->preview_enabled = camera_preview_enabled;
-        camera_ops->store_meta_data_in_buffers = camera_store_meta_data_in_buffers;
-        camera_ops->start_recording = camera_start_recording;
-        camera_ops->stop_recording = camera_stop_recording;
-        camera_ops->recording_enabled = camera_recording_enabled;
-        camera_ops->release_recording_frame = camera_release_recording_frame;
-        camera_ops->auto_focus = camera_auto_focus;
-        camera_ops->cancel_auto_focus = camera_cancel_auto_focus;
-        camera_ops->take_picture = camera_take_picture;
-        camera_ops->cancel_picture = camera_cancel_picture;
-        camera_ops->set_parameters = camera_set_parameters;
-        camera_ops->get_parameters = camera_get_parameters;
-        camera_ops->put_parameters = camera_put_parameters;
-        camera_ops->send_command = camera_send_command;
-        camera_ops->release = camera_release;
-        camera_ops->dump = camera_dump;
-
-        *device = &camera_device->base.common;
-
-        camera_device->cameraid = cameraid;
-        SelectedCameraName = gCameraName[sCameraInfo[cameraid].facing];
-
-        pCaptureDevice = android::createCaptureDevice(SelectedCameraName,
-                gCameraDevPath[sCameraInfo[cameraid].facing]);
-        pJpegEncoder = android::createJpegEncoder(android::SOFTWARE_JPEG_ENC);
-
-        camera = new CameraHal(cameraid);
-
-        if(!camera)
-        {
-            ALOGE("Couldn't create instance of CameraHal class");
-            rv = -ENOMEM;
-            goto fail;
-        }
-
-        if (camera->setCaptureDevice(pCaptureDevice) < 0 ||
-                camera->setJpegEncoder(pJpegEncoder) < 0) {
-            rv = -EINVAL;
-            goto fail;
-        }
-
-        if (camera->Init() < 0) {
-            rv = -EINVAL;
-            goto fail;
-        }
-
-        gCameraHals[cameraid] = camera;
-        gCamerasOpen++;
-    }
-
-    return rv;
-
-fail:
-    if(camera_device) {
-        free(camera_device);
-        camera_device = NULL;
-    }
-    if(camera_ops) {
-        free(camera_ops);
-        camera_ops = NULL;
-    }
-    if(camera) {
-        delete camera;
-        camera = NULL;
-    }
-    *device = NULL;
-    return rv;
-}
-
-static int GetDevPath(const char *pCameraName, char *pCameraDevPath, unsigned int pathLen)
-{
-    int retCode = -1;
-    int fd = 0;
-    char   dev_node[CAMAERA_FILENAME_LENGTH];
-    DIR *v4l_dir = NULL;
-    struct dirent *dir_entry;
-    struct v4l2_capability v4l2_cap;
-    struct v4l2_dbg_chip_ident vid_chip;
-
-    v4l_dir = opendir("/sys/class/video4linux");
-    if (v4l_dir){
-        while((dir_entry = readdir(v4l_dir))) {
-            memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-            if(strncmp(dir_entry->d_name, "video", 5))
-                continue;
-            sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-            if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                continue;
-            if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                close(fd);
-                fd = 0;
-                continue;
-            } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
-                if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                    close(fd);
-                    fd = 0;
-                    continue;
-                }
-                if(strstr(vid_chip.match.name, pCameraName)){
-                    //fsl csi/mipi camera name and path match
-                    if(pathLen > strlen(dev_node)) {
-                        strcpy(pCameraDevPath, dev_node);
-                        ALOGI("Get sensor %s's dev path %s", pCameraName, pCameraDevPath);
-                        retCode = 0;
-                    }
-                    close(fd);
-                    fd = 0;
-                    break;
-                }
-            }
-            close(fd);
-            fd = 0;
-        }
-        closedir(v4l_dir);
-    }
-
-    return retCode;
-}
-
-static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
-{
-    char orientStr[10];
-
-    property_get (FACE_BACK_CAMERA_NAME, pFaceBackCameraName, DEFAULT_ERROR_NAME_str );
-    property_get (FACE_BACK_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
-
-    if (orientStr[0] == DEFAULT_ERROR_NAME )
-        *pFaceBackOrient = 0;
-    else
-        *pFaceBackOrient = atoi(orientStr);
-
-    ALOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
-
-    property_get(FACE_FRONT_CAMERA_NAME, pFaceFrontCameraName, DEFAULT_ERROR_NAME_str );
-
-    property_get(FACE_FRONT_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
-
-
-    if (orientStr[0] == DEFAULT_ERROR_NAME )
-        *pFaceFrontOrient = 0;
-    else
-        *pFaceFrontOrient = atoi(orientStr);
-
-    ALOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
-}
-
-int camera_get_number_of_cameras()
-{
-    int back_orient =0,  front_orient = 0;
-    if(gCameraNum == 0) {
-        GetCameraPropery(gCameraName[0], gCameraName[1], &back_orient, &front_orient);
-        if (gCameraName[0][0] != DEFAULT_ERROR_NAME){
-            sCameraInfo[gCameraNum].facing = CAMERA_FACING_BACK;
-            sCameraInfo[gCameraNum].orientation = back_orient;
-            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
-            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
-            gCameraNum++;
-        }
-        if (gCameraName[1][0] != DEFAULT_ERROR_NAME){
-            sCameraInfo[gCameraNum].facing = CAMERA_FACING_FRONT;
-            sCameraInfo[gCameraNum].orientation = front_orient;
-            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
-            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
-            gCameraNum++;
-        }
-    }
-    return gCameraNum;
-
-}
-
-int camera_get_camera_info(int cameraId, struct camera_info* cameraInfo)
-{
-    memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(camera_info));
-    return 0;
-}
-
diff --git a/mx5x/libcamera/Camera_pmem.cpp b/mx5x/libcamera/Camera_pmem.cpp
deleted file mode 100755
index 865b352..0000000
--- a/mx5x/libcamera/Camera_pmem.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <semaphore.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <linux/android_pmem.h>
-#include "Camera_pmem.h"
-
-
-/*
- *   input parameter: 
- */
-
-using namespace android;
-
-PmemAllocator::PmemAllocator(int bufCount, int bufSize):
-    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
-    mVirBase(NULL),mPhyBase(NULL)
-{
-
-    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
-
-    int err;
-    struct pmem_region region;
-    mFD = open(PMEM_DEV, O_RDWR);
-    if (mFD < 0) {
-        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
-    if (err == 0)
-    {
-        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
-    }
-    else
-    {
-        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
-
-    mTotalSize = mBufSize*bufCount;
-    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
-        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
-    }
-    else
-    {
-        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
-                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
-
-        if (virtualbase == MAP_FAILED) {
-            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
-                    mFD, (unsigned int)mTotalSize, strerror(errno));
-            return;
-        }
-
-        memset(&region, 0, sizeof(region));
-
-        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
-        {
-            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
-            munmap(virtualbase, mTotalSize);
-            return;
-        }
-        mVirBase = (void *)virtualbase;
-        mPhyBase = region.offset;
-        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
-    }
-}
-
-PmemAllocator::~PmemAllocator()
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
-        }
-    }
-
-    if(mVirBase) {
-        munmap(mVirBase, mTotalSize);
-    }
-    if(mFD) {
-        close(mFD);
-    }
-
-}
-
-int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(!mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
-                    index,mBufSize,size);
-
-            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
-            pbuf->phy_offset= mPhyBase+index*mBufSize;
-            pbuf->length= mBufSize;
-            mSlotAllocated[index] = true;
-            return DMA_ALLOCATE_ERR_NONE;
-        }
-    }
-    return DMA_ALLOCATE_ERR_BAD_PARAM;
-}
-
-int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
-{
-    CAMERA_HAL_LOG_FUNC;
-    if((!mVirBase)||(!pbuf)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
-    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
-        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
-        mSlotAllocated[nSlot] = false;
-        return DMA_ALLOCATE_ERR_NONE;
-    }
-    else{
-        CAMERA_HAL_ERR("Error!Not a valid buffer");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-}
diff --git a/mx5x/libcamera/Camera_pmem.h b/mx5x/libcamera/Camera_pmem.h
deleted file mode 100755
index 8b174a4..0000000
--- a/mx5x/libcamera/Camera_pmem.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef __CAMERA_MEM__H__
-#define __CAMERA_MEM__H__
-
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-
-#define DEFAULT_PMEM_ALIGN (4096)
-#define PMEM_DEV "/dev/pmem_adsp"
-#define MAX_SLOT 64
-
-namespace android {
-
-class PmemAllocator : public virtual RefBase
-{
-public:
-    PmemAllocator(int bufCount,int bufSize);
-    virtual ~PmemAllocator();
-    virtual int allocate(DMA_BUFFER *p_buf, int size);
-    virtual int deAllocate(DMA_BUFFER *p_buf);
-	int err_ret;
-private:
-    int mFD;
-    unsigned long mTotalSize;
-    int mBufCount;
-    int mBufSize;
-    void *mVirBase;
-    unsigned int mPhyBase;
-    bool mSlotAllocated[MAX_SLOT];
-	
-};
-};
-
-#endif
diff --git a/mx5x/libcamera/Camera_utils.h b/mx5x/libcamera/Camera_utils.h
deleted file mode 100755
index c1d1c45..0000000
--- a/mx5x/libcamera/Camera_utils.h
+++ /dev/null
@@ -1,78 +0,0 @@
-
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAMERA_UTILS_H
-#define CAMERA_UTILS_H
-
-#undef LOG_TAG
-#define LOG_TAG "FslCameraHAL"
-#include <utils/Log.h>
-#include <utils/threads.h>
-
-//#define CAMERA_HAL_DEBUG_LOG
-#ifdef CAMERA_HAL_DEBUG_LOG
-#define CAMERA_LOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define CAMERA_LOG_FUNC ALOGI("%s is excuting...",  __FUNCTION__)
-#define CAMERA_LOG_TRACE   ALOGI("%s : %d", __FUNCTION__,__LINE__)
-#else
-#define CAMERA_LOG_RUNTIME(format, ...)
-#define CAMERA_LOG_FUNC
-#define CAMERA_LOG_TRACE
-#endif
-
-#define CAMERA_LOG_INFO(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define CAMERA_LOG_WARN(format, ...) ALOGW((format), ## __VA_ARGS__)
-#define CAMERA_LOG_ERR(format, ...) ALOGE((format), ##__VA_ARGS__)
-
-namespace android {
-
-    typedef enum{
-        DMA_ALLOCATE_ERR_NONE = 0,
-        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
-
-    }DMA_ALLOCATE_ERR_RET;
-
-    typedef enum{
-        WINDOW_BUFS_INVALID = 0,
-        WINDOW_BUFS_DEQUEUED = 1,
-        WINDOW_BUFS_QUEUED = 2,
-    }WINDOW_BUFS_STATE;
-
-    typedef struct {
-        unsigned char *virt_start;
-        size_t phy_offset;
-        unsigned int length;
-        void *native_buf;
-        Mutex mBufferLock;
-        unsigned int refCount;
-        WINDOW_BUFS_STATE buf_state;
-    }DMA_BUFFER;
-
-	// If struct change. Need info Camera Source.
-    typedef struct {
-        size_t phy_offset;
-        unsigned int length;
-    }VIDEOFRAME_BUFFER_PHY;
-
-}; //name space android
-
-#endif
-
diff --git a/mx5x/libcamera/CaptureDeviceInterface.cpp b/mx5x/libcamera/CaptureDeviceInterface.cpp
deleted file mode 100755
index 6f8c90a..0000000
--- a/mx5x/libcamera/CaptureDeviceInterface.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "V4l2UVCDevice.h"
-#include "V4l2CsiDevice.h"
-namespace android{
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath)
-    {
-        if(strstr(deviceName, UVC_NAME_STRING)){
-            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
-            device->SetDevName(deviceName, devPath);
-            return device;
-        }else{
-            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
-            device->SetDevName(deviceName, devPath);
-            return device;
-        }
-    }
-
-
-}
diff --git a/mx5x/libcamera/CaptureDeviceInterface.h b/mx5x/libcamera/CaptureDeviceInterface.h
deleted file mode 100755
index dddb38f..0000000
--- a/mx5x/libcamera/CaptureDeviceInterface.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAPTURE_DEVICE_INTERFACE_H
-#define CAPTURE_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-
-
-#define CAMAERA_FILENAME_LENGTH     256
-#define MAX_CAPTURE_BUF_QUE_NUM     6
-#define CAMERA_SENSOR_LENGTH       32
-#define MAX_DEQUEUE_WAIT_TIME  (5000)  //5000ms for uvc camera
-
-namespace android {
-#define UVC_NAME_STRING "uvc"
-
-    typedef enum{
-        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
-        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
-        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
-        CAPTURE_DEVICE_ERR_NONE = 0,
-        CAPTURE_DEVICE_ERR_OPEN = -1,
-        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
-        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
-        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
-        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
-        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
-        CAPTURE_DEVICE_ERR_OPT_TIMEOUT=-7,
-        CAPTURE_DEVICE_ERR_UNKNOWN = -100
-    }CAPTURE_DEVICE_RET;
-
-    typedef enum{
-        MOTION_MODE = 0,
-        HIGH_QUALITY_MODE = 1
-    }CAPTURE_MODE;
-
-    typedef enum{
-        CAMERA_TYPE_CSI = 0,
-        CAMERA_TYPE_UVC = 1,
-    }CAMERA_TYPE;
-
-    typedef enum{
-        OUTPU_FMT = 0,
-        FRAME_SIZE_FPS = 1
-    }DevParamType;
-
-	typedef enum{
-        SENSOR_PREVIEW_BACK_REF = 0,
-        SENSOR_PREVIEW_VERT_FLIP = 1,
-        SENSOR_PREVIEW_HORIZ_FLIP = 2,
-        SENSOR_PREVIEW_ROATE_180 = 3,
-        SENSOR_PREVIEW_ROATE_LAST = 3,
-        SENSOR_PREVIEW_ROATE_INVALID =4
-	}SENSOR_PREVIEW_ROTATE;
-
-    struct timeval_fract{
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct capture_config_t{
-        unsigned int fmt;
-        unsigned int width;
-        unsigned int height;
-        unsigned int framesize;   //out
-        unsigned int picture_waite_number;//out
-        struct timeval_fract tv;
-	SENSOR_PREVIEW_ROTATE rotate;
-    };
-
-
-    class CaptureDeviceInterface : public virtual RefBase{
-    public:
-
-        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char * devPath = NULL)=0;
-        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId)=0;
-        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
-        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
-        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_RET DevPrepare()=0;
-        virtual CAPTURE_DEVICE_RET DevStart()=0;
-        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx)=0;
-        virtual CAPTURE_DEVICE_RET DevQueue(unsigned int BufQueIdx)=0;
-        virtual CAPTURE_DEVICE_RET DevStop()=0;
-        virtual CAPTURE_DEVICE_RET DevDeAllocate()=0;
-        virtual CAPTURE_DEVICE_RET DevClose()=0;
-        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType)=0;
-
-        virtual ~ CaptureDeviceInterface(){}
-    };
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath);
-
-};
-#endif
-
diff --git a/mx5x/libcamera/JpegEncoderInterface.cpp b/mx5x/libcamera/JpegEncoderInterface.cpp
deleted file mode 100755
index 65ac721..0000000
--- a/mx5x/libcamera/JpegEncoderInterface.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "JpegEncoderSoftware.h"
-namespace android{
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
-    {
-        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
-            CAMERA_LOG_INFO("Create the software encoder");
-            return JpegEncoderSoftware::createInstance();
-        }
-        else{
-            CAMERA_LOG_ERR("the hardware encoder is not supported");
-            return NULL;
-        }
-    }
-};
diff --git a/mx5x/libcamera/JpegEncoderInterface.h b/mx5x/libcamera/JpegEncoderInterface.h
deleted file mode 100755
index 3f1a857..0000000
--- a/mx5x/libcamera/JpegEncoderInterface.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef JPEG_ENCODER_INTERFACE_H
-#define JPEG_ENCODER_INTERFACE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-namespace android{
-
-
-#define MAX_JPEG_MAKE_BYTES 256
-#define MAX_JPEG_MAKERNOTE_BYTES 256
-#define MAX_JPEG_MODEL_BYTES 256
-#define TIME_FMT_LENGTH 20
-#define MAX_GPS_PROCESSING_BYTES	256
-
-    typedef enum{
-    ORIENTATION_UNDEFINED = 0,
-    ORIENTATION_NORMAL = 1,
-    ORIENTATION_FLIP_HORIZONTAL = 2,
-    ORIENTATION_ROTATE_180 = 3,
-    ORIENTATION_FLIP_VERTICAL = 4,
-    ORIENTATION_TRANSPOSE = 5,
-    ORIENTATION_ROTATE_90 = 6,
-    ORIENTATION_TRANSVERSE = 7,
-    ORIENTATION_ROTATE_270 = 8
-    }JPEG_ENCODER_ROTATION;
-
-    typedef enum{
-    WHITEBALANCE_AUTO = 0,
-    WHITEBALANCE_MANUAL = 1
-    }JPEG_ENCODER_WHITEBALANCE;
-
-    typedef enum{
-    FLASH_NOT_FIRE = 0x00,
-    FLASH_FIRED    = 0x01,
-    FLASH_FIRED_AUTO = 0x19,
-    FLASH_FIRED_RED_EYE_REDUCE = 0x41,
-    FLASH_FIRED_COMPULOSORY = 0x09
-    }JPEG_ENCODER_FLASH;
-
-    typedef enum{
-        SOFTWARE_JPEG_ENC = 0,
-        HARDWARE_JPEG_ENC = 1
-    }JPEG_ENCODER_TYPE;
-
-    typedef enum{
-        JPEG_ENC_ERROR_NONE = 0,
-        JPEG_ENC_ERROR_BAD_PARAM = -1,
-        JPEG_ENC_ERROR_ALOC_BUF = -2
-    }JPEG_ENC_ERR_RET;
-
-
-    typedef enum{
-        SUPPORTED_FMT = 0,
-    }JPEEG_QUERY_TYPE;
-
-    struct jpeg_enc_focallength_t
-    {
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct jpeg_enc_make_info_t
-    {
-        unsigned char make_bytes;
-        unsigned char make[MAX_JPEG_MAKE_BYTES];
-    };
-    struct jpeg_enc_makernote_info_t
-    {
-        unsigned char makernote_bytes;
-        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
-    };
-
-    struct jpeg_enc_model_info_t
-    {
-        unsigned char model_bytes;
-        unsigned char model[MAX_JPEG_MODEL_BYTES];	
-    };
-
-    struct jpeg_enc_datetime_info_t
-    {
-        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
-    };
-
-    struct jpeg_enc_gps_param{
-        unsigned int version;//GPSVersionID
-        char latitude_ref[2];//GPSLatitudeRef: "N " is positive; "S " is negative
-        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
-        unsigned int latitude_degree[2];//GPSLatitude
-        unsigned int latitude_minute[2];
-        unsigned int latitude_second[2];
-        unsigned int longtitude_degree[2];//GPSLongitude
-        unsigned int longtitude_minute[2];
-        unsigned int longtitude_second[2];
-        char altitude_ref;//GPSAltitudeRef: 0 or 1(negative)
-        unsigned int altitude[2];//GPSAltitude: unit is meters
-        unsigned int hour[2];//GPSTimeStamp
-        unsigned int minute[2];
-        unsigned int seconds[2];
-        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
-        char processmethod_bytes;
-        char datestamp[11];//GPSDateStamp: "YYYY:MM:DD "
-    };
-
-    typedef struct{
-        unsigned int PicWidth;
-        unsigned int PicHeight;
-        unsigned int ThumbWidth;
-        unsigned int ThumbHeight;
-        unsigned int BufFmt;
-        JPEG_ENCODER_ROTATION RotationInfo;
-        JPEG_ENCODER_WHITEBALANCE WhiteBalanceInfo;
-        JPEG_ENCODER_FLASH FlashInfo;
-        struct jpeg_enc_focallength_t *pFoclLength;
-        struct jpeg_enc_make_info_t *pMakeInfo;
-        struct jpeg_enc_makernote_info_t *pMakeNote;
-        struct jpeg_enc_model_info_t *pModelInfo;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
-        struct jpeg_enc_gps_param *pGps_info;
-    }enc_cfg_param;
-
-    struct jpeg_encoding_conf{
-        unsigned int output_jpeg_size;
-    };
-
-    class JpegEncoderInterface : public virtual RefBase{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
-
-        virtual ~ JpegEncoderInterface(){}
-    }; 
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
-
-};
-
-#endif
diff --git a/mx5x/libcamera/JpegEncoderSoftware.cpp b/mx5x/libcamera/JpegEncoderSoftware.cpp
deleted file mode 100755
index 49868d7..0000000
--- a/mx5x/libcamera/JpegEncoderSoftware.cpp
+++ /dev/null
@@ -1,662 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "JpegEncoderSoftware.h"
-
-namespace android{
-
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
-    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
-
-    JpegEncoderSoftware :: JpegEncoderSoftware()
-        :mSupportedTypeIdx(0),
-        pEncCfgLocal(NULL),
-        pEncObj(NULL)
-    {
-        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
-        mSupportedType[1] = v4l2_fourcc('Y','U','Y','V');
-    }
-
-    JpegEncoderSoftware :: ~JpegEncoderSoftware()
-    {
-
-    }
-
-    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
-    {
-
-        int * pSupportedType = (int *)pQueryRet;
-        switch(QueryType){
-            case SUPPORTED_FMT:
-                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
-                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
-                    mSupportedTypeIdx ++;
-                }else{
-                    mSupportedTypeIdx = 0;
-                    return JPEG_ENC_ERROR_BAD_PARAM;
-                }
-                break;
-            default:
-                return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        return JPEG_ENC_ERROR_NONE;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
-    {
-        CAMERA_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        struct jpeg_enc_focallength_t * pFoclLength = NULL;
-        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
-        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
-        struct jpeg_enc_model_info_t *pModelInfo = NULL;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
-        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
-
-        if(pEncCfg == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
-
-        if (pEncCfgLocal == NULL){
-            CAMERA_LOG_ERR("Allocat buffer for EncCfg failed");
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-
-        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
-        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
-
-
-        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
-            goto INT_ERR_RET;
-        }
-
-        if (pEncCfg->pFoclLength != NULL){
-            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
-
-            if (pFoclLength == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pFoclLength failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
-            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
-            pEncCfgLocal->pFoclLength = pFoclLength;
-        }
-
-
-        if (pEncCfg->pMakeInfo != NULL){
-            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
-
-            if (pMakeInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pMakeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
-            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
-            pEncCfgLocal->pMakeInfo = pMakeInfo;
-        }
-
-        if (pEncCfg->pMakeNote != NULL){
-            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
-
-            if (pMakeNote == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pMakeNote failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
-            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
-            pEncCfgLocal->pMakeNote = pMakeNote;
-        }
-
-        if (pEncCfg->pModelInfo != NULL){
-            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
-
-            if (pModelInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pModelInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
-            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
-            pEncCfgLocal->pModelInfo = pModelInfo;
-        }
-
-        if (pEncCfg->pDatetimeInfo != NULL){
-            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
-
-            if (pDatetimeInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pDatetimeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
-            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
-            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
-        }
-
-        if (pEncCfg->pGps_info != NULL){
-            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
-
-            if (pGpsInfoLocal == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pGpsInfoLocal failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
-            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
-            pEncCfgLocal->pGps_info = pGpsInfoLocal;
-        }
-
-        return ret;
-
-INT_ERR_RET:
-        if(pEncCfgLocal)
-            free(pEncCfgLocal);
-        if(pFoclLength)
-            free(pFoclLength);
-        if(pMakeInfo)
-            free(pMakeInfo);
-        if(pMakeNote)
-            free(pMakeNote);
-        if(pModelInfo)
-            free(pModelInfo);
-        if(pDatetimeInfo)
-            free(pDatetimeInfo);
-        if(pGpsInfoLocal)
-            free(pGpsInfoLocal);
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
-        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }else{
-            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
-        }
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
-        CAMERA_LOG_FUNC;
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if (pEncCfgLocal != NULL ){
-            if (pEncCfgLocal->pFoclLength != NULL)
-                free(pEncCfgLocal->pFoclLength);
-            if (pEncCfgLocal->pMakeInfo != NULL)
-                free(pEncCfgLocal->pMakeInfo);
-            if (pEncCfgLocal->pMakeNote != NULL)
-                free(pEncCfgLocal->pMakeNote);
-            if (pEncCfgLocal->pModelInfo != NULL)
-                free(pEncCfgLocal->pModelInfo);
-            if (pEncCfgLocal->pDatetimeInfo != NULL)
-                free(pEncCfgLocal->pDatetimeInfo);
-            if (pEncCfgLocal->pGps_info != NULL)
-                free(pEncCfgLocal->pGps_info);
-            free(pEncCfgLocal);
-        }
-
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
-
-        CAMERA_LOG_FUNC;
-        int i = 0;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
-            CAMERA_LOG_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)||
-                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
-                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
-            CAMERA_LOG_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
-            if(pEncCfgLocal->BufFmt == mSupportedType[i])
-                break;
-        }
-
-        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
-            ret = JPEG_ENC_ERROR_BAD_PARAM;
-
-        return ret;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
-
-        CAMERA_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        int width, height, size,index;
-        JPEG_ENC_UINT8 * i_buff = NULL;
-        JPEG_ENC_UINT8 * y_buff = NULL;
-        JPEG_ENC_UINT8 * u_buff = NULL;
-        JPEG_ENC_UINT8 * v_buff = NULL;
-        JPEG_ENC_RET_TYPE return_val;
-        jpeg_enc_parameters * params = NULL;
-        jpeg_enc_object * obj_ptr = NULL;
-        JPEG_ENC_UINT8 number_mem_info;
-        jpeg_enc_memory_info * mem_info = NULL;
-        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
-        int thumbnail_width, thumbnail_height;
-        unsigned char *buffer = inBuf->virt_start;
-
-        bool mEncodeThumbnailFlag = true;
-
-        width = pEncCfgLocal->PicWidth;
-        height = pEncCfgLocal->PicHeight;
-
-        thumbnail_width = pEncCfgLocal->ThumbWidth;
-        thumbnail_height = pEncCfgLocal->ThumbHeight;
-
-
-        if (thumbnail_width <= 0 || thumbnail_height<= 0)
-            mEncodeThumbnailFlag = false;
-
-        g_JpegDataSize = 0;//Total size of g_JpegData
-        g_JpegDataLen = 0;//Valid data len of g_JpegData
-        g_JpegData = NULL;//Buffer to hold jpeg data
-        size = width * height * 3 / 2;
-
-        g_JpegData = outBuf->virt_start;
-        g_JpegDataSize = size;
-        if(!g_JpegData)
-        {
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        /* --------------------------------------------
-         * Allocate memory for Encoder Object
-         * -------------------------------------------*/
-        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
-        if(!obj_ptr)
-        {
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
-
-        /* Assign the function for streaming output */
-        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
-        obj_ptr->context=NULL;   //user can put private variables into it
-        /* --------------------------------------------
-         * Fill up the parameter structure of JPEG Encoder
-         * -------------------------------------------*/
-        params = &(obj_ptr->parameters);
-
-        if(mEncodeThumbnailFlag==true)
-        {
-
-            //need resizing code here!!!
-            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
-            if(!thumbnail_buffer)
-            {
-                return JPEG_ENC_ERROR_ALOC_BUF;
-            }
-
-            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
-
-            width = thumbnail_width;
-            height = thumbnail_height;
-
-            temp_buffer = buffer;
-            buffer = thumbnail_buffer;
-
-            params->mode = JPEG_ENC_THUMB;
-        }
-        else
-        {
-            params->mode = JPEG_ENC_MAIN_ONLY;
-        }
-
-encodeframe:
-
-        params->compression_method = JPEG_ENC_SEQUENTIAL;
-        params->quality = 75;
-        params->restart_markers = 0;
-        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height/2;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height/2;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
-        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
-        }
-        params->exif_flag = 1;
-
-        params->y_left = 0;
-        params->y_top = 0;
-        params->y_total_width = 0;
-        params->y_total_height = 0;
-        params->raw_dat_flag= 0;
-
-        if(params->y_total_width==0)
-        {
-            params->y_left=0;
-            params->u_left=0;
-            params->v_left=0;
-            params->y_total_width=params->y_width;  // no cropping
-            params->u_total_width=params->u_width;  // no cropping
-            params->v_total_width=params->v_width;  // no cropping
-        }
-
-        if(params->y_total_height==0)
-        {
-            params->y_top=0;
-            params->u_top=0;
-            params->v_top=0;
-            params->y_total_height=params->y_height; // no cropping
-            params->u_total_height=params->u_height; // no cropping
-            params->v_total_height=params->v_height; // no cropping
-        }
-
-        /* Pixel size is unknown by default */
-        params->jfif_params.density_unit = 0;
-        /* Pixel aspect ratio is square by default */
-        params->jfif_params.X_density = 1;
-        params->jfif_params.Y_density = 1;
-        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
-            y_buff = (JPEG_ENC_UINT8 *)buffer;
-            u_buff = y_buff+width*height;
-            v_buff = u_buff+width*height/4;
-            i_buff = NULL;
-        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
-            y_buff = NULL;
-            u_buff = NULL;
-            v_buff = NULL;
-            i_buff = (JPEG_ENC_UINT8 *)buffer;
-        }
-        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        /* --------------------------------------------
-         * QUERY MEMORY REQUIREMENTS
-         * -------------------------------------------*/
-        return_val = jpeg_enc_query_mem_req(obj_ptr);
-
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-        CAMERA_LOG_RUNTIME("jpeg_enc_query_mem_req success");
-        /* --------------------------------------------
-         * ALLOCATE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            /* This example code ignores the 'alignment' and
-             * 'memory_type', but some other applications might want
-             * to allocate memory based on them */
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            mem_info->memptr = (void *) malloc(mem_info->size);
-            if(mem_info->memptr==NULL) {
-                CAMERA_LOG_RUNTIME("Malloc error after query\n");
-                goto done;
-            }
-        }
-
-        return_val = jpeg_enc_init(obj_ptr);
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        CAMERA_LOG_RUNTIME("jpeg_enc_init success");
-        if(params->mode == JPEG_ENC_THUMB)
-            createJpegExifTags(obj_ptr);
-
-        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
-                y_buff, u_buff, v_buff);
-
-        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        if(params->mode == JPEG_ENC_THUMB)
-        {
-            JPEG_ENC_UINT8 num_entries;
-            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
-            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
-
-            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
-
-            for(int i = 0; i < num_entries; i++)
-            {
-                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
-            }
-
-            free(offset_tbl_ptr);
-            free(value_tbl_ptr);
-
-            free(buffer);
-
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-
-            g_JpegData += g_JpegDataLen;
-            g_JpegDataSize -= g_JpegDataLen;
-
-
-            //recover to build the main jpeg
-            params->mode = JPEG_ENC_MAIN;
-
-            buffer = temp_buffer;
-            width = pEncCfgLocal->PicWidth;
-            height = pEncCfgLocal->PicHeight;
-
-            goto encodeframe;
-        }
-        CAMERA_LOG_RUNTIME("jpeg_enc_encodeframe success");
-        // Make an IMemory for each frame
-        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
-        *pEncSize = g_JpegDataLen;
-
-done:
-        /* --------------------------------------------
-         * FREE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        if(obj_ptr)
-        {
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-            free(obj_ptr);
-        }
-
-        return ret;
-    }
-
-    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
-            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
-    {
-        JPEG_ENC_UINT32 i;
-        if(*out_buf_ptrptr == NULL)
-        {
-            /* This function is called for the 1'st time from the
-             * codec */
-            *out_buf_ptrptr = g_JpegData;
-            *out_buf_len_ptr = g_JpegDataSize;
-        }
-
-        else if(flush == 1)
-        {
-            /* Flush the buffer*/
-            g_JpegDataLen += *out_buf_len_ptr;
-            CAMERA_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
-
-            *out_buf_ptrptr = NULL;
-            *out_buf_len_ptr = 0;
-        }
-        else
-        {
-            CAMERA_LOG_RUNTIME("Not enough buffer for encoding");
-            return 0;
-        }
-
-        return(1); /* Success */
-    }
-
-    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
-    {
-        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FLASH, (unsigned int)(&(pEncCfgLocal->FlashInfo)));
-
-        if(pEncCfgLocal->pMakeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
-        if(pEncCfgLocal->pMakeNote)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
-        if(pEncCfgLocal->pModelInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
-        if(pEncCfgLocal->pDatetimeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
-        if(pEncCfgLocal->pFoclLength)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
-
-        if (pEncCfgLocal->pGps_info)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
-
-        return;
-    }
-
-    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
-    {
-        int i,j,s;
-        int h_offset;
-        int v_offset;
-        unsigned char *ptr,cc;
-        int h_scale_ratio;
-        int v_scale_ratio;
-
-        s = 0;
-
-_resize_begin:
-
-        if(!dst_width) return -1;
-        if(!dst_height) return -1;
-
-        h_scale_ratio = src_width / dst_width;
-        if(!h_scale_ratio) return -1;
-
-        v_scale_ratio = src_height / dst_height;
-        if(!v_scale_ratio) return -1;
-
-        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
-        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
-
-        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
-        {
-            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
-            {
-                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
-                cc = ptr[0];
-
-                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
-                ptr[0] = cc;
-            }
-        }
-
-        src_ptr += src_width*src_height;
-        dst_ptr += dst_width*dst_height;
-
-        if(s < 2)
-        {
-            if(!s++)
-            {
-                src_width >>= 1;
-                src_height >>= 1;
-
-                dst_width >>= 1;
-                dst_height >>= 1;
-            }
-
-            goto _resize_begin;
-        }
-
-        return 0;
-    }
-
-    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
-        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
-        return hardware;
-    }
-
-
-};
diff --git a/mx5x/libcamera/JpegEncoderSoftware.h b/mx5x/libcamera/JpegEncoderSoftware.h
deleted file mode 100755
index 7e22dff..0000000
--- a/mx5x/libcamera/JpegEncoderSoftware.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef JPEG_ENCODER_SOFTWARE_H
-#define JPEG_ENCODER_SOFTWARE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-
-#include "JpegEncoderInterface.h"
-#include "jpeg_enc_interface.h"
-
-
-namespace android{
-#define MAX_ENC_SUPPORTED_YUV_TYPE  2
-
-    class JpegEncoderSoftware : public JpegEncoderInterface{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
-
-        static sp<JpegEncoderInterface>createInstance();
-    private:
-
-        JpegEncoderSoftware();
-        virtual ~JpegEncoderSoftware();
-
-        virtual JPEG_ENC_ERR_RET CheckEncParm();
-        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
-
-
-        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
-                JPEG_ENC_UINT32 *out_buf_len_ptr,
-                JPEG_ENC_UINT8 flush,
-                void * context,
-                JPEG_ENC_MODE enc_mode);
-        void createJpegExifTags(jpeg_enc_object * obj_ptr);
-        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
-
-
-        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
-        unsigned int mSupportedTypeIdx;
-        enc_cfg_param *pEncCfgLocal;
-        jpeg_enc_object *pEncObj;
-
-
-        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
-        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
-        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
-
-    };
-};
-
-#endif
diff --git a/mx5x/libcamera/PP_ipulib.cpp b/mx5x/libcamera/PP_ipulib.cpp
deleted file mode 100755
index 07e72a4..0000000
--- a/mx5x/libcamera/PP_ipulib.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "PP_ipulib.h"
-#include <stdlib.h>
-#include <string.h>
-
-namespace android{
-
-    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
-
-    PPIpuLib :: PPIpuLib(){
-        return;
-    }
-
-    PPIpuLib :: ~PPIpuLib(){
-
-        singleton.clear();
-    }
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-        //Setting input format
-        mIPUInputParam.width = pp_input->width;
-        mIPUInputParam.height = pp_input->height;
-
-        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
-        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
-        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
-        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
-        mIPUInputParam.fmt = pp_input->fmt;
-        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
-
-        //Setting output format
-        mIPUOutputParam.fmt = pp_output->fmt;
-        mIPUOutputParam.width = pp_output->width;
-        mIPUOutputParam.height = pp_output->height;   
-        mIPUOutputParam.show_to_fb = 0;
-        //Output param should be same as input, since no resize,crop
-        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
-        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
-        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
-        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
-        mIPUOutputParam.rot = pp_output->rot;
-        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
-        CAMERA_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                mIPUOutputParam.width,
-                mIPUOutputParam.height,
-                mIPUOutputParam.output_win.pos.x,
-                mIPUOutputParam.output_win.pos.y,
-                mIPUOutputParam.output_win.win_w,
-                mIPUOutputParam.output_win.win_h,
-                mIPUOutputParam.rot);
-
-        CAMERA_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                mIPUInputParam.width,
-                mIPUInputParam.height,
-                mIPUInputParam.fmt,
-                mIPUInputParam.input_crop_win.pos.x,
-                mIPUInputParam.input_crop_win.pos.y,
-                mIPUInputParam.input_crop_win.win_w,
-                mIPUInputParam.input_crop_win.win_h);	  
-
-        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-        if (mIPURet < 0) {
-            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
-            return PPDEVICE_ERROR_INIT;
-        }  
-
-        return ret;
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
-
-        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
-
-        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset, 0,NULL,NULL);
-        if (mIPURet < 0) {
-            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
-            mxc_ipu_lib_task_uninit(&mIPUHandle);
-            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-            return PPDEVICE_ERROR_PROCESS;
-        }
-
-        return ret;
-
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        mxc_ipu_lib_task_uninit(&mIPUHandle);
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-
-        return ret;
-    }
-
-    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
-        CAMERA_LOG_FUNC;
-        if (singleton != 0) {
-            sp<PostProcessDeviceInterface> device = singleton.promote();
-            if (device != 0) {
-                return device;
-            }
-        }
-        sp<PostProcessDeviceInterface> device(new PPIpuLib());
-
-        singleton = device;
-        return device;
-    }
-
-};
diff --git a/mx5x/libcamera/PP_ipulib.h b/mx5x/libcamera/PP_ipulib.h
deleted file mode 100755
index ee5fe03..0000000
--- a/mx5x/libcamera/PP_ipulib.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef PP_IPU_LIB_H
-#define PP_IPU_LIB_H
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-#include "PostProcessDeviceInterface.h"
-
-namespace android{
-    class PPIpuLib : public PostProcessDeviceInterface
-    {
-    public:
-        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
-        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
-        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
-        static sp<PostProcessDeviceInterface> createInstance();
-    private:
-        PPIpuLib();
-        virtual ~PPIpuLib();
-        static wp<PostProcessDeviceInterface> singleton;
-
-        ipu_lib_input_param_t mIPUInputParam;	
-        ipu_lib_output_param_t mIPUOutputParam; 
-        ipu_lib_handle_t			mIPUHandle;
-    };
-};
-#endif
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.cpp b/mx5x/libcamera/PostProcessDeviceInterface.cpp
deleted file mode 100755
index 0b33c6d..0000000
--- a/mx5x/libcamera/PostProcessDeviceInterface.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "PP_ipulib.h" 
-namespace android{
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
-        return PPIpuLib :: createInstance();
-    }
-
-};
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.h b/mx5x/libcamera/PostProcessDeviceInterface.h
deleted file mode 100755
index d7cf58a..0000000
--- a/mx5x/libcamera/PostProcessDeviceInterface.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef POSTPROCESS_DEVICE_INTERFACE_H
-#define POSTPROCESS_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-#include <linux/videodev2.h>
-
-namespace android {
-
-    typedef enum{
-        PPDEVICE_ERROR_NONE = 0,
-        PPDEVICE_ERROR_INIT = -1,
-        PPDEVICE_ERROR_PROCESS  = -2,
-        PPDEVICE_ERROR_DEINIT = -3
-    }PPDEVICE_ERR_RET;
-
-    struct pp_fb_pos{
-        unsigned short x;
-        unsigned short y;
-    };
-
-    struct win_t{
-        struct pp_fb_pos pos;
-        unsigned int win_w;
-        unsigned int win_h;
-    } ;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        struct win_t input_crop_win;
-        int user_def_paddr;
-    } pp_input_param_t;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        unsigned int rot;
-        struct win_t output_win;
-        int user_def_paddr;
-    } pp_output_param_t;
-
-
-    class PostProcessDeviceInterface : public virtual RefBase{
-    public:
-        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
-        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
-        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
-
-        virtual ~PostProcessDeviceInterface(){}
-    }; 
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
-
-};
-#endif
-
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.cpp b/mx5x/libcamera/V4l2CapDeviceBase.cpp
deleted file mode 100755
index 77d82dd..0000000
--- a/mx5x/libcamera/V4l2CapDeviceBase.cpp
+++ /dev/null
@@ -1,715 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2013 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CapDeviceBase.h"
-
-
-
-
-namespace android{
-
-    V4l2CapDeviceBase ::V4l2CapDeviceBase()
-        :mCameraDevice(0),
-        mFmtParamIdx(0),
-        mSizeFPSParamIdx(0),
-        mRequiredFmt(0),
-        mBufQueNum(0),
-        mQueuedBufNum(0)
-
-    {
-        mCaptureDeviceName[0] = '#';
-        memset((void*)&mCapCfg, 0, sizeof(mCapCfg));
-    }
-
-    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
-    {
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::SetDevName(const char * deviceName, const char * devPath){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(mInitalDeviceName, deviceName);
-        if((devPath != NULL) && (strlen(devPath) > 0))
-            strcpy(mCaptureDeviceName, devPath);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(deviceName, mInitalDeviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::DevOpen(int cameraId){
-        CAMERA_LOG_FUNC;
-
-        return V4l2Open(cameraId);
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
-    {
-        CAMERA_LOG_FUNC;
-        if(pType == NULL)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        *pType = mCameraType;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        CAMERA_LOG_FUNC;
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        else
-            return V4l2EnumParam(devParamType,retParam);
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(mCapCfg.fmt != pCapcfg->fmt || mCapCfg.width != pCapcfg->width || mCapCfg.height != pCapcfg->height
-                || mCapCfg.tv.denominator/mCapCfg.tv.numerator != pCapcfg->tv.denominator/pCapcfg->tv.numerator) {
-            mCapCfg.fmt = pCapcfg->fmt;
-            mCapCfg.width = pCapcfg->width;
-            mCapCfg.height = pCapcfg->height;
-            mCapCfg.tv.denominator = pCapcfg->tv.denominator;
-            mCapCfg.tv.numerator = pCapcfg->tv.numerator;
-            CAMERA_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
-            ret = V4l2SetConfig(pCapcfg);
-            if(ret < 0) {
-                return ret;
-            }
-            mCapCfg.rotate = SENSOR_PREVIEW_ROATE_INVALID;
-        }
-
-        if(mCapCfg.rotate != pCapcfg->rotate) {
-            mCapCfg.rotate = pCapcfg->rotate;
-            CAMERA_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
-            if(V4l2SetRot(pCapcfg) < 0)
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        return ret;
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2RegisterBufs(DevBufQue, pBufQueNum);
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
-    }
-
-    CAPTURE_DEVICE_RET  V4l2CapDeviceBase :: DevPrepare(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Prepare();
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStart(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Start();
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
-
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Dequeue(pBufQueIdx);
-        }
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
-
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Queue(BufQueIdx);
-        }
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStop(){
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Stop();
-        }
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDeAllocate(){
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2DeAlloc();
-        }
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevClose(){
-
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Close();
-        }
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Open(int cameraId){
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-        char   dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_capability v4l2_cap;
-        struct v4l2_dbg_chip_ident vid_chip;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
-                        if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                            close(fd);
-                            fd = 0;
-                            CAMERA_LOG_ERR("dev_node %s:cannot get sensor name", dev_node);
-                            continue;
-                        }
-                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
-                                dev_node, vid_chip.match.name);
-                        if(strstr(vid_chip.match.name, mInitalDeviceName)){
-                            is_found = 1;
-                            strcpy(mInitalDeviceName, vid_chip.match.name);
-                            strcpy(mCaptureDeviceName, dev_node);
-                            break;
-                        }
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-            if (fd > 0){
-                mCameraDevice = fd;
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        CAMERA_LOG_FUNC;
-        CAMERA_LOG_RUNTIME("devParamType is %d", devParamType);
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        switch(devParamType){
-            case OUTPU_FMT:
-                ret = V4l2EnumFmt(retParam);
-                break;
-            case FRAME_SIZE_FPS:
-                {
-                    ret = V4l2EnumSizeFps(retParam);
-                    break;
-                }
-            default:
-                {
-                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    break;
-                }
-        }
-        return ret;
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        vid_fmtdesc.index = mFmtParamIdx;
-        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }else{
-            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
-            *pParamVal = vid_fmtdesc.pixelformat;
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_frmsizeenum vid_frmsize;
-        struct v4l2_frmivalenum vid_frmval;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
-            vid_frmval.pixel_format = pCapCfg->fmt;
-            vid_frmval.width = vid_frmsize.discrete.width;
-            vid_frmval.height= vid_frmsize.discrete.height;
-            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-                CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
-                mSizeFPSParamIdx = 0;
-                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-            }else{
-                pCapCfg->width	= vid_frmsize.discrete.width;
-                pCapCfg->height = vid_frmsize.discrete.height;
-                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
-                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
-                mSizeFPSParamIdx ++;
-                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-            }
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        *pMode = 0;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        V4l2ConfigInput(pCapcfg);
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("set format failed\n");
-            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-            CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                    parm.parm.capture.timeperframe.denominator);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-
-
-        if(V4l2SetRot(pCapcfg) < 0)
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-        unsigned int i;
-        struct v4l2_buffer buf;
-        enum v4l2_buf_type type;
-        struct v4l2_requestbuffers req;
-        int BufQueNum;
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mBufQueNum = *pBufQueNum;
-
-        memset(&req, 0, sizeof (req));
-        req.count = mBufQueNum;
-        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        req.memory = V4L2_MEMORY_MMAP;
-        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        /*the driver may can't meet the request, and return the buf num it can handle*/
-        *pBufQueNum = mBufQueNum = req.count;
-
-        for (i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (buf));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.index = i;
-            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } else {
-                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-            }
-
-            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
-            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
-            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
-            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-        unsigned int i;
-        struct v4l2_buffer buf;
-        enum v4l2_buf_type type;
-        struct v4l2_requestbuffers req;
-        int BufQueNum;
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mBufQueNum = *pBufQueNum;
-
-        memset(&req, 0, sizeof (req));
-        req.count = mBufQueNum;
-        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        req.memory = V4L2_MEMORY_USERPTR;
-        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        /*the driver may can't meet the request, and return the buf num it can handle*/
-        *pBufQueNum = mBufQueNum = req.count;
-
-        for (i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (buf));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_USERPTR;
-            buf.index = i;
-            buf.m.offset = mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
-            buf.length = mCaptureBuffers[i].length = DevBufQue[i].length;
-            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
-            //memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } else {
-                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-            }
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Prepare(){
-        CAMERA_LOG_FUNC;
-        struct v4l2_buffer buf;
-        mQueuedBufNum = 0;
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (struct v4l2_buffer));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_USERPTR;
-            buf.index = i;
-            buf.m.offset = mCaptureBuffers[i].phy_offset;
-
-            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            }
-            mQueuedBufNum ++;
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Start(){
-        enum v4l2_buf_type type;
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_STREAMON error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else{
-            CAMERA_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
-        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        *pBufQueIdx = cfilledbuffer.index;
-        mQueuedBufNum --;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
-        cfilledbuffer.index = BufQueIdx;
-        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        mQueuedBufNum ++;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Stop(){
-        enum v4l2_buf_type type;
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_STREAMOFF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else
-            CAMERA_LOG_INFO("VIDIOC_STREAMOFF ok\n");
-
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start != NULL)) {
-                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-                mCaptureBuffers[i].length = 0;
-                CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
-            }
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Close(){
-
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0 ){
-            CAMERA_LOG_INFO("the device handle is error");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        CAMERA_LOG_INFO("close the device");
-        close(mCameraDevice);
-        mCameraDevice = -1;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-};
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.h b/mx5x/libcamera/V4l2CapDeviceBase.h
deleted file mode 100755
index f48ac32..0000000
--- a/mx5x/libcamera/V4l2CapDeviceBase.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_CAP_DEVICE_BASE_H
-#define V4L2_CAP_DEVICE_BASE_H
-#include <linux/videodev2.h>
-
-#include "CaptureDeviceInterface.h"
-
-namespace android{
-
-    class V4l2CapDeviceBase : public CaptureDeviceInterface{
-    public:
-
-        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char *devPath = NULL);
-        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType);
-        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId);
-        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET DevPrepare();
-        virtual CAPTURE_DEVICE_RET DevStart();
-        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_RET DevQueue( unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_RET DevStop();
-        virtual CAPTURE_DEVICE_RET DevDeAllocate();
-        virtual CAPTURE_DEVICE_RET DevClose();
-
-    protected:
-
-        V4l2CapDeviceBase();
-        virtual ~V4l2CapDeviceBase();
-        virtual CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-        virtual CAPTURE_DEVICE_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET V4l2Prepare();
-        virtual CAPTURE_DEVICE_RET V4l2Start();
-        virtual CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_RET V4l2Stop();
-        virtual CAPTURE_DEVICE_RET V4l2DeAlloc();
-        virtual CAPTURE_DEVICE_RET V4l2Close();
-        virtual CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode);
-        virtual CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-
-        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
-        char         mInitalDeviceName[CAMERA_SENSOR_LENGTH];
-        int          mCameraDevice;
-        unsigned int mFmtParamIdx;
-        unsigned int mSizeFPSParamIdx;
-        unsigned int mRequiredFmt;
-        unsigned int mBufQueNum;
-        int          mQueuedBufNum;
-        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
-        struct   capture_config_t mCapCfg;
-        CAMERA_TYPE  mCameraType;
-
-    };
-};
-
-#endif
diff --git a/mx5x/libcamera/V4l2CsiDevice.cpp b/mx5x/libcamera/V4l2CsiDevice.cpp
deleted file mode 100755
index 60fe01b..0000000
--- a/mx5x/libcamera/V4l2CsiDevice.cpp
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev.h>
-#include <linux/videodev2.h>
-#include <linux/mxc_v4l2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CsiDevice.h"
-
-namespace android{
-    V4l2CsiDevice :: V4l2CsiDevice(){
-        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
-        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
-        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
-        mCameraType = CAMERA_TYPE_CSI;
-    }
-    V4l2CsiDevice :: ~V4l2CsiDevice()
-    {
-    }
-
-
-#ifdef V4L2_CAMERA_SWITCH
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2Open(int cameraId){
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char	dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_dbg_chip_ident vid_chip;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        ALOGI("%s: mInitalDeviceName %s, cameraId %d, mCaptureDeviceName %s",
-                __func__, mInitalDeviceName, cameraId, mCaptureDeviceName);
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-
-        if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-            ret = V4l2SetSensor(cameraId);
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-
-                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
-                        is_found = 1;
-                        strcpy(mCaptureDeviceName, dev_node);
-                        strcpy(mInitalDeviceName, vid_chip.match.name);
-                        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-                        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-                        break;
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-
-            if (fd > 0){
-                mCameraDevice = fd;
-                ret = V4l2SetSensor(cameraId);
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetSensor(int cameraId)
-    {
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        CAMERA_LOG_INFO("-----set camera sensor %d-----", cameraId);
-        if(cameraId >= 2) {
-            CAMERA_LOG_ERR("Error: camerId %d is too big", cameraId);
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        struct v4l2_control ctrl;
-        ctrl.id = V4L2_CID_MXC_SWITCH_CAM;
-        ctrl.value = cameraId;
-        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_LOG_ERR("set ctrl switch camera failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        return ret;
-    }
-#endif
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
-            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
-            *pParamVal = mSupportedFmt[mFmtParamIdx];
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }else{
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_frmsizeenum vid_frmsize;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            //hardcode here for ov3640
-            if (strstr(mInitalDeviceName, "3640") != NULL){
-                CAMERA_LOG_INFO("the sensor  is  mInitalDeviceName");
-                if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
-                    mSizeFPSParamIdx ++;
-                    vid_frmsize.index = mSizeFPSParamIdx;
-                    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-                        mSizeFPSParamIdx = 0;
-                        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    }
-                }
-            }
-            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            pCapCfg->width  = vid_frmsize.discrete.width;
-            pCapCfg->height = vid_frmsize.discrete.height;
-            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 15;
-            }else{
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 30;
-            }
-            mSizeFPSParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
-    {
-        CAMERA_LOG_FUNC;
-        int input = 1;
-        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
-            CAMERA_LOG_ERR("set input failed");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
-    {
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        memset(&parm, 0, sizeof(struct v4l2_streamparm));
-        memset(&fmt, 0, sizeof(struct v4l2_format));
-        V4l2ConfigInput(pCapcfg);
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        //hard code here to do a walk around.
-        if(pCapcfg->tv.denominator != 30 && pCapcfg->tv.denominator != 15){
-            pCapcfg->tv.numerator = 1;
-            pCapcfg->tv.denominator = 30;
-        }
-
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode),
-                &(parm.parm.capture.timeperframe));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            parm.parm.capture.timeperframe.numerator = 1;
-            parm.parm.capture.timeperframe.denominator = 15;
-            if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
-                CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-                CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                        parm.parm.capture.timeperframe.denominator);
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            }
-        }
-
-        CAMERA_LOG_INFO("Set FPS %d to Capture device",
-                parm.parm.capture.timeperframe.denominator);
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("set format failed\n");
-            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
-            unsigned int *pMode, struct v4l2_fract *pTimeFrame){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        unsigned int capturemode = 0;
-        unsigned int capturewidth =  pCapcfg->width;
-        unsigned int captureheight = pCapcfg->height;
-        unsigned int pic_waite_buf_num = 0;
-        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
-                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
-            pic_waite_buf_num = 6;
-            if (capturewidth == 640 && captureheight == 480) {
-                capturemode = 0;	/* VGA mode */
-            }
-            else if (capturewidth == 320 && captureheight == 240) {
-                capturemode = 1;	/* QVGA mode */
-            }
-            else if (capturewidth == 720 && captureheight == 480) {
-                capturemode = 2;	/* PAL mode */
-            }
-            else if (capturewidth == 720 && captureheight == 576) {
-                capturemode = 3;	/* PAL mode */
-            }
-            else if (capturewidth == 1280 && captureheight == 720) {
-                capturemode = 4;	/* 720P mode */
-            }
-            else if (capturewidth == 1920 && captureheight == 1080){
-                pic_waite_buf_num = 3;
-                capturemode = 5;	/* 1080P mode */
-            }
-            else if (capturewidth == 2592 && captureheight == 1944) {
-                pic_waite_buf_num =3;
-                capturemode = 6;	/* 2592x1944 mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 15;
-            }
-            else if (capturewidth == 176 && captureheight == 144) {
-                capturemode = 7;       /* QCIF mode */
-            }
-            else if (capturewidth == 1024 && captureheight == 768) {
-                capturemode = 8;       /* XGA mode */
-            }
-            else{
-                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
-            pic_waite_buf_num = 10;
-            if (capturewidth == 320 && captureheight == 240)
-                capturemode = 1;	/* QVGA mode */
-            else if (capturewidth == 640 && captureheight == 480)
-                capturemode = 0;	/* VGA mode */
-            else if (capturewidth == 720 && captureheight == 480)
-                capturemode = 4;
-            else if (capturewidth == 720 && captureheight == 576)
-                capturemode = 5;
-            else if (capturewidth == 2048 && captureheight == 1536)
-            {
-                pic_waite_buf_num = 10;
-                capturemode = 3;	/* QXGA mode */
-            }
-            else
-            {
-                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else{
-            CAMERA_LOG_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
-            capturemode = 0;
-            pic_waite_buf_num = 0;
-        }
-
-        CAMERA_LOG_INFO("camera mode:%d", capturemode);
-        *pMode = capturemode;
-        pCapcfg->picture_waite_number = pic_waite_buf_num;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        struct v4l2_control ctrl;
-
-        // Set rotation
-        ctrl.id = V4L2_CID_MXC_ROT;
-        if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
-            ctrl.value = V4L2_MXC_ROTATE_NONE;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
-            ctrl.value = V4L2_MXC_ROTATE_VERT_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
-            ctrl.value = V4L2_MXC_ROTATE_HORIZ_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
-            ctrl.value = V4L2_MXC_ROTATE_180;
-        else
-            ctrl.value = V4L2_MXC_ROTATE_NONE;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_LOG_ERR("set ctrl failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET  V4l2CsiDevice :: V4l2DeAlloc() {
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-};
-
diff --git a/mx5x/libcamera/V4l2CsiDevice.h b/mx5x/libcamera/V4l2CsiDevice.h
deleted file mode 100755
index bdc0632..0000000
--- a/mx5x/libcamera/V4l2CsiDevice.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_CSI_DEVICE_H
-#define V4L2_CSI_DEVICE_H
-
-#include <linux/videodev2.h>
-#include "V4l2CapDeviceBase.h"
-#define ENUM_SUPPORTED_FMT     3
-
-#define OV3640_NAME_STR   "ov3640"
-#define OV5640_NAME_STR   "ov5640"
-#define OV5642_NAME_STR   "ov5642"
-namespace android{
-
-class V4l2CsiDevice : public V4l2CapDeviceBase{
-    public:
-
-        V4l2CsiDevice();
-        virtual ~V4l2CsiDevice();
-    protected:
-
-#ifdef V4L2_CAMERA_SWITCH
-        //Only for switch camera with ioctl
-        CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-        CAPTURE_DEVICE_RET V4l2SetSensor(int cameraId);
-#endif
-	CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-	CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-	CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
-                unsigned int *pMode, struct v4l2_fract *pTimeFrame);
-        CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2DeAlloc();
-
-	unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
-   };
-
-};
-#endif
-
-
diff --git a/mx5x/libcamera/V4l2UVCDevice.cpp b/mx5x/libcamera/V4l2UVCDevice.cpp
deleted file mode 100644
index 9c9e7df..0000000
--- a/mx5x/libcamera/V4l2UVCDevice.cpp
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2013 Freescale Semiconductor, Inc.
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include <linux/videodev2.h>
-
-
-#include "V4l2UVCDevice.h"
-
-#define MAX_DEV_NAME_LENGTH 10
-
-namespace android {
-
-V4l2UVCDevice::V4l2UVCDevice()
-{
-    mCameraType = CAMERA_TYPE_UVC;
-    memset(mUvcBuffers, 0 , sizeof(mUvcBuffers));
-    mCaptureConfigNum = 0;
-    mCurrentConfig = NULL;
-    memset(mCaptureConfig, 0, sizeof(mCaptureConfig));
-
-    mEnableCSC = false;
-    mSensorFmtCnt = 0;
-    mCscFmtCnt = 0;
-    mActualCscFmtCnt = 0;
-    memset(mSensorSupportFmt, 0, sizeof(mSensorSupportFmt));
-    memset(mActualCscFmt, 0 , sizeof(mActualCscFmt));
-
-    memset(mCscGroup, 0, sizeof(mCscGroup));
-    //related to format support in CSC.
-    mCscGroup[0].srcFormat = v4l2_fourcc('Y','U','Y','V');
-    mCscGroup[0].dstFormat = v4l2_fourcc('N','V','1','2');
-    mCscGroup[0].cscConvert = convertYUYUToNV12;
-    mCscGroup[0].isSensorSupport = false;
-    mCscGroup[0].isOverlapWithSensor = false;
-    mDoCsc = NULL;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Open(int cameraId)
-{
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char   dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_capability v4l2_cap;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR | O_NONBLOCK, 0);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR | O_NONBLOCK, 0)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
-                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
-                                dev_node, v4l2_cap.driver);
-                        if(strstr((const char*)v4l2_cap.driver, mInitalDeviceName)){
-                            is_found = 1;
-                            CAMERA_LOG_RUNTIME("find the correct sensor %s, len=%d", v4l2_cap.driver, strlen((const char*)v4l2_cap.driver));
-                            strcpy(mInitalDeviceName, (const char*)v4l2_cap.driver);
-                            strcpy(mCaptureDeviceName, dev_node);
-                            break;
-                        }
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-            if (fd > 0){
-                mCameraDevice = fd;
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-        return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)
-{
-    unsigned int i;
-    struct v4l2_buffer buf;
-    enum v4l2_buf_type type;
-    struct v4l2_requestbuffers req;
-    int BufQueNum;
-
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    mBufQueNum = *pBufQueNum;
-
-    memset(&req, 0, sizeof (req));
-    req.count = mBufQueNum;
-    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    req.memory = V4L2_MEMORY_MMAP;
-    if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-        CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    /*the driver may can't meet the request, and return the buf num it can handle*/
-    *pBufQueNum = mBufQueNum = req.count;
-
-    for (i = 0; i < mBufQueNum; i++) {
-        memset(&buf, 0, sizeof (buf));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.index = i;
-        if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else {
-            CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-        }
-
-        mCaptureBuffers[i].length = DevBufQue[i].length = mUvcBuffers[i].length = buf.length;
-
-        mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
-        mUvcBuffers[i].phy_offset = (size_t) buf.m.offset;
-
-        mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
-        mUvcBuffers[i].virt_start = (unsigned char *)mmap (NULL, mUvcBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mUvcBuffers[i].phy_offset);
-
-        memset(mUvcBuffers[i].virt_start, 0xFF, mUvcBuffers[i].length);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].length = %d\n", i, mUvcBuffers[i].length);
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].phy_offset = 0x%x\n", i, mUvcBuffers[i].phy_offset);
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mUvcBuffers[i].virt_start));
-    }
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Prepare()
-{
-    CAMERA_LOG_FUNC;
-    struct v4l2_buffer buf;
-    mQueuedBufNum = 0;
-    for (unsigned int i = 0; i < mBufQueNum; i++) {
-        memset(&buf, 0, sizeof (struct v4l2_buffer));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.memory = V4L2_MEMORY_MMAP;
-        buf.index = i;
-        buf.m.offset = mUvcBuffers[i].phy_offset;
-
-        if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        mQueuedBufNum ++;
-    }
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Dequeue(unsigned int *pBufQueIdx)
-{
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_buffer cfilledbuffer;
-    int n;
-    fd_set rfds;
-    struct timeval tv;
-    //CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-        return CAPTURE_DEVICE_ERR_OPEN;
-    }
-
-    FD_ZERO(&rfds);
-    FD_SET(mCameraDevice, &rfds);
-    tv.tv_sec = 0;
-    tv.tv_usec = MAX_DEQUEUE_WAIT_TIME*1000;
-    n = select(mCameraDevice+1, &rfds, NULL, NULL, &tv);
-    if(n < 0) {
-        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state error.");
-        ret = CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-    else if(n == 0) {
-        CAMERA_LOG_INFO("Warning!Time out wait for V4L2 capture reading operation!");
-        ret = CAPTURE_DEVICE_ERR_OPT_TIMEOUT;
-    }
-    else if(FD_ISSET(mCameraDevice, &rfds)) {
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-        int rtval;
-        rtval = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
-        if (rtval < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", rtval);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        *pBufQueIdx = cfilledbuffer.index;
-
-        //should do hardware accelerate.
-        if(mEnableCSC && mDoCsc) {
-            mDoCsc->width = mCurrentConfig->width;
-            mDoCsc->height = mCurrentConfig->height;
-            mDoCsc->srcStride = mDoCsc->width;
-            mDoCsc->dstStride = mDoCsc->width;
-            mDoCsc->srcVirt = mUvcBuffers[*pBufQueIdx].virt_start;
-            mDoCsc->dstVirt = mCaptureBuffers[*pBufQueIdx].virt_start;
-            mDoCsc->srcPhy = mUvcBuffers[*pBufQueIdx].phy_offset;
-            mDoCsc->dstPhy = mCaptureBuffers[*pBufQueIdx].phy_offset;
-            mDoCsc->cscConvert(mDoCsc);
-        }
-        else
-            memcpy(mCaptureBuffers[*pBufQueIdx].virt_start, mUvcBuffers[*pBufQueIdx].virt_start, mCaptureBuffers[*pBufQueIdx].length);
-
-        mQueuedBufNum --;
-
-        ret =  CAPTURE_DEVICE_ERR_NONE;
-    }
-    else {
-        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state, no known error.");
-        ret = CAPTURE_DEVICE_ERR_UNKNOWN;
-    }
-
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Queue(unsigned int BufQueIdx)
-{
-    int ret;
-    struct v4l2_buffer cfilledbuffer;
-    //CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-        return CAPTURE_DEVICE_ERR_OPEN;
-    }
-    memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
-    cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-    cfilledbuffer.index = BufQueIdx;
-    ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
-    if (ret < 0) {
-        CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    mQueuedBufNum ++;
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2DeAlloc()
-{
-
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 ){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    for (unsigned int i = 0; i < mBufQueNum; i++) {
-        if (mUvcBuffers[i].length && (mUvcBuffers[i].virt_start != NULL)) {
-            munmap(mUvcBuffers[i].virt_start, mUvcBuffers[i].length);
-            mUvcBuffers[i].length = 0;
-            CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mUvcBuffers[i].virt_start));
-        }
-    }
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-void V4l2UVCDevice::selectCscFunction(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    mDoCsc = NULL;
-    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
-                     mCscGroup[i].dstFormat == format) {
-            mDoCsc = &mCscGroup[i];
-            CAMERA_LOG_RUNTIME("find the match mCscGroup[%d] CSC function", i);
-        }
-    }
-}
-
-unsigned int V4l2UVCDevice::queryCscSourceFormat(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
-                     mCscGroup[i].dstFormat == format) {
-            CAMERA_LOG_RUNTIME("find the CSC source format=0x%x convert to dest format=0x%x",
-                         mCscGroup[i].srcFormat, mCscGroup[i].dstFormat);
-            return mCscGroup[i].srcFormat;
-        }
-    }
-
-    CAMERA_LOG_ERR("invalidate format 0x%x in query", format);
-    return 0;
-}
-
-bool V4l2UVCDevice::needDoCsc(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    unsigned int i;
-    for(i=0; i < mActualCscFmtCnt; i++) {
-        if(mActualCscFmt[i] == format)
-            return true;
-    }
-
-    return false;
-}
-
-unsigned int V4l2UVCDevice::countActualCscFmt()
-{
-    CAMERA_LOG_FUNC;
-    if(mSensorFmtCnt <= 0) {
-        return 0;
-    }
-
-    unsigned int i, k;
-    unsigned int n = 0;
-
-    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
-        for(k=0; k < mSensorFmtCnt; k++) {
-            if(mCscGroup[i].srcFormat == mSensorSupportFmt[k]) {
-                mCscGroup[i].isSensorSupport = true;
-                break;
-            }
-        }
-    }
-
-    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
-        for(k=0; k < mSensorFmtCnt; k++) {
-            if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].dstFormat == mSensorSupportFmt[k]) {
-                mCscGroup[i].isOverlapWithSensor = true;
-                break;
-            }
-        }
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false) {
-            mActualCscFmt[n++] = mCscGroup[i].dstFormat;
-        }
-    }
-
-    return n;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumFmt(void *retParam)
-{
-    CAMERA_LOG_FUNC;
-
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_fmtdesc vid_fmtdesc;
-    unsigned int *pParamVal = (unsigned int *)retParam;
-
-    vid_fmtdesc.index = mFmtParamIdx;
-    vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
-        if(mSensorFmtCnt > 0) {
-            mCscFmtCnt = countActualCscFmt();
-            mActualCscFmtCnt = mCscFmtCnt;
-            mSensorFmtCnt = 0;
-        }
-        if(mCscFmtCnt > 0) {
-            *pParamVal = mActualCscFmt[mCscFmtCnt-1];
-            mFmtParamIdx ++;
-            mCscFmtCnt --;
-            return CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        mFmtParamIdx = 0;
-        ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-    }else{
-        CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
-        *pParamVal = vid_fmtdesc.pixelformat;
-        if(mFmtParamIdx < MAX_SUPPORTED_FMT) {
-            mSensorSupportFmt[mFmtParamIdx] = vid_fmtdesc.pixelformat;
-            mSensorFmtCnt ++;
-        }
-        mFmtParamIdx ++;
-        ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-    }
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumSizeFps(void *retParam)
-{
-    CAMERA_LOG_FUNC;
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_frmsizeenum vid_frmsize;
-    struct v4l2_frmivalenum vid_frmval;
-
-    struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-    memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-    mCaptureConfigNum = mSizeFPSParamIdx;
-    vid_frmsize.index = mSizeFPSParamIdx;
-    CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-
-    if(needDoCsc(pCapCfg->fmt)) {
-        vid_frmsize.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
-        if(vid_frmsize.pixel_format == 0) {
-            CAMERA_LOG_ERR("EnumSizeFps: queryCscSourceFormat return failed");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-    }
-    else {
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-    }
-    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-        mSizeFPSParamIdx = 0;
-        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-    }else{
-        //uvc handle 1600x1200 may have some problem. so, skip it.
-        if(vid_frmsize.discrete.width == 1600 && vid_frmsize.discrete.height == 1200) {
-            CAMERA_LOG_ERR("EnumSizeFps: now skip %d x %d resolution", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            mSizeFPSParamIdx = 0;
-            return CAPTURE_DEVICE_ERR_SET_PARAM;
-        }
-
-        memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-        CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-        vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
-        if(needDoCsc(pCapCfg->fmt)) {
-            vid_frmval.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
-            if(vid_frmsize.pixel_format == 0) {
-                CAMERA_LOG_ERR("EnumSizeFps2: queryCscSourceFormat return failed");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }
-        else {
-            vid_frmval.pixel_format = pCapCfg->fmt;
-        }
-        vid_frmval.width = vid_frmsize.discrete.width;
-        vid_frmval.height= vid_frmsize.discrete.height;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-            CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            pCapCfg->width	= vid_frmsize.discrete.width;
-            pCapCfg->height = vid_frmsize.discrete.height;
-            pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
-            pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
-            mSizeFPSParamIdx ++;
-
-            //store all configuration here.
-            mCaptureConfig[mCaptureConfigNum].fmt = vid_frmsize.pixel_format;//pCapCfg->fmt;
-            mCaptureConfig[mCaptureConfigNum].width = pCapCfg->width;
-            mCaptureConfig[mCaptureConfigNum].height = pCapCfg->height;
-            mCaptureConfig[mCaptureConfigNum].picture_waite_number = 0;
-            mCaptureConfig[mCaptureConfigNum].tv.numerator = pCapCfg->tv.numerator;
-            mCaptureConfig[mCaptureConfigNum].tv.denominator = pCapCfg->tv.denominator;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-    }
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2SetConfig(struct capture_config_t *pCapcfg)
-{
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || pCapcfg == NULL){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_format fmt;
-    struct v4l2_control ctrl;
-    struct v4l2_streamparm parm;
-    struct capture_config_t *matchConfig = NULL;
-    struct capture_config_t *betterMatchConfig = NULL;
-    struct capture_config_t *bestMatchConfig = NULL;
-
-    //find the best match configuration.
-    for(unsigned int i=0; i < mCaptureConfigNum; i++) {
-        if(/*mCaptureConfig[i].fmt == pCapcfg->fmt &&*/
-                 mCaptureConfig[i].width == pCapcfg->width &&
-                 mCaptureConfig[i].height == pCapcfg->height) {
-            matchConfig = &mCaptureConfig[i];
-            if(mCaptureConfig[i].tv.numerator == pCapcfg->tv.numerator &&
-                    mCaptureConfig[i].tv.denominator == pCapcfg->tv.denominator) {
-                bestMatchConfig = &mCaptureConfig[i];
-            }
-            else if(mCaptureConfig[i].tv.denominator/mCaptureConfig[i].tv.numerator >
-                   pCapcfg->tv.denominator/pCapcfg->tv.numerator){
-                betterMatchConfig = &mCaptureConfig[i];
-            }//else
-        }
-    }//for
-
-    if(bestMatchConfig != NULL) {
-        matchConfig = bestMatchConfig;
-    }
-    else if(betterMatchConfig != NULL) {
-        matchConfig = betterMatchConfig;
-    }
-
-    if(matchConfig == NULL) {
-        CAMERA_LOG_ERR("Error: not support format=0x%x, Width=%d, Height=%d",
-                       pCapcfg->fmt, pCapcfg->width, pCapcfg->height);
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    mCurrentConfig = matchConfig;
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if(needDoCsc(pCapcfg->fmt)) {
-        mEnableCSC = true;
-        //set mDoCsc 
-        selectCscFunction(pCapcfg->fmt);
-        fmt.fmt.pix.pixelformat = queryCscSourceFormat(pCapcfg->fmt);
-        if(fmt.fmt.pix.pixelformat == 0) {
-            CAMERA_LOG_ERR("SetConfig: queryCscSourceFormat return failed");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-    }
-    else {
-        mEnableCSC = false;
-        fmt.fmt.pix.pixelformat = matchConfig->fmt;
-    }
-
-    fmt.fmt.pix.width = matchConfig->width;
-    fmt.fmt.pix.height = matchConfig->height;
-    if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
-        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-    else
-        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-    fmt.fmt.pix.priv = 0;
-    fmt.fmt.pix.sizeimage = 0;
-
-    int err = 0;
-    if ((err = ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt)) < 0) {
-        CAMERA_LOG_ERR("set format failed err=%d\n", err);
-        CAMERA_LOG_ERR("matchConfig->width is %d, matchConfig->height is %d", matchConfig->width, matchConfig->height);
-        CAMERA_LOG_ERR(" Set the Format %x :%c%c%c%c\n", matchConfig->fmt,
-                matchConfig->fmt & 0xFF, (matchConfig->fmt >> 8) & 0xFF,
-                (matchConfig->fmt >> 16) & 0xFF, (matchConfig->fmt >> 24) & 0xFF);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    parm.parm.capture.timeperframe.numerator = matchConfig->tv.numerator;
-    parm.parm.capture.timeperframe.denominator = matchConfig->tv.denominator;
-    CAMERA_LOG_RUNTIME("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                parm.parm.capture.timeperframe.denominator);
-    if ( (err = ioctl(mCameraDevice, VIDIOC_S_PARM, &parm)) < 0) {
-        CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed err=%d\n", __FUNCTION__,__LINE__, err);
-        CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                parm.parm.capture.timeperframe.denominator);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-        CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }else{
-
-        CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-        CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-        CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-        CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-    }
-    matchConfig->framesize = fmt.fmt.pix.sizeimage;
-    pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-    //For uvc, the first frame is ok.
-    matchConfig->picture_waite_number = pCapcfg->picture_waite_number = 1;
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-void V4l2UVCDevice::convertYUYUToNV12(struct CscConversion* param)
-{
-    unsigned char *pSrcBufs = param->srcVirt;
-    unsigned char *pDstBufs = param->dstVirt;
-    unsigned int bufWidth = param->width;
-    unsigned int bufHeight = param->height;
-
-    unsigned char *pSrcY1Offset = pSrcBufs;
-    unsigned char *pSrcY2Offset = pSrcBufs + (bufWidth << 1);
-    unsigned char *pSrcY3Offset = pSrcBufs + (bufWidth << 1) * 2;
-    unsigned char *pSrcY4Offset = pSrcBufs + (bufWidth << 1) * 3;
-    unsigned char *pSrcU1Offset = pSrcY1Offset + 1;
-    unsigned char *pSrcU2Offset = pSrcY2Offset + 1;
-    unsigned char *pSrcU3Offset = pSrcY3Offset + 1;
-    unsigned char *pSrcU4Offset = pSrcY4Offset + 1;
-    unsigned char *pSrcV1Offset = pSrcY1Offset + 3;
-    unsigned char *pSrcV2Offset = pSrcY2Offset + 3;
-    unsigned char *pSrcV3Offset = pSrcY3Offset + 3;
-    unsigned char *pSrcV4Offset = pSrcY4Offset + 3;
-    unsigned int srcYStride = (bufWidth << 1) * 3;
-    unsigned int srcUVStride = srcYStride;
-
-    unsigned char *pDstY1Offset = pDstBufs;
-    unsigned char *pDstY2Offset = pDstBufs + bufWidth;
-    unsigned char *pDstY3Offset = pDstBufs + bufWidth * 2;
-    unsigned char *pDstY4Offset = pDstBufs + bufWidth * 3;
-    unsigned char *pDstU1Offset = pDstBufs + bufWidth * bufHeight;
-    unsigned char *pDstU2Offset = pDstBufs + bufWidth * (bufHeight + 1);
-    unsigned char *pDstV1Offset = pDstU1Offset + 1;
-    unsigned char *pDstV2Offset = pDstU2Offset + 1;
-    unsigned int dstYStride = bufWidth * 3;
-    unsigned int dstUVStride = bufWidth;
-
-    unsigned int nw, nh;
-    for(nh = 0; nh < (bufHeight >> 2); nh++) {
-        for(nw=0; nw < (bufWidth >> 1); nw++) {
-            *pDstY1Offset++ = *pSrcY1Offset;
-            *pDstY2Offset++ = *pSrcY2Offset;
-            *pDstY3Offset++ = *pSrcY3Offset;
-            *pDstY4Offset++ = *pSrcY4Offset;
-
-            pSrcY1Offset += 2;
-            pSrcY2Offset += 2;
-            pSrcY3Offset += 2;
-            pSrcY4Offset += 2;
-
-            *pDstY1Offset++ = *pSrcY1Offset;
-            *pDstY2Offset++ = *pSrcY2Offset;
-            *pDstY3Offset++ = *pSrcY3Offset;
-            *pDstY4Offset++ = *pSrcY4Offset;
-
-            pSrcY1Offset += 2;
-            pSrcY2Offset += 2;
-            pSrcY3Offset += 2;
-            pSrcY4Offset += 2;
-
-            *pDstU1Offset = *pSrcU1Offset;
-            *pDstU2Offset = *pSrcU3Offset;
-            pDstU1Offset += 2;
-            pDstU2Offset += 2;
-            pSrcU1Offset += 4;
-            pSrcU3Offset += 4;
-
-            *pDstV1Offset = *pSrcV1Offset;
-            *pDstV2Offset = *pSrcV3Offset;
-            pDstV1Offset += 2;
-            pDstV2Offset += 2;
-            pSrcV1Offset += 4;
-            pSrcV3Offset += 4;
-        }
-
-        pSrcY1Offset += srcYStride;
-        pSrcY2Offset += srcYStride;
-        pSrcY3Offset += srcYStride;
-        pSrcY4Offset += srcYStride;
-
-        pSrcU1Offset += srcUVStride;
-        pSrcU3Offset += srcUVStride;
-        pSrcV1Offset += srcUVStride;
-        pSrcV3Offset += srcUVStride;
-
-        pDstY1Offset += dstYStride;
-        pDstY2Offset += dstYStride;
-        pDstY3Offset += dstYStride;
-        pDstY4Offset += dstYStride;
-
-        pDstU1Offset += dstUVStride;
-        pDstU2Offset += dstUVStride;
-        pDstV1Offset += dstUVStride;
-        pDstV2Offset += dstUVStride;
-    }
-}
-
-};
-
diff --git a/mx5x/libcamera/V4l2UVCDevice.h b/mx5x/libcamera/V4l2UVCDevice.h
deleted file mode 100755
index 9aea82a..0000000
--- a/mx5x/libcamera/V4l2UVCDevice.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_UVC_DEVICE_H
-#define V4L2_UVC_DEVICE_H
-
-#include <linux/videodev2.h>
-#include "V4l2CapDeviceBase.h"
-
-#define MAX_DEV_NAME_LENGTH 10
-#define MAX_CAPTURE_CONFIG  20
-#define MAX_SUPPORTED_FMT  10
-#define MAX_CSC_SUPPORT_FMT 1
-
-namespace android{
-
-struct CscConversion {
-    //if the srcFormat is support by sensor.
-    bool isSensorSupport;
-    //if the dstFormat is support by sensor.
-    bool isOverlapWithSensor;
-    int width;
-    int height;
-    int srcStride;
-    int dstStride;
-    unsigned int srcFormat;
-    unsigned int dstFormat;
-    unsigned char* srcVirt;
-    unsigned char* dstVirt;
-    int srcPhy;
-    int dstPhy;
-
-    void(*cscConvert)(struct CscConversion* param);
-};
-
-class V4l2UVCDevice : public V4l2CapDeviceBase{
-public:
-    V4l2UVCDevice();//{mCameraType = CAMERA_TYPE_UVC;}
-    ~V4l2UVCDevice(){}
-
-protected:
-    CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-    CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-    CAPTURE_DEVICE_RET V4l2Prepare();
-    CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-    CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
-    CAPTURE_DEVICE_RET V4l2DeAlloc();
-    CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-    CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-    CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-
-private:
-    static void convertYUYUToNV12(struct CscConversion* param);
-    unsigned int countActualCscFmt();
-    bool needDoCsc(unsigned int);
-    void selectCscFunction(unsigned int format);
-    unsigned int queryCscSourceFormat(unsigned int format);
-    //DMA_BUFFER mCameraBuffer[MAX_CAPTURE_BUF_QUE_NUM];
-    //mCaptureBuffers defined in parent class store buffers allocated from user space.
-    //mUvcBuffers store the buffers allocated from uvc driver.
-    DMA_BUFFER mUvcBuffers[MAX_CAPTURE_BUF_QUE_NUM];
-
-    //store sensor configuration here.
-    unsigned int mCaptureConfigNum;
-    struct capture_config_t mCaptureConfig[MAX_CAPTURE_CONFIG];
-    struct capture_config_t* mCurrentConfig;
-
-    //for jpeg encoder support yuyv. this case, should not covert.
-    bool mEnableCSC;
-    //stores nedd csc format. 
-    struct CscConversion mCscGroup[MAX_CSC_SUPPORT_FMT];
-    struct CscConversion* mDoCsc;
-    unsigned int mActualCscFmt[MAX_CSC_SUPPORT_FMT];
-    unsigned int mActualCscFmtCnt;
-    //stores sensor support format.
-    unsigned int mSensorSupportFmt[MAX_SUPPORTED_FMT];
-    unsigned int mSensorFmtCnt;
-    unsigned int mCscFmtCnt;
-};
-
-};
-#endif
-
diff --git a/mx5x/libcamera/messageQueue.cpp b/mx5x/libcamera/messageQueue.cpp
deleted file mode 100644
index 29a2087..0000000
--- a/mx5x/libcamera/messageQueue.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-
-#include <stdint.h>
-#include <errno.h>
-#include <sys/types.h>
-
-#include <utils/threads.h>
-#include <utils/Timers.h>
-#include <utils/Log.h>
-#include <binder/IPCThreadState.h>
-
-#include "messageQueue.h"
-#include "Camera_utils.h"
-
-namespace android {
-
-void CMessageList::insert(const sp<CMessage>& node)
-{
-    mList.push_back(node);
-};
-
-void CMessageList::remove(CMessageList::LIST::iterator pos)
-{
-    mList.erase(pos);
-}
-
-void CMessageList::clear()
-{
-    mList.clear();
-}
-
-CMessageQueue::CMessageQueue()
-    :mQuit(false), mStop(false)
-{
-    mQuitMessage = new CMessage(CMESSAGE_TYPE_QUITE);
-    mStopMessage = new CMessage(CMESSAGE_TYPE_STOP);
-}
-
-CMessageQueue::~CMessageQueue()
-{
-    Mutex::Autolock _l(mLock);
-    mMessages.clear();
-}
-
-void CMessageQueue::clearMessage()
-{
-    CAMERA_LOG_ERR("-------CMessageQueue::clearMessage--------");
-    Mutex::Autolock _l(mLock);
-    mMessages.clear();
-    mStop = false;
-}
-
-sp<CMessage> CMessageQueue::waitMessage(nsecs_t timeout)
-{
-    sp<CMessage> result;
-    nsecs_t timeoutTime = systemTime() + timeout;
-    while(true) {
-        Mutex::Autolock _l(mLock);
-        nsecs_t now = systemTime();
-        LIST::iterator cur(mMessages.begin());
-
-        if(mQuit) {
-            result = mQuitMessage;
-            return result;
-        }
-        if(mStop) {
-            result = mStopMessage;
-            return result;
-        }
-
-        if(cur != mMessages.end()) {
-            result = *cur;
-        }
-
-        if(result != 0) {
-            mMessages.remove(cur);
-            break;
-        }
-
-        if(timeout >= 0) {
-            if(timeoutTime < now) {
-                result = 0;
-                break;
-            }
-            nsecs_t relTime = timeoutTime - systemTime();
-            mCondition.waitRelative(mLock, relTime);
-        }else {
-            mCondition.wait(mLock);
-        }
-    }
-    return result;
-}
-
-status_t CMessageQueue::postMessage(const sp<CMessage>& message, int32_t flags) 
-{
-    return queueMessage(message, flags);
-}
-
-status_t CMessageQueue::postQuitMessage()
-{
-    Mutex::Autolock _l(mLock);
-    mQuit = true;
-    mCondition.signal();
-    return NO_ERROR;
-}
-
-status_t CMessageQueue::postStopMessage()
-{
-    Mutex::Autolock _l(mLock);
-    mStop = true;
-    //mMessages.insert(new CMessage(CMESSAGE_TYPE_STOP, 0));
-    mCondition.signal();
-    return NO_ERROR;
-}
-
-status_t CMessageQueue::queueMessage(const sp<CMessage>& message, int32_t flags)
-{
-    Mutex::Autolock _l(mLock);
-    mMessages.insert(message);
-    mCondition.signal();
-    return NO_ERROR;
-}
-};
-
diff --git a/mx5x/libcamera/messageQueue.h b/mx5x/libcamera/messageQueue.h
deleted file mode 100644
index 243d497..0000000
--- a/mx5x/libcamera/messageQueue.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-
-#ifndef CAMERA_HAL_MESSAGE_QUEUE_H
-#define CAMERA_HAL_MESSAGE_QUEUE_H
-
-#include <stdint.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <utils/threads.h>
-#include <utils/Timers.h>
-#include <utils/List.h>
-
-//#include "Barrier.h"
-
-namespace android {
-
-typedef enum{
-    CMESSAGE_TYPE_NORMAL = 0,
-    CMESSAGE_TYPE_STOP = -1,
-    CMESSAGE_TYPE_QUITE = -2,
-}CMESSAGE_TYPE;
-
-class CMessage;
-
-class CMessageList
-{
-    List< sp<CMessage> > mList;
-    typedef List< sp<CMessage> > LIST;
-public:
-    inline LIST::iterator begin() {return mList.begin();}
-    inline LIST::const_iterator begin() const {return mList.begin();}
-    inline LIST::iterator end() {return mList.end();}
-    inline LIST::const_iterator end() const {return mList.end();}
-    inline bool isEmpty() const {return mList.empty();}
-    void insert(const sp<CMessage> &node);
-    void remove(LIST::iterator pos);
-    void clear();
-};
-
-class CMessage : public LightRefBase<CMessage>
-{
-public:
-    CMESSAGE_TYPE what;
-    int32_t arg0;
-
-    //CMessage(): what(0), arg0(0) {}
-    CMessage(CMESSAGE_TYPE what, int32_t arg0=0)
-        : what(what), arg0(arg0) {}
-
-//protected:
-    virtual ~CMessage() {}
-
-private:
-    friend class LightRefBase<CMessage>;
-};
-
-class CMessageQueue
-{
-    typedef List< sp<CMessage> > LIST;
-public:
-    CMessageQueue();
-    ~CMessageQueue();
-
-    sp<CMessage> waitMessage(nsecs_t timeout=-1);
-    status_t postMessage(const sp<CMessage>& message, int32_t flags=0);
-    status_t postQuitMessage();
-    status_t postStopMessage();
-    void clearMessage();
-
-private:
-    status_t queueMessage(const sp<CMessage>& message, int32_t flags);
-
-    Mutex mLock;
-    Condition mCondition;
-    CMessageList mMessages;
-    bool mQuit;
-    bool mStop;
-    sp<CMessage> mQuitMessage;
-    sp<CMessage> mStopMessage;
-};
-
-
-};
-
-#endif
diff --git a/mx5x/libcopybit/Android.mk b/mx5x/libcopybit/Android.mk
deleted file mode 100755
index f720147..0000000
--- a/mx5x/libcopybit/Android.mk
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-ifeq (true, false)
-ifeq ($(HAVE_FSL_IMX_GPU2D),true)
-ifeq ($(BOARD_SOC_CLASS),IMX5X)
-
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := true
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
-LOCAL_SHARED_LIBRARIES := liblog
-ifeq ($(BOARD_SOC_TYPE),IMX50)
-LOCAL_SHARED_LIBRARIES += libc2d_z160
-else
-LOCAL_SHARED_LIBRARIES += libc2d_z430
-endif
-
-LOCAL_SRC_FILES := 	\
-	copybit.cpp
-	
-LOCAL_MODULE := copybit.$(TARGET_BOARD_PLATFORM)
-LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).copybit\" -D_LINUX
-
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif
-endif
-endif
diff --git a/mx5x/libcopybit/c2d_api.h b/mx5x/libcopybit/c2d_api.h
deleted file mode 100755
index 7c55067..0000000
--- a/mx5x/libcopybit/c2d_api.h
+++ /dev/null
@@ -1,543 +0,0 @@
-/* -------------------------------------------------------------------------
- *
- *  Copyright (C) 2010  QUALCOMM Incorporated.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * $Id:
- * $DateTime:
- * $Author:
- *
- *//*!
- * \file    c2d_api.h
- * \brief   C2D API
- *//*----------------------------------------------------------------------*/
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
- 
-
-#ifndef __c2d_api_h_
-#define __c2d_api_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-/* -------------------------------------------------------------------------
- * C2D Defines
- *//*----------------------------------------------------------------------*/
-
-#ifndef _LINUX
-#define C2D_API __declspec (dllexport)     /*!< DLL exports */
-#ifndef C2D_API
-#ifdef WIN32
-#define C2D_API __declspec (dllexport)     /*!< DLL exports */
-#else
-#define C2D_API
-#endif
-#endif
-#else //_LINUX
-#define C2D_API
-#endif //_LINUX
-
-typedef void*                   C2D_CONTEXT; /*!< C2D Context type */
-typedef void*                   C2D_SURFACE; /*!< C2D Surface type */
-
-typedef enum __C2D_STATUS {         /*!< Status codes, returned by any c2d function */
-    C2D_STATUS_OK              = 0, /*!<   operation was successful     */ 
-    C2D_STATUS_FAILURE         = 1, /*!<   unspecified failure          */
-    C2D_STATUS_NOT_SUPPORTED   = 2, /*!<   not supported functionality  */ 
-    C2D_STATUS_OUT_OF_MEMORY   = 3, /*!<   memory allocation failed     */        
-    C2D_STATUS_INVALID_PARAM   = 4, /*!<   invalid parameter or combination of parameters */       
-} C2D_STATUS;
-
-
-typedef enum _C2D_COLORFORMAT {             /*!< Color formats */
-    /* 1bit formats (alpha mask) */
-    C2D_COLOR_A1                            = 0,    /*!< 1bit per pixel (alpha mask)    */
-    /* 4bit formats (alpha mask) */
-    C2D_COLOR_A4                            = 1,    /*!< 4bit per pixel (alpha mask)    */
-    /* 8bit formats */
-    C2D_COLOR_A8                            = 2,    /*!< 8bit per pixel (alpha mask)    */
-    C2D_COLOR_8                             = 3,    /*!< 8bit per pixel                 */  
-    /* 16bit formats */
-    C2D_COLOR_4444                          = 4,    /*!< 16bit per pixel 4444 ARGB      */
-    C2D_COLOR_4444_RGBA                     = 5,    /*!< 16bit per pixel 4444 RGBA      */
-    C2D_COLOR_1555                          = 6,    /*!< 16bit per pixel 1555 ARGB      */
-    C2D_COLOR_5551_RGBA                     = 7,    /*!< 16bit per pixel 5551 RGBA      */
-    C2D_COLOR_0565                          = 8,    /*!< 16bit per pixel 0565 RGB       */
-    /* 32bit formats */
-    C2D_COLOR_8888                          = 9,    /*!< 32bit per pixel 8888 ARGB      */
-    C2D_COLOR_8888_RGBA                     = 10,   /*!< 32bit per pixel 8888 RGBA      */
-    C2D_COLOR_8888_ABGR                     = 11,   /*!< 32bit per pixel 8888 ABGR      */
-    /* 24bit formats */
-    C2D_COLOR_888                           = 12,   /*!< 24bit per pixel 888 BGR        */
-    /* YUV Formats etc.   */
-    C2D_NUMBER_OF_COLORFORMATS              = 13,    /*!< number of color formats; keep this the last */
-    C2D_COLOR_DUMMY                         = (1<<30) /*!< dummy enum. C2D_COLORFORMAT is used in C2D_SURFACE_DEF struct,
-                                                           this makes sure that C2D_COLORFORMAT size is aligned to 32bit  */
-} C2D_COLORFORMAT;
-
-
-typedef struct _C2D_RECT /*!< c2d rectangle              */
-{
-    int x;         /*!<   upper-left x */
-    int y;         /*!<   upper-left y */
-    int width;     /*!<   width */
-    int height;    /*!<   height */
-} C2D_RECT;
-
-typedef struct _C2D_POINT
-{
-    int x;
-    int y;
-} C2D_POINT;
-
-
-typedef struct _C2D_SURFACE_DEF { /*!< Structure for creating a c2d surface                  */
-    C2D_COLORFORMAT format;     /*!< RGBA color format                                       */
-    unsigned int    width;      /*!< defines width in pixels                                 */
-    unsigned int    height;     /*!< defines height in pixels                                */
-    unsigned int    stride;     /*!< set by c2dSurfAlloc, defines stride in bytes            */
-    void           *buffer;     /*!< set by c2dSurfAlloc, physical address to surface buffer */ 
-    void           *host;       /*!< set by c2dSurfAlloc, virtual address to surface buffer  */ 
-    unsigned int    flags;      /*!< different flags to control the surface behavior         */
-} C2D_SURFACE_DEF;
-
-#define C2D_SURFACE_NO_BUFFER_ALLOC   1
-#define C2D_SURFACE_CLIPRECT_OVERRIDE 2
-
-
-typedef enum _C2D_GRADIENT_DIRECTION {  /*!< Direction of linear color fill */    
-    C2D_GD_LEFTTOP_RIGHTBOTTOM,  /*!< Left to Right, Top to Bottom */
-    C2D_GD_RIGHTTOP_LEFTBOTTOM,  /*!< Right to Left, Top to Bottom */
-    C2D_GD_LEFTBOTTOM_RIGHTTOP,  /*!< Left to Right, Bottom to Top */
-    C2D_GD_RIGHTBOTTOM_LEFTTOP,  /*!< Right to Left, Bottom to Top */
-    C2D_GD_TOP_BOTTOM,           /*!< Top to bottom */
-    C2D_GD_LEFT_RIGHT,           /*!< Left to right */
-    C2D_GD_BOTTOM_TOP,           /*!< Bottom up */
-    C2D_GD_RIGHT_LEFT            /*!< Right to left */
-} C2D_GRADIENT_DIRECTION;
-
-typedef enum __C2D_STRETCH_MODE {    /*!< Stretching modes */
-    C2D_STRETCH_POINT_SAMPLING,      /*!< Simple point sampling */
-    C2D_STRETCH_BILINEAR_SAMPLING    /*!< Linear interpolation in x- and y-direction */
-} C2D_STRETCH_MODE;
-
-typedef enum __C2D_ALPHA_BLEND_MODE {    /*!< Blending modes enumeration */
-    C2D_ALPHA_BLEND_NONE        = 0,     /*!< disables alpha blending */
-    C2D_ALPHA_BLEND_SRCOVER     = 1,     /*!< Source Over Destination */
-    C2D_ALPHA_BLEND_DIRECT      = 2,
-} C2D_ALPHA_BLEND_MODE;
-
-typedef enum __C2D_PARAMETERS {               /*!< Draw parameters                */
-    C2D_PARAM_FILL_BIT        = (1<<0),       /*!< fill rect or arc               */
-    C2D_PARAM_GRADIENT_BIT    = (1<<1),       /*!< fill with fg color to bg color */
-    C2D_PARAM_PATTERN_BIT     = (1<<2),       /*!< fill with brush                */
-    C2D_PARAM_TILING_BIT      = (1<<3),       /*!< tiling(repeat), no scaling for brush */
-    C2D_PARAM_MIRROR_BIT      = (1<<4),       /*!< horizontal mirroring           */
-    C2D_PARAM_LINE_LAST_PIXEL = (1<<5),       /*!< draw the last pixel of a line segment */
-} C2D_PARAMETERS;
-    
-
- typedef enum _C2D_DISPLAY {               /*!< Display enumeration */
-    C2D_DISPLAY_MAIN        = (1 << 0),    /*!< main display */
-    C2D_DISPLAY_SECONDARY   = (1 << 1),    /*!< secondary display */
-    C2D_DISPLAY_TV_OUT      = (1 << 2),    /*!< tv-out etc. */
-    C2D_DISPLAY_OVERLAY     = (1 << 3),    /*!< overlay window bit for display surface if overlay surfaces are supported */
-    C2D_DISPLAY_BG          = (1 << 4),    /*!< background window bit */
-} C2D_DISPLAY;
-
-
-/* -------------------------------------------------------------------------
- *                          C2D API
- *//*----------------------------------------------------------------------*/
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Create C2D context, 
- *          allocates and returns new handle to the draw state
- *  
- * \param   a_c2dContext is pointer to C2D_CONTEXT where context id is stored
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dCreateContext(C2D_CONTEXT *a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Destroy C2D context,
- *          free the given draw state
- *
- * \param   a_c2dContext is the C2D_CONTEXT where context was created
- *                       with c2dCreateContext function
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDestroyContext(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Alloc C2D surface, 
- *          allocates surface and returns handle to it
- *  
- * \param   a_c2dSurface is the pointer to C2D_SURFACE where surface id is stored
- * \param   a_surfaceDef is the pointer to C2D_SURFACE_DEF
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfAlloc(C2D_CONTEXT a_c2dContext, C2D_SURFACE *a_c2dSurface, C2D_SURFACE_DEF *a_surfaceDef);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Free C2D surface,
- *          free the given surface
- *
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfFree(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Lock C2D surface,
- *          Lock surface and return virtual address to surface buffer.
- *
- * \param   a_c2dContext is the context handle
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfLock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, void** a_ptr);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Unlock C2D surface,
- *          Give surface back for HW access
- *
- * \param   a_c2dContext is the context handle
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfUnlock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination surface
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_type is the C2D_SURFACE_TYPE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source surface
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_type is the C2D_SURFACE_TYPE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set ROP mode
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rop is the 32bit rop mode
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetRop(C2D_CONTEXT a_c2dContext, unsigned int a_rop);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set foreground color
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_fgColor is the 32bit value for the fgcolor
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetFgColor(C2D_CONTEXT a_c2dContext, unsigned int a_fgColor);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set background color
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_bgColoris the 32bit value for the bgcolor
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBgColor(C2D_CONTEXT a_c2dContext, unsigned int a_bgColor);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set gradient direction
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_direction is the C2D_GRADIENT_DIRECTION
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetGradientDirection(C2D_CONTEXT a_c2dContext, C2D_GRADIENT_DIRECTION a_direction);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set stretching mode
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_mode, C2D_STRETCH_MODE, how to perform stretching
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetStretchMode(C2D_CONTEXT a_c2dContext, C2D_STRETCH_MODE a_mode);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rect is the C2D_RECT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rect is the C2D_RECT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Sets the region of the destination surface that is clipped
- *          during rendering. Works similar to destination rectangle except
- *          clipping rectangle can be used to clip a stretched blt.
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_clipRect, *C2D_RECT, pass NULL to disable
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstClipRect(C2D_CONTEXT a_c2dContext, C2D_RECT *a_clipRect);
-
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source rotation
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_degree is the 32bit value for rotation
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination rotation
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_degree is the 32bit value for rotation
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set alpha blend mode
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_mode is the C2D_ALPHA_BLEND_MODE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBlendMode(C2D_CONTEXT a_c2dContext, C2D_ALPHA_BLEND_MODE a_mode);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set global alpha
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_value is the 32bit value for global alpha, (8bit used -> 0-255)
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetGlobalAlpha(C2D_CONTEXT a_c2dContext, unsigned int a_value);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source colorkey
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_color is the 32bit RGB value for source colorkey, alpha channel ignored
- * \param   a_bEnable, int, enable or disable the use of color key
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination colorkey
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_color, unsigned int, RGB, alpha channel ignored
- * \param   a_bEnable, int, enable or disable the use of color key
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set surface as the current brush
- *
- * \param   a_c2dContext is C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_tilingOffset, C2D_POINT*, offset added to upper left corner of the destination rectangle
- *          for brush aligment. Passing NULL equals to zero offset.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBrushSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_tilingOffset);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set mask surface, if a_c2dSurface is NULL the mask usage is disabled
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is the C2D_SURFACE
- * \param   a_offset, C2D_POINT*, mask offset to use, NULL means no offset
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetMaskSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_offset);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Blits the source surface to the destination surface with current state
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawBlit(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a rectangle,
- *          The dest regtangle is used to set draw coordinates
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawRect(C2D_CONTEXT a_c2dContext, C2D_PARAMETERS a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a line
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS. 
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawLine(C2D_CONTEXT a_c2dContext,
-                               C2D_POINT *a_start, C2D_POINT *a_end,
-                               unsigned int a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a circular or elliptical arc with coordinates from
- *          the destination rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawArc(C2D_CONTEXT a_c2dContext, int a_startAngle, int a_arcAngle, unsigned int a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Flush all the context draws to HW
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dFlush(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Flush all the context draws to HW and waits them to be executed
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dFinish(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Waits for the end-of-pipeline timestamp of the last submitted command buffer
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dWaitForTimestamp(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Get display info, a_displayInfo will be filled with information
- *
- * \param   a_display, C2D_DISPLAY
- * \param   a_displayInfo is the pointer to the C2D_SURFACE_DEF
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dGetDisplayInfo(C2D_DISPLAY a_display, C2D_SURFACE_DEF *a_displayInfo);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set display surface
- *
- * \param   a_display is the C2D_DISPLAY
- * \param   a_c2dSurface is the C2D_SURFACE
- * \param   a_displayConfig is the colorkey enable etc. if supported by diplay controller
- * \param   a_configParam is the colorkey value if supported by display controller
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE a_c2dSurface, unsigned int a_displayConfig, unsigned int a_configParam);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Get current display surface
- *
- * \param   a_display is the C2D_DISPLAY
- * \param   a_c2dSurface is the pointer to the C2D_SURFACE where surface id is stored
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dGetCurrentDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE *a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set dither
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_bEnable int, enable or disable the effect of dither
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDither(C2D_CONTEXT a_c2dContext, int a_bEnable);
-
-C2D_API C2D_STATUS c2dWaitIrq(C2D_CONTEXT a_c2dContext, unsigned int *Count, unsigned int timeout);
-C2D_API C2D_STATUS c2dLibOpen(void);
-C2D_API C2D_STATUS c2dLibClose(void);
-
-C2D_API C2D_STATUS c2dTranslatePhysaddr(void* virtAddr, unsigned int* physAddr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __c2d_api_h_ */
diff --git a/mx5x/libcopybit/copybit.cpp b/mx5x/libcopybit/copybit.cpp
deleted file mode 100755
index d344091..0000000
--- a/mx5x/libcopybit/copybit.cpp
+++ /dev/null
@@ -1,510 +0,0 @@
- /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#define LOG_TAG "copybit"
-
-#include <cutils/log.h>
- 
-#include <c2d_api.h>
-
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-
-#include <hardware/copybit.h>
-
-#include "gralloc_priv.h"
-
-
-/******************************************************************************/
-#define MAX_SCALE_FACTOR    (8)
-#define MDP_ALPHA_NOP 0xff
-/******************************************************************************/
-
-/* mFlags bit define */
-enum {
-    /* flip source image horizontally */
-    C2D_FLIP_H    = HAL_TRANSFORM_FLIP_H,
-    /* flip source image vertically */
-    C2D_FLIP_V    = HAL_TRANSFORM_FLIP_V,
-    /* enable or disable dithering */
-    C2D_DITHER = 0x4,
-    /* enable or disable alpha blend */
-    C2D_ALPHA_BLEND = 0x8,
-};
-
-/** State information for each device instance */
-struct copybit_context_t {
-    struct copybit_device_t device;
-    C2D_CONTEXT c2dctx;
-    int     mCache;
-    uint32_t mAlpha;
-    uint32_t mRotate;    
-    uint32_t mFlags;
-};
-
-
-/**
- * Common hardware methods
- */
-
-static int open_copybit(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device);
-
-static struct hw_module_methods_t copybit_module_methods = {
-    open:  open_copybit
-};
-
-/*
- * The COPYBIT Module
- */
-struct copybit_module_t HAL_MODULE_INFO_SYM = {
-    common: {
-        tag: HARDWARE_MODULE_TAG,
-        version_major: 1,
-        version_minor: 0,
-        id: COPYBIT_HARDWARE_MODULE_ID,
-        name: "C2D Z160 COPYBIT Module",
-        author: "Freescale, Inc.",
-        methods: &copybit_module_methods
-    }
-};
-
-/*****************************************************************************/
-/** check pixel alpha */
-static bool hasAlpha(int format) {
-    switch (format) {
-    case COPYBIT_FORMAT_RGBA_8888:
-    case COPYBIT_FORMAT_BGRA_8888:
-    case COPYBIT_FORMAT_RGBA_5551:
-    case COPYBIT_FORMAT_RGBA_4444:
-        return true;
-    default:
-        return false;
-    }
-}
-
-/** min of int a, b */
-static inline int min(int a, int b) {
-    return (a<b) ? a : b;
-}
-
-/** max of int a, b */
-static inline int max(int a, int b) {
-    return (a>b) ? a : b;
-}
-
-/** scale each parameter by mul/div. Assume div isn't 0 */
-static inline void MULDIV(int *a, int *b, int mul, int div) {
-    if (mul != div) {
-        *a = (mul * *a) / div;
-        *b = (mul * *b) / div;
-    }
-}
-
-/** Determine the intersection of lhs & rhs store in out */
-static void intersect(struct copybit_rect_t *out,
-                      const struct copybit_rect_t *lhs,
-                      const struct copybit_rect_t *rhs) {
-    out->l = max(lhs->l, rhs->l);
-    out->t = max(lhs->t, rhs->t);
-    out->r = min(lhs->r, rhs->r);
-    out->b = min(lhs->b, rhs->b);
-}
-
-/** Set a parameter to value */
-static int set_parameter_copybit(
-        struct copybit_device_t *dev,
-        int name,
-        int value) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    int status = 0;
-    if (ctx) {
-        switch(name) {
-        case COPYBIT_ROTATION_DEG:
-            switch (value) {
-            case 0:
-            case 90:
-            case 180:
-            case 270:
-                ctx->mRotate = value;
-                break;
-            default:
-                ALOGE("Invalid value for COPYBIT_ROTATION");
-                status = -EINVAL;
-                break;
-            }
-            break;
-        case COPYBIT_PLANE_ALPHA:
-            if (value < 0)      value = 0;
-            if (value >= 256)   value = 255;
-                ctx->mAlpha = value;
-            break;
-        case COPYBIT_DITHER:
-            if (value == COPYBIT_ENABLE) {
-                ctx->mFlags |= C2D_DITHER;
-            } else if (value == COPYBIT_DISABLE) {
-                ctx->mFlags &= ~C2D_DITHER;
-            }
-            break;
-        case COPYBIT_TRANSFORM:
-            switch (value) {
-            case 0:
-                ctx->mRotate = 0;
-                break;            
-            case COPYBIT_TRANSFORM_ROT_90:
-                ctx->mRotate = 90;
-                break;
-            case COPYBIT_TRANSFORM_ROT_180:
-                ctx->mRotate = 180;
-                break;
-            case COPYBIT_TRANSFORM_ROT_270:
-                ctx->mRotate = 270;
-                break;
-            case COPYBIT_TRANSFORM_FLIP_H:
-                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
-                ctx->mFlags |= C2D_FLIP_H;
-                break;
-            case COPYBIT_TRANSFORM_FLIP_V:
-                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
-                ctx->mFlags |= C2D_FLIP_V;
-                break;
-            default:
-                ALOGE("Invalid value for COPYBIT_ROTATION");
-                status = -EINVAL;
-                break;
-            }
-            break;        
-        case COPYBIT_BLUR:
-            ALOGE("Not support for COPYBIT_BLUR");
-            status = -EINVAL;
-            break;
-        default:
-            status = -EINVAL;
-            break;
-        }
-    } else {
-        status = -EINVAL;
-    }
-    return status;
-}
-
-/** Get a static info value */
-static int get(struct copybit_device_t *dev, int name) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    int value;
-    if (ctx) {
-        switch(name) {
-        case COPYBIT_MINIFICATION_LIMIT:
-            value = MAX_SCALE_FACTOR;
-            break;
-        case COPYBIT_MAGNIFICATION_LIMIT:
-            value = MAX_SCALE_FACTOR;
-            break;
-        case COPYBIT_SCALING_FRAC_BITS:
-            value = 32;
-            break;
-        case COPYBIT_ROTATION_STEP_DEG:
-            value = 90;
-            break;
-        default:
-            value = -EINVAL;
-        }
-    } else {
-        value = -EINVAL;
-    }
-    return value;
-}
-
-/** convert COPYBIT_FORMAT to C2D format */
-static C2D_COLORFORMAT get_format(int format) {
-    switch (format) {
-	case COPYBIT_FORMAT_RGBA_8888:     return C2D_COLOR_8888_ABGR;    
-    case COPYBIT_FORMAT_RGB_565:       return C2D_COLOR_0565;
-    case COPYBIT_FORMAT_RGBA_5551:     return C2D_COLOR_5551_RGBA;
-    case COPYBIT_FORMAT_RGBA_4444:     return C2D_COLOR_4444_RGBA;
-    case COPYBIT_FORMAT_RGBX_8888:	   return C2D_COLOR_8888_ABGR; //work-around, C2D does not support RGBX
-    case COPYBIT_FORMAT_RGB_888:
-	   return C2D_COLOR_888; //work-around, C2D supports BGR not RGB in this case
-    case COPYBIT_FORMAT_BGRA_8888:	   return C2D_COLOR_8888;//work-around, C2D supports ARGB not BGRA in this case
-    case COPYBIT_FORMAT_YCbCr_422_SP:  
-    case COPYBIT_FORMAT_YCbCr_420_SP:
- 
-    default:                           return C2D_COLOR_0565;//work-around, C2D does not support YCbCr   
-    }
-}
-
-/** get  pixelbit from COPYBIT_FORMAT format */
-static int get_pixelbit(int format) {
-    switch (format) {
-    case COPYBIT_FORMAT_RGBA_8888:
-    case COPYBIT_FORMAT_RGBX_8888:
-    case COPYBIT_FORMAT_BGRA_8888:     return 32;
-    case COPYBIT_FORMAT_RGB_888:       return 24;
-    case COPYBIT_FORMAT_RGB_565:
-    case COPYBIT_FORMAT_RGBA_5551:
-    case COPYBIT_FORMAT_RGBA_4444:     return 16;
-    case COPYBIT_FORMAT_YCbCr_422_SP:
-    case COPYBIT_FORMAT_YCbCr_420_SP:
-    default:                           return 8;
-    }
-}
-
-/** do convert of image to c2d surface **/
-static void image_to_surface(copybit_image_t const *img, C2D_SURFACE_DEF *surfaceDef) 
-{
-    private_handle_t* hnd = (private_handle_t*)img->handle;
-    surfaceDef->format = get_format(img->format);
-    surfaceDef->width =  img->w;
-    surfaceDef->height = img->h;
-
-	//make sure stride is 32 pixel aligned
-    surfaceDef->stride = ((img->w + 31) & ~31)*get_pixelbit(img->format)>>3;
-
-    surfaceDef->buffer = (void *)hnd->phys;
-    surfaceDef->host = (void *)hnd->base;
-    surfaceDef->flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-}
-
-/** setup rectangles */
-static void set_rects(struct copybit_context_t *dev,
-                      C2D_RECT *srcRect,
-                      C2D_RECT *dstRect,
-                      const struct copybit_rect_t *dst,
-                      const struct copybit_rect_t *src,
-                      const struct copybit_rect_t *scissor,
-                      copybit_image_t const *img) {
-    struct copybit_rect_t clip;
-    intersect(&clip, scissor, dst);
-
-    dstRect->x  = clip.l;
-    dstRect->y  = clip.t;
-    dstRect->width  = clip.r - clip.l;
-    dstRect->height  = clip.b - clip.t;
-
-    uint32_t W, H;
-    if ((dev->mRotate == 90) || ((dev->mRotate == 270))) {
-        srcRect->x = (clip.t - dst->t) + src->t;
-        srcRect->y = (dst->r - clip.r) + src->l;
-        srcRect->width = (clip.b - clip.t);
-        srcRect->height = (clip.r - clip.l);
-        W = dst->b - dst->t;
-        H = dst->r - dst->l;
-    } else {
-        srcRect->x  = (clip.l - dst->l) + src->l;
-        srcRect->y  = (clip.t - dst->t) + src->t;
-        srcRect->width  = (clip.r - clip.l);
-        srcRect->height  = (clip.b - clip.t);
-        W = dst->r - dst->l;
-        H = dst->b - dst->t;
-    }
-    MULDIV(&srcRect->x, &srcRect->width, src->r - src->l, W);
-    MULDIV(&srcRect->y, &srcRect->height, src->b - src->t, H);
-
-    if ((dev->mRotate == 180) || ((dev->mRotate == 270))) {
-        srcRect->y = src->b - src->t - (srcRect->y + srcRect->height);
-        srcRect->x = src->r - src->l - (srcRect->x + srcRect->width);
-    }
-}
-
-/** do a stretch blit type operation */
-static int stretch_copybit(
-        struct copybit_device_t *dev,
-        struct copybit_image_t const *dst,
-        struct copybit_image_t const *src,
-        struct copybit_rect_t const *dst_rect,
-        struct copybit_rect_t const *src_rect,
-        struct copybit_region_t const *region) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    C2D_SURFACE_DEF srcSurfaceDef;
-    C2D_SURFACE_DEF dstSurfaceDef;
-    C2D_SURFACE srcSurface;
-    C2D_SURFACE dstSurface;    
-    C2D_RECT srcRect;
-    C2D_RECT dstRect;
-    int status = 0;
-
-    if (ctx) {
-        if (ctx->mAlpha < 255) {
-            switch (src->format) {
-                // we don't support plane alpha with below formats
-                case COPYBIT_FORMAT_RGBX_8888:
-                case COPYBIT_FORMAT_RGB_888:
-                case COPYBIT_FORMAT_BGRA_8888:
-                case COPYBIT_FORMAT_YCbCr_422_SP:
-                case COPYBIT_FORMAT_YCbCr_420_SP:
-                    return -EINVAL;
-            }
-        }
-
-        if (src_rect->l < 0 || src_rect->r > src->w ||
-            src_rect->t < 0 || src_rect->b > src->h) {
-            // this is always invalid
-            ALOGE("src_rect invalid");
-            return -EINVAL;
-        }
-
-        const struct copybit_rect_t bounds = { 0, 0, dst->w, dst->h };
-        struct copybit_rect_t clip;
-        status = 0;
-
-
-        image_to_surface(src, &srcSurfaceDef);
-        if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
-        {
-            ALOGE("srcSurface c2dSurfAlloc fail");
-            return -EINVAL;
-        }
-                
-        image_to_surface(dst, &dstSurfaceDef);
-        if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
-        {
-            ALOGE("dstSurface c2dSurfAlloc fail");
-            c2dSurfFree(ctx->c2dctx, srcSurface);
-            return -EINVAL;
-        }
-
-
-        c2dSetSrcSurface(ctx->c2dctx, srcSurface);
-        c2dSetDstSurface(ctx->c2dctx, dstSurface); 
-        c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
-        
-
-        //if (hasAlpha(src->format) || hasAlpha(dst->format))
-        if (hasAlpha(src->format) && (ctx->mFlags & C2D_ALPHA_BLEND))
-                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_SRCOVER);
-        else
-                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);
-                   
-        c2dSetGlobalAlpha(ctx->c2dctx, ctx->mAlpha);  
-        c2dSetDither(ctx->c2dctx, (ctx->mFlags & C2D_DITHER) > 0 ? 1:0); 
-
-        while ((status == 0) && region->next(region, &clip)) {          
-                intersect(&clip, &bounds, &clip);
-                set_rects(ctx, &srcRect, &dstRect, dst_rect, src_rect, &clip, src);
-                if (srcRect.width<=0 || srcRect.height<=0)
-                {
-                        ALOGE("srcRect invalid");
-                        continue;
-                }
-                if (dstRect.width<=0 || dstRect.height<=0)
-                {
-                        ALOGE("dstRect invalid");
-                        continue;
-                }
-
-                c2dSetSrcRectangle(ctx->c2dctx, &srcRect);
-                c2dSetDstRectangle(ctx->c2dctx, &dstRect);      
-                c2dDrawBlit(ctx->c2dctx); 
-        }
-
-		c2dFinish(ctx->c2dctx);
-		c2dSurfFree(ctx->c2dctx, srcSurface);
-		c2dSurfFree(ctx->c2dctx, dstSurface);
-
-    } 
-    else {
-        status = -EINVAL;
-    }
-
-
-    return status;
-}
-
-/** Perform a blit type operation */
-/* Pay attention, from now on blit_copybit will only work on C2D_ALPHA_BLEND_NONE mode,
- if need C2D_ALPHA_BLEND_SRCOVER mode pls use stretch_copybit */
-static int blit_copybit(
-        struct copybit_device_t *dev,
-        struct copybit_image_t const *dst,
-        struct copybit_image_t const *src,
-        struct copybit_region_t const *region) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    struct copybit_rect_t dr = { 0, 0, dst->w, dst->h };
-    struct copybit_rect_t sr = { 0, 0, src->w, src->h };
-    if (ctx->mFlags & C2D_ALPHA_BLEND)
-    {
-        int status = 0;
-        ctx->mFlags &= ~C2D_ALPHA_BLEND;
-        status = stretch_copybit(dev, dst, src, &dr, &sr, region);
-        ctx->mFlags |= C2D_ALPHA_BLEND;
-        return status;
-    }
-    else
-        return stretch_copybit(dev, dst, src, &dr, &sr, region);
-}
-
-/*****************************************************************************/
-
-/** Close the copybit device */
-static int close_copybit(struct hw_device_t *dev) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    if (ctx) {
-        C2D_STATUS c2dstatus;
-        if (ctx->c2dctx != NULL)
-        	c2dstatus = c2dDestroyContext(ctx->c2dctx);
-        free(ctx);
-    }
-    return 0;
-}
-
-/** Open a new instance of a copybit device using name */
-static int open_copybit(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device)
-{
-    int status = -EINVAL;
-       
-    copybit_context_t *ctx;
-    ctx = (copybit_context_t *)malloc(sizeof(copybit_context_t));
-    memset(ctx, 0, sizeof(*ctx));
-
-    ctx->device.common.tag = HARDWARE_DEVICE_TAG;
-    ctx->device.common.version = 1;
-    ctx->device.common.module = const_cast<hw_module_t*>(module);
-    ctx->device.common.close = close_copybit;
-    ctx->device.set_parameter = set_parameter_copybit;
-    ctx->device.get = get;
-    ctx->device.blit = blit_copybit;
-    ctx->device.stretch = stretch_copybit;
-    ctx->mAlpha = MDP_ALPHA_NOP;
-    ctx->mFlags |= C2D_ALPHA_BLEND;
-     
-    C2D_STATUS c2dstatus;
-    c2dstatus = c2dCreateContext(&ctx->c2dctx);
-    if (c2dstatus != C2D_STATUS_OK)
-        close_copybit(&ctx->device.common);
-    else
-    {
-        *device = &ctx->device.common;
-        status = 0;
-    }
-
-    return status;
-}
diff --git a/mx5x/libgralloc/Android.mk b/mx5x/libgralloc/Android.mk
deleted file mode 100644
index 4099eb6..0000000
--- a/mx5x/libgralloc/Android.mk
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-
-ifeq ($(TARGET_HAVE_IMX_GRALLOC), true)
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := true
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libcutils libGLESv1_CM libipu libion
-LOCAL_SHARED_LIBRARIES += libc2d_z430
-LOCAL_C_INCLUDES += external/linux-lib/ipu
-LOCAL_C_INCLUDES += hardware/imx/mx5x/libcopybit
-
-LOCAL_SRC_FILES := 	\
-	gralloc.cpp 	\
-	framebuffer.cpp \
-	mapper.cpp
-LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
-LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).gralloc\" -D_LINUX -Wno-missing-field-initializers
-
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif
diff --git a/mx5x/libgralloc/framebuffer.cpp b/mx5x/libgralloc/framebuffer.cpp
deleted file mode 100644
index 1c5ca14..0000000
--- a/mx5x/libgralloc/framebuffer.cpp
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <fcntl.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <linux/fb.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <sys/mman.h>
-
-#include <GLES/gl.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-#include <cutils/log.h>
-#include <hardware/gralloc.h>
-#include <hardware/hardware.h>
-
-#include "gralloc_priv.h"
-#include "gr.h"
-#define  MAX_RECT_NUM   20
-
-// numbers of buffers for page flipping
-#define NUM_BUFFERS 3
-
-enum {
-    PAGE_FLIP = 0x00000001,
-    LOCKED = 0x00000002
-};
-
-struct fb_context_t {
-    framebuffer_device_t  device;
-};
-
-static int nr_framebuffers;
-static int no_ipu = 0;
-
-sem_t * fslwatermark_sem_open()
-{
-    int fd;
-    int ret;
-    sem_t *pSem = NULL;
-    char *shm_path, shm_file[256];
-
-    shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */ 
-
-    if (shm_path == NULL)
-        strcpy(shm_file, "/dev/shm");   /* default path */
-    else
-        strcpy(shm_file, shm_path);
-
-    strcat(shm_file, "/"); 
-    strcat(shm_file, "codec.shm");
-
-    fd = open(shm_file, O_RDWR, 0666);
-    if (fd < 0) { 
-        /* first thread/process need codec protection come here */
-        fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0666);
-       if(fd < 0)
-       {
-           return NULL;
-       }
-       /* Change permissions of shmem, so that other process can access it */
-       chmod(shm_file, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
-       ftruncate(fd, sizeof(sem_t));
-
-       /* map the semaphore variant in the file */ 
-       pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-       if((void *)(-1) == pSem)
-       {
-           return NULL;
-       }
-       /* do the semaphore initialization */
-       ret = sem_init(pSem, 0, 1);
-       if(-1 == ret)
-       {
-           return NULL;
-       }
-    }
-    else
-      pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-
-    close(fd);
-
-    return pSem;
-}
-
-static int fb_setSwapInterval(struct framebuffer_device_t* dev,
-            int interval)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
-        return -EINVAL;
-    // FIXME: implement fb_setSwapInterval
-    return 0;
-}
-
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int l, int t, int w, int h)
-{
-    if (((w|h) <= 0) || ((l|t)<0))
-        return -EINVAL;
-    return 0;
-}
-
-static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
-{
-    if (!buffer)
-        return -EINVAL;
-
-    fb_context_t* ctx = (fb_context_t*)dev;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    if (m->currentBuffer) {
-        m->base.unlock(&m->base, m->currentBuffer);
-        m->currentBuffer = 0;
-    }
-
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-
-        void *vaddr = NULL;
-        m->base.lock(&m->base, buffer, 
-                private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), &vaddr);
-
-        const size_t offset = hnd->base - m->framebuffer->base;
-        m->info.activate = FB_ACTIVATE_VBL;
-        m->info.yoffset = offset / m->finfo.line_length;
-
-        if (ioctl(m->framebuffer->fd, FBIOPAN_DISPLAY, &m->info) == -1) {
-            ALOGE("FBIOPAN_DISPLAY failed");
-            m->base.unlock(&m->base, buffer); 
-            return -errno;
-        }
-
-        m->currentBuffer = buffer;
-        
-    } else {
-        // If we can't do the page_flip, just copy the buffer to the front 
-        // FIXME: use copybit HAL instead of memcpy
-        
-        void* fb_vaddr;
-        void* buffer_vaddr;
-        
-        m->base.lock(&m->base, m->framebuffer, 
-                GRALLOC_USAGE_SW_WRITE_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &fb_vaddr);
-
-        m->base.lock(&m->base, buffer, 
-                GRALLOC_USAGE_SW_READ_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &buffer_vaddr);
-
-        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres));
-
-        m->base.unlock(&m->base, buffer); 
-        m->base.unlock(&m->base, m->framebuffer); 
-    }
-    
-    return 0;
-}
-
-static int fb_compositionComplete(struct framebuffer_device_t* dev)
-{
-    glFinish();
-    return 0;
-}
-
-int mapFrameBufferLocked(struct private_module_t* module)
-{
-    // already initialized...
-    if (module->framebuffer) {
-        return 0;
-    }
-        
-    char const * const device_template[] = {
-            "/dev/graphics/fb%u",
-            "/dev/fb%u",
-            0 };
-
-    int fd = -1;
-    int i=0;
-    char name[64];
-
-    while ((fd==-1) && device_template[i]) {
-        snprintf(name, 64, device_template[i], 0);
-        fd = open(name, O_RDWR, 0);
-        i++;
-    }
-
-    if (fd < 0)
-        return -errno;
-
-    struct fb_fix_screeninfo finfo;
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    struct fb_var_screeninfo info;
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-
-    if(info.bits_per_pixel == 32){
-        ALOGW("32bpp setting of Framebuffer catched!");
-        /*
-         * Explicitly request RGBA 8/8/8/8
-         */
-        info.bits_per_pixel = 32;
-        info.red.offset     = 0;
-        info.red.length     = 8;
-        info.red.msb_right    = 0;
-        info.green.offset     = 8;
-        info.green.length     = 8;
-        info.green.msb_right  = 0;
-        info.blue.offset      = 16;
-        info.blue.length      = 8;
-        info.blue.msb_right   = 0;
-        info.transp.offset    = 24;
-        info.transp.length    = 8;
-        info.transp.msb_right = 0;
-    }
-    else{
-        /*
-         * Explicitly request 5/6/5
-         */
-        info.bits_per_pixel   = 16;
-        info.red.offset       = 11;
-        info.red.length       = 5;
-        info.red.msb_right    = 0;
-        info.green.offset     = 5;
-        info.green.length     = 6;
-        info.green.msb_right  = 0;
-        info.blue.offset      = 0;
-        info.blue.length      = 5;
-        info.blue.msb_right   = 0;
-        info.transp.offset    = 0;
-        info.transp.length    = 0;
-        info.transp.msb_right = 0;
-
-    }
-
-    /*
-     * Request nr_framebuffers screens (at lest 2 for page flipping)
-     */
-    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
-    info.xres_virtual = ALIGN_PIXEL(info.xres);
-    
-    uint32_t flags = PAGE_FLIP;
-    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        ALOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
-    }
-
-    if (info.yres_virtual < ALIGN_PIXEL_128(info.yres) * 2) {
-        // we need at least 2 for page-flipping
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        ALOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
-                info.yres_virtual, ALIGN_PIXEL_128(info.yres)*2);
-    }
-
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1) {
-        ALOGE("<%s,%d> FBIOGET_VSCREENINFO failed", __FUNCTION__, __LINE__);
-        return -errno;
-    }
-
-    int refreshRate = 1000000000000000LLU /
-    (
-            uint64_t(info.upper_margin + info.lower_margin + info.yres + info.vsync_len)
-            * (info.left_margin  + info.right_margin + info.xres + info.hsync_len)
-            * info.pixclock
-    );
-
-    if (refreshRate == 0) {
-        // bleagh, bad info from the driver
-        refreshRate = 60*1000;  // 60 Hz
-    }
-
-    if (int(info.width) <= 0 || int(info.height) <= 0) {
-        // the driver doesn't return that information
-        // default to 160 dpi
-        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
-        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
-    }
-
-    float xdpi = (info.xres * 25.4f) / info.width;
-    float ydpi = (info.yres * 25.4f) / info.height;
-    float fps  = refreshRate / 1000.0f;
-
-    ALOGI(   "using (fd=%d)\n"
-            "id           = %s\n"
-            "xres         = %d px\n"
-            "yres         = %d px\n"
-            "xres_virtual = %d px\n"
-            "yres_virtual = %d px\n"
-            "bpp          = %d\n"
-            "r            = %2u:%u\n"
-            "g            = %2u:%u\n"
-            "b            = %2u:%u\n",
-            fd,
-            finfo.id,
-            info.xres,
-            info.yres,
-            info.xres_virtual,
-            info.yres_virtual,
-            info.bits_per_pixel,
-            info.red.offset, info.red.length,
-            info.green.offset, info.green.length,
-            info.blue.offset, info.blue.length
-    );
-
-    ALOGI(   "width        = %d mm (%f dpi)\n"
-            "height       = %d mm (%f dpi)\n"
-            "refresh rate = %.2f Hz\n",
-            info.width,  xdpi,
-            info.height, ydpi,
-            fps
-    );
-
-
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    if (finfo.smem_len <= 0)
-        return -errno;
-
-
-    module->flags = flags;
-    module->info = info;
-    module->finfo = finfo;
-    module->xdpi = xdpi;
-    module->ydpi = ydpi;
-    module->fps = fps;
-
-    /*
-     * map the framebuffer
-     */
-
-    int err;
-    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-    module->framebuffer = new private_handle_t(dup(fd), fbSize,
-            private_handle_t::PRIV_FLAGS_USES_ION);
-
-    module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
-    module->bufferMask = 0;
-
-    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
-    if (vaddr == MAP_FAILED) {
-        ALOGE("Error mapping the framebuffer (%s)", strerror(errno));
-        return -errno;
-    }
-    module->framebuffer->base = intptr_t(vaddr);
-    module->framebuffer->phys = intptr_t(finfo.smem_start);
-    memset(vaddr, 0, fbSize);
-    return 0;
-}
-
-static int mapFrameBuffer(struct private_module_t* module)
-{
-    pthread_mutex_lock(&module->lock);
-    int err = mapFrameBufferLocked(module);
-    pthread_mutex_unlock(&module->lock);
-    return err;
-}
-
-static int fb_close(struct hw_device_t *dev)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (ctx) {
-        free(ctx);
-    }
-    return 0;
-}
-
-int fb_device_open(hw_module_t const* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-
-    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
-        alloc_device_t* gralloc_device;
-        framebuffer_device_t *fbdev;
-
-        status = gralloc_open(module, &gralloc_device);
-        if (status < 0)
-            return status;
-
-        /* initialize our state here */
-        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = fb_close;
-        dev->device.setSwapInterval = fb_setSwapInterval;
-        dev->device.post            = fb_post;
-        dev->device.setUpdateRect = fb_setUpdateRect;
-        dev->device.compositionComplete = fb_compositionComplete;
-
-        private_module_t* m = (private_module_t*)module;
-        status = mapFrameBuffer(m);
-        if (status >= 0) {
-            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
-            const_cast<uint32_t&>(dev->device.flags) = 0xfb0;
-            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
-            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
-            const_cast<int&>(dev->device.stride) = stride;
-            if(m->info.bits_per_pixel != 32) {
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
-            }
-            else{
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGBA_8888;
-            }
-            const_cast<float&>(dev->device.xdpi) = m->xdpi;
-            const_cast<float&>(dev->device.ydpi) = m->ydpi;
-            const_cast<float&>(dev->device.fps) = m->fps;
-            const_cast<int&>(dev->device.minSwapInterval) = 1;
-            const_cast<int&>(dev->device.maxSwapInterval) = 1;
-            const_cast<int&>(dev->device.numFramebuffers) = NUM_BUFFERS;
-            *device = &dev->device.common;
-            fbdev = (framebuffer_device_t*) *device;
-      }
-
-    fslwatermark_sem_open();
-
-    }
-    return status;
-}
diff --git a/mx5x/libgralloc/gr.h b/mx5x/libgralloc/gr.h
deleted file mode 100644
index b2e60fd..0000000
--- a/mx5x/libgralloc/gr.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef GR_H_
-#define GR_H_
-
-#include <asm/page.h>
-#include <pthread.h>
-
-struct private_module_t;
-struct private_handle_t;
-
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-int mapFrameBufferLocked(struct private_module_t* module);
-int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
-
-class Locker {
-    pthread_mutex_t mutex;
-public:
-    class Autolock {
-        Locker& locker;
-    public:
-        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
-        inline ~Autolock() { locker.unlock(); }
-    };
-    inline Locker()        { pthread_mutex_init(&mutex, 0); }
-    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
-    inline void lock()     { pthread_mutex_lock(&mutex); }
-    inline void unlock()   { pthread_mutex_unlock(&mutex); }
-};
-#endif /* GR_H_ */
diff --git a/mx5x/libgralloc/gralloc.cpp b/mx5x/libgralloc/gralloc.cpp
deleted file mode 100644
index 991c7f6..0000000
--- a/mx5x/libgralloc/gralloc.cpp
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2013 Freescale Semiconductor, Inc. */
-
-#include <limits.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-#include "gr.h"
-
-#include <ion/ion.h>
-
-/*****************************************************************************/
-
-struct gralloc_context_t {
-    alloc_device_t  device;
-    /* our private data here */
-};
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle);
-
-/*****************************************************************************/
-
-int fb_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-static int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-extern int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr);
-
-extern int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle);
-
-extern int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-extern int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-extern int gralloc_perform(struct gralloc_module_t const* module,
-                           int operation, ... );
-
-/*****************************************************************************/
-
-static struct hw_module_methods_t gralloc_module_methods = {
-        open: gralloc_device_open
-};
-
-struct private_module_t HAL_MODULE_INFO_SYM = {
-    base: {
-        common: {
-            tag: HARDWARE_MODULE_TAG,
-            version_major: 1,
-            version_minor: 0,
-            id: GRALLOC_HARDWARE_MODULE_ID,
-            name: "Graphics Memory Allocator Module",
-            author: "The Android Open Source Project",
-            methods: &gralloc_module_methods,
-            dso: 0,
-            reserved: {0},
-        },
-        registerBuffer: gralloc_register_buffer,
-        unregisterBuffer: gralloc_unregister_buffer,
-        lock: gralloc_lock,
-        unlock: gralloc_unlock,
-        perform: gralloc_perform,
-        lock_ycbcr: 0,
-        reserved_proc: {0},
-    },
-    framebuffer: 0,
-    flags: 0,
-    numBuffers: 0,
-    bufferMask: 0,
-    lock: PTHREAD_MUTEX_INITIALIZER,
-    currentBuffer: 0,
-    ion_master: -1,
-    master_phys: 0,
-};
-
-#define ION_GPU_POOL_ID 2
-
-/*****************************************************************************/
-
-static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-
-    // allocate the framebuffer
-    if (m->framebuffer == NULL) {
-        // initialize the framebuffer, the framebuffer is mapped once
-        // and forever.
-        int err = mapFrameBufferLocked(m);
-        if (err < 0) {
-            return err;
-        }
-    }
-
-    const uint32_t bufferMask = m->bufferMask;
-    const uint32_t numBuffers = m->numBuffers;
-    const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-    if (numBuffers == 1) {
-        // If we have only one buffer, we never use page-flipping. Instead,
-        // we return a regular buffer which will be memcpy'ed to the main
-        // screen when post is called.
-        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
-        pthread_mutex_unlock(&m->lock);
-        int ret = gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);
-        pthread_mutex_lock(&m->lock);
-        return ret;
-    }
-
-    if (bufferMask >= ((1LU<<numBuffers)-1)) {
-        // We ran out of buffers.
-        return -ENOMEM;
-    }
-
-    // create a "fake" handles for it
-    intptr_t vaddr = intptr_t(m->framebuffer->base);
-    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer->fd), size,
-            private_handle_t::PRIV_FLAGS_USES_ION |
-            private_handle_t::PRIV_FLAGS_FRAMEBUFFER);
-
-    // find a free slot
-    for (uint32_t i=0 ; i<numBuffers ; i++) {
-        if ((bufferMask & (1LU<<i)) == 0) {
-            m->bufferMask |= (1LU<<i);
-            break;
-        }
-        vaddr += bufferSize;
-    }
-    
-    hnd->base = vaddr;
-    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
-    hnd->phys = intptr_t(m->framebuffer->phys) + hnd->offset;
-    *pHandle = hnd;
-
-    return 0;
-}
-
-static int gralloc_alloc_framebuffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    pthread_mutex_lock(&m->lock);
-    int err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int init_ion_area_locked(private_module_t* m)
-{
-    int err = 0;
-    int master_fd = ion_open();
-    if (master_fd >= 0) {
-        m->ion_master = master_fd;
-    } else {
-        err = -errno;
-    }
-    return err;
-}
-
-static int init_ion_area(private_module_t* m)
-{
-    pthread_mutex_lock(&m->lock);
-    int err = m->ion_master;
-    if (err == -1) {
-        // first time, try to initialize ion
-        err = init_ion_area_locked(m);
-        if (err) {
-            m->ion_master = err;
-        }
-    } else if (err < 0) {
-        // ion couldn't be initialized, never use it
-    } else {
-        // ion OK
-        err = 0;
-    }
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    int err = 0;
-    int flags = 0;
-
-    int fd = -1;
-    void* base = 0;
-    int offset = 0;
-    int lockState = 0;
-    void *buffer_handle = NULL;
-
-    size = roundUpToPageSize(size);
-
-    if (usage & GRALLOC_USAGE_HW_TEXTURE) {
-        // enable ion in that case, so our software GL can fallback to
-        // the copybit module.
-        flags |= private_handle_t::PRIV_FLAGS_USES_ION;
-    }
-    
-    if (usage & GRALLOC_USAGE_HW_2D) {
-        flags |= private_handle_t::PRIV_FLAGS_USES_ION;
-    }
-
-    /* If not ION, try ashmem */
-    if ((flags & private_handle_t::PRIV_FLAGS_USES_ION) == 0) {
-try_ashmem:
-        fd = ashmem_create_region("gralloc-buffer", size);
-        if (fd < 0) {
-            ALOGE("couldn't create ashmem (%s)", strerror(-errno));
-            err = -errno;
-        }
-    } else {
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-
-        err = init_ion_area(m);
-        if (err == 0) {
-            struct ion_handle *handle, *alloc_handle;
-            unsigned char *base = 0;
-
-            err = ion_alloc(m->ion_master, size, PAGE_SIZE, ION_GPU_POOL_ID, &handle);
-            if(err < 0) {
-                ALOGE("Cannot allocate ion size = %d err = %d", size, err);
-                return err;
-            }
-
-            alloc_handle = handle;
-            buffer_handle = (void*)handle;
-
-            err = ion_share(m->ion_master, handle, &fd);
-            if(err < 0) {
-                ALOGE("Cannot share ion handle = %p err = %d", handle, err);
-                return err;
-            }
-
-            m->master_phys = ion_phys(m->ion_master, handle);
-            if(m->master_phys == 0) {
-                ALOGE("Cannot get physical for ion handle = %p", handle);
-                return -errno;
-            }
-
-            err = ion_free(m->ion_master, alloc_handle);
-            if(err < 0) {
-                ALOGE("Cannot free ion handle = %p err = %d", alloc_handle, err);
-                return err;
-            }
-        } else {
-            if ((usage & GRALLOC_USAGE_HW_2D) == 0) {
-                // the caller didn't request ION, so we can try something else
-                flags &= ~private_handle_t::PRIV_FLAGS_USES_ION;
-                err = 0;
-                goto try_ashmem;
-            } else {
-                ALOGE("couldn't open ion (%s)", strerror(-errno));
-            }
-        }
-    }
-
-    if (err == 0) {
-        private_handle_t* hnd = new private_handle_t(fd, size, flags);
-        hnd->offset = 0 ;
-        hnd->base = int(base);
-        hnd->lockState = lockState;
-        hnd->handle = buffer_handle;
-        if (flags & private_handle_t::PRIV_FLAGS_USES_ION) {
-            private_module_t* m = reinterpret_cast<private_module_t*>(
-                    dev->common.module);
-            hnd->phys = m->master_phys;
-        }
-        *pHandle = hnd;
-    }
-
-    ALOGE_IF(err, "gralloc failed err=%s", strerror(-err));
-    
-    return err;
-}
-
-/*****************************************************************************/
-
-static int gralloc_alloc(alloc_device_t* dev,
-        int w, int h, int format, int usage,
-        buffer_handle_t* pHandle, int* pStride)
-{
-    if (!pHandle || !pStride)
-        return -EINVAL;
-
-    size_t size, alignedw, alignedh;
-    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || format == HAL_PIXEL_FORMAT_YCbCr_422_I ||
-        format == HAL_PIXEL_FORMAT_YCbCr_422_SP ||
-        format == HAL_PIXEL_FORMAT_YV12         || format == HAL_PIXEL_FORMAT_YCbCr_420_P ||
-        format == HAL_PIXEL_FORMAT_YCbCr_422_P)
-    {
-        int luma_size;
-        int chroma_size;
-
-        // FIXME: there is no way to return the alignedh
-        // Aligning height and width to 64 forces 4096 alignment of chroma
-        // buffer assuming that the luma starts with 4096 alignment or higher.
-        // This is required for GPU rendering in ICS for iMX5.
-        alignedw = ALIGN_PIXEL_64(w);
-        alignedh = ALIGN_PIXEL_64(h);
-        luma_size = ALIGN_PIXEL_4096(alignedw * alignedh);
-        switch (format) {
-            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-            case HAL_PIXEL_FORMAT_YCbCr_422_I:
-            case HAL_PIXEL_FORMAT_YCbCr_422_P:
-                chroma_size = ALIGN_PIXEL_4096( (alignedw * alignedh) / 2) * 2;
-                break;
-            case HAL_PIXEL_FORMAT_YCbCr_420_SP: //NV21
-            case HAL_PIXEL_FORMAT_YCbCr_420_P:
-            case HAL_PIXEL_FORMAT_YV12:
-                chroma_size = ALIGN_PIXEL_4096(alignedw/2 * alignedh/2) * 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-        size = luma_size + chroma_size;
-    } else {
-        alignedw = ALIGN_PIXEL(w);
-        alignedh = ALIGN_PIXEL(h);
-        int bpp = 0;
-        switch (format) {
-            case HAL_PIXEL_FORMAT_RGBA_8888:
-            case HAL_PIXEL_FORMAT_RGBX_8888:
-            case HAL_PIXEL_FORMAT_BGRA_8888:
-                bpp = 4;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_888:
-                bpp = 3;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_565:
-            case HAL_PIXEL_FORMAT_RGBA_5551:
-            case HAL_PIXEL_FORMAT_RGBA_4444:
-                bpp = 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-        size = alignedw * alignedh * bpp;
-    }
-
-    int err;
-    if (usage & GRALLOC_USAGE_HW_FB) {
-        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);
-    } else {
-        err = gralloc_alloc_buffer(dev, size, usage, pHandle);
-    }
-
-    if (err < 0) {
-        return err;
-    }
-
-    private_handle_t* hnd = (private_handle_t*)(*pHandle);
-    hnd->usage = usage;
-    hnd->format = format;
-    hnd->width = alignedw;
-    hnd->height = alignedh;
-
-    *pStride = alignedw;
-    return 0;
-}
-
-static int gralloc_free(alloc_device_t* dev,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-        // free this buffer
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-        const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-        int index = (hnd->base - m->framebuffer->base) / bufferSize;
-        m->bufferMask &= ~(1<<index); 
-    } else {
-        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>(
-                dev->common.module);
-        terminateBuffer(module, const_cast<private_handle_t*>(hnd));
-        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION) {
-            int fd = ion_open();
-            ion_import(fd, hnd->fd, (struct ion_handle **)&hnd->handle);
-            if(munmap((void *)hnd->base, hnd->size)) {
-                ALOGE("Failed to unmap at %p : %s", (void*)hnd->base, strerror(errno));
-            }
-            ion_free(fd,(struct ion_handle *)hnd->handle);
-            close(fd);
-        }
-
-    }
-
-    close(hnd->fd);
-    delete hnd;
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int gralloc_close(struct hw_device_t *dev)
-{
-    gralloc_context_t* ctx = reinterpret_cast<gralloc_context_t*>(dev);
-    if (ctx) {
-        /* TODO: keep a list of all buffer_handle_t created, and free them
-         * all here.
-         */
-        free(ctx);
-    }
-    return 0;
-}
-
-int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    hw_module_t *hw = const_cast<hw_module_t *>(module);
-    private_module_t* m = reinterpret_cast<private_module_t*>(hw);
-
-    /* if gpu0 */
-    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
-        gralloc_context_t *dev;
-        dev = (gralloc_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = gralloc_close;
-
-        dev->device.alloc   = gralloc_alloc;
-        dev->device.free    = gralloc_free;
-
-        *device = &dev->device.common;
-        status = 0;
-    } else {
-
-        m->flags = 0;
-        m->ion_master = -1;
-        m->master_phys = 0;
-
-        status = fb_device_open(module, name, device);
-    }
-    return status;
-}
diff --git a/mx5x/libgralloc/gralloc_priv.h b/mx5x/libgralloc/gralloc_priv.h
deleted file mode 100644
index 6acd690..0000000
--- a/mx5x/libgralloc/gralloc_priv.h
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef GRALLOC_PRIV_H_
-#define GRALLOC_PRIV_H_
-
-#include <stdint.h>
-#include <pthread.h>
-#include <errno.h>
-#include <linux/fb.h>
-
-#include <cutils/native_handle.h>
-#include <hardware/gralloc.h>
-
-#define  ALIGN_PIXEL(x)  ((x+ 31) & ~31)
-#define  ALIGN_PIXEL_64(x)  ((x+ 63) & ~63)
-/** z430 core need 4k aligned memory, since xres has been 32 aligned, make yres
-    to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
-#define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
-/** z430 core needs 4k aligned memory for all YUV pixel
- *  formats */
-#define  ALIGN_PIXEL_4096(x)  ((x+ 4095) & ~4095)
-
-/*****************************************************************************/
-
-struct private_module_t;
-struct private_handle_t;
-
-struct private_module_t {
-    gralloc_module_t base;
-
-    private_handle_t* framebuffer;
-    uint32_t flags;
-    uint32_t numBuffers;
-    uint32_t bufferMask;
-    pthread_mutex_t lock;
-    buffer_handle_t currentBuffer;
-    int ion_master;
-    unsigned long master_phys;
-
-    struct fb_var_screeninfo info;
-    struct fb_fix_screeninfo finfo;
-    float xdpi;
-    float ydpi;
-    float fps;
-    
-    enum {
-        // flag to indicate we'll post this buffer
-        PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
-    };
-};
-
-/*****************************************************************************/
-
-#ifdef __cplusplus
-struct private_handle_t : public native_handle {
-#else
-struct private_handle_t {
-    struct native_handle nativeHandle;
-#endif
-    
-    enum {
-        PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
-        PRIV_FLAGS_USES_PMEM   = 0x00000002,
-        PRIV_FLAGS_USES_ION    = 0x00000004,
-        PRIV_FLAGS_NEEDS_FLUSH    = 0x00000008,
-    };
-
-    enum {
-        LOCK_STATE_WRITE     =   1<<31,
-        LOCK_STATE_MAPPED    =   1<<30,
-        LOCK_STATE_READ_MASK =   0x3FFFFFFF
-    };
-
-    // file-descriptors
-    int     fd;
-    // ints
-    int     magic;
-    int     flags;
-    int     size;
-    int     offset;
-    int     gpu_fd;
-
-    // FIXME: the attributes below should be out-of-line
-    int     base;
-    int     lockState;
-    int     writeOwner;
-    int     phys; // The physical address of that chunk of memory. If using ashmem, set to 0 They don't care
-    int     pid;
-    int	    usage;
-    int	    format;
-    int     width;
-    int     height;
-    void*   handle;
-    
-#ifdef __cplusplus
-    static const int sNumInts = 14;
-    static const int sNumFds = 1;
-    static const int sMagic = 'igpu';
-
-    private_handle_t(int fd, int size, int flags) :
-        fd(fd), magic(sMagic), flags(flags), size(size), offset(0),gpu_fd(-1),
-        base(0), lockState(0), writeOwner(0), phys(0),pid(getpid()),usage(0),
-        format(0), width(0), height(0)
-    {
-        version = sizeof(native_handle);
-        numInts = sNumInts;
-        numFds = sNumFds;
-    }
-    ~private_handle_t() {
-        magic = 0;
-    }
-
-    bool usesPhysicallyContiguousMemory() {
-        return (flags & PRIV_FLAGS_USES_ION) != 0;
-    }
-
-    static int validate(const native_handle* h) {
-        const private_handle_t* hnd = (const private_handle_t*)h;
-        if (!h || h->version != sizeof(native_handle) ||
-                h->numInts != sNumInts || h->numFds != sNumFds ||
-                hnd->magic != sMagic) 
-        {
-            ALOGE("invalid gralloc handle (at %p)", h);
-            return -EINVAL;
-        }
-        return 0;
-    }
-
-    static private_handle_t* dynamicCast(const native_handle* in) {
-        if (validate(in) == 0) {
-            return (private_handle_t*) in;
-        }
-        return NULL;
-    }
-#endif
-};
-
-#endif /* GRALLOC_PRIV_H_ */
diff --git a/mx5x/libgralloc/mapper.cpp b/mx5x/libgralloc/mapper.cpp
deleted file mode 100644
index b7513b4..0000000
--- a/mx5x/libgralloc/mapper.cpp
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <errno.h>
-#include <pthread.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <ion/ion.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-
-static int gralloc_map(gralloc_module_t const* module,
-        buffer_handle_t handle,
-        void** vaddr)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        int fd;
-        size_t size = hnd->size;
-
-        fd = ion_open();
-        if(fd < 0) {
-            ALOGE("gralloc_map() Cannot open ion err = %d", errno);
-            return -errno;
-        }
-        void* mappedAddress = mmap(0, size,
-                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
-        if (mappedAddress == MAP_FAILED) {
-            ALOGE("Could not mmap handle %p, fd=%d (%s)",
-                    handle, hnd->fd, strerror(errno));
-            hnd->base = 0;
-            return -errno;
-        }
-        hnd->base = intptr_t(mappedAddress);
-        memset(mappedAddress, 0, size);
-        //ALOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", 
-        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
-        close(fd);
-    }
-    *vaddr = (void*)hnd->base;
-    return 0;
-}
-
-static int gralloc_unmap(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        void* base = (void*)hnd->base;
-        size_t size = hnd->size;
-
-        //ALOGD("unmapping from %p, size=%d", base, size);
-        if (munmap(base, size) < 0) {
-            ALOGE("Could not unmap %s", strerror(errno));
-        }
-    }
-    hnd->base = 0;
-    return 0;
-}
-
-static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER; 
-
-int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    // In this implementation, we don't need to do anything here
-
-    /* NOTE: we need to initialize the buffer as not mapped/not locked
-     * because it shouldn't when this function is called the first time
-     * in a new process. Ideally these flags shouldn't be part of the
-     * handle, but instead maintained in the kernel or at least 
-     * out-of-line
-     */ 
-
-    // if this handle was created in this process, then we keep it as is.
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (hnd->pid != getpid()) {
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     * NOTE: the framebuffer is handled differently and is never unmapped.
-     */
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    
-    ALOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[unregister] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-
-    // never unmap buffers that were created in this process
-    if (hnd->pid != getpid()) {
-        if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-            gralloc_unmap(module, handle);
-        }
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int terminateBuffer(gralloc_module_t const* module,
-        private_handle_t* hnd)
-{
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     */
-
-    ALOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[terminate] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-    
-    if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-        // this buffer was mapped, unmap it now
-        if ((hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION) &&
-            (hnd->pid == getpid())) {
-            // ... unless it's a "master" ion buffer, that is a buffer
-            // mapped in the process it's been allocated.
-            // (see gralloc_alloc_buffer())
-        } else {
-            gralloc_unmap(module, hnd);
-        }
-    }
-
-    return 0;
-}
-
-int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    int err = 0;
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-    int retry;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // already locked for write 
-            ALOGE("handle %p already locked for write", handle);
-            return -EBUSY;
-        } else if (current_value & private_handle_t::LOCK_STATE_READ_MASK) {
-            // already locked for read
-            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-                ALOGE("handle %p already locked for read", handle);
-                return -EBUSY;
-            } else {
-                // this is not an error
-                //ALOGD("%p already locked for read... count = %d", 
-                //        handle, (current_value & ~(1<<31)));
-            }
-        }
-
-        // not currently locked
-        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-            // locking for write
-            new_value |= private_handle_t::LOCK_STATE_WRITE;
-        }
-        new_value++;
-
-        retry = android_atomic_cmpxchg(current_value, new_value, 
-                (volatile int32_t*)&hnd->lockState);
-    } while (retry);
-
-    if (new_value & private_handle_t::LOCK_STATE_WRITE) {
-        // locking for write, store the tid
-        hnd->writeOwner = gettid();
-    }
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
-        if (!(current_value & private_handle_t::LOCK_STATE_MAPPED)) {
-            // we need to map for real
-            pthread_mutex_t* const lock = &sMapLock;
-            pthread_mutex_lock(lock);
-            if (!(hnd->lockState & private_handle_t::LOCK_STATE_MAPPED)) {
-                err = gralloc_map(module, handle, vaddr);
-                if (err == 0) {
-                    android_atomic_or(private_handle_t::LOCK_STATE_MAPPED,
-                            (volatile int32_t*)&(hnd->lockState));
-                }
-            }
-            pthread_mutex_unlock(lock);
-        }
-        *vaddr = (void*)hnd->base;
-    }
-
-    return err;
-}
-
-int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // locked for write
-            if (hnd->writeOwner == gettid()) {
-                hnd->writeOwner = 0;
-                new_value &= ~private_handle_t::LOCK_STATE_WRITE;
-            }
-        }
-
-        if ((new_value & private_handle_t::LOCK_STATE_READ_MASK) == 0) {
-            ALOGE("handle %p not locked", handle);
-            return -EINVAL;
-        }
-
-        new_value--;
-
-    } while (android_atomic_cmpxchg(current_value, new_value, 
-            (volatile int32_t*)&hnd->lockState));
-
-    return 0;
-}
-
-int gralloc_perform(struct gralloc_module_t const* module,
-                    int operation, ... )
-{
-    return 0;
-}
-
diff --git a/mx5x/power/Android.mk b/mx5x/power/Android.mk
deleted file mode 100644
index 970c135..0000000
--- a/mx5x/power/Android.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-# Copyright (C) 2012 The Android Open Source Project
-# Copyright (C) 2012 Freescale Semiconductor, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation stored in
-# hw/<POWERS_HARDWARE_MODULE_ID>.<ro.hardware>.so
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libcutils
-LOCAL_SRC_FILES := power.c
-LOCAL_MODULE := power.$(TARGET_BOARD_PLATFORM)
-LOCAL_MODULE_TAGS := optional
-include $(BUILD_SHARED_LIBRARY)
diff --git a/mx5x/power/power.c b/mx5x/power/power.c
deleted file mode 100644
index a5800dc..0000000
--- a/mx5x/power/power.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <errno.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-#define LOG_TAG "i.MX5X PowerHAL"
-#include <utils/Log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/power.h>
-
-static int boost_fd = -1;
-static int boost_warned;
-
-static void sysfs_write(char *path, char *s)
-{
-    int len;
-    int fd = open(path, O_WRONLY);
-
-    if (fd < 0) {
-        ALOGE("Error opening %s: %s\n", path, strerror(errno));
-        return;
-    }
-
-    len = write(fd, s, strlen(s));
-    if (len < 0) {
-        ALOGE("Error writing to %s: %s\n", path, strerror(errno));
-    }
-
-    close(fd);
-}
-
-static void fsl_power_init(struct power_module *module)
-{
-	sysfs_write("/sys/devices/platform/imx_dvfscore.0/enable", "1");
-}
-
-static void fsl_power_set_interactive(struct power_module *module, int on)
-{
-
-}
-
-static void fsl_power_hint(struct power_module *module, power_hint_t hint,
-                            void *data)
-{
-
-}
-
-static struct hw_module_methods_t power_module_methods = {
-    .open = NULL,
-};
-
-struct power_module HAL_MODULE_INFO_SYM = {
-    .common = {
-        .tag = HARDWARE_MODULE_TAG,
-        .module_api_version = POWER_MODULE_API_VERSION_0_2,
-        .hal_api_version = HARDWARE_HAL_API_VERSION,
-        .id = POWER_HARDWARE_MODULE_ID,
-        .name = "FSL i.MX5X Power HAL",
-        .author = "Freescale Semiconductor, Inc.",
-        .methods = &power_module_methods,
-    },
-
-    .init = fsl_power_init,
-    .setInteractive = fsl_power_set_interactive,
-    .powerHint = fsl_power_hint,
-};
diff --git a/wlan/intel/Android.mk b/wlan/intel/Android.mk
deleted file mode 100644
index 4ab06ab..0000000
--- a/wlan/intel/Android.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-ifeq ($(BOARD_WLAN_DEVICE),INTEL)
-    include $(call all-subdir-makefiles)
-endif
diff --git a/wlan/intel/wpa_supplicant_8_lib/Android.mk b/wlan/intel/wpa_supplicant_8_lib/Android.mk
deleted file mode 100644
index 91fbe72..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/Android.mk
+++ /dev/null
@@ -1,65 +0,0 @@
-#
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-LOCAL_PATH := $(call my-dir)
-
-ifeq ($(WPA_SUPPLICANT_VERSION),VER_0_8_X)
-
-ifneq ($(BOARD_WPA_SUPPLICANT_DRIVER),)
-  CONFIG_DRIVER_$(BOARD_WPA_SUPPLICANT_DRIVER) := y
-endif
-
-WPA_SUPPL_DIR = external/wpa_supplicant_8
-WPA_SRC_FILE :=
-
-include $(WPA_SUPPL_DIR)/wpa_supplicant/android.config
-
-WPA_SUPPL_DIR_INCLUDE = $(WPA_SUPPL_DIR)/src \
-	$(WPA_SUPPL_DIR)/src/common \
-	$(WPA_SUPPL_DIR)/src/drivers \
-	$(WPA_SUPPL_DIR)/src/l2_packet \
-	$(WPA_SUPPL_DIR)/src/utils \
-	$(WPA_SUPPL_DIR)/src/wps \
-	$(WPA_SUPPL_DIR)/wpa_supplicant
-
-ifdef CONFIG_DRIVER_NL80211
-WPA_SUPPL_DIR_INCLUDE += external/libnl-headers
-WPA_SRC_FILE += driver_cmd_nl80211.c
-endif
-
-ifdef CONFIG_DRIVER_WEXT
-WPA_SRC_FILE += driver_cmd_wext.c
-endif
-
-# To force sizeof(enum) = 4
-L_CFLAGS += -mabi=aapcs-linux
-
-ifdef CONFIG_ANDROID_LOG
-L_CFLAGS += -DCONFIG_ANDROID_LOG
-endif
-
-########################
-
-include $(CLEAR_VARS)
-LOCAL_MODULE := private_lib_driver_cmd_intel
-LOCAL_SHARED_LIBRARIES := libc libcutils
-LOCAL_CFLAGS := $(L_CFLAGS)
-LOCAL_SRC_FILES := $(WPA_SRC_FILE)
-LOCAL_C_INCLUDES := $(WPA_SUPPL_DIR_INCLUDE)
-include $(BUILD_STATIC_LIBRARY)
-
-########################
-
-endif
diff --git a/wlan/intel/wpa_supplicant_8_lib/MODULE_LICENSE_BSD b/wlan/intel/wpa_supplicant_8_lib/MODULE_LICENSE_BSD
deleted file mode 100644
index e69de29..0000000
diff --git a/wlan/intel/wpa_supplicant_8_lib/NOTICE b/wlan/intel/wpa_supplicant_8_lib/NOTICE
deleted file mode 100644
index 58b094c..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/NOTICE
+++ /dev/null
@@ -1,43 +0,0 @@
-
-Copyright (c) 2005-2010, The Android Open Source Project
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
- * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
- * Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in
-   the documentation and/or other materials provided with the
-   distribution.
- * Neither the name of The Android Open Source Project nor the names
-   of its contributors may be used to endorse or promote products
-   derived from this software without specific prior written
-   permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
-OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
-AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGE.
-
- * Copyright (c) 2002-2010, Jouni Malinen <j@w1.fi>
- * Copyright (c) 2003-2004, Instant802 Networks, Inc.
- * Copyright (c) 2005-2006, Devicescape Software, Inc.
- * Copyright (c) 2007, Johannes Berg <johannes@sipsolutions.net>
- * Copyright (c) 2009-2010, Atheros Communications
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
diff --git a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_common.h b/wlan/intel/wpa_supplicant_8_lib/driver_cmd_common.h
deleted file mode 100644
index 03ce253..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_common.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Driver interaction for private interface
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- */
-#ifndef DRIVER_CMD_COMMON_H
-#define DRIVER_CMD_COMMON_H
-
-#include "config_ssid.h"
-
-#define MAX_DRV_CMD_SIZE		248
-#define DRV_NUMBER_SEQUENTIAL_ERRORS	4
-
-#define RSSI_CMD			"RSSI"
-#define LINKSPEED_CMD			"LINKSPEED"
-
-#define MAX_WPSP2PIE_CMD_SIZE		384
-
-#define WEXT_PNOSETUP_HEADER		"PNOSETUP "
-#define WEXT_PNOSETUP_HEADER_SIZE	9
-#define WEXT_PNO_TLV_PREFIX		'S'
-#define WEXT_PNO_TLV_VERSION		'1'
-#define WEXT_PNO_TLV_SUBVERSION		'2'
-#define WEXT_PNO_TLV_RESERVED		'0'
-#define WEXT_PNO_VERSION_SIZE		4
-#define WEXT_PNO_AMOUNT			16
-#define WEXT_PNO_SSID_SECTION		'S'
-/* SSID header size is SSID section type above + SSID length */
-#define WEXT_PNO_SSID_HEADER_SIZE	2
-#define WEXT_PNO_SCAN_INTERVAL_SECTION	'T'
-#define WEXT_PNO_SCAN_INTERVAL_LENGTH	2
-#define WEXT_PNO_SCAN_INTERVAL		30
-/* Scan interval size is scan interval section type + scan interval length above*/
-#define WEXT_PNO_SCAN_INTERVAL_SIZE	(1 + WEXT_PNO_SCAN_INTERVAL_LENGTH)
-#define WEXT_PNO_REPEAT_SECTION		'R'
-#define WEXT_PNO_REPEAT_LENGTH		1
-#define WEXT_PNO_REPEAT			4
-/* Repeat section size is Repeat section type + Repeat value length above*/
-#define WEXT_PNO_REPEAT_SIZE		(1 + WEXT_PNO_REPEAT_LENGTH)
-#define WEXT_PNO_MAX_REPEAT_SECTION	'M'
-#define WEXT_PNO_MAX_REPEAT_LENGTH	1
-#define WEXT_PNO_MAX_REPEAT		3
-/* Max Repeat section size is Max Repeat section type + Max Repeat value length above*/
-#define WEXT_PNO_MAX_REPEAT_SIZE	(1 + WEXT_PNO_MAX_REPEAT_LENGTH)
-/* This corresponds to the size of all sections expect SSIDs */
-#define WEXT_PNO_NONSSID_SECTIONS_SIZE	(WEXT_PNO_SCAN_INTERVAL_SIZE + WEXT_PNO_REPEAT_SIZE + WEXT_PNO_MAX_REPEAT_SIZE)
-/* PNO Max command size is total of header, version, ssid and other sections + Null termination */
-#define WEXT_PNO_MAX_COMMAND_SIZE	(WEXT_PNOSETUP_HEADER_SIZE + WEXT_PNO_VERSION_SIZE \
-					+ WEXT_PNO_AMOUNT * (WEXT_PNO_SSID_HEADER_SIZE + MAX_SSID_LEN) \
-					+ WEXT_PNO_NONSSID_SECTIONS_SIZE + 1)
-
-#endif /* DRIVER_CMD_COMMON_H */
diff --git a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_nl80211.c b/wlan/intel/wpa_supplicant_8_lib/driver_cmd_nl80211.c
deleted file mode 100644
index d9fad24..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_nl80211.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Driver interaction with extended Linux CFG8021
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- */
-
-#include "driver_nl80211.h"
-#include "driver_cmd_common.h"
-
-#include "wpa_supplicant_i.h"
-#include "config.h"
-
-#define WPA_EVENT_DRIVER_STATE		"CTRL-EVENT-DRIVER-STATE "
-
-#define WPA_PS_ENABLED		0
-#define WPA_PS_DISABLED		1
-
-typedef struct android_wifi_priv_cmd {
-	char *buf;
-	int used_len;
-	int total_len;
-} android_wifi_priv_cmd;
-
-int send_and_recv_msgs(struct wpa_driver_nl80211_data *drv, struct nl_msg *msg,
-		       int (*valid_handler)(struct nl_msg *, void *),
-		       void *valid_data);
-
-static int drv_errors = 0;
-
-static void wpa_driver_send_hang_msg(struct wpa_driver_nl80211_data *drv)
-{
-	drv_errors++;
-	if (drv_errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
-		drv_errors = 0;
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-	}
-}
-
-static int wpa_driver_set_power_save(void *priv, int state)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	int ret = -1;
-	enum nl80211_ps_state ps_state;
-
-	msg = nlmsg_alloc();
-	if (!msg)
-		return -1;
-
-	genlmsg_put(msg, 0, 0, genl_family_get_id(drv->nl80211), 0, 0,
-		    NL80211_CMD_SET_POWER_SAVE, 0);
-
-	if (state == WPA_PS_ENABLED)
-		ps_state = NL80211_PS_ENABLED;
-	else
-		ps_state = NL80211_PS_DISABLED;
-
-	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-	NLA_PUT_U32(msg, NL80211_ATTR_PS_STATE, ps_state);
-
-	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
-	msg = NULL;
-	if (ret < 0)
-		wpa_printf(MSG_ERROR, "nl80211: Set power mode fail: %d", ret);
-nla_put_failure:
-	nlmsg_free(msg);
-	return ret;
-}
-
-static int get_power_mode_handler(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	int *state = (int *)arg;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_PS_STATE])
-		return NL_SKIP;
-
-	if (state) {
-		*state = (int)nla_get_u32(tb[NL80211_ATTR_PS_STATE]);
-		wpa_printf(MSG_DEBUG, "nl80211: Get power mode = %d", *state);
-		*state = (*state == NL80211_PS_ENABLED) ?
-				WPA_PS_ENABLED : WPA_PS_DISABLED;
-	}
-
-	return NL_SKIP;
-}
-
-static int wpa_driver_get_power_save(void *priv, int *state)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	int ret = -1;
-	enum nl80211_ps_state ps_state;
-
-	msg = nlmsg_alloc();
-	if (!msg)
-		return -1;
-
-	genlmsg_put(msg, 0, 0, genl_family_get_id(drv->nl80211), 0, 0,
-		    NL80211_CMD_GET_POWER_SAVE, 0);
-
-	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-
-	ret = send_and_recv_msgs(drv, msg, get_power_mode_handler, state);
-	msg = NULL;
-	if (ret < 0)
-		wpa_printf(MSG_ERROR, "nl80211: Get power mode fail: %d", ret);
-nla_put_failure:
-	nlmsg_free(msg);
-	return ret;
-}
-
-static int wpa_driver_set_backgroundscan_params(void *priv)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct wpa_supplicant *wpa_s;
-	struct ifreq ifr;
-	android_wifi_priv_cmd priv_cmd;
-	int ret = 0, i = 0, bp;
-	char buf[WEXT_PNO_MAX_COMMAND_SIZE];
-	struct wpa_ssid *ssid_conf;
-
-	if (drv == NULL) {
-		wpa_printf(MSG_ERROR, "%s: drv is NULL. Exiting", __func__);
-		return -1;
-	}
-	if (drv->ctx == NULL) {
-		wpa_printf(MSG_ERROR, "%s: drv->ctx is NULL. Exiting", __func__);
-		return -1;
-	}
-	wpa_s = (struct wpa_supplicant *)(drv->ctx);
-	if (wpa_s->conf == NULL) {
-		wpa_printf(MSG_ERROR, "%s: wpa_s->conf is NULL. Exiting", __func__);
-		return -1;
-	}
-	ssid_conf = wpa_s->conf->ssid;
-
-	bp = WEXT_PNOSETUP_HEADER_SIZE;
-	os_memcpy(buf, WEXT_PNOSETUP_HEADER, bp);
-	buf[bp++] = WEXT_PNO_TLV_PREFIX;
-	buf[bp++] = WEXT_PNO_TLV_VERSION;
-	buf[bp++] = WEXT_PNO_TLV_SUBVERSION;
-	buf[bp++] = WEXT_PNO_TLV_RESERVED;
-
-	while ((i < WEXT_PNO_AMOUNT) && (ssid_conf != NULL)) {
-		/* Check that there is enough space needed for 1 more SSID, the other sections and null termination */
-		if ((bp + WEXT_PNO_SSID_HEADER_SIZE + MAX_SSID_LEN + WEXT_PNO_NONSSID_SECTIONS_SIZE + 1) >= (int)sizeof(buf))
-			break;
-		if ((!ssid_conf->disabled) && (ssid_conf->ssid_len <= MAX_SSID_LEN)){
-			wpa_printf(MSG_DEBUG, "For PNO Scan: %s", ssid_conf->ssid);
-			buf[bp++] = WEXT_PNO_SSID_SECTION;
-			buf[bp++] = ssid_conf->ssid_len;
-			os_memcpy(&buf[bp], ssid_conf->ssid, ssid_conf->ssid_len);
-			bp += ssid_conf->ssid_len;
-			i++;
-		}
-		ssid_conf = ssid_conf->next;
-	}
-
-	buf[bp++] = WEXT_PNO_SCAN_INTERVAL_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_SCAN_INTERVAL_LENGTH + 1, "%x", WEXT_PNO_SCAN_INTERVAL);
-	bp += WEXT_PNO_SCAN_INTERVAL_LENGTH;
-
-	buf[bp++] = WEXT_PNO_REPEAT_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_REPEAT_LENGTH + 1, "%x", WEXT_PNO_REPEAT);
-	bp += WEXT_PNO_REPEAT_LENGTH;
-
-	buf[bp++] = WEXT_PNO_MAX_REPEAT_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_MAX_REPEAT_LENGTH + 1, "%x", WEXT_PNO_MAX_REPEAT);
-	bp += WEXT_PNO_MAX_REPEAT_LENGTH + 1;
-
-	memset(&ifr, 0, sizeof(ifr));
-	memset(&priv_cmd, 0, sizeof(priv_cmd));
-	os_strncpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
-
-	priv_cmd.buf = buf;
-	priv_cmd.used_len = bp;
-	priv_cmd.total_len = bp;
-	ifr.ifr_data = &priv_cmd;
-
-	ret = ioctl(drv->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr);
-
-	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (pnosetup): %d", ret);
-		wpa_driver_send_hang_msg(drv);
-	} else {
-		drv_errors = 0;
-	}
-	return ret;
-}
-
-int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
-				  size_t buf_len )
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct ifreq ifr;
-	android_wifi_priv_cmd priv_cmd;
-	int ret = 0;
-
-	if (os_strcasecmp(cmd, "STOP") == 0) {
-		linux_set_iface_flags(drv->ioctl_sock, bss->ifname, 0);
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
-	} else if (os_strcasecmp(cmd, "START") == 0) {
-		linux_set_iface_flags(drv->ioctl_sock, bss->ifname, 1);
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
-	} else if (os_strcasecmp(cmd, "MACADDR") == 0) {
-		u8 macaddr[ETH_ALEN] = {};
-
-		ret = linux_get_ifhwaddr(drv->ioctl_sock, bss->ifname, macaddr);
-		if (!ret)
-			ret = os_snprintf(buf, buf_len,
-					  "Macaddr = " MACSTR "\n", MAC2STR(macaddr));
-	} else if (os_strcasecmp(cmd, "RELOAD") == 0) {
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-	} else if (os_strncasecmp(cmd, "POWERMODE ", 10) == 0) {
-		int state;
-
-		state = atoi(cmd + 10);
-		ret = wpa_driver_set_power_save(priv, state);
-		if (ret < 0)
-			wpa_driver_send_hang_msg(drv);
-		else
-			drv_errors = 0;
-	} else if (os_strncasecmp(cmd, "GETPOWER", 8) == 0) {
-		int state = -1;
-
-		ret = wpa_driver_get_power_save(priv, &state);
-		if (!ret && (state != -1)) {
-			ret = os_snprintf(buf, buf_len, "POWERMODE = %d\n", state);
-			drv_errors = 0;
-		} else {
-			wpa_driver_send_hang_msg(drv);
-		}
-	} else { /* Use private command */
-		if (os_strcasecmp(cmd, "BGSCAN-START") == 0) {
-			ret = wpa_driver_set_backgroundscan_params(priv);
-			if (ret < 0) {
-				return ret;
-			}
-			os_memcpy(buf, "PNOFORCE 1", 11);
-		} else if (os_strcasecmp(cmd, "BGSCAN-STOP") == 0) {
-			os_memcpy(buf, "PNOFORCE 0", 11);
-		} else {
-			os_memcpy(buf, cmd, strlen(cmd) + 1);
-		}
-		memset(&ifr, 0, sizeof(ifr));
-		memset(&priv_cmd, 0, sizeof(priv_cmd));
-		os_strncpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
-
-		priv_cmd.buf = buf;
-		priv_cmd.used_len = buf_len;
-		priv_cmd.total_len = buf_len;
-		ifr.ifr_data = &priv_cmd;
-
-#if 0 //ndef __i386__ /* we don't support SIOCDEVPRIVATE */
-		if ((ret = ioctl(drv->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
-			wpa_printf(MSG_ERROR, "%s: failed to issue private commands\n", __func__);
-			wpa_driver_send_hang_msg(drv);
-		} else {
-			drv_errors = 0;
-			ret = 0;
-			if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
-			    (os_strcasecmp(cmd, "RSSI") == 0) ||
-			    (os_strcasecmp(cmd, "GETBAND") == 0) ||
-			    (os_strcasecmp(cmd, "P2P_GET_NOA") == 0))
-				ret = strlen(buf);
-
-			wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
-		}
-#endif
-	}
-	return ret;
-}
-
-int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration)
-{
-	char buf[MAX_DRV_CMD_SIZE];
-
-	memset(buf, 0, sizeof(buf));
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	snprintf(buf, sizeof(buf), "P2P_SET_NOA %d %d %d", count, start, duration);
-	return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf)+1);
-}
-
-int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len)
-{
-	char rbuf[MAX_DRV_CMD_SIZE];
-	char *cmd = "P2P_GET_NOA";
-	int ret;
-
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	os_memset(buf, 0, len);
-	ret = wpa_driver_nl80211_driver_cmd(priv, cmd, rbuf, sizeof(rbuf));
-	if (ret <= 0)
-		return 0;
-	ret >>= 1;
-	if (ret > (int)len)
-		ret = (int)len;
-	hexstr2bin(rbuf, buf, ret);
-	return ret;
-}
-
-int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow)
-{
-	char buf[MAX_DRV_CMD_SIZE];
-
-	memset(buf, 0, sizeof(buf));
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	snprintf(buf, sizeof(buf), "P2P_SET_PS %d %d %d", legacy_ps, opp_ps, ctwindow);
-	return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
-}
-
-int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
-				 const struct wpabuf *proberesp,
-				 const struct wpabuf *assocresp)
-{
-	char buf[MAX_WPSP2PIE_CMD_SIZE];
-	struct wpabuf *ap_wps_p2p_ie = NULL;
-	char *_cmd = "SET_AP_WPS_P2P_IE";
-	char *pbuf;
-	int ret = 0;
-	int i;
-	struct cmd_desc {
-		int cmd;
-		const struct wpabuf *src;
-	} cmd_arr[] = {
-		{0x1, beacon},
-		{0x2, proberesp},
-		{0x4, assocresp},
-		{-1, NULL}
-	};
-
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	for (i = 0; cmd_arr[i].cmd != -1; i++) {
-		os_memset(buf, 0, sizeof(buf));
-		pbuf = buf;
-		pbuf += sprintf(pbuf, "%s %d", _cmd, cmd_arr[i].cmd);
-		*pbuf++ = '\0';
-		ap_wps_p2p_ie = cmd_arr[i].src ?
-			wpabuf_dup(cmd_arr[i].src) : NULL;
-		if (ap_wps_p2p_ie) {
-			os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
-			ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf,
-				strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie));
-			wpabuf_free(ap_wps_p2p_ie);
-			if (ret < 0)
-				break;
-		}
-	}
-
-	return ret;
-}
diff --git a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.c b/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.c
deleted file mode 100644
index 70a8157..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.c
+++ /dev/null
@@ -1,392 +0,0 @@
-/*
- * Driver interaction with extended Linux Wireless Extensions
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- */
-
-#include "includes.h"
-#include <sys/ioctl.h>
-#include <net/if_arp.h>
-#include <net/if.h>
-
-#include "wireless_copy.h"
-#include "common.h"
-#include "driver.h"
-#include "eloop.h"
-#include "priv_netlink.h"
-#include "driver_wext.h"
-#include "ieee802_11_defs.h"
-#include "wpa_common.h"
-#include "wpa_ctrl.h"
-#include "wpa_supplicant_i.h"
-#include "config.h"
-#include "linux_ioctl.h"
-#include "scan.h"
-
-#include "driver_cmd_wext.h"
-#include "driver_cmd_common.h"
-
-/**
- * wpa_driver_wext_set_scan_timeout - Set scan timeout to report scan completion
- * @priv:  Pointer to private wext data from wpa_driver_wext_init()
- *
- * This function can be used to set registered timeout when starting a scan to
- * generate a scan completed event if the driver does not report this.
- */
-static void wpa_driver_wext_set_scan_timeout(void *priv)
-{
-	struct wpa_driver_wext_data *drv = priv;
-	int timeout = 10; /* In case scan A and B bands it can be long */
-
-	/* Not all drivers generate "scan completed" wireless event, so try to
-	 * read results after a timeout. */
-	if (drv->scan_complete_events) {
-	/*
-	 * The driver seems to deliver SIOCGIWSCAN events to notify
-	 * when scan is complete, so use longer timeout to avoid race
-	 * conditions with scanning and following association request.
-	 */
-		timeout = 30;
-	}
-	wpa_printf(MSG_DEBUG, "Scan requested - scan timeout %d seconds",
-		   timeout);
-	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
-	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
-			       drv->ctx);
-}
-
-/**
- * wpa_driver_wext_combo_scan - Request the driver to initiate combo scan
- * @priv: Pointer to private wext data from wpa_driver_wext_init()
- * @params: Scan parameters
- * Returns: 0 on success, -1 on failure
- */
-int wpa_driver_wext_combo_scan(void *priv, struct wpa_driver_scan_params *params)
-{
-	char buf[WEXT_CSCAN_BUF_LEN];
-	struct wpa_driver_wext_data *drv = priv;
-	struct iwreq iwr;
-	int ret, bp;
-	unsigned i;
-	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
-
-	if (!drv->driver_is_started) {
-		wpa_printf(MSG_DEBUG, "%s: Driver stopped", __func__);
-		return 0;
-	}
-
-	wpa_printf(MSG_DEBUG, "%s: Start", __func__);
-
-	/* Set list of SSIDs */
-	bp = WEXT_CSCAN_HEADER_SIZE;
-	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
-	for(i=0; i < params->num_ssids; i++) {
-		if ((bp + IW_ESSID_MAX_SIZE + 10) >= (int)sizeof(buf))
-			break;
-		wpa_printf(MSG_DEBUG, "For Scan: %s", params->ssids[i].ssid);
-		buf[bp++] = WEXT_CSCAN_SSID_SECTION;
-		buf[bp++] = params->ssids[i].ssid_len;
-		os_memcpy(&buf[bp], params->ssids[i].ssid, params->ssids[i].ssid_len);
-		bp += params->ssids[i].ssid_len;
-	}
-
-	/* Set list of channels */
-	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
-	buf[bp++] = 0;
-
-	/* Set passive dwell time (default is 250) */
-	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
-	buf[bp++] = (u8)WEXT_CSCAN_PASV_DWELL_TIME;
-	buf[bp++] = (u8)(WEXT_CSCAN_PASV_DWELL_TIME >> 8);
-
-	/* Set home dwell time (default is 40) */
-	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
-	buf[bp++] = (u8)WEXT_CSCAN_HOME_DWELL_TIME;
-	buf[bp++] = (u8)(WEXT_CSCAN_HOME_DWELL_TIME >> 8);
-
-	os_memset(&iwr, 0, sizeof(iwr));
-	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = bp;
-
-	if ((ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr)) < 0) {
-		if (!drv->bgscan_enabled)
-			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (cscan): %d", ret);
-		else
-			ret = 0;	/* Hide error in case of bg scan */
-	}
-	return ret;
-}
-
-static int wpa_driver_wext_set_cscan_params(char *buf, size_t buf_len, char *cmd)
-{
-	char *pasv_ptr;
-	int bp, i;
-	u16 pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
-	u8 channel;
-
-	wpa_printf(MSG_DEBUG, "%s: %s", __func__, cmd);
-
-	/* Get command parameters */
-	pasv_ptr = os_strstr(cmd, ",TIME=");
-	if (pasv_ptr) {
-		*pasv_ptr = '\0';
-		pasv_ptr += 6;
-		pasv_dwell = (u16)atoi(pasv_ptr);
-		if (pasv_dwell == 0)
-			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
-	}
-	channel = (u8)atoi(cmd + 5);
-
-	bp = WEXT_CSCAN_HEADER_SIZE;
-	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
-
-	/* Set list of channels */
-	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
-	buf[bp++] = channel;
-	if (channel != 0) {
-		i = (pasv_dwell - 1) / WEXT_CSCAN_PASV_DWELL_TIME_DEF;
-		for (; i > 0; i--) {
-			if ((size_t)(bp + 12) >= buf_len)
-				break;
-			buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
-			buf[bp++] = channel;
-		}
-	} else {
-		if (pasv_dwell > WEXT_CSCAN_PASV_DWELL_TIME_MAX)
-			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_MAX;
-	}
-
-	/* Set passive dwell time (default is 250) */
-	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
-	if (channel != 0) {
-		buf[bp++] = (u8)WEXT_CSCAN_PASV_DWELL_TIME_DEF;
-		buf[bp++] = (u8)(WEXT_CSCAN_PASV_DWELL_TIME_DEF >> 8);
-	} else {
-		buf[bp++] = (u8)pasv_dwell;
-		buf[bp++] = (u8)(pasv_dwell >> 8);
-	}
-
-	/* Set home dwell time (default is 40) */
-	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
-	buf[bp++] = (u8)WEXT_CSCAN_HOME_DWELL_TIME;
-	buf[bp++] = (u8)(WEXT_CSCAN_HOME_DWELL_TIME >> 8);
-
-	/* Set cscan type */
-	buf[bp++] = WEXT_CSCAN_TYPE_SECTION;
-	buf[bp++] = WEXT_CSCAN_TYPE_PASSIVE;
-	return bp;
-}
-
-static char *wpa_driver_get_country_code(int channels)
-{
-	char *country = "US"; /* WEXT_NUMBER_SCAN_CHANNELS_FCC */
-
-	if (channels == WEXT_NUMBER_SCAN_CHANNELS_ETSI)
-		country = "EU";
-	else if( channels == WEXT_NUMBER_SCAN_CHANNELS_MKK1)
-		country = "JP";
-	return country;
-}
-
-static int wpa_driver_set_backgroundscan_params(void *priv)
-{
-	struct wpa_driver_wext_data *drv = priv;
-	struct wpa_supplicant *wpa_s;
-	struct iwreq iwr;
-	int ret = 0, i = 0, bp;
-	char buf[WEXT_PNO_MAX_COMMAND_SIZE];
-	struct wpa_ssid *ssid_conf;
-
-	if (drv == NULL) {
-		wpa_printf(MSG_ERROR, "%s: drv is NULL. Exiting", __func__);
-		return -1;
-	}
-	if (drv->ctx == NULL) {
-		wpa_printf(MSG_ERROR, "%s: drv->ctx is NULL. Exiting", __func__);
-		return -1;
-	}
-	wpa_s = (struct wpa_supplicant *)(drv->ctx);
-	if (wpa_s->conf == NULL) {
-		wpa_printf(MSG_ERROR, "%s: wpa_s->conf is NULL. Exiting", __func__);
-		return -1;
-	}
-	ssid_conf = wpa_s->conf->ssid;
-
-	bp = WEXT_PNOSETUP_HEADER_SIZE;
-	os_memcpy(buf, WEXT_PNOSETUP_HEADER, bp);
-	buf[bp++] = WEXT_PNO_TLV_PREFIX;
-	buf[bp++] = WEXT_PNO_TLV_VERSION;
-	buf[bp++] = WEXT_PNO_TLV_SUBVERSION;
-	buf[bp++] = WEXT_PNO_TLV_RESERVED;
-
-	while ((i < WEXT_PNO_AMOUNT) && (ssid_conf != NULL)) {
-		/* Check that there is enough space needed for 1 more SSID, the other sections and null termination */
-		if ((bp + WEXT_PNO_SSID_HEADER_SIZE + IW_ESSID_MAX_SIZE + WEXT_PNO_NONSSID_SECTIONS_SIZE + 1) >= (int)sizeof(buf))
-			break;
-		if ((!ssid_conf->disabled) && (ssid_conf->ssid_len <= IW_ESSID_MAX_SIZE)){
-			wpa_printf(MSG_DEBUG, "For PNO Scan: %s", ssid_conf->ssid);
-			buf[bp++] = WEXT_PNO_SSID_SECTION;
-			buf[bp++] = ssid_conf->ssid_len;
-			os_memcpy(&buf[bp], ssid_conf->ssid, ssid_conf->ssid_len);
-			bp += ssid_conf->ssid_len;
-			i++;
-		}
-		ssid_conf = ssid_conf->next;
-	}
-
-	buf[bp++] = WEXT_PNO_SCAN_INTERVAL_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_SCAN_INTERVAL_LENGTH + 1, "%x", WEXT_PNO_SCAN_INTERVAL);
-	bp += WEXT_PNO_SCAN_INTERVAL_LENGTH;
-
-	buf[bp++] = WEXT_PNO_REPEAT_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_REPEAT_LENGTH + 1, "%x", WEXT_PNO_REPEAT);
-	bp += WEXT_PNO_REPEAT_LENGTH;
-
-	buf[bp++] = WEXT_PNO_MAX_REPEAT_SECTION;
-	os_snprintf(&buf[bp], WEXT_PNO_MAX_REPEAT_LENGTH + 1, "%x", WEXT_PNO_MAX_REPEAT);
-	bp += WEXT_PNO_MAX_REPEAT_LENGTH + 1;
-
-	os_memset(&iwr, 0, sizeof(iwr));
-	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = bp;
-
-	ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr);
-
-	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (pnosetup): %d", ret);
-		drv->errors++;
-		if (drv->errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
-			drv->errors = 0;
-			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-		}
-	} else {
-		drv->errors = 0;
-	}
-	return ret;
-
-}
-
-int wpa_driver_wext_driver_cmd( void *priv, char *cmd, char *buf, size_t buf_len )
-{
-	struct wpa_driver_wext_data *drv = priv;
-	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
-	struct iwreq iwr;
-	int ret = 0, flags;
-
-	wpa_printf(MSG_DEBUG, "%s %s len = %d", __func__, cmd, buf_len);
-
-	if (!drv->driver_is_started && (os_strcasecmp(cmd, "START") != 0)) {
-		wpa_printf(MSG_ERROR,"WEXT: Driver not initialized yet");
-		return -1;
-	}
-
-	if (os_strcasecmp(cmd, "RSSI-APPROX") == 0) {
-		os_strncpy(cmd, RSSI_CMD, MAX_DRV_CMD_SIZE);
-	} else if( os_strncasecmp(cmd, "SCAN-CHANNELS", 13) == 0 ) {
-		int no_of_chan;
-
-		no_of_chan = atoi(cmd + 13);
-		os_snprintf(cmd, MAX_DRV_CMD_SIZE, "COUNTRY %s",
-			wpa_driver_get_country_code(no_of_chan));
-	} else if (os_strcasecmp(cmd, "STOP") == 0) {
-		linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
-	} else if( os_strcasecmp(cmd, "RELOAD") == 0 ) {
-		wpa_printf(MSG_DEBUG,"Reload command");
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-		return ret;
-	} else if( os_strcasecmp(cmd, "BGSCAN-START") == 0 ) {
-		ret = wpa_driver_set_backgroundscan_params(priv);
-		if (ret < 0) {
-			return ret;
-		}
-		os_strncpy(cmd, "PNOFORCE 1", MAX_DRV_CMD_SIZE);
-		drv->bgscan_enabled = 1;
-	} else if( os_strcasecmp(cmd, "BGSCAN-STOP") == 0 ) {
-		os_strncpy(cmd, "PNOFORCE 0", MAX_DRV_CMD_SIZE);
-		drv->bgscan_enabled = 0;
-	}
-
-	os_memset(&iwr, 0, sizeof(iwr));
-	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
-	os_memcpy(buf, cmd, strlen(cmd) + 1);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = buf_len;
-
-	if( os_strncasecmp(cmd, "CSCAN", 5) == 0 ) {
-		if (!wpa_s->scanning && ((wpa_s->wpa_state <= WPA_SCANNING) ||
-					(wpa_s->wpa_state >= WPA_COMPLETED))) {
-			iwr.u.data.length = wpa_driver_wext_set_cscan_params(buf, buf_len, cmd);
-		} else {
-			wpa_printf(MSG_ERROR, "Ongoing Scan action...");
-			return ret;
-		}
-	}
-
-	ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr);
-
-	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "%s failed (%d): %s", __func__, ret, cmd);
-		drv->errors++;
-		if (drv->errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
-			drv->errors = 0;
-			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-		}
-	} else {
-		drv->errors = 0;
-		ret = 0;
-		if ((os_strcasecmp(cmd, RSSI_CMD) == 0) ||
-		    (os_strcasecmp(cmd, LINKSPEED_CMD) == 0) ||
-		    (os_strcasecmp(cmd, "MACADDR") == 0) ||
-		    (os_strcasecmp(cmd, "GETPOWER") == 0) ||
-		    (os_strcasecmp(cmd, "GETBAND") == 0)) {
-			ret = strlen(buf);
-		} else if (os_strcasecmp(cmd, "START") == 0) {
-			drv->driver_is_started = TRUE;
-			linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1);
-			/* os_sleep(0, WPA_DRIVER_WEXT_WAIT_US);
-			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED"); */
-		} else if (os_strcasecmp(cmd, "STOP") == 0) {
-			drv->driver_is_started = FALSE;
-			/* wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED"); */
-		} else if (os_strncasecmp(cmd, "CSCAN", 5) == 0) {
-			wpa_driver_wext_set_scan_timeout(priv);
-			wpa_supplicant_notify_scanning(wpa_s, 1);
-		}
-		wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
-	}
-	return ret;
-}
-
-int wpa_driver_signal_poll(void *priv, struct wpa_signal_info *si)
-{
-	char buf[MAX_DRV_CMD_SIZE];
-	struct wpa_driver_wext_data *drv = priv;
-	char *prssi;
-	int res;
-
-	os_memset(si, 0, sizeof(*si));
-	res = wpa_driver_wext_driver_cmd(priv, RSSI_CMD, buf, sizeof(buf));
-	/* Answer: SSID rssi -Val */
-	if (res < 0)
-		return res;
-	prssi = strcasestr(buf, RSSI_CMD);
-	if (!prssi)
-		return -1;
-	si->current_signal = atoi(prssi + strlen(RSSI_CMD) + 1);
-
-	res = wpa_driver_wext_driver_cmd(priv, LINKSPEED_CMD, buf, sizeof(buf));
-	/* Answer: LinkSpeed Val */
-	if (res < 0)
-		return res;
-	si->current_txrate = atoi(buf + strlen(LINKSPEED_CMD) + 1) * 1000;
-
-	return 0;
-}
diff --git a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.h b/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.h
deleted file mode 100644
index 1c6e8a1..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/driver_cmd_wext.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Driver interaction with extended Linux Wireless Extensions
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- */
-#ifndef DRIVER_CMD_WEXT_H
-#define DRIVER_CMD_WEXT_H
-
-#define WEXT_NUMBER_SCAN_CHANNELS_FCC	11
-#define WEXT_NUMBER_SCAN_CHANNELS_ETSI	13
-#define WEXT_NUMBER_SCAN_CHANNELS_MKK1	14
-
-#define WPA_DRIVER_WEXT_WAIT_US		400000
-#define WEXT_CSCAN_AMOUNT		9
-#define WEXT_CSCAN_BUF_LEN		360
-#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
-#define WEXT_CSCAN_HEADER_SIZE		12
-#define WEXT_CSCAN_SSID_SECTION		'S'
-#define WEXT_CSCAN_CHANNEL_SECTION	'C'
-#define WEXT_CSCAN_NPROBE_SECTION	'N'
-#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
-#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
-#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
-#define WEXT_CSCAN_TYPE_SECTION		'T'
-#define WEXT_CSCAN_TYPE_DEFAULT		0
-#define WEXT_CSCAN_TYPE_PASSIVE		1
-#define WEXT_CSCAN_PASV_DWELL_TIME	130
-#define WEXT_CSCAN_PASV_DWELL_TIME_DEF	250
-#define WEXT_CSCAN_PASV_DWELL_TIME_MAX	3000
-#define WEXT_CSCAN_HOME_DWELL_TIME	130
-
-#endif /* DRIVER_CMD_WEXT_H */
diff --git a/wlan/intel/wpa_supplicant_8_lib/driver_nl80211.h b/wlan/intel/wpa_supplicant_8_lib/driver_nl80211.h
deleted file mode 100644
index 7d19995..0000000
--- a/wlan/intel/wpa_supplicant_8_lib/driver_nl80211.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Driver interaction with Linux nl80211/cfg80211
- * Copyright (c) 2002-2010, Jouni Malinen <j@w1.fi>
- * Copyright (c) 2003-2004, Instant802 Networks, Inc.
- * Copyright (c) 2005-2006, Devicescape Software, Inc.
- * Copyright (c) 2007, Johannes Berg <johannes@sipsolutions.net>
- * Copyright (c) 2009-2010, Atheros Communications
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- *
- * See README and COPYING for more details.
- */
-
-#ifndef _DRIVER_NL80211_H_
-#define _DRIVER_NL80211_H_
-
-#include "includes.h"
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <net/if.h>
-#include <netlink/genl/genl.h>
-#include <netlink/genl/family.h>
-#include <netlink/genl/ctrl.h>
-#include <linux/rtnetlink.h>
-#include <netpacket/packet.h>
-#include <linux/filter.h>
-#include "nl80211_copy.h"
-
-#include "common.h"
-#include "eloop.h"
-#include "utils/list.h"
-#include "common/ieee802_11_defs.h"
-#include "netlink.h"
-#include "linux_ioctl.h"
-#include "radiotap.h"
-#include "radiotap_iter.h"
-#include "rfkill.h"
-#include "driver.h"
-
-#ifdef CONFIG_LIBNL20
-/* libnl 2.0 compatibility code */
-#define nl_handle nl_sock
-#define nl80211_handle_alloc nl_socket_alloc_cb
-#define nl80211_handle_destroy nl_socket_free
-#endif /* CONFIG_LIBNL20 */
-
-#ifndef IFF_LOWER_UP
-#define IFF_LOWER_UP   0x10000         /* driver signals L1 up         */
-#endif
-#ifndef IFF_DORMANT
-#define IFF_DORMANT    0x20000         /* driver signals dormant       */
-#endif
-
-#ifndef IF_OPER_DORMANT
-#define IF_OPER_DORMANT 5
-#endif
-#ifndef IF_OPER_UP
-#define IF_OPER_UP 6
-#endif
-
-struct nl80211_global {
-	struct dl_list interfaces;
-};
-
-struct i802_bss {
-	struct wpa_driver_nl80211_data *drv;
-	struct i802_bss *next;
-	int ifindex;
-	char ifname[IFNAMSIZ + 1];
-	char brname[IFNAMSIZ];
-	unsigned int beacon_set:1;
-	unsigned int added_if_into_bridge:1;
-	unsigned int added_bridge:1;
-};
-
-struct wpa_driver_nl80211_data {
-	struct nl80211_global *global;
-	struct dl_list list;
-	u8 addr[ETH_ALEN];
-	char phyname[32];
-	void *ctx;
-	struct netlink_data *netlink;
-	int ioctl_sock; /* socket for ioctl() use */
-	int ifindex;
-	int if_removed;
-	int if_disabled;
-	struct rfkill_data *rfkill;
-	struct wpa_driver_capa capa;
-	int has_capability;
-
-	int operstate;
-
-	int scan_complete_events;
-
-	struct nl_handle *nl_handle;
-	struct nl_handle *nl_handle_event;
-	struct nl_handle *nl_handle_preq;
-	struct nl_cache *nl_cache;
-	struct nl_cache *nl_cache_event;
-	struct nl_cache *nl_cache_preq;
-	struct nl_cb *nl_cb;
-	struct genl_family *nl80211;
-
-	u8 auth_bssid[ETH_ALEN];
-	u8 bssid[ETH_ALEN];
-	int associated;
-	u8 ssid[32];
-	size_t ssid_len;
-	int nlmode;
-	int ap_scan_as_station;
-	unsigned int assoc_freq;
-
-	int monitor_sock;
-	int monitor_ifidx;
-	int no_monitor_iface_capab;
-	int disable_11b_rates;
-
-	unsigned int pending_remain_on_chan:1;
-
-	u64 remain_on_chan_cookie;
-	u64 send_action_cookie;
-
-	unsigned int last_mgmt_freq;
-	unsigned int ap_oper_freq;
-
-	struct wpa_driver_scan_filter *filter_ssids;
-	size_t num_filter_ssids;
-
-	struct i802_bss first_bss;
-
-#ifdef HOSTAPD
-	int eapol_sock; /* socket for EAPOL frames */
-
-	int default_if_indices[16];
-	int *if_indices;
-	int num_if_indices;
-
-	int last_freq;
-	int last_freq_ht;
-#endif /* HOSTAPD */
-};
-
-#endif
-- 
1.8.0

