From b7c010c7607e2767f69bef9b7712bfb2473b983c Mon Sep 17 00:00:00 2001
From: Liu Xiaowen <b37945@freescale.com>
Date: Thu, 8 Sep 2011 15:28:02 +0800
Subject: [PATCH 173/635] ENGR00156182 add camera hal for honeycomb in
 imx53-smd

add camera hal for honeycomb in imx53-smd and modify
camera hal to use the surface dequeued buffer to
transfer to v4l2 capture device and by queue buffer
to hwcomposer to preview.

Signed-off-by: Liu Xiaowen <b37945@freescale.com>
---
 Android.mk                                    |    4 +-
 mx5x/hwcomposer/blit_ipu.cpp                  |  342 ++--
 mx5x/libcamera/Android.mk                     |   71 +
 mx5x/libcamera/CameraHal.cpp                  | 2094 +++++++++++++++++++++++++
 mx5x/libcamera/CameraHal.h                    |  388 +++++
 mx5x/libcamera/Camera_pmem.cpp                |  163 ++
 mx5x/libcamera/Camera_pmem.h                  |   53 +
 mx5x/libcamera/Camera_utils.h                 |   73 +
 mx5x/libcamera/CaptureDeviceInterface.cpp     |   40 +
 mx5x/libcamera/CaptureDeviceInterface.h       |  103 ++
 mx5x/libcamera/JpegEncoderInterface.cpp       |   34 +
 mx5x/libcamera/JpegEncoderInterface.h         |  173 ++
 mx5x/libcamera/JpegEncoderSoftware.cpp        |  661 ++++++++
 mx5x/libcamera/JpegEncoderSoftware.h          |   84 +
 mx5x/libcamera/PP_ipulib.cpp                  |  138 ++
 mx5x/libcamera/PP_ipulib.h                    |   47 +
 mx5x/libcamera/PostProcessDeviceInterface.cpp |   26 +
 mx5x/libcamera/PostProcessDeviceInterface.h   |   78 +
 mx5x/libcamera/V4l2CapDeviceBase.cpp          |  669 ++++++++
 mx5x/libcamera/V4l2CapDeviceBase.h            |   86 +
 mx5x/libcamera/V4l2CsiDevice.cpp              |  362 +++++
 mx5x/libcamera/V4l2CsiDevice.h                |   53 +
 mx5x/libcamera/V4l2UVCDevice.h                |   41 +
 23 files changed, 5610 insertions(+), 173 deletions(-)
 create mode 100755 mx5x/libcamera/Android.mk
 create mode 100755 mx5x/libcamera/CameraHal.cpp
 create mode 100755 mx5x/libcamera/CameraHal.h
 create mode 100755 mx5x/libcamera/Camera_pmem.cpp
 create mode 100755 mx5x/libcamera/Camera_pmem.h
 create mode 100755 mx5x/libcamera/Camera_utils.h
 create mode 100755 mx5x/libcamera/CaptureDeviceInterface.cpp
 create mode 100755 mx5x/libcamera/CaptureDeviceInterface.h
 create mode 100755 mx5x/libcamera/JpegEncoderInterface.cpp
 create mode 100755 mx5x/libcamera/JpegEncoderInterface.h
 create mode 100755 mx5x/libcamera/JpegEncoderSoftware.cpp
 create mode 100755 mx5x/libcamera/JpegEncoderSoftware.h
 create mode 100755 mx5x/libcamera/PP_ipulib.cpp
 create mode 100755 mx5x/libcamera/PP_ipulib.h
 create mode 100755 mx5x/libcamera/PostProcessDeviceInterface.cpp
 create mode 100755 mx5x/libcamera/PostProcessDeviceInterface.h
 create mode 100755 mx5x/libcamera/V4l2CapDeviceBase.cpp
 create mode 100755 mx5x/libcamera/V4l2CapDeviceBase.h
 create mode 100755 mx5x/libcamera/V4l2CsiDevice.cpp
 create mode 100755 mx5x/libcamera/V4l2CsiDevice.h
 create mode 100755 mx5x/libcamera/V4l2UVCDevice.h

diff --git a/Android.mk b/Android.mk
index 9f1d376..4f175b6 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
-common_imx_dirs := libsensors alsa libcamera
-mx5x_dirs := $(common_imx_dirs) libgps mx5x/libcopybit mx5x/libgralloc
+common_imx_dirs := libsensors alsa
+mx5x_dirs := $(common_imx_dirs) libgps mx5x/libcopybit mx5x/libgralloc  mx5x/hwcomposer mx5x/libcamera
 mx6_dirs := $(common_imx_dirs) mx6/libgralloc
 
 ifeq ($(TARGET_BOARD_PLATFORM),imx6)
diff --git a/mx5x/hwcomposer/blit_ipu.cpp b/mx5x/hwcomposer/blit_ipu.cpp
index 24c0fdd..718e86b 100755
--- a/mx5x/hwcomposer/blit_ipu.cpp
+++ b/mx5x/hwcomposer/blit_ipu.cpp
@@ -1,171 +1,171 @@
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_ipu.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h"
-}
-/*****************************************************************************/
-using namespace android;
-
-int blit_device::isIPUDevice(const char *dev_name)
-{
-		return !strcmp(dev_name, BLIT_IPU);
-}
-
-int blit_device::isGPUDevice(const char *dev_name)
-{
-		return !strcmp(dev_name, BLIT_GPU);
-}
-
-blit_ipu::blit_ipu()
-{
-		init();
-}
-
-blit_ipu::~blit_ipu()
-{
-		uninit();
-}
-
-int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
-{
-		//int status = -EINVAL;
-
-    return 0;
-}
-
-int blit_ipu::uninit()
-{
-	  //int status = -EINVAL;
-
-	  return 0;
-}
-
-static void fill_buffer(char *pbuf, int len)
-{
-    static int k = 0;
-    short * pframe = (short *)pbuf;
-    if(k == 0) {
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0xf800;
-        }
-    }
-
-    if(k == 1){
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0x001f;
-        }
-    }
-
-    if(k == 2){
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0x07E0;
-        }
-    }
-
-    k = (k+1)%3;
-}
-
-int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
-{
-	  int status = -EINVAL;
-	  if(layer == NULL || out_buf == NULL){
-	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
-	  	  return status;
-	  }
-	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
-
-HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^^^^^^^^^^^^^^^^^^^^^");
-	  hwc_rect_t *src_crop = &(layer->sourceCrop);
-	  hwc_rect_t *disp_frame = &(layer->displayFrame);
-	  private_handle_t *handle = (private_handle_t *)(layer->handle);
-
-    //fill_buffer((char *)(handle->base), handle->size);
-
-	  mIPUInputParam.width = src_crop->right - src_crop->left;
-	  mIPUInputParam.height = src_crop->bottom - src_crop->top;
-	  mIPUInputParam.input_crop_win.pos.x = src_crop->left;
-    mIPUInputParam.input_crop_win.pos.y = src_crop->top;
-    mIPUInputParam.input_crop_win.win_w = src_crop->right - src_crop->left;
-    mIPUInputParam.input_crop_win.win_h = src_crop->bottom - src_crop->top;
-
-    if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= NV12");
-        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
-    }
-    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
-HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= I420");
-        mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
-    }
-    else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
-HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= RGBP");
-       // mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
-    }else{
-        HWCOMPOSER_LOG_ERR("Error!Not supported input format %d",handle->format);
-        return status;
-    }
-#if 0
-    if(handle->base != 0) {
-       int *pVal = (int *)handle->base;
-       HWCOMPOSER_LOG_RUNTIME("=========buff[%d]=%x, buff[%d]=%x, phy=%x", 0, pVal[0], 1, pVal[1], handle->phys);
-    }
-#endif
-    mIPUInputParam.user_def_paddr[0] = handle->phys;
-    //out_buf should has width and height to be checked with the display_frame.
-    mIPUOutputParam.fmt = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
-    mIPUOutputParam.show_to_fb = 0;
-//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^out_buf->format= %x, out->phy_addr=%x, in->phys=%x", out_buf->format, out_buf->phy_addr, handle->phys);
-    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK) {
-	    mIPUOutputParam.width = out_buf->width;
-	    mIPUOutputParam.height = out_buf->height;
-		mIPUOutputParam.output_win.pos.x = 0;
-		mIPUOutputParam.output_win.pos.y = 0;
-		mIPUOutputParam.output_win.win_w = out_buf->width;
-		mIPUOutputParam.output_win.win_h = out_buf->height;
-    }
-    else {
-	    mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
-	    mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
-	    mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
-	    mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
-	    mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-	    mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
-  	}
-//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^^right=%d, left=%d, bottom=%d, top=%d", disp_frame->right, disp_frame->left, disp_frame->bottom, disp_frame->top);
-    mIPUOutputParam.rot = layer->transform;
-    mIPUOutputParam.user_def_paddr[0] = out_buf->phy_addr;
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_init-----in blit_ipu::blit()------\n");
-    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
-        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-    else
-        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-	  if(status < 0) {
-	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_init failed %d",status);
-	  		return status;
-	  }
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_buf_update-----in blit_ipu::blit()------\n");
-	  status = mxc_ipu_lib_task_buf_update(&mIPUHandle, handle->phys, out_buf->phy_addr, NULL,NULL,NULL);
-	  if(status < 0) {
-	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_buf_update failed %d",status);
-	  		return status;
-	  }
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_uninit-----in blit_ipu::blit()------\n");
-		mxc_ipu_lib_task_uninit(&mIPUHandle);
-		status = 0;
-        HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^end^^^^^^^^^^^^^^^^^^^^");
-	  return status;
-}
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+using namespace android;
+
+int blit_device::isIPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_IPU);
+}
+
+int blit_device::isGPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_GPU);
+}
+
+blit_ipu::blit_ipu()
+{
+		init();
+}
+
+blit_ipu::~blit_ipu()
+{
+		uninit();
+}
+
+int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
+{
+		//int status = -EINVAL;
+
+    return 0;
+}
+
+int blit_ipu::uninit()
+{
+	  //int status = -EINVAL;
+
+	  return 0;
+}
+
+static void fill_buffer(char *pbuf, int len)
+{
+    static int k = 0;
+    short * pframe = (short *)pbuf;
+    if(k == 0) {
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0xf800;
+        }
+    }
+
+    if(k == 1){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x001f;
+        }
+    }
+
+    if(k == 2){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x07E0;
+        }
+    }
+
+    k = (k+1)%3;
+}
+
+int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+	  int status = -EINVAL;
+	  if(layer == NULL || out_buf == NULL){
+	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
+	  	  return status;
+	  }
+	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
+
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^^^^^^^^^^^^^^^^^^^^^");
+	  hwc_rect_t *src_crop = &(layer->sourceCrop);
+	  hwc_rect_t *disp_frame = &(layer->displayFrame);
+	  private_handle_t *handle = (private_handle_t *)(layer->handle);
+
+    //fill_buffer((char *)(handle->base), handle->size);
+
+	  mIPUInputParam.width = src_crop->right - src_crop->left;
+	  mIPUInputParam.height = src_crop->bottom - src_crop->top;
+	  mIPUInputParam.input_crop_win.pos.x = src_crop->left;
+    mIPUInputParam.input_crop_win.pos.y = src_crop->top;
+    mIPUInputParam.input_crop_win.win_w = src_crop->right - src_crop->left;
+    mIPUInputParam.input_crop_win.win_h = src_crop->bottom - src_crop->top;
+
+    if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= NV12");
+        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }
+    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= I420");
+        mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+    }
+    else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= RGBP");
+        mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+        //mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }else{
+        HWCOMPOSER_LOG_ERR("Error!Not supported input format %d",handle->format);
+        return status;
+    }
+#if 0
+    if(handle->base != 0) {
+       int *pVal = (int *)handle->base;
+       HWCOMPOSER_LOG_RUNTIME("=========buff[%d]=%x, buff[%d]=%x, phy=%x", 0, pVal[0], 1, pVal[1], handle->phys);
+    }
+#endif
+    mIPUInputParam.user_def_paddr[0] = handle->phys;
+    //out_buf should has width and height to be checked with the display_frame.
+    mIPUOutputParam.fmt = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
+    mIPUOutputParam.show_to_fb = 0;
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^out_buf->format= %x, out->phy_addr=%x, in->phys=%x", out_buf->format, out_buf->phy_addr, handle->phys);
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK) {
+	    mIPUOutputParam.width = out_buf->width;
+	    mIPUOutputParam.height = out_buf->height;
+		mIPUOutputParam.output_win.pos.x = 0;
+		mIPUOutputParam.output_win.pos.y = 0;
+		mIPUOutputParam.output_win.win_w = out_buf->width;
+		mIPUOutputParam.output_win.win_h = out_buf->height;
+    }
+    else {
+	    mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
+	    mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
+	    mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
+	    mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
+	    mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+	    mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+  	}
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^^right=%d, left=%d, bottom=%d, top=%d", disp_frame->right, disp_frame->left, disp_frame->bottom, disp_frame->top);
+    mIPUOutputParam.rot = layer->transform;
+    mIPUOutputParam.user_def_paddr[0] = out_buf->phy_addr;
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_init-----in blit_ipu::blit()------\n");
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
+    else
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_init failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_buf_update-----in blit_ipu::blit()------\n");
+	  status = mxc_ipu_lib_task_buf_update(&mIPUHandle, handle->phys, out_buf->phy_addr, NULL,NULL,NULL);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_buf_update failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_uninit-----in blit_ipu::blit()------\n");
+		mxc_ipu_lib_task_uninit(&mIPUHandle);
+		status = 0;
+        HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^end^^^^^^^^^^^^^^^^^^^^");
+	  return status;
+}
diff --git a/mx5x/libcamera/Android.mk b/mx5x/libcamera/Android.mk
new file mode 100755
index 0000000..15e68b5
--- /dev/null
+++ b/mx5x/libcamera/Android.mk
@@ -0,0 +1,71 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(BOARD_SOC_CLASS),IMX5X)
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=    \
+	CameraHal.cpp    \
+    Camera_pmem.cpp  \
+	CaptureDeviceInterface.cpp \
+	V4l2CsiDevice.cpp \
+	V4l2CapDeviceBase.cpp  \
+	PostProcessDeviceInterface.cpp \
+	PP_ipulib.cpp    \
+	JpegEncoderInterface.cpp \
+    JpegEncoderSoftware.cpp
+
+LOCAL_CPPFLAGS +=
+
+LOCAL_SHARED_LIBRARIES:= \
+    libcamera_client \
+    libui \
+    libutils \
+    libcutils \
+    libbinder \
+    libmedia \
+    libhardware_legacy \
+    libdl \
+    libc \
+	libipu
+
+LOCAL_C_INCLUDES += \
+	frameworks/base/include/binder \
+	frameworks/base/include/ui \
+	frameworks/base/camera/libcameraservice \
+	external/linux-lib/ipu \
+    hardware/imx/mx5x/libgralloc
+
+ifeq ($(HAVE_FSL_IMX_CODEC),true)
+    LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
+    LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
+    LOCAL_C_INCLUDES +=	\
+					device/fsl/proprietary/codec/ghdr
+endif
+ifeq ($(BOARD_CAMERA_NV12),true)
+    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
+else
+    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_YUV420
+endif
+	
+LOCAL_MODULE:= libcamera
+
+LOCAL_CFLAGS += -fno-short-enums
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := eng
+
+include $(BUILD_SHARED_LIBRARY)
+endif
diff --git a/mx5x/libcamera/CameraHal.cpp b/mx5x/libcamera/CameraHal.cpp
new file mode 100755
index 0000000..6ab9974
--- /dev/null
+++ b/mx5x/libcamera/CameraHal.cpp
@@ -0,0 +1,2094 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#include <cutils/properties.h>
+#include "CameraHal.h"
+#include <time.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <hardware_legacy/power.h>
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+#include "gralloc_priv.h"
+
+namespace android {
+
+    CameraHal::CameraHal()
+        : mParameters(),
+        mCallbackCookie(NULL),
+        mNotifyCb(NULL),
+        mDataCb(NULL),
+        mDataCbTimestamp(NULL),
+        mCaptureFrameThread(NULL),
+        mPostProcessThread(NULL),
+        mPreviewShowFrameThread(NULL),
+        mEncodeFrameThread(NULL),
+        mAutoFocusThread(NULL),
+        mTakePicThread(NULL),
+        mLock(),
+        supportedPictureSizes(NULL),
+        supportedPreviewSizes(NULL),
+        supportedFPS(NULL),
+        supprotedThumbnailSizes(NULL),
+        mNativeWindow(NULL),
+        mMsgEnabled(0),
+        mPreviewHeap(0),
+        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
+        mPPbufNum(0),
+        mPreviewRunning(0),
+        mPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
+        mPreviewFrameSize(0),
+        mTakePicFlag(false),
+        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
+        mCaptureFrameSize(0),
+        mCaptureBufNum(0),
+        mEnqueuedBufs(0),
+        isCaptureBufsAllocated(0),
+        //isPreviewFinsh(0),
+        mRecordRunning(0),
+        mCurrentRecordFrame(0),
+        nCameraBuffersQueued(0),
+        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
+        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
+        mCameraReady(false),
+        mCaptureDeviceOpen(false),
+        mPPDeviceNeed(false),
+		bDerectInput(false),
+        mPPDeviceNeedForPic(false),
+        mPowerLock(false),
+        mPreviewRotate(CAMERA_PREVIEW_BACK_REF)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        preInit();
+    }
+
+    CameraHal :: ~CameraHal()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CameraMiscDeInit();
+        CloseCaptureDevice();
+        FreeInterBuf();
+        postDestroy();
+    }
+
+    void CameraHal :: release()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        Mutex::Autolock lock(mLock);
+
+        mCameraReady = false;
+        CameraHALStopPreview();
+        UnLockWakeLock();
+        return;
+    }
+
+    void CameraHal :: preInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+    }
+    void CameraHal :: postDestroy()
+    {
+        CAMERA_HAL_LOG_FUNC;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mCaptureDevice = capturedevice;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mPPDevice = postprocessdevice;
+        else 
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mJpegEncoder = jpegencoder;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal::Init()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        mCameraReady == true;
+
+        if ((ret = AolLocForInterBuf())<0)
+            return ret;
+        if ((ret = InitCameraHalParam()) < 0)
+            return ret;
+        if (mPPDeviceNeed == true && mPPDevice == NULL)
+            return CAMERA_HAL_ERR_PP_NULL;
+        if ((ret = CameraMiscInit()) < 0)
+            return ret;
+
+        return ret;
+    }
+    void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mPreviewRotate = previewRotate;
+        return ;
+    }
+
+    CAMERA_HAL_ERR_RET  CameraHal :: AolLocForInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+
+        supportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+
+        if (supportedPictureSizes == NULL ||
+                supportedPreviewSizes == NULL ||
+                supportedFPS          == NULL ||
+                supprotedThumbnailSizes == NULL)
+            ret = CAMERA_HAL_ERR_ALLOC_BUF;
+
+        return ret;
+    }
+    void  CameraHal :: FreeInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (supportedPictureSizes)
+            free(supportedPictureSizes);
+        if (supportedPreviewSizes)
+            free(supportedPreviewSizes);
+        if (supportedFPS)
+            free(supportedFPS);
+        if (supprotedThumbnailSizes)
+            free(supprotedThumbnailSizes);
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
+    {	
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+
+        if ((ret = GetCameraBaseParam(&mParameters)) < 0)
+            return ret;
+
+        if ((ret = GetPictureExifParam(&mParameters)) < 0)
+            return ret;
+
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        pthread_mutex_init(&mPPIOParamMutex, NULL);
+        pthread_mutex_init(&mOverlayMutex, NULL);
+        return ret;
+    }
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        pthread_mutex_destroy(&mPPIOParamMutex);
+        pthread_mutex_destroy(&mOverlayMutex);
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: GetCameraBaseParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char TmpStr[20];
+        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
+        struct capture_config_t CaptureSizeFps;
+        int  previewCnt= 0, pictureCnt = 0, i;
+
+        pParam->setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);
+        pParam->set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, CameraParameters::PIXEL_FORMAT_YUV420SP);
+
+        //the Camera Open here will not be close immediately, for later preview.
+        if (OpenCaptureDevice() < 0)
+            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
+
+        memset(mCaptureSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+
+        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mCaptureSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
+
+        if (NegotiateCaptureFmt(false) < 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
+
+        CaptureSizeFps.fmt = mPreviewCapturedFormat;
+
+        CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat is %x", mPreviewCapturedFormat);
+
+        for(;;){
+            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
+                CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
+                break;
+            }
+            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
+            CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
+            if (previewCnt == 0)
+                strncpy((char*) supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            else{
+                strncat(supportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                strncat(supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            }
+            pictureCnt ++;
+
+            if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator > 25){
+                if (previewCnt == 0)
+                    strncpy((char*) supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                else{
+                    strncat(supportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                }
+                previewCnt ++;
+            }
+        }
+
+        /*hard code here*/
+        strcpy(supportedFPS, "15,30");
+        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", supportedPictureSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", supportedPreviewSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", supportedFPS);
+
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, supportedPictureSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, supportedPreviewSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, supportedFPS);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(1000,15000),(5000,30000)");
+        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "5000,30000");
+
+        pParam->setPreviewSize(640, 480);
+        pParam->setPictureSize(640, 480);
+        pParam->setPreviewFrameRate(5);
+
+        return CAMERA_HAL_ERR_NONE;
+
+    }
+
+    status_t CameraHal :: OpenCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDeviceOpen){
+            CAMERA_HAL_LOG_INFO("The capture device already open");
+            return NO_ERROR;
+        }
+        else if (mCaptureDevice != NULL){
+            if ( mCaptureDevice->DevOpen()<0 )
+                return INVALID_OPERATION;
+            mCaptureDeviceOpen = true;
+        }else{
+            CAMERA_HAL_ERR("no capture device assigned");
+            return INVALID_OPERATION;
+        }
+        return ret;
+    }
+    void CameraHal ::CloseCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
+            mCaptureDevice->DevClose();
+            mCaptureDeviceOpen = false;
+        }
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: GetPictureExifParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
+
+        /*hard code here*/
+        pParam->set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
+        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
+        strcpy(supprotedThumbnailSizes, "0x0,128x128,96x96");
+        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, supprotedThumbnailSizes);
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
+        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
+        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
+
+        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
+        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
+
+        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
+        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
+        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
+        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
+        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
+        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
+        // default zoom should be 0 as CTS defined
+        pParam->set(CameraParameters::KEY_ZOOM, "0");
+        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+        //returned as 320. The number of elements is {@link
+        //#getMaxZoom} + 1. The list is sorted from small to large. The
+        //first element is always 100. The last element is the zoom
+        //ratio of the maximum zoom value.
+        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
+
+        return CAMERA_HAL_ERR_NONE;
+    }
+
+    sp<IMemoryHeap> CameraHal::getRawHeap() const
+    {
+        return NULL;
+    }
+
+    status_t CameraHal::dump(int fd, const Vector<String16>& args) const
+    {
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
+            int32_t arg2)
+    {
+        return BAD_VALUE;
+    }
+
+    void CameraHal::setCallbacks(notify_callback notify_cb,
+            data_callback data_cb,
+            data_callback_timestamp data_cb_timestamp,
+            void* user)
+    {
+        Mutex::Autolock lock(mLock);
+        mNotifyCb = notify_cb;
+        mDataCb = data_cb;
+        mDataCbTimestamp = data_cb_timestamp;
+        mCallbackCookie = user;
+    }
+
+    void CameraHal::enableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg enabled is %x###", msgType);
+        mMsgEnabled |= msgType;
+    }
+
+    void CameraHal::disableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg disabled is %x###", msgType);
+        mMsgEnabled &= ~msgType;
+    }
+    bool CameraHal::msgTypeEnabled(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg check is %x###", msgType);
+        return (mMsgEnabled & msgType);
+    }
+
+    CameraParameters CameraHal::getParameters() const
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        Mutex::Autolock lock(mLock);
+        return mParameters;
+    }
+
+    status_t  CameraHal:: setParameters(const CameraParameters& params)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int w, h;
+        int framerate;
+        int max_zoom,zoom, max_fps, min_fps;
+        char tmp[128];
+        Mutex::Autolock lock(mLock);
+
+        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
+        zoom = params.getInt(CameraParameters::KEY_ZOOM);
+        if(zoom > max_zoom){
+            CAMERA_HAL_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
+            return BAD_VALUE;
+        }
+        if (!(strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
+                (strcmp(params.getPreviewFormat(), "yuv422i") == 0)) {
+            CAMERA_HAL_ERR("Only yuv420 or yuv420i is supported");
+            return BAD_VALUE;
+        }
+
+        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
+            CAMERA_HAL_ERR("Only jpeg still pictures are supported");
+            return BAD_VALUE;
+        }
+
+        params.getPreviewSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
+        if (strstr(supportedPreviewSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
+
+        params.getPictureSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
+        if (strstr(supportedPictureSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
+
+        framerate = params.getPreviewFrameRate();
+        CAMERA_HAL_LOG_INFO("##the set frame rate is %d ##", framerate);
+        if (framerate >30 || framerate<0 ){
+            CAMERA_HAL_ERR("The framerate is not corrected");
+            return BAD_VALUE;
+        }
+
+        params.getPreviewFpsRange(&min_fps, &max_fps);
+        CAMERA_HAL_LOG_INFO("###the fps is %d###", max_fps);
+        if (max_fps < 1000 || min_fps < 1000 || max_fps > 30000 || min_fps > 30000){
+            CAMERA_HAL_ERR("The fps range from %d to %d is error", min_fps, max_fps);
+            return BAD_VALUE;
+        }
+
+        mParameters = params;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::setPreviewWindow(const sp<ANativeWindow>& buf)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(buf == 0) {
+            isCaptureBufsAllocated = 0;
+            CAMERA_HAL_ERR("the buf is null!");
+        }
+        else {
+            CAMERA_HAL_ERR("the buf is not null!");
+        }
+        mNativeWindow = buf;
+        if((mNativeWindow != NULL) && !isCaptureBufsAllocated) {
+            if(PrepareCaptureBufs() < 0) {
+                CAMERA_HAL_ERR("PrepareCaptureBufs()-2 error");
+                return BAD_VALUE;
+            }
+            if(CameraHALPreviewStart() < 0) {
+                CAMERA_HAL_ERR("CameraHALPreviewStart()-2 error");
+                return BAD_VALUE;
+            }
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::freeBuffersToNativeWindow()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        //Mutex::Autolock lock(mLock);
+        if (mNativeWindow == NULL){
+            CAMERA_HAL_ERR("the native window is null!");
+            return BAD_VALUE;
+        }
+ 
+        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+        android_native_buffer_t *buf;
+        private_handle_t *handle;
+        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
+            if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_QUEUED)
+                continue;
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_QUEUED;
+            buf = (android_native_buffer_t *)mCaptureBuffers[i].native_buf;
+            if(mCaptureBuffers[i].virt_start != NULL) {
+                handle = (private_handle_t *)buf->handle;
+                mapper.unlock(handle);
+            }
+            if(buf != NULL) {
+                mNativeWindow->cancelBuffer(mNativeWindow.get(), buf);
+            }
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::allocateBuffersFromNativeWindow()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        //Mutex::Autolock lock(mLock);
+        if (mNativeWindow == NULL){
+            CAMERA_HAL_ERR("the native window is null!");
+            return NO_ERROR;//BAD_VALUE;
+        }
+        status_t err = native_window_set_buffers_geometry(mNativeWindow.get(),
+                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height, 
+                HAL_PIXEL_FORMAT_YCbCr_420_SP);//mCaptureDeviceCfg.fmt);
+        if(err != 0){
+            CAMERA_HAL_ERR("native_window_set_buffers_geometry failed:%s(%d)", 
+                    strerror(-err), -err);
+            return err;
+        }
+
+        err = native_window_set_usage(mNativeWindow.get(), GRALLOC_USAGE_SW_READ_OFTEN |
+                GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HWC_OVERLAY);
+        if(err != 0){
+            CAMERA_HAL_ERR("native_window_set_usage failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        int minUndequeueBufs = 0;
+        err = mNativeWindow->query(mNativeWindow.get(),
+                NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, &minUndequeueBufs);
+        if(err != 0) {
+            CAMERA_HAL_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        if(mCaptureBufNum > PREVIEW_CAPTURE_BUFFER_NUM) {
+            CAMERA_HAL_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
+            return BAD_VALUE;
+        }
+
+        err = native_window_set_buffer_count(mNativeWindow.get(), mCaptureBufNum);
+        if(err != 0) {
+            CAMERA_HAL_ERR("native_window_set_buffer_count failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        unsigned int i;
+        Rect bounds(mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+        void *pVaddr = NULL;
+        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+        for(i = 0; i < mCaptureBufNum; i++) {
+            android_native_buffer_t *buf = NULL;
+            pVaddr = NULL;
+            err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf);
+            if((err != 0) || (buf == NULL)) {
+                CAMERA_HAL_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
+                break;
+            }
+            private_handle_t *handle = (private_handle_t *)buf->handle;
+            mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
+
+            if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
+                 CAMERA_HAL_ERR("%s: dequeue invalide Buffer, phys=%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
+                 break;
+            }
+
+            mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
+            mCaptureBuffers[i].phy_offset = handle->phys;
+            mCaptureBuffers[i].length = handle->size;
+            mCaptureBuffers[i].native_buf = (void *)buf;
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
+            CAMERA_HAL_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%x, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::startPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        Mutex::Autolock lock(mLock);
+        //isPreviewFinsh = 0;
+        if (mPreviewRunning) {
+            return NO_ERROR;
+        }
+        if ((ret == CameraHALStartPreview())<0)
+            return ret;
+
+        if((ret = AllocateRecordVideoBuf())<0)
+            return ret;
+        LockWakeLock();
+        return ret;
+    }
+
+    void CameraHal::stopPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timeval af_time, be_time;
+        Mutex::Autolock lock(mLock);
+        /* Cannot stop preview in recording */
+        //   if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
+        //       return;
+
+        //isPreviewFinsh = 1;
+        CameraHALStopPreview();
+        UnLockWakeLock();
+
+    }
+
+    bool CameraHal::previewEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return mPreviewRunning;
+    }
+
+	status_t CameraHal::storeMetaDataInBuffers(bool enable)
+	{
+        CAMERA_HAL_LOG_FUNC;
+        unsigned int i;
+
+		bDerectInput = enable;
+		if (bDerectInput == true) {
+			if (!mPPDeviceNeed){
+				for(i = 0 ; i < mCaptureBufNum; i ++) {
+					mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
+					CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mCaptureBuffers[i].phy_offset);
+					mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
+					memcpy(mVideoBuffers[i]->pointer(),
+							(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+				}
+			}else{
+				for(i = 0 ; i < mPPbufNum; i ++) {
+					mVideoBufferPhy[i].phy_offset = mPPbuf[i].phy_offset;
+					CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mPPbuf[i].phy_offset);
+					mVideoBufferPhy[i].length = mPPbuf[i].length;
+					memcpy(mVideoBuffers[i]->pointer(),
+							(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+				}
+			}
+		}
+
+		return NO_ERROR;
+	}
+
+	int32_t CameraHal::getNumberOfVideoBuffers() const
+	{
+        CAMERA_HAL_LOG_FUNC;
+
+		if (!mPPDeviceNeed){
+			return mCaptureBufNum;
+		}else{
+			return  mPPbufNum;
+		}
+	}
+
+	sp<IMemory> CameraHal::getVideoBuffer(int32_t index) const
+	{
+        CAMERA_HAL_LOG_FUNC;
+
+		return mVideoBuffers[index];
+	}
+
+    status_t CameraHal::startRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int i;
+
+        if (mRecordRunning == true ) {
+            CAMERA_HAL_LOG_INFO("Recording is already existed\n");
+            return ret;
+        }
+
+        mRecordRunning = true;
+
+		if (bDerectInput == true) {
+			if (!mPPDeviceNeed){
+				for(i = 0 ; i < mCaptureBufNum; i ++) {
+					sem_post(&avab_enc_frame_finish);
+				}
+			}else{
+				for(i = 0 ; i < mPPbufNum; i ++) {
+					sem_post(&avab_enc_frame_finish);
+				}
+			}
+
+			for(i = 0; i < mVideoBufNume; i++) {
+				mVideoBufferUsing[i] = 0;
+			}
+		}
+
+        return NO_ERROR;
+    }
+
+    void CameraHal::stopRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mRecordRunning = false;
+		if (bDerectInput == true) 
+			bDerectInput = false;
+			sem_post(&avab_enc_frame_finish);
+		}
+
+    void CameraHal::releaseRecordingFrame(const sp<IMemory>& mem)
+    {
+        ssize_t offset;
+        size_t  size;
+        int index;
+
+        offset = mem->offset();
+        size   = mem->size();
+        index = offset / size;
+
+        mVideoBufferUsing[index] = 0;
+
+		if (bDerectInput == true)
+			sem_post(&avab_enc_frame_finish);
+    }
+
+    bool CameraHal::recordingEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return (mPreviewRunning && mRecordRunning);
+    }
+
+    status_t CameraHal::autoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        Mutex::Autolock lock(mLock);
+
+        if (mAutoFocusThread != NULL)
+            mAutoFocusThread.clear();
+
+        mAutoFocusThread = new AutoFocusThread(this);
+        if (mAutoFocusThread == NULL)
+            return UNKNOWN_ERROR;
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::cancelAutoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::takePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        Mutex::Autolock lock(mLock);
+
+        if (mTakePicThread != NULL)
+            mTakePicThread.clear();
+
+        mTakePicThread= new TakePicThread(this);
+        if (mTakePicThread == NULL)
+            return UNKNOWN_ERROR;
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::cancelPicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        return NO_ERROR;
+    }
+
+
+    int CameraHal::autoFocusThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int FocusFlag = 0;
+
+        if (mMsgEnabled & CAMERA_MSG_FOCUS)
+            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
+
+        return UNKNOWN_ERROR; //exit the thread
+    }
+
+    int CameraHal::takepicThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_INFO("Camera is taking picture!");
+
+        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
+        CameraHALStopPreview();
+        cameraHALTakePicture();
+
+        return UNKNOWN_ERROR;
+    }
+
+    int CameraHal :: cameraHALTakePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR;
+        unsigned int DeQueBufIdx = 0;
+        struct jpeg_encoding_conf JpegEncConf;
+        DMA_BUFFER Buf_input, Buf_output;
+        sp<MemoryBase> JpegMemBase = NULL;
+        sp<MemoryHeapBase> JpegImageHeap = NULL;
+        int  max_fps, min_fps;
+
+        if (mJpegEncoder == NULL){
+            CAMERA_HAL_ERR("the jpeg encoder is NULL");
+            return BAD_VALUE;
+        }
+        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDevice->GetDevName(mCameraSensorName);
+        if (strstr(mCameraSensorName, "uvc") == NULL){
+        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
+        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
+        if (mParameters.getPreviewFrameRate() >= 15)
+            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        else{
+            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
+            CAMERA_HAL_LOG_INFO("###start the preview the fps is %d###", max_fps);
+            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+        }
+        }else{
+                mCaptureDeviceCfg.tv.denominator = 15;
+        }
+        mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
+        mPPbufNum = 1;
+        mTakePicFlag = true;
+        mPPDeviceNeedForPic = false;
+        if ((ret = GetJpegEncoderParam()) < 0)
+            return ret;
+        if ((ret = NegotiateCaptureFmt(true)) < 0)
+            return ret;
+
+        if (mPPDeviceNeedForPic){
+            if ((ret = PreparePostProssDevice()) < 0){
+                CAMERA_HAL_ERR("PreparePostProssDevice error");
+                return ret;
+            }
+        }
+        if ((ret = PrepareCaptureDevices()) < 0)
+            return ret;
+
+        if (mPPDeviceNeedForPic){
+            if ((ret = PreparePreviwBuf()) < 0){
+                CAMERA_HAL_ERR("PreparePreviwBuf error");
+                return ret;
+            }
+        }
+        if ((ret = PrepareJpegEncoder()) < 0)
+            return ret;
+
+        if (mCaptureDevice->DevStart()<0){
+            CAMERA_HAL_ERR("the capture start up failed !!!!");
+            return INVALID_OPERATION;
+        }
+
+        for (unsigned int i =0;;){
+            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
+                LOGE("VIDIOC_DQBUF Failed!!!");
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
+
+            if (++i == mCaptureDeviceCfg.picture_waite_number)
+                break;
+
+            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
+        }
+
+        JpegImageHeap= new MemoryHeapBase(mCaptureFrameSize);
+        if (JpegImageHeap == NULL){
+            ret = NO_MEMORY;
+            goto Pic_out;
+        }
+        // do the csc if necessary
+        if (mPPDeviceNeedForPic){
+            mPPInputParam.user_def_paddr = mCaptureBuffers[DeQueBufIdx].phy_offset;
+            mPPOutputParam.user_def_paddr = mPPbuf[0].phy_offset;
+            mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+            mPPDevice->DoPorcess(&(mCaptureBuffers[DeQueBufIdx]), &(mPPbuf[0]));
+            mPPDevice->PPDeviceDeInit();
+            Buf_input = mPPbuf[0];
+        }else{
+            Buf_input = mCaptureBuffers[DeQueBufIdx];
+        }
+
+        Buf_output.virt_start = (unsigned char *)(JpegImageHeap->getBase());
+        CAMERA_HAL_LOG_INFO("Generated a picture");
+
+        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
+            CAMERA_HAL_LOG_INFO("CAMERA_MSG_SHUTTER");
+            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
+        }
+
+        if (mJpegEncoder->DoEncode(&Buf_input,&Buf_output,&JpegEncConf) < 0){
+            ret = UNKNOWN_ERROR;
+            goto Pic_out;
+        }
+
+        JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
+
+Pic_out:
+        mCaptureDevice->DevStop();
+        //mCaptureDevice->DevDeAllocate();
+        freeBuffersToNativeWindow();
+        CloseCaptureDevice();
+
+        if ((JpegMemBase != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
+            CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
+            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, mCallbackCookie);
+        }
+
+
+        return ret;
+
+    }
+
+    int CameraHal :: GetJpegEncoderParam()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0;
+        memset(mEncoderSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+
+        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mEncoderSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0){
+            CAMERA_HAL_ERR("Get the parameters error");
+            return UNKNOWN_ERROR;
+        }
+        return ret;
+    }
+    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0, j = 0;
+
+
+        if(TakePicFlag){
+            mPictureEncodeFormat = 0;
+            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
+                    if (mEncoderSupportedFormat[j] == 0)
+                        break;
+                    if (mCaptureSupportedFormat[i] == mEncoderSupportedFormat[j]){
+                        mPictureEncodeFormat= mCaptureSupportedFormat[i];
+
+                        CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
+                                mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
+                                (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
+                        break;
+                    }
+                }
+                if ((mPictureEncodeFormat != 0) || (mCaptureSupportedFormat[i] == 0))
+                    break;
+            }
+            if (mPictureEncodeFormat == 0){
+                mPictureEncodeFormat = mEncoderSupportedFormat[0];
+                mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat; //For uvc now, IPU only can support yuyv.
+                mPPDeviceNeedForPic = true;
+                CAMERA_HAL_LOG_INFO("Need to do the CSC for Jpeg encoder");
+                CAMERA_HAL_LOG_INFO(" Get the captured format is :%c%c%c%c\n",
+                        mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
+                        (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
+                CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
+                        mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
+                        (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
+            }else{
+                mCaptureDeviceCfg.fmt = mPictureEncodeFormat;
+            }
+        }else{
+            CAMERA_HAL_LOG_INFO("mPreviewFormat :%c%c%c%c\n",
+                    mPreviewFormat & 0xFF, (mPreviewFormat >> 8) & 0xFF,
+                    (mPreviewFormat >> 16) & 0xFF, (mPreviewFormat >> 24) & 0xFF);
+            CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
+                    mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
+                    (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
+
+            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
+                if (mCaptureSupportedFormat[i] == mPreviewFormat){
+                    CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                    mPPDeviceNeed = false;
+                    mPreviewCapturedFormat = mPreviewFormat;
+                    break;
+                }
+            }
+
+            if (i == MAX_QUERY_FMT_TIMES){
+                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                    //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
+                    if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
+                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                        mPPDeviceNeed = true;
+                        mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
+                        break;
+                    }
+                }
+            }
+
+            CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat :%c%c%c%c\n",
+                    mPreviewCapturedFormat & 0xFF, (mPreviewCapturedFormat >> 8) & 0xFF,
+                    (mPreviewCapturedFormat >> 16) & 0xFF, (mPreviewCapturedFormat >> 24) & 0xFF);
+
+            if ((i == MAX_QUERY_FMT_TIMES)){
+                CAMERA_HAL_ERR("Negotiate for the preview format error");
+                return BAD_VALUE;
+            }
+        }
+
+
+        return ret;
+    }
+
+    int CameraHal :: PrepareJpegEncoder()
+    {
+        int ret = NO_ERROR;
+        struct jpeg_enc_make_info_t make_info;
+        struct jpeg_enc_makernote_info_t makernote_info;
+        struct jpeg_enc_model_info_t model_info;
+        struct jpeg_enc_datetime_info_t datetime_info;
+        struct jpeg_enc_focallength_t focallength_info;
+        struct jpeg_enc_gps_param gps_info;
+        int rotate_angle = 0;
+        JPEG_ENCODER_WHITEBALANCE whitebalance_info;
+        JPEG_ENCODER_FLASH flash_info;
+        const char * pWhiteBalanceStr, *pFlashStr;
+
+        char temp_string[30], gps_datetime_string[11];
+        char format[30] = "%Y:%m:%d %k:%M:%S";
+        time_t clock;
+        struct tm *tm, *temp_tm;
+        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
+        double dAltitude;
+
+        mJpegEncCfg.BufFmt = mPictureEncodeFormat;
+        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
+        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
+        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
+        CAMERA_HAL_LOG_INFO("the pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
+        CAMERA_HAL_LOG_INFO("the thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
+        //set focallength info
+        focallength_info.numerator=10001;
+        focallength_info.denominator=1000;  // hardcode here for the cts
+        mJpegEncCfg.pFoclLength = &focallength_info;
+
+        //set the make info
+        make_info.make_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)make_info.make, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeInfo = &make_info;
+
+        //set makernote info
+        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeNote = &makernote_info;
+
+        //set model info
+        model_info.model_bytes=strlen(EXIF_MODEL);
+        strcpy((char *)model_info.model,EXIF_MODEL);
+        mJpegEncCfg.pModelInfo = &model_info;
+
+        //set datetime
+        time(&clock);
+        tm = localtime(&clock);
+        time_t GpsUtcTime;
+        strftime(temp_string, sizeof(temp_string), format, tm);
+        CAMERA_HAL_LOG_INFO("the date time is %s", temp_string);
+        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
+        mJpegEncCfg.pDatetimeInfo = &datetime_info;
+
+        rotate_angle = mParameters.getInt(CameraParameters::KEY_ROTATION);
+        if (rotate_angle == 0)
+            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL; //the android and the jpeg has the same define
+        else if (rotate_angle == 90)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_90;
+        else if (rotate_angle == 180)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_180;
+        else if (rotate_angle == 270)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
+        else
+            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
+        CAMERA_HAL_LOG_INFO("ratate info is %d", rotate_angle);
+
+        pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
+        CAMERA_HAL_LOG_INFO("white balance is %s",pWhiteBalanceStr);
+        if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
+            whitebalance_info = WHITEBALANCE_AUTO;
+        }else{
+            whitebalance_info = WHITEBALANCE_MANUAL;
+        }
+        mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
+
+        pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
+        CAMERA_HAL_LOG_INFO("flash mode is %s", pFlashStr);
+        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
+            flash_info = FLASH_NOT_FIRE;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
+            flash_info = FLASH_FIRED_AUTO;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) == 0){
+            flash_info = FLASH_FIRED;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) == 0){
+            flash_info = FLASH_FIRED_RED_EYE_REDUCE;
+        }
+        else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) == 0){
+            flash_info = FLASH_FIRED_COMPULOSORY;
+        }
+        else{
+            flash_info = FLASH_NOT_FIRE;
+        }
+        mJpegEncCfg.FlashInfo = flash_info;
+
+        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
+        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
+        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
+        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
+
+        if (cLatitude !=NULL && cLatitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
+
+            gps_info.version=0x02020000;
+
+            //latitude: dd/1,mm/1,ss/1
+            gps_info.latitude_degree[1]=1;
+            gps_info.latitude_minute[1]=1;
+            gps_info.latitude_second[1]=1;
+            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
+
+            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
+                //the ref is south
+                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
+            }
+
+            //longtitude: dd/1,mm/1,ss/1
+            gps_info.longtitude_degree[1]=1;
+            gps_info.longtitude_minute[1]=1;
+            gps_info.longtitude_second[1]=1;
+            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
+
+            if (stringTodegree(cLatitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
+                //the ref is Weston
+                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
+            }
+
+            //altitude(meters): aa/1
+            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
+            gps_info.altitude[0]=1000;
+            gps_info.altitude[1]=1;
+            if (cAltitude != NULL){
+                int intValue;
+                gps_info.altitude[1]=1000;	   // the precision is CM
+                dAltitude= atof(cAltitude);
+                CAMERA_HAL_LOG_RUNTIME("the altitude is %s", cAltitude);
+                intValue = (int)(dAltitude * 1000.0);
+                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
+                gps_info.altitude[0] = (unsigned long) intValue;
+                CAMERA_HAL_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
+            }
+
+            //timestamp: hh/1,mm/1,ss/1
+            gps_info.hour[1]=1;
+            gps_info.minute[1]=1;
+            gps_info.seconds[1]=1;
+            if (cTimeStamp != NULL){
+
+                GpsUtcTime = atol(cTimeStamp);
+                CAMERA_HAL_LOG_INFO("the Timestamp is %s", cTimeStamp);
+                temp_tm = gmtime((const time_t*)&GpsUtcTime);
+                if (temp_tm != NULL)
+                    tm = temp_tm;
+            }
+
+            gps_info.hour[0] = tm->tm_hour;
+            gps_info.minute[0] = tm->tm_min;
+            gps_info.seconds[0] = tm->tm_sec;
+
+            strcpy (format, "%Y:%m:%d ");
+
+
+            strftime((char *)temp_string, strlen(temp_string), format, tm);
+            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
+
+
+            char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
+            if (progressMehod == NULL){
+                CAMERA_HAL_LOG_INFO("The progressMethod is NULL, add a fake");
+                progressMehod = (char *)"fsl_fake_method";
+            }
+            CAMERA_HAL_LOG_INFO("the progressMethod is %s", progressMehod);
+
+            memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
+
+            gps_info.processmethod_bytes=strlen(progressMehod);
+
+            CAMERA_HAL_LOG_INFO("the method is %s", gps_info.processmethod);
+
+            mJpegEncCfg.pGps_info = &gps_info;
+        }else{
+            mJpegEncCfg.pGps_info = NULL;
+        }
+
+        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
+            CAMERA_HAL_ERR("Jpeg Encoder Init error !!!");
+            return UNKNOWN_ERROR;
+        }
+
+        return ret;
+    }
+    status_t CameraHal::CameraHALStartPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int  max_fps, min_fps;
+        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
+        mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDevice->GetDevName(mCameraSensorName);
+        if (strstr(mCameraSensorName, "uvc") == NULL){
+        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
+        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
+        if (mParameters.getPreviewFrameRate() >= 15)
+            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        else{
+            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
+            CAMERA_HAL_LOG_INFO("###start the capture the fps is %d###", max_fps);
+            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+        }
+        }else{
+                mCaptureDeviceCfg.tv.denominator = 15;
+        }
+        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
+        mPPbufNum = POST_PROCESS_BUFFER_NUM;
+        mTakePicFlag = false;
+
+        if ((ret = PrepareCaptureDevices()) < 0){
+            CAMERA_HAL_ERR("PrepareCaptureDevices error ");
+            return ret;
+        }
+        if (mPPDeviceNeed){
+            if ((ret = PreparePostProssDevice()) < 0){
+                CAMERA_HAL_ERR("PreparePostProssDevice error");
+                return ret;
+            }
+        }
+        if ((ret = PreparePreviwBuf()) < 0){
+            CAMERA_HAL_ERR("PreparePreviwBuf error");
+            return ret;
+        }
+
+        if ((ret = PreparePreviwMisc()) < 0){
+            CAMERA_HAL_ERR("PreparePreviwMisc error");
+            return ret;
+        }
+
+        if(mNativeWindow != NULL) {
+            if ((ret = CameraHALPreviewStart()) < 0){
+                CAMERA_HAL_ERR("CameraHALPreviewStart error");
+                return ret;
+            }
+        }
+        mPreviewRunning = true;
+        return ret;
+    }
+    void CameraHal::CameraHALStopPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mPreviewRunning != 0)	{
+            CameraHALStopThreads();
+            CameraHALStopMisc();
+            CAMERA_HAL_LOG_INFO("camera hal stop preview done");
+        }else{
+            CAMERA_HAL_LOG_INFO("Camera hal already stop preview");
+        }
+        return ;
+    }
+
+    void CameraHal :: CameraHALStopThreads()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mPreviewRunning = 0;
+        if (mCaptureFrameThread!= 0){
+            mCaptureFrameThread->requestExitAndWait();
+            mCaptureFrameThread.clear();
+        }
+        if (mPPDeviceNeed){
+            if (mPostProcessThread!= 0){
+                mPostProcessThread->requestExitAndWait();
+                mPostProcessThread.clear();
+            }
+        }
+        if (mPreviewShowFrameThread!= 0){
+            mPreviewShowFrameThread->requestExitAndWait();
+            mPreviewShowFrameThread.clear();
+        }
+
+        if (mEncodeFrameThread!= 0){
+            mEncodeFrameThread->requestExitAndWait();
+            mEncodeFrameThread.clear();
+        }
+        return ;
+    }
+
+    void CameraHal :: CameraHALStopMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        sem_destroy(&avab_dequeue_frame);
+        sem_destroy(&avab_show_frame);
+        sem_destroy(&avab_enc_frame);
+        sem_destroy(&avab_enc_frame_finish);
+        if(mPPDeviceNeed){
+            sem_destroy(&avab_pp_in_frame);
+            sem_destroy(&avab_pp_out_frame);
+        }
+        if(mPPDeviceNeed){
+            for (unsigned int i = 0; i < mPPbufNum; i++){
+                mPmemAllocator->deAllocate(&mPPbuf[i]);
+            }
+            mPmemAllocator = NULL;
+        }
+        mCaptureDevice->DevStop();
+        //mCaptureDevice->DevDeAllocate();
+        freeBuffersToNativeWindow();
+        CloseCaptureDevice();
+
+    }
+
+    status_t CameraHal :: PrepareCaptureBufs()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        //status_t ret = NO_ERROR;
+        unsigned int CaptureBufNum = mCaptureBufNum;
+        
+        if(allocateBuffersFromNativeWindow() < 0) {
+            CAMERA_HAL_ERR("allocateBuffersFromNativeWindow error");
+            return BAD_VALUE;
+        }
+
+        if (mCaptureDevice->DevRegisterBufs(mCaptureBuffers,&CaptureBufNum)< 0){
+            CAMERA_HAL_ERR("capture device allocat buf error");
+            return BAD_VALUE;
+        }
+        if(mCaptureBufNum != CaptureBufNum){
+            CAMERA_HAL_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
+        }
+
+        mCaptureBufNum = CaptureBufNum;
+
+        if (mCaptureDevice->DevPrepare()< 0){
+            CAMERA_HAL_ERR("capture device prepare error");
+            return BAD_VALUE;
+        }
+        nCameraBuffersQueued = mCaptureBufNum;
+        isCaptureBufsAllocated = 1;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal :: PrepareCaptureDevices()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int i =0;
+        //unsigned int CaptureBufNum = mCaptureBufNum;
+        struct capture_config_t *pCapcfg;
+        if ((ret = OpenCaptureDevice())<0)
+            return ret;
+
+        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
+            CAMERA_HAL_ERR("Dev config failed");
+            return BAD_VALUE;
+        }
+        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
+
+        if(mNativeWindow != 0) {
+            if(PrepareCaptureBufs() < 0) {
+                CAMERA_HAL_ERR("PrepareCaptureBufs() error");
+                return BAD_VALUE;
+            }
+        }
+
+        return ret;
+    }
+
+    status_t CameraHal::PreparePostProssDevice()
+    {
+
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int targetFmt;
+        if (mTakePicFlag)
+            targetFmt = mPictureEncodeFormat;
+        else
+            targetFmt = mPreviewFormat;
+
+        pthread_mutex_lock(&mPPIOParamMutex);
+        mPPInputParam.width = mCaptureDeviceCfg.width;
+        mPPInputParam.height= mCaptureDeviceCfg.height;
+        mPPInputParam.fmt   = mCaptureDeviceCfg.fmt;
+        mPPInputParam.input_crop_win.pos.x = 0;
+        mPPInputParam.input_crop_win.pos.y = 0;
+        mPPInputParam.input_crop_win.win_w = mCaptureDeviceCfg.width;
+        mPPInputParam.input_crop_win.win_h = mCaptureDeviceCfg.height;
+
+        mPPOutputParam.width = mCaptureDeviceCfg.width;
+        mPPOutputParam.height= mCaptureDeviceCfg.height;
+        mPPOutputParam.fmt   = targetFmt;
+        mPPOutputParam.rot   = 0;
+        mPPOutputParam.output_win.pos.x = 0;
+        mPPOutputParam.output_win.pos.y = 0;
+        mPPOutputParam.output_win.win_w = mCaptureDeviceCfg.width;
+        mPPOutputParam.output_win.win_h = mCaptureDeviceCfg.height;
+        pthread_mutex_unlock(&mPPIOParamMutex);
+        return ret;
+    }
+
+    status_t CameraHal::PreparePreviwBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int i =0;
+
+        //temply hard code here
+        if (mTakePicFlag == 0){
+            if(V4L2_PIX_FMT_NV12)
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
+            else 
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
+
+            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
+            mPreviewHeap.clear();
+            for (i = 0; i< mPreviewHeapBufNum; i++)
+                mPreviewBuffers[i].clear();
+            mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
+            if (mPreviewHeap == NULL)
+                return NO_MEMORY;
+            for (i = 0; i < mPreviewHeapBufNum; i++)
+                mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
+        }
+        /*allocate the buffer for IPU process*/
+        if (mPPDeviceNeed || mPPDeviceNeedForPic){
+            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
+
+            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
+                return NO_MEMORY;
+            }
+            for (i = 0; i < mPPbufNum; i++){
+                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
+                    return NO_MEMORY;
+                }
+            }
+        }
+        return ret;
+    }
+
+    status_t CameraHal ::PreparePreviwMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        dequeue_head = 0;
+        preview_heap_buf_head = 0;
+        display_head = 0;
+        enc_head     = 0;
+        pp_in_head   = 0;
+        pp_out_head  = 0;
+        error_status = 0;
+        is_first_buffer = 1;
+        last_display_index = 0;
+
+        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
+        sem_init(&avab_show_frame, 0, 0);
+        sem_init(&avab_enc_frame, 0, 0);
+		sem_init(&avab_enc_frame_finish, 0, 0);
+		if(mPPDeviceNeed){
+            sem_init(&avab_pp_in_frame, 0, 0);
+            sem_init(&avab_pp_out_frame, 0, mPPbufNum);
+        }
+        return ret;
+    }
+
+    status_t CameraHal ::CameraHALPreviewStart()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDevice->DevStart()<0)
+            return INVALID_OPERATION;
+
+        mCaptureFrameThread = new CaptureFrameThread(this);
+        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
+        mEncodeFrameThread = new EncodeFrameThread(this);
+        if(mPPDeviceNeed){
+            mPostProcessThread = new PostProcessThread(this);
+            if (mPostProcessThread == NULL)
+                return UNKNOWN_ERROR;
+        }
+
+        if (mCaptureFrameThread == NULL ||
+                mPreviewShowFrameThread == NULL ||
+                mEncodeFrameThread == NULL){
+            return UNKNOWN_ERROR;
+        }
+        //mPreviewRunning = true;
+        isCaptureBufsAllocated = 1;
+        return ret;
+    }
+
+
+    int CameraHal ::captureframeThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        unsigned int DeqBufIdx = 0;
+        struct timespec ts;
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_dequeue_frame, &ts) != 0) );
+
+        if(!mPreviewRunning || error_status)
+            return UNKNOWN_ERROR;
+
+        mCaptureDevice->DevDequeue(&DeqBufIdx);
+
+        nCameraBuffersQueued--;
+
+        buffer_index_maps[dequeue_head]=DeqBufIdx;
+        dequeue_head ++;
+        dequeue_head %= mCaptureBufNum;
+
+        if(!mPPDeviceNeed){
+            sem_post(&avab_show_frame);
+            sem_post(&avab_enc_frame);
+        }else{
+            sem_post(&avab_pp_in_frame);
+        }
+
+        return NO_ERROR;
+    }
+
+    int CameraHal::postprocessThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int PPInIdx = 0, PPoutIdx = 0;
+        DMA_BUFFER PPInBuf, PPoutBuf;
+        struct timespec ts;
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_in_frame, &ts) != 0) );
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_out_frame, &ts) != 0) );
+
+
+        if(!mPreviewRunning || error_status)
+            return UNKNOWN_ERROR;
+        PPInIdx = buffer_index_maps[pp_in_head];
+        PPInBuf = mCaptureBuffers[PPInIdx];
+        pp_in_head ++;
+        pp_in_head %= mCaptureBufNum;
+
+        PPoutIdx = pp_out_head;
+        PPoutBuf = mPPbuf[PPoutIdx];
+        pp_out_head ++;
+        pp_out_head %= mPPbufNum;
+
+        pthread_mutex_lock(&mPPIOParamMutex);
+        mPPInputParam.user_def_paddr = PPInBuf.phy_offset;
+        mPPOutputParam.user_def_paddr = PPoutBuf.phy_offset;
+        mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+        mPPDevice->DoPorcess(&PPInBuf, &PPoutBuf);
+        mPPDevice->PPDeviceDeInit();
+        pthread_mutex_unlock(&mPPIOParamMutex);
+
+        sem_post(&avab_show_frame);
+        sem_post(&avab_enc_frame);
+
+        if (mCaptureDevice->DevQueue(PPInIdx) < 0){
+            CAMERA_HAL_ERR("queue buf back error");
+            return INVALID_OPERATION;
+        }
+        nCameraBuffersQueued ++;
+        sem_post(&avab_dequeue_frame);
+
+        return NO_ERROR;
+    }
+
+    void CameraHal::SearchBuffer(void *pNativeBuf, unsigned int *pIndex)
+    {
+        //int index;
+        for(unsigned int i=0; i < mCaptureBufNum; i++){
+            if(mCaptureBuffers[i].native_buf == pNativeBuf) {
+                *pIndex = i;
+                return;
+            }
+        }
+
+        *pIndex = -1;
+        return;
+    }
+
+    int CameraHal ::previewshowFrameThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timespec ts;
+        int display_index = 0;
+        //DMA_BUFFER InBuf;
+        DMA_BUFFER *pInBuf = NULL;
+        unsigned int queue_back_index = 0;
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (!error_status && mPreviewRunning &&(sem_timedwait(&avab_show_frame, &ts) != 0) );
+
+        if ((mPreviewRunning == 0) || error_status)
+            return UNKNOWN_ERROR;
+
+        if (!mPPDeviceNeed){
+            display_index = buffer_index_maps[display_head];
+            //InBuf = mCaptureBuffers[display_index];
+            pInBuf = &mCaptureBuffers[display_index];
+            display_head ++;
+            display_head %= mCaptureBufNum;
+        }else{
+            display_index = display_head;
+            //InBuf = mPPbuf[display_index];
+            pInBuf = &mCaptureBuffers[display_index];
+            display_head ++;
+            display_head %= mPPbufNum;
+        }
+
+        if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+            convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
+                    (uint8_t*)(mPreviewBuffers[preview_heap_buf_head]->pointer()),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+            mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewBuffers[preview_heap_buf_head], mCallbackCookie);
+            preview_heap_buf_head ++;
+            preview_heap_buf_head %= mPreviewHeapBufNum;
+        }
+
+        if (mNativeWindow != 0) {
+            if (mNativeWindow->queueBuffer(mNativeWindow.get(), (android_native_buffer_t * )pInBuf->native_buf) < 0){
+                CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
+            }
+            pInBuf->buf_state = WINDOW_BUFS_QUEUED;
+#ifdef FSL_CAMERAHAL_DUMP
+            //for test code
+            char value[10] = {0};
+            static int vflg = 0;
+            property_get("rw.camera.test", value, "");
+            if(strcmp(value, "1") == 0)
+                vflg = 1;
+            if(vflg){
+                FILE *pf = NULL;
+                pf = fopen("/sdcard/camera_tst.data", "wb");
+                if(pf == NULL) {
+                    CAMERA_HAL_ERR("open /sdcard/camera_tst.data failed");
+                }
+                else {
+                    fwrite(pInBuf->virt_start, pInBuf->length, 1, pf);
+                    fclose(pf);
+                }
+                vflg = 0;
+            }
+#endif            
+            mEnqueuedBufs ++;
+
+            if (mEnqueuedBufs <= 2) {
+                return NO_ERROR;
+            }
+        }
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=200000; // 100ms
+        } while ((sem_timedwait(&avab_enc_frame_finish, &ts) != 0)&&!error_status && mPreviewRunning );
+
+        if (!mPPDeviceNeed && mNativeWindow != 0){
+            //queue the v4l2 buf back
+            android_native_buffer_t *buf = NULL;
+            int err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf);
+            if((err != 0) || buf == NULL) {
+                CAMERA_HAL_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
+                return INVALID_OPERATION;
+            }
+
+            SearchBuffer((void *)buf, &queue_back_index);
+            if(queue_back_index < mCaptureBufNum) {
+                if(mCaptureDevice->DevQueue(queue_back_index) <0){
+                    CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
+                    return INVALID_OPERATION;
+                }
+                mCaptureBuffers[queue_back_index].buf_state = WINDOW_BUFS_DEQUEUED;
+                nCameraBuffersQueued++;
+                sem_post(&avab_dequeue_frame);
+            }else {
+                CAMERA_HAL_ERR("dequeue invalide buffer!!!!");
+                return INVALID_OPERATION;
+            }
+        }else{
+            sem_post(&avab_pp_out_frame);
+        }
+
+        return NO_ERROR;
+    }
+
+    int CameraHal :: encodeframeThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timespec ts;
+        unsigned int enc_index = 0, i = 0;
+        DMA_BUFFER EncBuf;
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while ((sem_timedwait(&avab_enc_frame, &ts) != 0) && !error_status &&  mPreviewRunning );
+
+        if ((mPreviewRunning == 0) || error_status)
+            return UNKNOWN_ERROR;
+
+        if (!mPPDeviceNeed){
+            enc_index = buffer_index_maps[enc_head];
+            EncBuf = mCaptureBuffers[enc_index];
+            enc_head ++;
+            enc_head %= mCaptureBufNum;
+        }else{
+            enc_index = enc_head;
+            EncBuf = mPPbuf[enc_index];
+            enc_head ++;
+            enc_head %= mPPbufNum;
+        }
+
+        if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
+            nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
+            for(i = 0 ; i < mVideoBufNume; i ++) {
+				if(mVideoBufferUsing[i] == 0) {
+					if (bDerectInput == true) {
+						memcpy(mVideoBuffers[i]->pointer(),
+								(void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
+					} else {
+						memcpy(mVideoBuffers[i]->pointer(),
+								(void*)EncBuf.virt_start, mPreviewFrameSize);
+					}
+
+                    mVideoBufferUsing[i] = 1;
+                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoBuffers[i], mCallbackCookie);
+                    break;
+                }
+            }
+            if (i == mVideoBufNume)
+                CAMERA_HAL_LOG_INFO("no Buffer can be used for record\n");
+        }
+
+		if (!(bDerectInput == true && mRecordRunning == true))
+			sem_post(&avab_enc_frame_finish);
+
+        return NO_ERROR;
+
+    }
+
+
+    status_t CameraHal :: AllocateRecordVideoBuf()
+    {
+        status_t ret = NO_ERROR;
+        unsigned int i = 0;
+        mVideoHeap.clear();
+        for(i = 0; i < mVideoBufNume; i++) {
+            mVideoBuffers[i].clear();
+            mVideoBufferUsing[i] = 0;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
+        mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
+        if (mVideoHeap == NULL)
+            return NO_MEMORY;
+        for(i = 0; i < mVideoBufNume; i++) {
+            CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
+            mVideoBuffers[i] = new MemoryBase(mVideoHeap,
+                    mPreviewFrameSize * i, mPreviewFrameSize);
+        }
+
+        return ret;
+    }
+
+
+    void CameraHal :: LockWakeLock()
+    {
+        if (!mPowerLock) {
+            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
+            mPowerLock = true;
+        }
+    }
+    void CameraHal :: UnLockWakeLock()
+    {
+        if (mPowerLock) {
+            release_wake_lock (V4LSTREAM_WAKE_LOCK);
+            mPowerLock = false;
+        }
+    }
+
+    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
+    {
+        /* Color space conversion from I420 to YUV420SP */
+        int Ysize = 0, UVsize = 0;
+        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
+
+        Ysize = width * height;
+        UVsize = width *  height >> 2;
+
+        Yin = inputBuffer;
+        Uin = Yin + Ysize;
+        Vin = Uin + 1;
+
+        Yout = outputBuffer;
+        Vout = Yout + Ysize;
+        Uout = Vout + 1;
+
+        memcpy(Yout, Yin, Ysize);
+
+        for(int k = 0; k < UVsize; k++) {
+            *Uout = *Uin;
+            *Vout = *Vin;
+            Uout += 2;
+            Vout += 2;
+            Uin  += 2;
+            Vin += 2;
+        }
+    }
+
+
+
+    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
+    {
+        double dAttribtute;
+        long intAttribute;
+        int ret  = 0;
+        if (cAttribute == NULL){
+            return -1;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("the attribute is %s", cAttribute);
+
+        dAttribtute = atof(cAttribute);
+
+        CAMERA_HAL_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
+        intAttribute  = (long)(dAttribtute*(double)3600.0);
+        if (intAttribute < 0){
+            ret = 1;
+            intAttribute *=-1;
+        }
+
+        second = (unsigned int)(intAttribute%60);
+        minute = (unsigned int)((intAttribute%3600-second)/60);
+        degree = (unsigned int)(intAttribute/3600);
+
+        CAMERA_HAL_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
+
+        return ret;
+
+    }
+
+
+#define FACE_BACK_CAMERA_NAME "back_camera_name"
+#define FACE_FRONT_CAMERA_NAME "front_camera_name"
+#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
+#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
+#define DEFAULT_ERROR_NAME '#'
+#define DEFAULT_ERROR_NAME_str "#"
+#define UVC_NAME "uvc"
+    static CameraInfo sCameraInfo[2];
+    static char Camera_name[2][MAX_SENSOR_NAME];
+
+    static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
+    {
+        char orientStr[10];
+
+        property_get (FACE_BACK_CAMERA_NAME,
+                pFaceBackCameraName,
+                DEFAULT_ERROR_NAME_str );
+        property_get (FACE_BACK_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
+
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceBackOrient = 0;
+        else 
+            *pFaceBackOrient = atoi(orientStr);
+
+        LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
+
+        property_get (FACE_FRONT_CAMERA_NAME,
+                pFaceFrontCameraName,
+                DEFAULT_ERROR_NAME_str );
+
+        property_get (FACE_FRONT_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
+
+
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceFrontOrient = 0;
+        else 
+            *pFaceFrontOrient = atoi(orientStr);
+
+        LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
+
+    }
+
+    int HAL_getNumberOfCameras()
+    {
+        int back_orient =0,  front_orient = 0;
+        int back_camera_num = 0, front_camera_num = 0;
+        GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
+        if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
+            sCameraInfo[0].facing = CAMERA_FACING_BACK;
+            sCameraInfo[0].orientation = back_orient;
+            back_camera_num++;
+        }
+        if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
+            if(back_camera_num > 0){
+                sCameraInfo[1].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[1].orientation = front_orient;
+            }else{
+                sCameraInfo[0].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[0].orientation = front_orient;
+            }
+            front_camera_num ++;
+        }
+        return (back_camera_num + front_camera_num);					
+
+    }
+
+    void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
+    {
+        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));					
+    }
+
+    sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
+    {
+        char *SelectedCameraName;
+        int back_camera_num = 0, front_camera_num = 0;
+        sp<CaptureDeviceInterface> pCaptureDevice = NULL;
+        sp<PostProcessDeviceInterface> pPPDevice = NULL;
+        sp<JpegEncoderInterface>pJpegEncoder = NULL;
+
+        if (HAL_getNumberOfCameras() ==0 ){
+            CAMERA_HAL_ERR("There is no configure for Cameras");
+            return NULL;
+        }
+
+        SelectedCameraName = Camera_name[sCameraInfo[cameraId].facing];
+
+        pCaptureDevice = createCaptureDevice(SelectedCameraName);
+        pPPDevice = createPPDevice();
+        pJpegEncoder = createJpegEncoder(SOFTWARE_JPEG_ENC);
+
+        CameraHal *pCameraHal = new CameraHal();
+        if (pCameraHal->setCaptureDevice(pCaptureDevice) < 0 ||
+                pCameraHal->setPostProcessDevice(pPPDevice) < 0 ||
+                pCameraHal->setJpegEncoder(pJpegEncoder) < 0)
+            return NULL;
+
+        if (pCameraHal->Init() < 0)
+            return NULL;
+
+        //now the board has only one csi camera sensor, so just do mirror for it
+        if(strstr(SelectedCameraName, "ov") != NULL){
+            pCameraHal->setPreviewRotate(CAMERA_PREVIEW_BACK_REF);
+        }
+
+        sp<CameraHardwareInterface> hardware(pCameraHal);
+        CAMERA_HAL_LOG_INFO("created the fsl Camera hal");
+
+        return hardware;
+    }
+
+};
+
+
+
diff --git a/mx5x/libcamera/CameraHal.h b/mx5x/libcamera/CameraHal.h
new file mode 100755
index 0000000..8084ea1
--- /dev/null
+++ b/mx5x/libcamera/CameraHal.h
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#ifndef CAMERA_HAL_BASE_H
+#define CAMERA_HAL_BASE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/CameraHardwareInterface.h>
+//#include <ui/Overlay.h>
+#include <semaphore.h>
+
+#include "Camera_pmem.h"
+#include "CaptureDeviceInterface.h"
+#include "PostProcessDeviceInterface.h"
+#include "JpegEncoderInterface.h"
+
+
+#define EXIF_MAKENOTE "fsl_makernote"
+#define EXIF_MODEL    "fsl_model"
+
+#define CAMER_PARAM_BUFFER_SIZE 512
+#define MAX_QUERY_FMT_TIMES 20
+#define PARAMS_DELIMITER ","
+#define V4LSTREAM_WAKE_LOCK "V4LCapture"
+#define MAX_SENSOR_NAME 32
+
+#define PREVIEW_HEAP_BUF_NUM    5
+#define VIDEO_OUTPUT_BUFFER_NUM 5
+#define POST_PROCESS_BUFFER_NUM 5
+#define TAKE_PIC_QUE_BUF_NUM 5
+
+#define PREVIEW_CAPTURE_BUFFER_NUM 5
+#define PICTURE_CAPTURE_BUFFER_NUM 3
+
+namespace android {
+
+    typedef enum{
+        CAMERA_HAL_ERR_NONE = 0,
+        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
+        CAMERA_HAL_ERR_GET_PARAM           = -2,
+        CAMERA_HAL_ERR_BAD_PARAM =-3,
+        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
+        CAMERA_HAL_ERR_INIT = -5,
+        CAMERA_HAL_ERR_ALLOC_BUF =-6,
+        CAMERA_HAL_ERR_PP_NULL = -7
+    }CAMERA_HAL_ERR_RET;
+
+	typedef enum{
+        CAMERA_PREVIEW_BACK_REF = 0,
+        CAMERA_PREVIEW_VERT_FLIP = 1,
+        CAMERA_PREVIEW_HORIZ_FLIP = 2,
+        CAMERA_PREVIEW_ROATE_180 = 3,
+        CAMERA_PREVIEW_ROATE_LAST = 3
+	}CAMERA_PREVIEW_ROTATE;
+
+    class CameraHal : public CameraHardwareInterface {
+    public:
+        //virtual sp<IMemoryHeap> getPreviewHeap() const;
+        virtual sp<IMemoryHeap> getRawHeap() const;
+
+        virtual status_t setPreviewWindow(const sp<ANativeWindow>& buf);
+        virtual void        setCallbacks(notify_callback notify_cb,
+                data_callback data_cb,
+                data_callback_timestamp data_cb_timestamp,
+                void* user);
+
+        virtual void        enableMsgType(int32_t msgType);
+        virtual void        disableMsgType(int32_t msgType);
+        virtual bool        msgTypeEnabled(int32_t msgType);
+
+        virtual status_t    startPreview();
+        virtual void        stopPreview();
+        virtual bool        previewEnabled();
+
+		virtual status_t  storeMetaDataInBuffers(bool enable);
+		virtual int32_t getNumberOfVideoBuffers() const;
+		virtual sp<IMemory> getVideoBuffer(int32_t index) const;
+
+        virtual status_t    startRecording();
+        virtual void        stopRecording();
+        virtual bool        recordingEnabled();
+        virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
+
+        virtual status_t    autoFocus();
+        virtual status_t    cancelAutoFocus();
+        virtual status_t    takePicture();
+        virtual status_t    cancelPicture();
+        virtual status_t    dump(int fd, const Vector<String16>& args) const;
+        virtual status_t    setParameters(const CameraParameters& params);
+        virtual CameraParameters  getParameters() const;
+        virtual status_t    sendCommand(int32_t command, int32_t arg1,
+                int32_t arg2);
+        virtual void release();
+
+        CAMERA_HAL_ERR_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
+        CAMERA_HAL_ERR_RET setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice);
+        CAMERA_HAL_ERR_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
+        CAMERA_HAL_ERR_RET  Init();
+        void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
+
+        CameraHal();
+        virtual             ~CameraHal();
+
+    private:
+
+        class CaptureFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            CaptureFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->captureframeThread();
+                return true;
+            }
+        };
+
+        class PostProcessThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PostProcessThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->postprocessThread();
+                return true;
+            }
+        };
+
+
+        class PreviewShowFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PreviewShowFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->previewshowFrameThread();
+                return true;
+            }
+        };
+
+        class EncodeFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            EncodeFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->encodeframeThread();
+                return true;
+            }
+        };
+
+        class AutoFocusThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            AutoFocusThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                if (mHardware->autoFocusThread()>=0)
+                    return true;
+                else
+                    return false;
+            }
+        };
+
+
+        class TakePicThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            TakePicThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                if (mHardware->takepicThread()>=0)
+                    return true;
+                else
+                    return false;
+            }
+        };
+
+        void preInit();
+        void postDestroy();
+
+        status_t OpenCaptureDevice();
+        void CloseCaptureDevice();
+
+        CAMERA_HAL_ERR_RET AolLocForInterBuf();
+        void  FreeInterBuf();
+        CAMERA_HAL_ERR_RET InitCameraHalParam();
+        CAMERA_HAL_ERR_RET GetCameraBaseParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET GetPictureExifParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET CameraMiscInit();
+        CAMERA_HAL_ERR_RET CameraMiscDeInit();
+        status_t CameraHALPreviewStart();
+        int captureframeThread();
+        int postprocessThread();
+        int previewshowFrameThread();
+        int encodeframeThread();
+        status_t AllocateRecordVideoBuf();
+
+        status_t CameraHALStartPreview();
+        void     CameraHALStopPreview();
+
+        status_t PreparePreviwBuf();
+        status_t PrepareCaptureDevices();
+        status_t PreparePostProssDevice();
+        status_t PreparePreviwMisc();
+
+        void CameraHALStopThreads();
+        void LockWakeLock();
+
+        void UnLockWakeLock();
+
+        int autoFocusThread();
+        int takepicThread();
+
+        int GetJpegEncoderParam();
+        int NegotiateCaptureFmt(bool TakePicFlag);
+        int cameraHALTakePicture();
+        void CameraHALStopMisc();
+        int PrepareJpegEncoder();
+        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
+
+        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
+
+        status_t allocateBuffersFromNativeWindow();
+        void SearchBuffer(void *pNativeBuf, unsigned int *pIndex);
+        status_t freeBuffersToNativeWindow();
+        status_t PrepareCaptureBufs();
+        volatile bool isCaptureBufsAllocated;
+        //volatile bool isPreviewFinsh;
+
+        CameraParameters    mParameters;
+        void               *mCallbackCookie;
+        notify_callback    mNotifyCb;
+        data_callback      mDataCb;
+        data_callback_timestamp mDataCbTimestamp;
+
+        sp<CaptureDeviceInterface> mCaptureDevice;
+        sp<PostProcessDeviceInterface> mPPDevice;
+        sp<JpegEncoderInterface> mJpegEncoder;
+
+
+        sp<CaptureFrameThread> mCaptureFrameThread;
+        sp<PostProcessThread>  mPostProcessThread;
+        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
+        sp<EncodeFrameThread> mEncodeFrameThread;
+        sp<AutoFocusThread>mAutoFocusThread;
+        sp<TakePicThread> mTakePicThread;
+
+        mutable Mutex       mLock;
+
+        char *supportedPictureSizes;
+        char *supportedPreviewSizes;
+        char *supportedFPS;
+        char *supprotedThumbnailSizes;
+
+        sp<ANativeWindow>   mNativeWindow;
+        unsigned int        mMsgEnabled;
+
+        struct capture_config_t mCaptureDeviceCfg;
+        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        sp<MemoryHeapBase>  mPreviewHeap;
+        sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
+
+        /* the buffer for recorder */
+        unsigned int        mVideoBufNume;
+        sp<MemoryHeapBase>  mVideoHeap;
+        sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
+        volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
+		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
+
+        sp<PmemAllocator>   mPmemAllocator;
+        DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
+        unsigned int        mPPbufNum;
+        pp_input_param_t    mPPInputParam;
+        pp_output_param_t   mPPOutputParam;
+
+        volatile bool       mPreviewRunning;
+        unsigned int        mPreviewFormat;
+        unsigned int 		mPreviewFrameSize;
+        unsigned int        mPreviewCapturedFormat;
+
+        bool                mTakePicFlag;
+        unsigned int        mEncoderSupportedFormat[MAX_QUERY_FMT_TIMES];
+        enc_cfg_param       mJpegEncCfg;
+
+        unsigned int        mUvcSpecialCaptureFormat;
+        unsigned int        mCaptureSupportedFormat[MAX_QUERY_FMT_TIMES];
+        unsigned int        mPictureEncodeFormat;
+        unsigned int        mCaptureFrameSize;
+        unsigned int        mCaptureBufNum;
+        //unsigned int        mCaptureBufsActual;
+        unsigned int        mEnqueuedBufs;
+
+        bool                mRecordRunning;
+        int                 mCurrentRecordFrame;
+        int 		        nCameraBuffersQueued;
+
+        unsigned int        mPreviewHeapBufNum;
+        unsigned int        mTakePicBufQueNum;
+
+        char                mCameraSensorName[MAX_SENSOR_NAME];
+        bool mCameraReady;
+        bool mCaptureDeviceOpen;
+        bool mPPDeviceNeed;
+        bool mPPDeviceNeedForPic;
+        bool mPreviewStopped;
+        bool mRecordStopped;
+        bool mPowerLock;
+		bool bDerectInput;
+
+        int error_status;
+        unsigned int preview_heap_buf_head;
+        unsigned int display_head;
+        unsigned int enc_head;
+        unsigned int dequeue_head;
+        unsigned int is_first_buffer;
+        unsigned int last_display_index;
+        unsigned int pp_in_head;
+        unsigned int pp_out_head;
+        unsigned int buffer_index_maps[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        sem_t avab_show_frame;
+        sem_t avab_dequeue_frame;
+        sem_t avab_enc_frame;
+        sem_t avab_enc_frame_finish;
+        sem_t avab_pp_in_frame;
+        sem_t avab_pp_out_frame;
+
+        pthread_mutex_t mOverlayMutex;
+        pthread_mutex_t mMsgMutex;
+        pthread_mutex_t mPPIOParamMutex;
+        CAMERA_PREVIEW_ROTATE mPreviewRotate;
+
+    };
+
+}; // namespace android
+
+#endif
+
diff --git a/mx5x/libcamera/Camera_pmem.cpp b/mx5x/libcamera/Camera_pmem.cpp
new file mode 100755
index 0000000..865b352
--- /dev/null
+++ b/mx5x/libcamera/Camera_pmem.cpp
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <linux/android_pmem.h>
+#include "Camera_pmem.h"
+
+
+/*
+ *   input parameter: 
+ */
+
+using namespace android;
+
+PmemAllocator::PmemAllocator(int bufCount, int bufSize):
+    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
+    mVirBase(NULL),mPhyBase(NULL)
+{
+
+    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
+
+    int err;
+    struct pmem_region region;
+    mFD = open(PMEM_DEV, O_RDWR);
+    if (mFD < 0) {
+        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
+    if (err == 0)
+    {
+        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
+    }
+    else
+    {
+        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
+
+    mTotalSize = mBufSize*bufCount;
+    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
+        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
+    }
+    else
+    {
+        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
+                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
+
+        if (virtualbase == MAP_FAILED) {
+            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
+                    mFD, (unsigned int)mTotalSize, strerror(errno));
+            return;
+        }
+
+        memset(&region, 0, sizeof(region));
+
+        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
+        {
+            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
+            munmap(virtualbase, mTotalSize);
+            return;
+        }
+        mVirBase = (void *)virtualbase;
+        mPhyBase = region.offset;
+        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
+    }
+}
+
+PmemAllocator::~PmemAllocator()
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
+        }
+    }
+
+    if(mVirBase) {
+        munmap(mVirBase, mTotalSize);
+    }
+    if(mFD) {
+        close(mFD);
+    }
+
+}
+
+int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(!mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
+                    index,mBufSize,size);
+
+            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
+            pbuf->phy_offset= mPhyBase+index*mBufSize;
+            pbuf->length= mBufSize;
+            mSlotAllocated[index] = true;
+            return DMA_ALLOCATE_ERR_NONE;
+        }
+    }
+    return DMA_ALLOCATE_ERR_BAD_PARAM;
+}
+
+int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
+{
+    CAMERA_HAL_LOG_FUNC;
+    if((!mVirBase)||(!pbuf)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
+    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
+        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
+        mSlotAllocated[nSlot] = false;
+        return DMA_ALLOCATE_ERR_NONE;
+    }
+    else{
+        CAMERA_HAL_ERR("Error!Not a valid buffer");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+}
diff --git a/mx5x/libcamera/Camera_pmem.h b/mx5x/libcamera/Camera_pmem.h
new file mode 100755
index 0000000..8b174a4
--- /dev/null
+++ b/mx5x/libcamera/Camera_pmem.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef __CAMERA_MEM__H__
+#define __CAMERA_MEM__H__
+
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+
+#define DEFAULT_PMEM_ALIGN (4096)
+#define PMEM_DEV "/dev/pmem_adsp"
+#define MAX_SLOT 64
+
+namespace android {
+
+class PmemAllocator : public virtual RefBase
+{
+public:
+    PmemAllocator(int bufCount,int bufSize);
+    virtual ~PmemAllocator();
+    virtual int allocate(DMA_BUFFER *p_buf, int size);
+    virtual int deAllocate(DMA_BUFFER *p_buf);
+	int err_ret;
+private:
+    int mFD;
+    unsigned long mTotalSize;
+    int mBufCount;
+    int mBufSize;
+    void *mVirBase;
+    unsigned int mPhyBase;
+    bool mSlotAllocated[MAX_SLOT];
+	
+};
+};
+
+#endif
diff --git a/mx5x/libcamera/Camera_utils.h b/mx5x/libcamera/Camera_utils.h
new file mode 100755
index 0000000..89c6729
--- /dev/null
+++ b/mx5x/libcamera/Camera_utils.h
@@ -0,0 +1,73 @@
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAMERA_UTILS_H
+#define CAMERA_UTILS_H
+
+#undef LOG_TAG
+#define LOG_TAG "FslCameraHAL"
+#include <utils/Log.h>
+
+//#define CAMERA_HAL_DEBUG_LOG
+
+#ifdef CAMERA_HAL_DEBUG_LOG
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define CAMERA_HAL_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) 
+#define CAMERA_HAL_LOG_FUNC
+#endif
+
+#define CAMERA_HAL_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define CAMERA_HAL_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define CAMERA_HAL_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+namespace android {
+
+    typedef enum{
+        DMA_ALLOCATE_ERR_NONE = 0,
+        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
+
+    }DMA_ALLOCATE_ERR_RET;
+
+    typedef enum{
+        WINDOW_BUFS_DEQUEUED = 1,
+        WINDOW_BUFS_QUEUED = 2,
+    }WINDOW_BUFS_STATE;
+
+    typedef struct {
+        unsigned char *virt_start;
+        size_t phy_offset;
+        unsigned int length;
+        void *native_buf;
+        WINDOW_BUFS_STATE buf_state;
+    }DMA_BUFFER;
+
+	// If struct change. Need info Camera Source.
+    typedef struct {
+        size_t phy_offset;
+        unsigned int length;
+    }VIDEOFRAME_BUFFER_PHY;
+
+}; //name space android
+
+#endif
+
diff --git a/mx5x/libcamera/CaptureDeviceInterface.cpp b/mx5x/libcamera/CaptureDeviceInterface.cpp
new file mode 100755
index 0000000..8adc966
--- /dev/null
+++ b/mx5x/libcamera/CaptureDeviceInterface.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "V4l2UVCDevice.h"
+#include "V4l2CsiDevice.h"
+namespace android{
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
+    {
+        if(strstr(deviceName, UVC_NAME_STRING)){
+            CAMERA_HAL_LOG_INFO("It is the UVC device");
+
+            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }else{
+            CAMERA_HAL_LOG_INFO("It is the CSI device");
+            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }
+    }
+
+
+}
diff --git a/mx5x/libcamera/CaptureDeviceInterface.h b/mx5x/libcamera/CaptureDeviceInterface.h
new file mode 100755
index 0000000..bbba44c
--- /dev/null
+++ b/mx5x/libcamera/CaptureDeviceInterface.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAPTURE_DEVICE_INTERFACE_H
+#define CAPTURE_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+
+
+namespace android {
+#define UVC_NAME_STRING "uvc"
+
+    typedef enum{
+        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
+        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
+        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
+        CAPTURE_DEVICE_ERR_NONE = 0,
+        CAPTURE_DEVICE_ERR_OPEN = -1,
+        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
+        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
+        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
+        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
+        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
+        CAPTURE_DEVICE_ERR_UNKNOWN = -100
+    }CAPTURE_DEVICE_ERR_RET;
+
+    typedef enum{
+        MOTION_MODE = 0,
+        HIGH_QUALITY_MODE = 1
+    }CAPTURE_MODE;
+
+    typedef enum{
+        OUTPU_FMT = 0,
+        FRAME_SIZE_FPS = 1
+    }DevParamType;
+
+	typedef enum{
+        SENSOR_PREVIEW_BACK_REF = 0,
+        SENSOR_PREVIEW_VERT_FLIP = 1,
+        SENSOR_PREVIEW_HORIZ_FLIP = 2,
+        SENSOR_PREVIEW_ROATE_180 = 3,
+        SENSOR_PREVIEW_ROATE_LAST = 3
+	}SENSOR_PREVIEW_ROTATE;
+
+    struct timeval_fract{
+        unsigned int numerator;
+        unsigned int denominator;
+    };
+
+    struct capture_config_t{
+        unsigned int fmt;
+        unsigned int width;
+        unsigned int height;
+        unsigned int framesize;   //out
+        unsigned int picture_waite_number;//out
+        struct timeval_fract tv;
+		SENSOR_PREVIEW_ROTATE rotate;
+    };
+
+
+    class CaptureDeviceInterface : public virtual RefBase{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen()=0;
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStart()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue(unsigned int BufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
+
+        virtual ~ CaptureDeviceInterface(){}
+    };
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName);
+
+};
+#endif
+
diff --git a/mx5x/libcamera/JpegEncoderInterface.cpp b/mx5x/libcamera/JpegEncoderInterface.cpp
new file mode 100755
index 0000000..30b9d96
--- /dev/null
+++ b/mx5x/libcamera/JpegEncoderInterface.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. 
+ */
+#include "JpegEncoderSoftware.h"
+namespace android{
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
+    {
+        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
+            CAMERA_HAL_LOG_INFO("Create the software encoder");
+            return JpegEncoderSoftware::createInstance();
+        }
+        else{
+            CAMERA_HAL_ERR("the hardware encoder is not supported");
+            return NULL;
+        }
+    }
+};
diff --git a/mx5x/libcamera/JpegEncoderInterface.h b/mx5x/libcamera/JpegEncoderInterface.h
new file mode 100755
index 0000000..b515757
--- /dev/null
+++ b/mx5x/libcamera/JpegEncoderInterface.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_INTERFACE_H
+#define JPEG_ENCODER_INTERFACE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+namespace android{
+
+
+#define MAX_JPEG_MAKE_BYTES 256
+#define MAX_JPEG_MAKERNOTE_BYTES 256
+#define MAX_JPEG_MODEL_BYTES 256
+#define TIME_FMT_LENGTH 20
+#define MAX_GPS_PROCESSING_BYTES	256
+
+    typedef enum{
+    ORIENTATION_UNDEFINED = 0,
+    ORIENTATION_NORMAL = 1,
+    ORIENTATION_FLIP_HORIZONTAL = 2,
+    ORIENTATION_ROTATE_180 = 3,
+    ORIENTATION_FLIP_VERTICAL = 4,
+    ORIENTATION_TRANSPOSE = 5,
+    ORIENTATION_ROTATE_90 = 6,
+    ORIENTATION_TRANSVERSE = 7,
+    ORIENTATION_ROTATE_270 = 8
+    }JPEG_ENCODER_ROTATION;
+
+    typedef enum{
+    WHITEBALANCE_AUTO = 0,
+    WHITEBALANCE_MANUAL = 1
+    }JPEG_ENCODER_WHITEBALANCE;
+
+    typedef enum{
+    FLASH_NOT_FIRE = 0x00,
+    FLASH_FIRED    = 0x01,
+    FLASH_FIRED_AUTO = 0x19,
+    FLASH_FIRED_RED_EYE_REDUCE = 0x41,
+    FLASH_FIRED_COMPULOSORY = 0x09
+    }JPEG_ENCODER_FLASH;
+
+    typedef enum{
+        SOFTWARE_JPEG_ENC = 0,
+        HARDWARE_JPEG_ENC = 1
+    }JPEG_ENCODER_TYPE;
+
+    typedef enum{
+        JPEG_ENC_ERROR_NONE = 0,
+        JPEG_ENC_ERROR_BAD_PARAM = -1,
+        JPEG_ENC_ERROR_ALOC_BUF = -2
+    }JPEG_ENC_ERR_RET;
+
+
+    typedef enum{
+        SUPPORTED_FMT = 0,
+    }JPEEG_QUERY_TYPE;
+
+    struct jpeg_enc_focallength_t
+    {
+        unsigned int numerator;
+        unsigned int denominator;
+    };
+
+    struct jpeg_enc_make_info_t
+    {
+        unsigned char make_bytes;
+        unsigned char make[MAX_JPEG_MAKE_BYTES];
+    };
+    struct jpeg_enc_makernote_info_t
+    {
+        unsigned char makernote_bytes;
+        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
+    };
+
+    struct jpeg_enc_model_info_t
+    {
+        unsigned char model_bytes;
+        unsigned char model[MAX_JPEG_MODEL_BYTES];	
+    };
+
+    struct jpeg_enc_datetime_info_t
+    {
+        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
+    };
+
+    struct jpeg_enc_gps_param{
+        unsigned int version;//GPSVersionID
+        char latitude_ref[2];//GPSLatitudeRef: "N " is positive; "S " is negative
+        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
+        unsigned int latitude_degree[2];//GPSLatitude
+        unsigned int latitude_minute[2];
+        unsigned int latitude_second[2];
+        unsigned int longtitude_degree[2];//GPSLongitude
+        unsigned int longtitude_minute[2];
+        unsigned int longtitude_second[2];
+        char altitude_ref;//GPSAltitudeRef: 0 or 1(negative)
+        unsigned int altitude[2];//GPSAltitude: unit is meters
+        unsigned int hour[2];//GPSTimeStamp
+        unsigned int minute[2];
+        unsigned int seconds[2];
+        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
+        char processmethod_bytes;
+        char datestamp[11];//GPSDateStamp: "YYYY:MM:DD "
+    };
+
+    typedef struct{
+        unsigned int PicWidth;
+        unsigned int PicHeight;
+        unsigned int ThumbWidth;
+        unsigned int ThumbHeight;
+        unsigned int BufFmt;
+        JPEG_ENCODER_ROTATION RotationInfo;
+        JPEG_ENCODER_WHITEBALANCE WhiteBalanceInfo;
+        JPEG_ENCODER_FLASH FlashInfo;
+        struct jpeg_enc_focallength_t *pFoclLength;
+        struct jpeg_enc_make_info_t *pMakeInfo;
+        struct jpeg_enc_makernote_info_t *pMakeNote;
+        struct jpeg_enc_model_info_t *pModelInfo;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
+        struct jpeg_enc_gps_param *pGps_info;
+    }enc_cfg_param;
+
+    struct jpeg_encoding_conf{
+        unsigned int output_jpeg_size;
+    };
+
+    class JpegEncoderInterface : public virtual RefBase{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
+
+        virtual ~ JpegEncoderInterface(){}
+    }; 
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
+
+};
+
+#endif
diff --git a/mx5x/libcamera/JpegEncoderSoftware.cpp b/mx5x/libcamera/JpegEncoderSoftware.cpp
new file mode 100755
index 0000000..14adb6a
--- /dev/null
+++ b/mx5x/libcamera/JpegEncoderSoftware.cpp
@@ -0,0 +1,661 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "JpegEncoderSoftware.h"
+
+namespace android{
+
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
+    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
+
+    JpegEncoderSoftware :: JpegEncoderSoftware()
+        :mSupportedTypeIdx(0),
+        pEncCfgLocal(NULL),
+        pEncObj(NULL)
+    {
+        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
+    }
+
+    JpegEncoderSoftware :: ~JpegEncoderSoftware()
+    {
+
+    }
+
+    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
+    {
+
+        int * pSupportedType = (int *)pQueryRet;
+        switch(QueryType){	
+            case SUPPORTED_FMT:
+                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
+                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
+                    mSupportedTypeIdx ++;
+                }else{
+                    mSupportedTypeIdx = 0;
+                    return JPEG_ENC_ERROR_BAD_PARAM;
+                }
+                break;
+            default:
+                return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        return JPEG_ENC_ERROR_NONE;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        struct jpeg_enc_focallength_t * pFoclLength = NULL;
+        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
+        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
+        struct jpeg_enc_model_info_t *pModelInfo = NULL;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
+        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
+
+        if(pEncCfg == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
+
+        if (pEncCfgLocal == NULL){
+            CAMERA_HAL_ERR("Allocat buffer for EncCfg failed");
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+
+        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
+        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
+
+
+        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
+            goto INT_ERR_RET;
+        }
+
+        if (pEncCfg->pFoclLength != NULL){
+            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
+
+            if (pFoclLength == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pFoclLength failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
+            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
+            pEncCfgLocal->pFoclLength = pFoclLength;
+        }
+
+
+        if (pEncCfg->pMakeInfo != NULL){
+            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
+
+            if (pMakeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
+            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
+            pEncCfgLocal->pMakeInfo = pMakeInfo;
+        }
+
+        if (pEncCfg->pMakeNote != NULL){
+            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
+
+            if (pMakeNote == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeNote failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
+            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
+            pEncCfgLocal->pMakeNote = pMakeNote;
+        }
+
+        if (pEncCfg->pModelInfo != NULL){
+            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
+
+            if (pModelInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pModelInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
+            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
+            pEncCfgLocal->pModelInfo = pModelInfo;
+        }
+
+        if (pEncCfg->pDatetimeInfo != NULL){
+            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
+
+            if (pDatetimeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pDatetimeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
+            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
+            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
+        }
+
+        if (pEncCfg->pGps_info != NULL){
+            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
+
+            if (pGpsInfoLocal == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pGpsInfoLocal failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
+            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
+            pEncCfgLocal->pGps_info = pGpsInfoLocal;
+        }
+
+        return ret;
+
+INT_ERR_RET:
+        if(pEncCfgLocal)
+            free(pEncCfgLocal);
+        if(pFoclLength)
+            free(pFoclLength);
+        if(pMakeInfo)
+            free(pMakeInfo);
+        if(pMakeNote)
+            free(pMakeNote);
+        if(pModelInfo)
+            free(pModelInfo);
+        if(pDatetimeInfo)
+            free(pDatetimeInfo);
+        if(pGpsInfoLocal)
+            free(pGpsInfoLocal);
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
+        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }else{
+            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
+        }
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if (pEncCfgLocal != NULL ){
+            if (pEncCfgLocal->pFoclLength != NULL)
+                free(pEncCfgLocal->pFoclLength);
+            if (pEncCfgLocal->pMakeInfo != NULL)
+                free(pEncCfgLocal->pMakeInfo);
+            if (pEncCfgLocal->pMakeNote != NULL)
+                free(pEncCfgLocal->pMakeNote);
+            if (pEncCfgLocal->pModelInfo != NULL)
+                free(pEncCfgLocal->pModelInfo);
+            if (pEncCfgLocal->pDatetimeInfo != NULL)
+                free(pEncCfgLocal->pDatetimeInfo);
+            if (pEncCfgLocal->pGps_info != NULL)
+                free(pEncCfgLocal->pGps_info);
+            free(pEncCfgLocal);
+        }
+
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
+
+        CAMERA_HAL_LOG_FUNC;
+        int i = 0;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)|| 
+                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
+                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
+            if(pEncCfgLocal->BufFmt == mSupportedType[i])
+                break;
+        }
+
+        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
+            ret = JPEG_ENC_ERROR_BAD_PARAM;
+
+        return ret;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        int width, height, size,index;
+        JPEG_ENC_UINT8 * i_buff = NULL;
+        JPEG_ENC_UINT8 * y_buff = NULL;
+        JPEG_ENC_UINT8 * u_buff = NULL;
+        JPEG_ENC_UINT8 * v_buff = NULL;
+        JPEG_ENC_RET_TYPE return_val;
+        jpeg_enc_parameters * params = NULL;
+        jpeg_enc_object * obj_ptr = NULL;
+        JPEG_ENC_UINT8 number_mem_info;
+        jpeg_enc_memory_info * mem_info = NULL;
+        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
+        int thumbnail_width, thumbnail_height;
+        unsigned char *buffer = inBuf->virt_start;
+
+        bool mEncodeThumbnailFlag = true;
+
+        width = pEncCfgLocal->PicWidth;
+        height = pEncCfgLocal->PicHeight;
+
+        thumbnail_width = pEncCfgLocal->ThumbWidth;
+        thumbnail_height = pEncCfgLocal->ThumbHeight;
+
+
+        if (thumbnail_width <= 0 || thumbnail_height<= 0)
+            mEncodeThumbnailFlag = false;
+
+        g_JpegDataSize = 0;//Total size of g_JpegData
+        g_JpegDataLen = 0;//Valid data len of g_JpegData
+        g_JpegData = NULL;//Buffer to hold jpeg data
+        size = width * height * 3 / 2;
+
+        g_JpegData = outBuf->virt_start;
+        g_JpegDataSize = size;
+        if(!g_JpegData)
+        {
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        /* --------------------------------------------
+         * Allocate memory for Encoder Object
+         * -------------------------------------------*/
+        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
+        if(!obj_ptr)
+        {
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
+
+        /* Assign the function for streaming output */
+        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
+        obj_ptr->context=NULL;   //user can put private variables into it
+        /* --------------------------------------------
+         * Fill up the parameter structure of JPEG Encoder
+         * -------------------------------------------*/
+        params = &(obj_ptr->parameters);
+
+        if(mEncodeThumbnailFlag==true)
+        {
+
+            //need resizing code here!!!
+            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
+            if(!thumbnail_buffer)
+            {
+                return JPEG_ENC_ERROR_ALOC_BUF;
+            }
+
+            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
+
+            width = thumbnail_width;
+            height = thumbnail_height;
+
+            temp_buffer = buffer;
+            buffer = thumbnail_buffer;
+
+            params->mode = JPEG_ENC_THUMB;
+        }
+        else
+        {
+            params->mode = JPEG_ENC_MAIN_ONLY;
+        }
+
+encodeframe:
+
+        params->compression_method = JPEG_ENC_SEQUENTIAL;
+        params->quality = 75;
+        params->restart_markers = 0;
+        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height/2;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height/2;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
+        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
+        }
+        params->exif_flag = 1;
+
+        params->y_left = 0;
+        params->y_top = 0;
+        params->y_total_width = 0;
+        params->y_total_height = 0;
+        params->raw_dat_flag= 0;
+
+        if(params->y_total_width==0)
+        {
+            params->y_left=0;
+            params->u_left=0;
+            params->v_left=0;
+            params->y_total_width=params->y_width;  // no cropping
+            params->u_total_width=params->u_width;  // no cropping
+            params->v_total_width=params->v_width;  // no cropping
+        }
+
+        if(params->y_total_height==0)
+        {
+            params->y_top=0;
+            params->u_top=0;
+            params->v_top=0;
+            params->y_total_height=params->y_height; // no cropping
+            params->u_total_height=params->u_height; // no cropping
+            params->v_total_height=params->v_height; // no cropping
+        }
+
+        /* Pixel size is unknown by default */
+        params->jfif_params.density_unit = 0;
+        /* Pixel aspect ratio is square by default */
+        params->jfif_params.X_density = 1;
+        params->jfif_params.Y_density = 1;
+        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
+            y_buff = (JPEG_ENC_UINT8 *)buffer;
+            u_buff = y_buff+width*height;
+            v_buff = u_buff+width*height/4;
+            i_buff = NULL;
+        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
+            y_buff = NULL;
+            u_buff = NULL;
+            v_buff = NULL;
+            i_buff = (JPEG_ENC_UINT8 *)buffer;
+        }
+        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+
+        /* --------------------------------------------
+         * QUERY MEMORY REQUIREMENTS
+         * -------------------------------------------*/
+        return_val = jpeg_enc_query_mem_req(obj_ptr);
+
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_query_mem_req success");
+        /* --------------------------------------------
+         * ALLOCATE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        number_mem_info = obj_ptr->mem_infos.no_entries;
+        for(index = 0; index < number_mem_info; index++)
+        {
+            /* This example code ignores the 'alignment' and
+             * 'memory_type', but some other applications might want
+             * to allocate memory based on them */
+            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+            mem_info->memptr = (void *) malloc(mem_info->size);
+            if(mem_info->memptr==NULL) {
+                CAMERA_HAL_LOG_RUNTIME("Malloc error after query\n");
+                goto done;
+            }
+        }
+
+        return_val = jpeg_enc_init(obj_ptr);
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_init success");
+        if(params->mode == JPEG_ENC_THUMB)
+            createJpegExifTags(obj_ptr);
+
+        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
+                y_buff, u_buff, v_buff);
+
+        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        if(params->mode == JPEG_ENC_THUMB)
+        {
+            JPEG_ENC_UINT8 num_entries;
+            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
+            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
+
+            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
+
+            for(int i = 0; i < num_entries; i++)
+            {
+                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
+            }
+
+            free(offset_tbl_ptr);
+            free(value_tbl_ptr);
+
+            free(buffer);
+
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+
+            g_JpegData += g_JpegDataLen;
+            g_JpegDataSize -= g_JpegDataLen;
+
+
+            //recover to build the main jpeg
+            params->mode = JPEG_ENC_MAIN;
+
+            buffer = temp_buffer;
+            width = pEncCfgLocal->PicWidth;
+            height = pEncCfgLocal->PicHeight;
+
+            goto encodeframe;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_encodeframe success");
+        // Make an IMemory for each frame
+        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
+        *pEncSize = g_JpegDataLen;
+
+done:
+        /* --------------------------------------------
+         * FREE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        if(obj_ptr)
+        {
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+            free(obj_ptr);
+        }
+
+        return ret;
+    }
+
+    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
+            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
+    {
+        JPEG_ENC_UINT32 i;
+        if(*out_buf_ptrptr == NULL)
+        {
+            /* This function is called for the 1'st time from the
+             * codec */
+            *out_buf_ptrptr = g_JpegData;
+            *out_buf_len_ptr = g_JpegDataSize;
+        }
+
+        else if(flush == 1)
+        {
+            /* Flush the buffer*/
+            g_JpegDataLen += *out_buf_len_ptr;
+            CAMERA_HAL_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
+
+            *out_buf_ptrptr = NULL;
+            *out_buf_len_ptr = NULL;
+        }
+        else
+        {
+            CAMERA_HAL_LOG_RUNTIME("Not enough buffer for encoding");
+            return 0;
+        }
+
+        return(1); /* Success */
+    }
+
+    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
+    {
+        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FLASH, (unsigned int)(&(pEncCfgLocal->FlashInfo)));
+
+        if(pEncCfgLocal->pMakeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
+        if(pEncCfgLocal->pMakeNote)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
+        if(pEncCfgLocal->pModelInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
+        if(pEncCfgLocal->pDatetimeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
+        if(pEncCfgLocal->pFoclLength)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
+
+        if (pEncCfgLocal->pGps_info)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
+
+        return;
+    }
+
+    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
+    {
+        int i,j,s;
+        int h_offset;
+        int v_offset;
+        unsigned char *ptr,cc;
+        int h_scale_ratio;
+        int v_scale_ratio;
+
+        s = 0;
+
+_resize_begin:
+
+        if(!dst_width) return -1;
+        if(!dst_height) return -1;
+
+        h_scale_ratio = src_width / dst_width;
+        if(!h_scale_ratio) return -1;
+
+        v_scale_ratio = src_height / dst_height;
+        if(!v_scale_ratio) return -1;
+
+        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
+        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
+
+        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
+        {
+            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
+            {
+                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
+                cc = ptr[0];
+
+                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
+                ptr[0] = cc;
+            }
+        }
+
+        src_ptr += src_width*src_height;
+        dst_ptr += dst_width*dst_height;
+
+        if(s < 2)
+        {
+            if(!s++)
+            {
+                src_width >>= 1;
+                src_height >>= 1;
+
+                dst_width >>= 1;
+                dst_height >>= 1;
+            }
+
+            goto _resize_begin;
+        }
+
+        return 0;
+    }
+
+    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
+        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
+        return hardware;
+    }
+
+
+};
diff --git a/mx5x/libcamera/JpegEncoderSoftware.h b/mx5x/libcamera/JpegEncoderSoftware.h
new file mode 100755
index 0000000..2bcd2d1
--- /dev/null
+++ b/mx5x/libcamera/JpegEncoderSoftware.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_SOFTWARE_H
+#define JPEG_ENCODER_SOFTWARE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#include "JpegEncoderInterface.h"
+#include "jpeg_enc_interface.h"
+
+
+namespace android{
+#define MAX_ENC_SUPPORTED_YUV_TYPE  1
+
+    class JpegEncoderSoftware : public JpegEncoderInterface{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
+
+        static sp<JpegEncoderInterface>createInstance();
+    private:
+
+        JpegEncoderSoftware();
+        virtual ~JpegEncoderSoftware();
+
+        virtual JPEG_ENC_ERR_RET CheckEncParm();
+        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
+
+
+        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
+                JPEG_ENC_UINT32 *out_buf_len_ptr,
+                JPEG_ENC_UINT8 flush, 
+                void * context, 
+                JPEG_ENC_MODE enc_mode);
+        void createJpegExifTags(jpeg_enc_object * obj_ptr);
+        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
+
+
+        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
+        unsigned int mSupportedTypeIdx;
+        enc_cfg_param *pEncCfgLocal;
+        jpeg_enc_object *pEncObj;
+
+
+        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
+        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
+        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
+
+    }; 
+};
+
+#endif
diff --git a/mx5x/libcamera/PP_ipulib.cpp b/mx5x/libcamera/PP_ipulib.cpp
new file mode 100755
index 0000000..69d91ee
--- /dev/null
+++ b/mx5x/libcamera/PP_ipulib.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h"
+#include <stdlib.h>
+#include <string.h>
+
+namespace android{
+
+    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
+
+    PPIpuLib :: PPIpuLib(){
+        return;
+    }
+
+    PPIpuLib :: ~PPIpuLib(){
+
+        singleton.clear();
+    }
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+        //Setting input format
+        mIPUInputParam.width = pp_input->width;
+        mIPUInputParam.height = pp_input->height;
+
+        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
+        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
+        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
+        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
+        mIPUInputParam.fmt = pp_input->fmt;
+        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
+
+        //Setting output format
+        mIPUOutputParam.fmt = pp_output->fmt;
+        mIPUOutputParam.width = pp_output->width;
+        mIPUOutputParam.height = pp_output->height;   
+        mIPUOutputParam.show_to_fb = 0;
+        //Output param should be same as input, since no resize,crop
+        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
+        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
+        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
+        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
+        mIPUOutputParam.rot = pp_output->rot;
+        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
+        CAMERA_HAL_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+                mIPUOutputParam.width,
+                mIPUOutputParam.height,
+                mIPUOutputParam.output_win.pos.x,
+                mIPUOutputParam.output_win.pos.y,
+                mIPUOutputParam.output_win.win_w,
+                mIPUOutputParam.output_win.win_h,
+                mIPUOutputParam.rot);
+
+        CAMERA_HAL_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+                mIPUInputParam.width,
+                mIPUInputParam.height,
+                mIPUInputParam.fmt,
+                mIPUInputParam.input_crop_win.pos.x,
+                mIPUInputParam.input_crop_win.pos.y,
+                mIPUInputParam.input_crop_win.win_w,
+                mIPUInputParam.input_crop_win.win_h);	  
+
+        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
+            return PPDEVICE_ERROR_INIT;
+        }  
+
+        return ret;
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
+
+        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
+
+        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset,NULL,NULL,NULL);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
+            mxc_ipu_lib_task_uninit(&mIPUHandle);
+            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+            return PPDEVICE_ERROR_PROCESS;
+        }
+
+        return ret;
+
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        mxc_ipu_lib_task_uninit(&mIPUHandle);
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+
+        return ret;
+    }
+
+    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
+        CAMERA_HAL_LOG_FUNC;
+        if (singleton != 0) {
+            sp<PostProcessDeviceInterface> device = singleton.promote();
+            if (device != 0) {
+                return device;
+            }
+        }
+        sp<PostProcessDeviceInterface> device(new PPIpuLib());
+
+        singleton = device;
+        return device;
+    }
+
+};
diff --git a/mx5x/libcamera/PP_ipulib.h b/mx5x/libcamera/PP_ipulib.h
new file mode 100755
index 0000000..39b0d4c
--- /dev/null
+++ b/mx5x/libcamera/PP_ipulib.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef PP_IPU_LIB_H
+#define PP_IPU_LIB_H
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+} 
+
+#include "PostProcessDeviceInterface.h"
+
+namespace android{
+    class PPIpuLib : public PostProcessDeviceInterface
+    {
+    public:
+        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
+        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
+        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
+        static sp<PostProcessDeviceInterface> createInstance();
+    private:
+        PPIpuLib();
+        virtual ~PPIpuLib();
+        static wp<PostProcessDeviceInterface> singleton;
+
+        ipu_lib_input_param_t mIPUInputParam;	
+        ipu_lib_output_param_t mIPUOutputParam; 
+        ipu_lib_handle_t			mIPUHandle;
+    };
+};
+#endif
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.cpp b/mx5x/libcamera/PostProcessDeviceInterface.cpp
new file mode 100755
index 0000000..3d7e752
--- /dev/null
+++ b/mx5x/libcamera/PostProcessDeviceInterface.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h" 
+namespace android{
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
+        return PPIpuLib :: createInstance();
+    }
+
+};
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.h b/mx5x/libcamera/PostProcessDeviceInterface.h
new file mode 100755
index 0000000..9d730b6
--- /dev/null
+++ b/mx5x/libcamera/PostProcessDeviceInterface.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef POSTPROCESS_DEVICE_INTERFACE_H
+#define POSTPROCESS_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+#include <linux/videodev2.h>
+
+namespace android {
+
+    typedef enum{
+        PPDEVICE_ERROR_NONE = 0,
+        PPDEVICE_ERROR_INIT = -1,
+        PPDEVICE_ERROR_PROCESS  = -2,
+        PPDEVICE_ERROR_DEINIT = -3
+    }PPDEVICE_ERR_RET;
+
+    struct pp_fb_pos{
+        unsigned short x;
+        unsigned short y;
+    };
+
+    struct win_t{
+        struct pp_fb_pos pos;
+        unsigned int win_w;
+        unsigned int win_h;
+    } ;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        struct win_t input_crop_win;
+        int user_def_paddr;
+    } pp_input_param_t;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        unsigned int rot;
+        struct win_t output_win;
+        int user_def_paddr;
+    } pp_output_param_t;
+
+
+    class PostProcessDeviceInterface : public virtual RefBase{
+    public:
+        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
+        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
+        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
+
+        virtual ~PostProcessDeviceInterface(){}
+    }; 
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
+
+};
+#endif
+
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.cpp b/mx5x/libcamera/V4l2CapDeviceBase.cpp
new file mode 100755
index 0000000..3202591
--- /dev/null
+++ b/mx5x/libcamera/V4l2CapDeviceBase.cpp
@@ -0,0 +1,669 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CapDeviceBase.h"
+
+
+
+
+namespace android{
+
+    V4l2CapDeviceBase ::V4l2CapDeviceBase()
+        :mCameraDevice(0),
+        mFmtParamIdx(0),
+        mSizeFPSParamIdx(0),
+        mRequiredFmt(0),
+        mBufQueNum(0),
+        mQueuedBufNum(0)
+
+    {
+        mCaptureDeviceName[0] = '#';
+    }
+
+    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
+    {
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::SetDevName(char * deviceName){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        if(NULL == deviceName)
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        strcpy(mInitalDeviceName, deviceName);
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if(NULL == deviceName)
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        strcpy(deviceName, mInitalDeviceName);
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::DevOpen(){
+        CAMERA_HAL_LOG_FUNC;
+
+        return V4l2Open(); 
+    } 
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        CAMERA_HAL_LOG_FUNC;
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        else
+            return V4l2EnumParam(devParamType,retParam);
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mCapCfg = *pCapcfg;
+        return V4l2SetConfig(pCapcfg);
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2RegisterBufs(DevBufQue, pBufQueNum);
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
+    }
+
+    CAPTURE_DEVICE_ERR_RET  V4l2CapDeviceBase :: DevPrepare(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Prepare();
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStart(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Start();
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
+
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Dequeue(pBufQueIdx);
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
+
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Queue(BufQueIdx);
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStop(){
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Stop();
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDeAllocate(){
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2DeAlloc();
+        }
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevClose(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Close();
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char   dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_capability v4l2_cap;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
+                        close(fd);
+                        continue;
+                    } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
+                            (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
+                        break;
+                    } else
+                        close(fd);
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_RUNTIME("devParamType is %d", devParamType);
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        switch(devParamType){
+            case OUTPU_FMT: 
+                ret = V4l2EnumFmt(retParam);
+                break;
+            case FRAME_SIZE_FPS:
+                {
+                    ret = V4l2EnumSizeFps(retParam);
+                    break;
+                }
+            default:
+                {
+                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+                    break;
+                }
+        }
+        return ret;
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_fmtdesc vid_fmtdesc;
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        vid_fmtdesc.index = mFmtParamIdx;
+        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }else{
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
+            *pParamVal = vid_fmtdesc.pixelformat;
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+        struct v4l2_frmivalenum vid_frmval;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
+            vid_frmval.pixel_format = pCapCfg->fmt;
+            vid_frmval.width = vid_frmsize.discrete.width;
+            vid_frmval.height= vid_frmsize.discrete.height;
+            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
+                CAMERA_HAL_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
+                mSizeFPSParamIdx = 0;
+                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+            }else{
+                pCapCfg->width	= vid_frmsize.discrete.width;
+                pCapCfg->height = vid_frmsize.discrete.height;
+                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
+                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
+                mSizeFPSParamIdx ++;
+                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+            }
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        *pMode = 0;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        struct v4l2_format fmt;
+        struct v4l2_control ctrl;
+        struct v4l2_streamparm parm;
+
+        V4l2ConfigInput(pCapcfg);
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
+
+        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
+        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
+        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+        else
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+        fmt.fmt.pix.priv = 0;
+        fmt.fmt.pix.sizeimage = 0;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("set format failed\n");
+            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
+                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
+        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
+            CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+            CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
+                    parm.parm.capture.timeperframe.denominator);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+
+
+        if(V4l2SetRot(pCapcfg) < 0)
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }else{
+
+            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+        }
+        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+        unsigned int i;
+        struct v4l2_buffer buf;
+        enum v4l2_buf_type type;
+        struct v4l2_requestbuffers req;
+        int BufQueNum;
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mBufQueNum = *pBufQueNum;
+
+        memset(&req, 0, sizeof (req));
+        req.count = mBufQueNum;
+        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        req.memory = V4L2_MEMORY_MMAP;
+        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        /*the driver may can't meet the request, and return the buf num it can handle*/
+        *pBufQueNum = mBufQueNum = req.count;
+
+        for (i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (buf));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.index = i;
+            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } else {
+                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+            }
+
+            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
+            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
+            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
+            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+        unsigned int i;
+        struct v4l2_buffer buf;
+        enum v4l2_buf_type type;
+        struct v4l2_requestbuffers req;
+        int BufQueNum;
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mBufQueNum = *pBufQueNum;
+
+        memset(&req, 0, sizeof (req));
+        req.count = mBufQueNum;
+        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        req.memory = V4L2_MEMORY_USERPTR;
+        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        /*the driver may can't meet the request, and return the buf num it can handle*/
+        *pBufQueNum = mBufQueNum = req.count;
+
+        for (i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (buf));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.memory = V4L2_MEMORY_USERPTR;
+            buf.index = i;
+            buf.m.offset = mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
+            buf.length = mCaptureBuffers[i].length = DevBufQue[i].length;
+            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
+            //memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } else {
+                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+            }
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Prepare(){
+        CAMERA_HAL_LOG_FUNC;
+        struct v4l2_buffer buf;
+        mQueuedBufNum = 0;
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (struct v4l2_buffer));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.memory = V4L2_MEMORY_USERPTR;
+            buf.index = i;
+            buf.m.offset = mCaptureBuffers[i].phy_offset;
+
+            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } 
+            mQueuedBufNum ++;
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Start(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else{
+            CAMERA_HAL_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
+        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        *pBufQueIdx = cfilledbuffer.index;
+
+        mQueuedBufNum --;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
+        cfilledbuffer.index = BufQueIdx;
+        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        mQueuedBufNum ++;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Stop(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else
+            CAMERA_HAL_LOG_INFO("VIDIOC_STREAMOFF ok\n");
+
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
+                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+                mCaptureBuffers[i].length = 0;
+                CAMERA_HAL_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
+            }
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Close(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0 ){
+            CAMERA_HAL_LOG_INFO("the device handle is error");
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        CAMERA_HAL_LOG_INFO("close the device");
+        close(mCameraDevice);
+        mCameraDevice = -1;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+};
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.h b/mx5x/libcamera/V4l2CapDeviceBase.h
new file mode 100755
index 0000000..0408fcb
--- /dev/null
+++ b/mx5x/libcamera/V4l2CapDeviceBase.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CAP_DEVICE_BASE_H
+#define V4L2_CAP_DEVICE_BASE_H
+#include <linux/videodev2.h>
+
+#include "CaptureDeviceInterface.h"
+
+#define CAMAERA_FILENAME_LENGTH     256
+#define MAX_CAPTURE_BUF_QUE_NUM     6
+#define CAMAERA_SENSOR_LENGTH       32
+
+namespace android{
+
+    class V4l2CapDeviceBase : public CaptureDeviceInterface{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen();
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare();
+        virtual CAPTURE_DEVICE_ERR_RET DevStart();
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue( unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevStop();
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate();
+        virtual CAPTURE_DEVICE_ERR_RET DevClose();
+
+    protected:
+
+        V4l2CapDeviceBase();
+        virtual ~V4l2CapDeviceBase();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Open();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Prepare();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Start();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Dequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Queue(unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Stop();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2DeAlloc();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Close();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
+        char         mInitalDeviceName[CAMAERA_SENSOR_LENGTH];
+        int          mCameraDevice;
+        unsigned int mFmtParamIdx;
+        unsigned int mSizeFPSParamIdx;
+        unsigned int mRequiredFmt;
+        unsigned int mBufQueNum;
+        int          mQueuedBufNum;
+        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
+        struct   capture_config_t mCapCfg;
+
+    };
+};
+
+#endif
diff --git a/mx5x/libcamera/V4l2CsiDevice.cpp b/mx5x/libcamera/V4l2CsiDevice.cpp
new file mode 100755
index 0000000..e67f301
--- /dev/null
+++ b/mx5x/libcamera/V4l2CsiDevice.cpp
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/mxc_v4l2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CsiDevice.h"
+
+namespace android{
+    V4l2CsiDevice :: V4l2CsiDevice(){
+        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
+        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
+        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
+
+    }
+    V4l2CsiDevice :: ~V4l2CsiDevice()
+    {
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char	dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_dbg_chip_ident vid_chip;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
+                        close(fd);
+                        continue;
+                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        strcpy(mInitalDeviceName, vid_chip.match.name);
+                        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
+                        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
+                        break;
+                    } else{
+                        close(fd);
+                        fd = 0;
+                    }
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
+            *pParamVal = mSupportedFmt[mFmtParamIdx];
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }else{
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            //hardcode here for ov3640
+            if (strstr(mInitalDeviceName, "3640") != NULL){
+                CAMERA_HAL_LOG_INFO("the sensor  is  mInitalDeviceName");
+                if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
+                    mSizeFPSParamIdx ++;
+                    vid_frmsize.index = mSizeFPSParamIdx;
+                    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+                        mSizeFPSParamIdx = 0;
+                        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+                    }
+                }
+            }
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            pCapCfg->width  = vid_frmsize.discrete.width;
+            pCapCfg->height = vid_frmsize.discrete.height;
+            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 15;
+            }else{
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 30;
+            }
+            mSizeFPSParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int input = 1;
+        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
+            CAMERA_HAL_ERR("set input failed");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
+    {
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        struct v4l2_format fmt;
+        struct v4l2_control ctrl;
+        struct v4l2_streamparm parm;
+
+        V4l2ConfigInput(pCapcfg);
+
+        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        //hard code here to do a walk around.
+        if(pCapcfg->tv.denominator != 30 && pCapcfg->tv.denominator != 15){
+            pCapcfg->tv.numerator = 1;
+            pCapcfg->tv.denominator = 30;
+        }
+        CAMERA_HAL_LOG_RUNTIME("the fps is %d", pCapcfg->tv.denominator);
+
+        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
+        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
+            parm.parm.capture.timeperframe.numerator = 1;
+            parm.parm.capture.timeperframe.denominator = 15;
+            if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
+                CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+                CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator, 
+                        parm.parm.capture.timeperframe.denominator);
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            }
+        }
+
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
+
+        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
+        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
+        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+        else
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+        fmt.fmt.pix.priv = 0;
+        fmt.fmt.pix.sizeimage = 0;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("set format failed\n");
+            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
+                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        if(V4l2SetRot(pCapcfg) < 0)
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }else{
+
+            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+        }
+        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        unsigned int capturemode = 0;
+        unsigned int capturewidth =  pCapcfg->width;
+        unsigned int captureheight = pCapcfg->height;
+        unsigned int pic_waite_buf_num = 0;
+        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
+                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
+            pic_waite_buf_num = 10;
+            if (capturewidth == 640 && captureheight == 480)
+                capturemode = 0;	/* VGA mode */
+            else if (capturewidth == 320 && captureheight == 240)
+                capturemode = 1;	/* QVGA mode */
+            else if (capturewidth == 720 && captureheight == 480)
+                capturemode = 2;	/* PAL mode */
+            else if (capturewidth == 720 && captureheight == 576)
+                capturemode = 3;	/* PAL mode */
+            else if (capturewidth == 1280 && captureheight == 720)
+                capturemode = 4;	/* 720P mode */
+            else if (capturewidth == 1920 && captureheight == 1080){
+                pic_waite_buf_num = 5;
+                capturemode = 5;	/* 1080P mode */
+            }
+            else if (capturewidth == 2592 && captureheight == 1944) {
+                pic_waite_buf_num = 5;
+                capturemode = 6;	/* 2592x1944 mode */
+            }
+            else{
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
+            pic_waite_buf_num = 10;
+            if (capturewidth == 320 && captureheight == 240)
+                capturemode = 1;	/* QVGA mode */
+            else if (capturewidth == 640 && captureheight == 480)
+                capturemode = 0;	/* VGA mode */
+            else if (capturewidth == 720 && captureheight == 480)
+                capturemode = 4;
+            else if (capturewidth == 720 && captureheight == 576)
+                capturemode = 5;
+            else if (capturewidth == 2048 && captureheight == 1536)
+            {
+                pic_waite_buf_num = 10;
+                capturemode = 3;	/* QXGA mode */
+            }
+            else
+            {
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else{
+            capturemode = 0;
+            pic_waite_buf_num = 0;
+        }
+
+        CAMERA_HAL_LOG_INFO("the mode is %d", capturemode);
+        *pMode = capturemode;
+        pCapcfg->picture_waite_number = pic_waite_buf_num;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        struct v4l2_control ctrl;
+
+        // Set rotation
+        ctrl.id = V4L2_CID_MXC_ROT;
+        if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
+            ctrl.value = V4L2_MXC_CAM_ROTATE_NONE;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
+            ctrl.value = V4L2_MXC_CAM_ROTATE_VERT_FLIP;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
+            ctrl.value = V4L2_MXC_CAM_ROTATE_HORIZ_FLIP;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
+            ctrl.value = V4L2_MXC_CAM_ROTATE_180;
+        else
+            ctrl.value = V4L2_MXC_ROTATE_NONE;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
+            CAMERA_HAL_ERR("set ctrl failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        return ret;
+    }
+};
+
diff --git a/mx5x/libcamera/V4l2CsiDevice.h b/mx5x/libcamera/V4l2CsiDevice.h
new file mode 100755
index 0000000..5247eae
--- /dev/null
+++ b/mx5x/libcamera/V4l2CsiDevice.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CSI_DEVICE_H
+#define V4L2_CSI_DEVICE_H
+
+#include <linux/videodev2.h>
+#include "V4l2CapDeviceBase.h"
+#define ENUM_SUPPORTED_FMT     3
+
+#define OV3640_NAME_STR   "ov3640"
+#define OV5640_NAME_STR   "ov5640"
+#define OV5642_NAME_STR   "ov5642"
+namespace android{
+
+class V4l2CsiDevice : public V4l2CapDeviceBase{
+    public:
+        
+        V4l2CsiDevice();
+        virtual ~V4l2CsiDevice();
+    protected:
+		
+		CAPTURE_DEVICE_ERR_RET V4l2Open();
+		CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+		CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
+   };
+
+};
+#endif
+
+
diff --git a/mx5x/libcamera/V4l2UVCDevice.h b/mx5x/libcamera/V4l2UVCDevice.h
new file mode 100755
index 0000000..f3af040
--- /dev/null
+++ b/mx5x/libcamera/V4l2UVCDevice.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_UVC_DEVICE_H
+#define V4L2_UVC_DEVICE_H
+
+#include <linux/videodev2.h>
+
+
+#include "V4l2CapDeviceBase.h"
+
+#define MAX_DEV_NAME_LENGTH 10
+
+namespace android{
+
+    class V4l2UVCDevice : public V4l2CapDeviceBase{
+    public:
+        V4l2UVCDevice(){}
+        ~V4l2UVCDevice(){}
+
+    };
+
+};
+#endif
+
-- 
1.8.0

