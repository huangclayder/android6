From 845ee99deb0f5b1095ef8f84b37f34223e399cb7 Mon Sep 17 00:00:00 2001
From: Yaoming Qin <b10945@freescale.com>
Date: Tue, 22 Mar 2011 10:54:01 +0800
Subject: [PATCH 125/635] ENGR00140930 Camera HAL rework

1. Optimize the camera preview for csi and uvc camera
2. add the support for dual camera.

Signed-off-by: Yaoming Qin<B10945@freescale.com>
---
 libcamera/Android.mk                     |   45 +-
 libcamera/CameraHal.cpp                  | 3349 +++++++++++++-----------------
 libcamera/CameraHal.h                    |  574 ++---
 libcamera/Camera_pmem.cpp                |  159 ++
 libcamera/Camera_pmem.h                  |   49 +
 libcamera/Camera_utils.h                 |   60 +
 libcamera/CaptureDeviceInterface.cpp     |   40 +
 libcamera/CaptureDeviceInterface.h       |   92 +
 libcamera/JpegEncoderInterface.cpp       |   34 +
 libcamera/JpegEncoderInterface.h         |  146 ++
 libcamera/JpegEncoderSoftware.cpp        |  656 ++++++
 libcamera/JpegEncoderSoftware.h          |   84 +
 libcamera/PP_ipulib.cpp                  |  138 ++
 libcamera/PP_ipulib.h                    |   47 +
 libcamera/PostProcessDeviceInterface.cpp |   26 +
 libcamera/PostProcessDeviceInterface.h   |   78 +
 libcamera/V4l2CapDeviceBase.cpp          |  602 ++++++
 libcamera/V4l2CapDeviceBase.h            |   82 +
 libcamera/V4l2CsiDevice.cpp              |  256 +++
 libcamera/V4l2CsiDevice.h                |   52 +
 libcamera/V4l2UVCDevice.h                |   41 +
 liboverlay/overlay_thread.h              |    4 +-
 22 files changed, 4403 insertions(+), 2211 deletions(-)
 create mode 100755 libcamera/Camera_pmem.cpp
 create mode 100755 libcamera/Camera_pmem.h
 create mode 100755 libcamera/Camera_utils.h
 create mode 100755 libcamera/CaptureDeviceInterface.cpp
 create mode 100755 libcamera/CaptureDeviceInterface.h
 create mode 100755 libcamera/JpegEncoderInterface.cpp
 create mode 100755 libcamera/JpegEncoderInterface.h
 create mode 100755 libcamera/JpegEncoderSoftware.cpp
 create mode 100755 libcamera/JpegEncoderSoftware.h
 create mode 100755 libcamera/PP_ipulib.cpp
 create mode 100755 libcamera/PP_ipulib.h
 create mode 100755 libcamera/PostProcessDeviceInterface.cpp
 create mode 100755 libcamera/PostProcessDeviceInterface.h
 create mode 100755 libcamera/V4l2CapDeviceBase.cpp
 create mode 100755 libcamera/V4l2CapDeviceBase.h
 create mode 100755 libcamera/V4l2CsiDevice.cpp
 create mode 100755 libcamera/V4l2CsiDevice.h
 create mode 100755 libcamera/V4l2UVCDevice.h

diff --git a/libcamera/Android.mk b/libcamera/Android.mk
index db11f5d..0c6dd22 100755
--- a/libcamera/Android.mk
+++ b/libcamera/Android.mk
@@ -17,10 +17,18 @@ LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:=               \
-    CameraHal.cpp
+LOCAL_SRC_FILES:=    \
+	CameraHal.cpp    \
+    Camera_pmem.cpp  \
+	CaptureDeviceInterface.cpp \
+	V4l2CsiDevice.cpp \
+	V4l2CapDeviceBase.cpp  \
+	PostProcessDeviceInterface.cpp \
+	PP_ipulib.cpp    \
+	JpegEncoderInterface.cpp \
+    JpegEncoderSoftware.cpp
 
-LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC -DDUMP_CAPTURE_YUVxx -DCAPTURE_ONLY_TESTxx
+LOCAL_CPPFLAGS +=
 
 LOCAL_SHARED_LIBRARIES:= \
     libcamera_client \
@@ -31,36 +39,27 @@ LOCAL_SHARED_LIBRARIES:= \
     libmedia \
     libhardware_legacy \
     libdl \
-    libc
+    libc \
+	libipu
 
 LOCAL_C_INCLUDES += \
 	frameworks/base/include/binder \
 	frameworks/base/include/ui \
-	frameworks/base/services/camera/libcameraservice
+	frameworks/base/camera/libcameraservice \
+	external/linux-lib/ipu
 
+ifeq ($(HAVE_FSL_IMX_CODEC),true)
+    LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
+    LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
+    LOCAL_C_INCLUDES +=	\
+					external/fsl_imx_codec/fsl_mad_multimedia_codec/ghdr \
+					device/fsl/proprietary/codec/ghdr
+endif
 ifeq ($(BOARD_CAMERA_NV12),true)
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
 else
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_YUV420
 endif
-
-ifeq ($(BOARD_CAMERA_SENSOR_TYPE),OV5642)
-    LOCAL_CFLAGS += -DCAMERA_SENSOR_OV5642
-else
-  ifeq ($(BOARD_CAMERA_SENSOR_TYPE),OV5640)
-    LOCAL_CFLAGS += -DCAMERA_SENSOR_OV5640
-  else
-    LOCAL_CFLAGS += -DCAMERA_SENSOR_OV3640
-  endif
-endif
-
-ifeq ($(HAVE_FSL_IMX_CODEC),true)
-LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
-LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC -DDUMP_CAPTURE_YUVxx
-LOCAL_C_INCLUDES +=	\
-	external/fsl_imx_codec/fsl_mad_multimedia_codec/ghdr \
-	device/fsl/proprietary/codec/ghdr
-endif	
 	
 LOCAL_MODULE:= libcamera
 
diff --git a/libcamera/CameraHal.cpp b/libcamera/CameraHal.cpp
index 45e5312..6f5fb91 100755
--- a/libcamera/CameraHal.cpp
+++ b/libcamera/CameraHal.cpp
@@ -1,2206 +1,1691 @@
 /*
- * Copyright (C) Texas Instruments - http://www.ti.com/
+ * Copyright (C) 2008 The Android Open Source Project
  *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /*
- *   Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
-/**
-* @file CameraHal.cpp
-*
-* This file maps the Camera Hardware Interface to V4L2.
-*
-*/
-#define LOG_TAG "CameraHal"
+
 #include <cutils/properties.h>
 #include "CameraHal.h"
 #include <time.h>
 #include <stdlib.h>
 #include <string.h>
+#include <dlfcn.h>
 #include <hardware_legacy/power.h>
 
-
-
 namespace android {
-int CameraHal::camera_device = -1;
-int CameraHal::g_rotate=0;
-int CameraHal::g_still_bpp = 16;
-char CameraHal::dev_node[FILENAME_LENGTH];
-
-#ifdef USE_FSL_JPEG_ENC 
-JPEG_ENC_UINT32 CameraHal::g_JpegDataSize = 0;//Total size of g_JpegData
-JPEG_ENC_UINT32 CameraHal::g_JpegDataLen = 0;//Valid data len of g_JpegData
-JPEG_ENC_UINT8 *CameraHal::g_JpegData = NULL;//Buffer to hold jpeg data
-#endif
-
-wp<CameraHardwareInterface> CameraHal::singleton;
-
-#if defined(CAMERA_SENSOR_OV5642)
-const char CameraHal::supportedPictureSizes [] = "2592x1944,1280x720,720x576,640x480";
-const char CameraHal::supportedPreviewSizes [] = "720x576,640x480,320x240";
-#elif defined(CAMERA_SENSOR_OV5640)
-const char CameraHal::supportedPictureSizes [] = "1920x1080,1280x720,720x576,640x480,320x240";
-const char CameraHal::supportedPreviewSizes [] = "720x576,640x480,320x240";
-#else
-const char CameraHal::supportedPictureSizes [] = "2048x1536,720x576,720x480,640x480,320x240";
-const char CameraHal::supportedPreviewSizes [] = "720x576,720x480,640x480,320x240";
-#endif
-const char CameraHal::supportedFPS [] = "30,15,10";
-const char CameraHal::supprotedThumbnailSizes []= "0x0,128x128,96x96"; //according to the Gallery thumbnail size
-const char CameraHal::PARAMS_DELIMITER []= ",";
-
-CameraHal::CameraHal()
-                  : mParameters(),
-                    mPreviewHeap(0),
-                    mPreviewRunning(0),
-                    mRecordHeight(0),
-                    mRecordWidth(0),
-                    mOverlay(NULL),
-                    mNotifyCb(0),
-                    mDataCb(0),
-                    mDataCbTimestamp(0),
-                    mCallbackCookie(0),
-                    mMsgEnabled(0),
-                    mCameraOpened(0),
-                    mPictureHeight(0),
-                    mPictureWidth(0),
-                    mRecordFrameSize(0),
-                    mRecordRunning(0),
-                    mCurrentRecordFrame(0),
-                    nCameraBuffersQueued(0),
-                    mVideoHeap(0),
-                    mPowerLock(false)
-{
-    int i;
-
-    for (i = 0; i < VIDEO_OUTPUT_BUFFER_NUM; i++) {
-        mVideoBuffers[i] = 0;
-        mVideoBufferUsing[i] = 0;
-    }
-
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++) {
-	mPreviewBuffers[i] = 0;
-	mCaptureBuffers[i].length = 0;
-    }
-
-    pthread_mutex_init(&mOverlay_sem,NULL);
-    is_overlay_pushmode = 0;
-
-#ifdef UVC_CAMERA
-    mRecordFormat = mPictureFormat = V4L2_PIX_FMT_YUYV;
-#else
-    mRecordFormat = mPictureFormat = V4L2_PIX_FMT_YUV420;
-#endif
-
-    initDefaultParameters();
-}
-
-void CameraHal::initDefaultParameters()
-{
-    CameraParameters p;
-    char tmpBuffer[PARAM_BUFFER], picture_sizes[PARAM_BUFFER];
-
-    p.setPreviewSize(RECORDING_WIDTH_NORMAL, RECORDING_HEIGHT_NORMAL);
-    p.setPreviewFrameRate(PREVIEW_FRAMERATE);
-    p.setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);
-
-    p.setPictureSize(PICTURE_WIDTH, PICTURE_HEIGHT);
-    p.setPictureFormat("jpeg");
-    p.set(CameraParameters::KEY_JPEG_QUALITY, 100);
-
-    //Eclair extended parameters
-#ifdef UVC_CAMERA
-    uvcGetDeviceAndCapability(tmpBuffer);
-    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, tmpBuffer);
-    LOGD("supportedPictureSize=%s", tmpBuffer);
-#else
-    /* /dev/video0 is for on-board camera */
-    strcpy(dev_node, "/dev/video0");
-    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, CameraHal::supportedPictureSizes);
-#endif
-
-    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
-    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, CameraHal::supportedPreviewSizes);
-    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, CameraParameters::PIXEL_FORMAT_YUV420SP);
-    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, CameraHal::supportedFPS);
-    p.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, CameraHal::supprotedThumbnailSizes);
-	p.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
-	p.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
-	p.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);
-
-    memset(tmpBuffer, '\0', PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
-    p.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
-
-    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
-    p.set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
-
-    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
-    p.set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
-
-    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_AUTO, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_INFINITY, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_MACRO, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_FIXED, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, tmpBuffer);
-    p.set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
-
-    p.set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
-    p.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
-    p.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
-    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
-    p.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
-    p.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
-    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
-
-    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
-    p.set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
-
-    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-    strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, PARAM_BUFFER);
-    p.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
-    p.set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
-    p.set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
-    p.set(CameraParameters::KEY_MAX_ZOOM, "1");
-    // default zoom should be 0 as CTS defined
-    p.set(CameraParameters::KEY_ZOOM, "0");
-    //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-    //returned as 320. The number of elements is {@link
-    //#getMaxZoom} + 1. The list is sorted from small to large. The
-    //first element is always 100. The last element is the zoom
-    //ratio of the maximum zoom value.
-    p.set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
-    if (setParameters(p) != NO_ERROR) {
-        LOGE("Failed to set default parameters?!");
-    }
-
-}
-
-CameraHal::~CameraHal()
-{
-    int err = 0;
-
-    LOG_FUNCTION_NAME
-    LOGD(">>> Release");
-
-    pthread_mutex_destroy(&mOverlay_sem);
-
-    cameraDestroy();
-
-    LOGD("<<< Release");
-
-    singleton.clear();
-}
-
-int CameraHal::uvcGetDeviceAndCapability(char *sizes_buf)
-{
-    int fd, i, j, is_found = 0;
-    const char *flags[] = {"uncompressed", "compressed"};
-    char tmp[40];
-    DIR *v4l_dir = NULL;
-    struct dirent *dir_entry;
-    struct v4l2_capability v4l2_cap;
-    struct v4l2_fmtdesc vid_fmtdesc;
-    struct v4l2_frmsizeenum vid_frmsize;
-
-    /* Check avaiable UVC device */
-    v4l_dir = opendir("/sys/class/video4linux");
-    if (v4l_dir) {
-        while((dir_entry = readdir(v4l_dir))) {
-            memset((void *)dev_node, 0, FILENAME_LENGTH);
-            if(strncmp(dir_entry->d_name, "video", 5)) /* Not video device */
-                continue;
-                sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                    continue;
-                /* Query the capability of device */
-                if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                    close(fd);
-                continue;
-            } else if ((strcmp((char *)v4l2_cap.driver, "uvcvideo") == 0) &&
-                       (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
-                is_found = 1;  /* No need to close device here */
-                break;
-            } else
-                close(fd);
-        }
-    }
 
-    if (is_found) {
-        LOGD("Found one UVC camera\n");
-    } else
-        return -1;
-
-    memset(sizes_buf, '\0', PARAM_BUFFER);
-    /* Enum pixel format of UVC camera */
-    for (i = 0;; i++) {
-        memset(&vid_fmtdesc, 0, sizeof(vid_fmtdesc));
-        vid_fmtdesc.index = i;
-        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(fd, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0)
-            break;
-        /* We got a video format/codec back */
-        LOGD("VIDIOC_ENUM_FMT(%d, %s)\n", vid_fmtdesc.index, "VIDEO_CAPTURE");
-        LOGD(" flags       :%s\n", flags[vid_fmtdesc.flags]);
-        LOGD(" description :%s\n", vid_fmtdesc.description);
-        /* Convert the pixelformat attributes from FourCC into 'human readable' format*/
-        LOGD(" pixelformat :%c%c%c%c\n",
-                    vid_fmtdesc.pixelformat & 0xFF, (vid_fmtdesc.pixelformat >> 8) & 0xFF,
-                    (vid_fmtdesc.pixelformat >> 16) & 0xFF, (vid_fmtdesc.pixelformat >> 24) & 0xFF);
-        if (vid_fmtdesc.pixelformat == V4L2_PIX_FMT_YUYV) {
-        /* Only support YUYV format now */
-        /* Enum YUYV frame size */
-            for (j = 0;; j++) {
-                vid_frmsize.index = j;
-                vid_frmsize.pixel_format = vid_fmtdesc.pixelformat;
-                if (ioctl(fd, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0)
-                    break;
-                sprintf(tmp, "%dx%d", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-                if (vid_frmsize.index == 0)
-                    strncpy((char*) sizes_buf, tmp, PARAM_BUFFER);
-                else {
-                    strncat((char*) sizes_buf, (const char*) PARAMS_DELIMITER, PARAM_BUFFER);
-                    strncat((char*) sizes_buf, tmp, PARAM_BUFFER);
-                }
-                LOGD(" framze size: width %d, height %d,", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            }
-            /* FIXME: will do enum YUYV frame intervals later*/
-        }
+    CameraHal::CameraHal()
+        : mParameters(),
+        mCallbackCookie(NULL),
+        mNotifyCb(NULL),
+        mDataCb(NULL),
+        mDataCbTimestamp(NULL),
+        mCaptureFrameThread(NULL),
+        mPostProcessThread(NULL),
+        mPreviewShowFrameThread(NULL),
+        mEncodeFrameThread(NULL),
+        mAutoFocusThread(NULL),
+        mTakePicThread(NULL),
+        mLock(),
+        supportedPictureSizes(NULL),
+        supportedPreviewSizes(NULL),
+        supportedFPS(NULL),
+        supprotedThumbnailSizes(NULL),
+        mOverlay(NULL),
+        mMsgEnabled(0),
+        mPreviewHeap(0),
+        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
+        mPPbufNum(0),
+        mPreviewRunning(0),
+        mPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
+        mPreviewFrameSize(0),
+        mTakePicFlag(false),
+        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
+        mCaptureFrameSize(0),
+        mCaptureBufNum(0),
+        mRecordRunning(0),
+        mCurrentRecordFrame(0),
+        nCameraBuffersQueued(0),
+        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
+        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
+        mCameraReady(false),
+        mCaptureDeviceOpen(false),
+        mPPDeviceNeed(false),
+        mPPDeviceNeedForPic(false),
+        mPowerLock(false)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        preInit();
     }
-    close(fd);
 
-    return 0;
-}
+    CameraHal :: ~CameraHal()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CameraMiscDeInit();
+        CloseCaptureDevice();
+        FreeInterBuf();
+        postDestroy();
+    }
 
-int CameraHal::cameraOpen()
-{
-    int err;
+    void CameraHal :: release()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mCameraReady = false;
+        return;
+    }
 
-    LOG_FUNCTION_NAME
+    void CameraHal :: preInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-    if(mCameraOpened == 0){
-        camera_device = open(dev_node, O_RDWR|O_NONBLOCK, 0);
-        LOGD("dev_node in open:%s\n", dev_node);
-        if (camera_device < 0) {
-            LOGE ("Could not open the camera device: %s",  strerror(errno) );
-            return -1;
-        }
-        mCameraOpened = 1;
-        LOGD("Camera Opened - Success");
-
-    } else
-        LOGE ("Camera device has been opened!");
-
-    return 0;
-}
-
-int CameraHal::cameraClose()
-{
-    LOG_FUNCTION_NAME
-    /* Free buffers firstly */
-    for (int i = 0; i < CAPTURE_BUFFER_NUM; i++) {
-        if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
-	    munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-            mCaptureBuffers[i].length = 0;
-	    LOGD("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
-        }
     }
-    if (camera_device != -1) {
-        close(camera_device);
-        camera_device = -1;
-        mCameraOpened = 0;
-    }
-
-    return 0;
-}
-
-int CameraHal::cameraDestroy()
-{
-    int err, i;
-    cameraClose();
-    if (mOverlay != 0)
-    {
-        mOverlay->destroy();
-        mOverlay = NULL;
-    }
-    return 0;
-}
-
-int CameraHal::cameraTakePicConfig()
-{
-    struct v4l2_streamparm parm;
-    struct v4l2_format fmt;
-    struct v4l2_crop crop;
-    int fd_v4l;
-
-    if (cameraOpen() < 0)
-         return -1;
-    fd_v4l = camera_device;
-
-    memset(&fmt, 0, sizeof(fmt));
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    fmt.fmt.pix.pixelformat = mPictureFormat;
-    fmt.fmt.pix.width = mPictureWidth;
-    fmt.fmt.pix.height = mPictureHeight;
-    fmt.fmt.pix.sizeimage = fmt.fmt.pix.width * fmt.fmt.pix.height * g_still_bpp / 8;
-    if (mPictureFormat == V4L2_PIX_FMT_YUV420)
-        fmt.fmt.pix.bytesperline = mPictureWidth;
-    else if (mPictureFormat == V4L2_PIX_FMT_YUYV)
-        fmt.fmt.pix.bytesperline = mPictureWidth * 2;
-    else
-        LOGE("Not supported format");
-
-    if (ioctl(fd_v4l, VIDIOC_S_FMT, &fmt) < 0) {
-        LOGE("set format failed\n");
-        return -1;
-    }
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(fd_v4l, VIDIOC_G_FMT, &fmt) < 0)
-        return -1;
-    else {
-        LOGD(" Width = %d\n", fmt.fmt.pix.width);
-        LOGD(" Height = %d \n", fmt.fmt.pix.height);
-        LOGD(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-        LOGD(" pixelformat = %d\n", fmt.fmt.pix.pixelformat);
-    }
-
-    if ((mPictureWidth != (int)fmt.fmt.pix.width) ||
-        (mPictureHeight != (int)fmt.fmt.pix.height)) {
-        LOGD("Hardware not support the width or height");
-        mPictureWidth = fmt.fmt.pix.width;
-        mPictureHeight = fmt.fmt.pix.height;
-        mParameters.setPictureSize(mPictureWidth, mPictureHeight);
-    }
-
-    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    parm.parm.capture.timeperframe.numerator = 1;
-    parm.parm.capture.timeperframe.denominator = 30;
-#ifndef UVC_CAMERA
-#if defined(CAMERA_SENSOR_OV5642) || defined (CAMERA_SENSOR_OV5640)
-    /* This capturemode value is related to ov5642/ov5640 driver */
-    if (mPictureWidth == 640 && mPictureHeight == 480)
-        parm.parm.capture.capturemode = 0;  /* VGA mode */
-    else if (mPictureWidth == 320 && mPictureHeight == 240)
-        parm.parm.capture.capturemode = 1;  /* QVGA mode */
-    else if (mPictureWidth == 720 && mPictureHeight == 576)
-        parm.parm.capture.capturemode = 3;  /* PAL mode */
-    else if (mPictureWidth == 1280 && mPictureHeight == 720)
-        parm.parm.capture.capturemode = 4;  /* 720P mode */
-    else if (mPictureWidth == 1920 && mPictureHeight == 1080)
-        parm.parm.capture.capturemode = 5;  /* 1080P mode */
-    else if (mPictureWidth == 2592 && mPictureHeight == 1944) {
-        parm.parm.capture.timeperframe.denominator = 15; /* Only support 15fps */
-        parm.parm.capture.capturemode = 6;  /* 2592x1944 mode */
-    }
-#else
-    parm.parm.capture.timeperframe.denominator = 15;
-    /* This capturemode value is related to ov3640 driver */
-    if (mPictureWidth == 320 && mPictureHeight == 240)
-        parm.parm.capture.capturemode = 1;  /* QVGA mode */
-	else if (mPictureWidth == 640 && mPictureHeight == 480)
-        parm.parm.capture.capturemode = 0;  /* VGA mode */
-    else if (mPictureWidth == 720 && mPictureHeight == 480)
-        parm.parm.capture.capturemode = 4;
-	else if (mPictureWidth == 720 && mPictureHeight == 576)
-        parm.parm.capture.capturemode = 5;
-	else if (mPictureWidth == 2048 || mPictureHeight == 1536)
-        parm.parm.capture.capturemode = 3;  /* QXGA mode */
-#endif
-#endif
-    if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0) {
-        LOGE("VIDIOC_S_PARM failed\n");
-        return -1;
-    }
-
-#ifdef UVC_CAMERA
-    /* streaming is used from uvc picture since .read function
-       isn't realized in driver */
-    cameraPreviewStart();
-#else
-    crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    crop.c.left = 0;
-    crop.c.top = 0;
-    crop.c.width = mPictureWidth;
-    crop.c.height = mPictureHeight;
-    if (ioctl(fd_v4l, VIDIOC_S_CROP, &crop) < 0) {
-        LOGE("set cropping failed\n");
-        return -1;
-    }
-#endif
-    return NO_ERROR;
-}
-
-int CameraHal::cameraPreviewConfig()
-{
-    struct v4l2_format fmt;
-    struct v4l2_control ctrl;
-    struct v4l2_streamparm parm;
-    int fd_v4l;
-    LOG_FUNCTION_NAME
-
-    if (cameraOpen() < 0)
-        return -1;
-    fd_v4l = camera_device;
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    fmt.fmt.pix.pixelformat = mRecordFormat;
-    fmt.fmt.pix.width = mRecordWidth&0xFFFFFFF8;
-    fmt.fmt.pix.height = mRecordHeight&0xFFFFFFF8;
-    if (mRecordFormat == V4L2_PIX_FMT_YUV420)
-        fmt.fmt.pix.bytesperline = mRecordWidth;
-    else if (mRecordFormat == V4L2_PIX_FMT_YUYV)
-        fmt.fmt.pix.bytesperline = mRecordWidth * 2;
-    fmt.fmt.pix.priv = 0;
-    fmt.fmt.pix.sizeimage = 0;
-
-    if (ioctl(fd_v4l, VIDIOC_S_FMT, &fmt) < 0) {
-        LOGE("set format failed, format 0x%x\n", mRecordFormat);
-        return -1;
-    }
-
-    //Camera Recording VIDIOC_S_PARM
-    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    parm.parm.capture.timeperframe.numerator = 1;
-    parm.parm.capture.timeperframe.denominator = PREVIEW_FRAMERATE;
-    parm.parm.capture.capturemode = 0;  /* VGA */
-
-    if (ioctl(fd_v4l, VIDIOC_S_PARM, &parm) < 0) {
-        LOGE("VIDIOC_S_PARM failed\n");
-        return -1;
-    }
-
-#ifndef UVC_CAMERA
-    // Set rotation
-    ctrl.id = V4L2_CID_PRIVATE_BASE + 0;
-    ctrl.value = g_rotate;
-    if (ioctl(fd_v4l, VIDIOC_S_CTRL, &ctrl) < 0) {
-        LOGE("set ctrl failed\n");
-        return -1;
-    }
-#endif
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(fd_v4l, VIDIOC_G_FMT, &fmt) < 0)
-        return -1;
-    else {
-        LOGD(" Width = %d\n", fmt.fmt.pix.width);
-        LOGD(" Height = %d \n", fmt.fmt.pix.height);
-        LOGD(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-        LOGD(" pixelformat = %d\n", fmt.fmt.pix.pixelformat);
-    }
-
-    /* mRecordFrameSize is the size of frame size to upper layer,
-       only yuv420sp is supported. */
-    mRecordFrameSize = mRecordWidth * mRecordHeight * 3 / 2;
-    return 0;
-}
-
-int CameraHal::cameraPreviewStart()
-{
-    int i;
-    struct v4l2_buffer buf;
-    enum v4l2_buf_type type;
-    int fd_v4l = camera_device;
-
-    LOG_FUNCTION_NAME
-
-    struct v4l2_requestbuffers req;
-    memset(&req, 0, sizeof (req));
-
-    req.count = CAPTURE_BUFFER_NUM;
-    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    req.memory = V4L2_MEMORY_MMAP;
-    if (ioctl(fd_v4l, VIDIOC_REQBUFS, &req) < 0) {
-        LOGE("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-        return -1;
-    }
-
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++) {
-        memset(&buf, 0, sizeof (buf));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.index = i;
-        if (ioctl(fd_v4l, VIDIOC_QUERYBUF, &buf) < 0) {
-            LOGE("VIDIOC_QUERYBUF error\n");
-            return -1;
-        } else {
-            LOGE("VIDIOC_QUERYBUF ok\n");
-        }
-
-        mCaptureBuffers[i].length = buf.length;
-        mCaptureBuffers[i].phy_offset = (size_t) buf.m.offset;
-        mCaptureBuffers[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, fd_v4l, mCaptureBuffers[i].phy_offset);
-        memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-        LOGE("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-        LOGE("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-        LOGE("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-    }
-
-    nCameraBuffersQueued = 0;
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++) {
-        memset(&buf, 0, sizeof (buf));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.memory = V4L2_MEMORY_MMAP;
-        buf.index = i;
-        buf.m.offset = mCaptureBuffers[i].phy_offset;
-
-        if (ioctl (fd_v4l, VIDIOC_QBUF, &buf) < 0) {
-            LOGE("VIDIOC_QBUF error\n");
-            return -1;
-        } else {
-            LOGE("VIDIOC_QBUF ok\n");
-        }
-        nCameraBuffersQueued++;
-    }
-
-    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl (fd_v4l, VIDIOC_STREAMON, &type) < 0) {
-        LOGE("VIDIOC_STREAMON error\n");
-        return -1;
-    } else
-        LOGE("VIDIOC_STREAMON ok\n");
-
-    return 0;
-}
-
-sp<IMemoryHeap> CameraHal::getPreviewHeap() const
-{
-    LOG_FUNCTION_NAME
-
-    return mPreviewHeap;
-}
-
-sp<IMemoryHeap> CameraHal::getRawHeap() const
-{
-    return NULL;
-}
-
-void CameraHal::setCallbacks(notify_callback notify_cb,
-                                      data_callback data_cb,
-                                      data_callback_timestamp data_cb_timestamp,
-                                      void* user)
-{
-    Mutex::Autolock lock(mLock);
-    mNotifyCb = notify_cb;
-    mDataCb = data_cb;
-    mDataCbTimestamp = data_cb_timestamp;
-    mCallbackCookie = user;
-}
-
-void CameraHal::enableMsgType(int32_t msgType)
-{
-    Mutex::Autolock lock(mLock);
-	LOGD("###the mesg enabled is %x###", msgType);
-    mMsgEnabled |= msgType;
-}
-
-void CameraHal::disableMsgType(int32_t msgType)
-{
-    Mutex::Autolock lock(mLock);
-    mMsgEnabled &= ~msgType;
-}
-
-bool CameraHal::msgTypeEnabled(int32_t msgType)
-{
-    Mutex::Autolock lock(mLock);
-    return (mMsgEnabled & msgType);
-}
-
-// ---------------------------------------------------------------------------
-
-void CameraHal::previewOneFrame()
-{
-    struct v4l2_buffer cfilledbuffer;
-    overlay_buffer_t overlaybuffer;
-    int ret, display_index, i, image_size, count = 0;
-    struct timespec ts;
-
-    /* Use timed wait since captureFrame thread may be exited when waiting for the semaphore */
-    do {
-	clock_gettime(CLOCK_REALTIME, &ts);
-	ts.tv_nsec +=100000; // 100ms
-    } while ((sem_timedwait(&avaiable_show_frame, &ts) != 0) && !error_status &&  mPreviewRunning);
-
-    if ((mPreviewRunning == 0) || error_status)
-	return;
-
-    image_size = mRecordFrameSize;
-    display_index = buffer_index_maps[display_head];
-
-	//for vpu enc, the buffer format is I420
-    if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
-        nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-        for(i = 0 ; i < VIDEO_OUTPUT_BUFFER_NUM; i ++) {
-            if(mVideoBufferUsing[i] == 0) {
-                if (mRecordFormat == V4L2_PIX_FMT_YUYV)
-                    memcpy(mVideoBuffers[i]->pointer(), mPreviewBuffers[display_index]->pointer(), image_size);
-                else
-                    memcpy(mVideoBuffers[i]->pointer(),
-		                       (void*)mCaptureBuffers[display_index].virt_start, image_size);
-                 mVideoBufferUsing[i] = 1;
-                 mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoBuffers[i], mCallbackCookie);
-                 break;
-            }
-        }
-        if (i == VIDEO_OUTPUT_BUFFER_NUM)
-                 LOGD("no Buffer can be used for record\n");
-    }
-
-	// for preview frame, the format should be YUV420SP(NV21)
-    if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-        if (mRecordFormat == V4L2_PIX_FMT_YUYV)
-            convertI420toYUV420SP((uint8_t*)(mPreviewBuffers[display_index]->pointer()),
-                  (uint8_t*)(mPreviewConvertBuffers[display_index]->pointer()),mRecordWidth, mRecordHeight);
-		else
-			convertI420toYUV420SP((uint8_t*)(mCaptureBuffers[display_index].virt_start),
-                 (uint8_t*)(mPreviewConvertBuffers[display_index]->pointer()),mRecordWidth, mRecordHeight);
-
-        mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewConvertBuffers[display_index], mCallbackCookie);
-    }
-
-    pthread_mutex_lock(&mOverlay_sem);
-    /* Notify overlay of a new frame. */
-    if (mOverlay != 0) {
-    	if (is_overlay_pushmode) {
-    	    if (mOverlay->queueBuffer((overlay_buffer_t)mCaptureBuffers[display_index].phy_offset))
-    		LOGD("queueBuffer failed. May be bcos stream was not turned on yet.");
-    	    /* For overlay push mode, the second queueBuffer return means last buffer can
-    	       be used for capturing next frame */
-    	    if (is_first_buffer) {
-    		is_first_buffer = 0;
-    		last_display_index = display_index;
-    		goto out;
-    	    }
-    	} else {
-                mOverlay->dequeueBuffer(&overlaybuffer);
-                if(overlaybuffer != 0) {
-                    void* address = mOverlay->getBufferAddress(overlaybuffer);
-                    if (mRecordFormat == V4L2_PIX_FMT_YUYV)
-                        memcpy(address, mPreviewBuffers[display_index]->pointer(), image_size);
-                    else
-                        memcpy(address, (void*)mCaptureBuffers[display_index].virt_start, image_size);
-                    if (mOverlay->queueBuffer(overlaybuffer))
-        		    LOGD("queueBuffer failed. May be bcos stream was not turned on yet.");
-                }
-                else{
-                    mOverlay = NULL;
-                    LOGE("dequeueBuffer failed. Maybe in destroying!");
-                }
-        }
+    void CameraHal :: postDestroy()
+    {
+        CAMERA_HAL_LOG_FUNC;
     }
 
-    /* Queue the buffer to camera for coming usage */
-    memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-    cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-    if (mOverlay != 0 && is_overlay_pushmode)
-        cfilledbuffer.index = last_display_index;
-    else
-        cfilledbuffer.index = display_index;
-
-
-#ifdef UVC_CAMERA
-    ret = ioctl(camera_device, VIDIOC_QBUF, &cfilledbuffer);
-    if (ret < 0) {
-	LOGE("uvc camera device VIDIOC_QBUF failure, ret=%d", ret);
-	error_status = -1;
-    pthread_mutex_unlock(&mOverlay_sem);
-	return;
-    }
-#else
-    ret = ioctl(camera_device, VIDIOC_QUERYBUF, &cfilledbuffer);
-    if (ret < 0) {
-        error_status = -1;
-        LOGE("VIDIOC_QUERYBUF camera device failure, ret=%d", ret);
-        pthread_mutex_unlock(&mOverlay_sem);
-        return;
+    CAMERA_HAL_ERR_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mCaptureDevice = capturedevice;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
     }
 
-    while ((ret = ioctl(camera_device, VIDIOC_QBUF, &cfilledbuffer) < 0) && (count < 10)) {
-	count ++;
+    CAMERA_HAL_ERR_RET CameraHal :: setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mPPDevice = postprocessdevice;
+        else 
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
     }
-    if (ret < 0) {
-	LOGE("VIDIOC_QBUF Failure, ret=%d", ret);
-	error_status = -1;
-    pthread_mutex_unlock(&mOverlay_sem);
-	return;
+
+    CAMERA_HAL_ERR_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mJpegEncoder = jpegencoder;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
     }
 
-#endif
-    nCameraBuffersQueued++;
-    last_display_index = display_index;
+    CAMERA_HAL_ERR_RET CameraHal::Init()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        mCameraReady == true;
 
-    sem_post(&avaible_dequeue_frame);
-out:
-    pthread_mutex_unlock(&mOverlay_sem);
-    display_head ++;
-    display_head %= CAPTURE_BUFFER_NUM;
-    return;
-}
+        if ((ret = AolLocForInterBuf())<0)
+            return ret;
+        if ((ret = InitCameraHalParam()) < 0)
+            return ret;
+        if (mPPDeviceNeed == true && mPPDevice == NULL)
+            return CAMERA_HAL_ERR_PP_NULL;
+        if ((ret = CameraMiscInit()) < 0)
+            return ret;
 
-int CameraHal::previewShowFrameThread()
-{
-    if (mPreviewRunning && !error_status) {
-        previewOneFrame();
+        return ret;
     }
 
-    return NO_ERROR;
-}
-
-status_t CameraHal::setOverlay(const sp<Overlay> &overlay)
-{
-    LOG_FUNCTION_NAME
-    char  propBuf[PROPERTY_VALUE_MAX];
+    CAMERA_HAL_ERR_RET  CameraHal :: AolLocForInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
 
-    Mutex::Autolock lock(mLock);
-    if (overlay == NULL)
-        LOGE("Trying to set overlay, but overlay is null!");
-    pthread_mutex_lock(&mOverlay_sem);
-    mOverlay = overlay;
-    pthread_mutex_unlock(&mOverlay_sem);
+        supportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        supprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
 
-    is_overlay_pushmode = 0;
+        if (supportedPictureSizes == NULL ||
+                supportedPreviewSizes == NULL ||
+                supportedFPS          == NULL ||
+                supprotedThumbnailSizes == NULL)
+            ret = CAMERA_HAL_ERR_ALLOC_BUF;
 
-    if (mOverlay != 0) {
-	/* Not enable push mode for UVC camera case yet*/
-#ifndef UVC_CAMERA
-    property_get("camera.overlay.enable-pushmode", propBuf, "");
-    is_overlay_pushmode = (propBuf[0] == '1');
-    if (is_overlay_pushmode)
-        mOverlay->setParameter(OVERLAY_MODE, OVERLAY_PUSH_MODE);
-#endif
+        return ret;
+    }
+    void  CameraHal :: FreeInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (supportedPictureSizes)
+            free(supportedPictureSizes);
+        if (supportedPreviewSizes)
+            free(supportedPreviewSizes);
+        if (supportedFPS)
+            free(supportedFPS);
+        if (supprotedThumbnailSizes)
+            free(supprotedThumbnailSizes);
     }
 
-    return NO_ERROR;
-}
+    CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
+    {	
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
 
-int CameraHal::previewCaptureFrameThread()
-{
-    struct v4l2_buffer cfilledbuffer;
-    int ret, index, count = 0;
-    struct timespec ts;
+        if ((ret = GetCameraBaseParam(&mParameters)) < 0)
+            return ret;
 
-    if (mPreviewRunning && !error_status) {
+        if ((ret = GetPictureExifParam(&mParameters)) < 0)
+            return ret;
 
-        /* Use timed wait since another thread may be failure when waiting for the semaphore */
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while ((sem_timedwait(&avaible_dequeue_frame, &ts) != 0) && mPreviewRunning && !error_status);
+        return ret;
+    }
 
-        if ((mPreviewRunning == 0) || error_status)
-            return -1;
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        pthread_mutex_init(&mPPIOParamMutex, NULL);
+        pthread_mutex_init(&mOverlayMutex, NULL);
+        return ret;
+    }
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        pthread_mutex_destroy(&mPPIOParamMutex);
+        pthread_mutex_destroy(&mOverlayMutex);
+        return ret;
+    }
 
-	memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-	cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	cfilledbuffer.memory = V4L2_MEMORY_MMAP;
+    CAMERA_HAL_ERR_RET CameraHal :: GetCameraBaseParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char TmpStr[20];
+        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
+        struct capture_config_t CaptureSizeFps;
+        int  previewCnt= 0, pictureCnt = 0, i;
 
-	/* De-queue the next avaliable buffer in loop since timout is used in driver */
-	while ((ret = ioctl(camera_device, VIDIOC_DQBUF, &cfilledbuffer) == -1) &&
-                (count < 20000) && mPreviewRunning) {
-	    usleep(50);
-	    count ++;
-	}
+        pParam->setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);
+        pParam->set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, CameraParameters::PIXEL_FORMAT_YUV420SP);
 
-	if (ret < 0) {
-	    LOGE("Camera VIDIOC_DQBUF failure, ret=%d", ret);
-	    error_status = -1;
-	    return -1;
-	}
+        //the Camera Open here will not be close immediately, for later preview.
+        if (OpenCaptureDevice() < 0)
+            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
 
-	if (mPreviewRunning == 0)
-	    return -1;
+        memset(mCaptureSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
 
-	nCameraBuffersQueued--;
+        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mCaptureSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
 
-	/* Convert YUYV to NV12 and put to mPreviewBuffer */
-	if (mRecordFormat == V4L2_PIX_FMT_YUYV) {
-	    convertYUYVtoI420(mCaptureBuffers[cfilledbuffer.index].virt_start,
-				  (uint8_t *)mPreviewBuffers[cfilledbuffer.index]->pointer(), mRecordWidth, mRecordHeight);
-	}
+        if (NegotiateCaptureFmt(false) < 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
 
-	buffer_index_maps[dequeue_head] = cfilledbuffer.index;
-	dequeue_head ++;
-	dequeue_head %= CAPTURE_BUFFER_NUM;
-	sem_post(&avaiable_show_frame);
-    }
+        CaptureSizeFps.fmt = mPreviewCapturedFormat;
 
-    return UNKNOWN_ERROR;
-}
+        CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat is %x", mPreviewCapturedFormat);
 
-status_t CameraHal::startPreview()
-{
-    LOG_FUNCTION_NAME
+        for(;;){
+            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
+                CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
+                break;
+            }
+            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
+            CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
+            if (previewCnt == 0)
+                strncpy((char*) supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            else{
+                strncat(supportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                strncat(supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            }
+            pictureCnt ++;
+
+            if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator > 25){
+                pParam->setPreviewSize(CaptureSizeFps.width, CaptureSizeFps.height);
+                pParam->setPreviewFrameRate(CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator );
+                pParam->setPictureSize(CaptureSizeFps.width, CaptureSizeFps.height);
+                if (previewCnt == 0)
+                    strncpy((char*) supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                else{
+                    strncat(supportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                }
+                previewCnt ++;
+            }
+        }
+
+        /*hard code here*/
+        strcpy(supportedFPS, "30,15,10");
+        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", supportedPictureSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", supportedPreviewSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", supportedFPS);
 
-    int i, width, height;
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, supportedPictureSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, supportedPreviewSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, supportedFPS);
+
+        return CAMERA_HAL_ERR_NONE;
 
-    Mutex::Autolock lock(mLock);
-    if (mPreviewRunning != 0) {
-        // already running
-        return INVALID_OPERATION;
     }
-	 if (!mPowerLock) {
-        acquire_wake_lock (PARTIAL_WAKE_LOCK, "V4LCapture");
-        mPowerLock = true;
+
+    status_t CameraHal :: OpenCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDeviceOpen){
+            CAMERA_HAL_LOG_INFO("The capture device already open");
+            return NO_ERROR;
+        }
+        else if (mCaptureDevice != NULL){
+            if ( mCaptureDevice->DevOpen()<0 )
+                return INVALID_OPERATION;
+            mCaptureDeviceOpen = true;
+        }else{
+            CAMERA_HAL_ERR("no capture device assigned");
+            return INVALID_OPERATION;
+        }
+        return ret;
+    }
+    void CameraHal ::CloseCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
+            mCaptureDevice->DevClose();
+            mCaptureDeviceOpen = false;
+        }
     }
 
-    dequeue_head = 0;
-    display_head = 0;
-    error_status = 0;
-    is_first_buffer = 1;
-    last_display_index = 0;
+    CAMERA_HAL_ERR_RET CameraHal :: GetPictureExifParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
+
+        /*hard code here*/
+
+        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
+        strcpy(supprotedThumbnailSizes, "0x0,128x128,96x96");
+        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, supprotedThumbnailSizes);
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
+        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
+        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_INFINITY, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_MACRO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::FOCUS_MODE_FIXED, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
+
+        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
+        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
+        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
+        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
+        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
+        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
+        // default zoom should be 0 as CTS defined
+        pParam->set(CameraParameters::KEY_ZOOM, "0");
+        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+        //returned as 320. The number of elements is {@link
+        //#getMaxZoom} + 1. The list is sorted from small to large. The
+        //first element is always 100. The last element is the zoom
+        //ratio of the maximum zoom value.
+        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
+
+        return CAMERA_HAL_ERR_NONE;
+    }
+
+    sp<IMemoryHeap> CameraHal::getPreviewHeap() const
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++) {
-        mCaptureBuffers[i].length = 0;
+        return mPreviewHeap;
     }
 
-    if (cameraPreviewConfig() < 0)
-        return INVALID_OPERATION;
+    sp<IMemoryHeap> CameraHal::getRawHeap() const
+    {
+        return NULL;
+    }
 
-    LOGD("Clear the old preview memory and Init new memory");
-    mPreviewHeap.clear();
-    for (i = 0; i< CAPTURE_BUFFER_NUM; i++)
-        mPreviewBuffers[i].clear();
-    mPreviewHeap = new MemoryHeapBase(mRecordFrameSize * VIDEO_OUTPUT_BUFFER_NUM);
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++)
-       mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mRecordFrameSize * i, mRecordFrameSize);
+    status_t CameraHal::dump(int fd, const Vector<String16>& args) const
+    {
+        return NO_ERROR;
+    }
 
-    mPreviewConvertHeap.clear();
-    for (i = 0; i< CAPTURE_BUFFER_NUM; i++)
-        mPreviewConvertBuffers[i].clear();
-    mPreviewConvertHeap = new MemoryHeapBase(mRecordFrameSize * VIDEO_OUTPUT_BUFFER_NUM);
-    for (i = 0; i < CAPTURE_BUFFER_NUM; i++)
-       mPreviewConvertBuffers[i] = new MemoryBase(mPreviewConvertHeap, mRecordFrameSize * i, mRecordFrameSize);
+    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
+            int32_t arg2)
+    {
+        return BAD_VALUE;
+    }
 
-    cameraPreviewStart();
+    void CameraHal::setCallbacks(notify_callback notify_cb,
+            data_callback data_cb,
+            data_callback_timestamp data_cb_timestamp,
+            void* user)
+    {
+        Mutex::Autolock lock(mLock);
+        mNotifyCb = notify_cb;
+        mDataCb = data_cb;
+        mDataCbTimestamp = data_cb_timestamp;
+        mCallbackCookie = user;
+    }
 
-    sem_init(&avaiable_show_frame, 0, 0);
-    /* Init sem to CAPTURE_BUFFER_NUM -1 since buffer can be dequeued at least
-       two buffers are queued */
-    sem_init(&avaible_dequeue_frame, 0, CAPTURE_BUFFER_NUM - 1);
+    void CameraHal::enableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg enabled is %x###", msgType);
+        mMsgEnabled |= msgType;
+    }
 
+    void CameraHal::disableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg disabled is %x###", msgType);
+        mMsgEnabled &= ~msgType;
+    }
+    bool CameraHal::msgTypeEnabled(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg check is %x###", msgType);
+        return (mMsgEnabled & msgType);
+    }
 
-    mPreviewCaptureFrameThread = new PreviewCaptureFrameThread(this);
-    mPreviewShowFrameThread = new PreviewShowFrameThread(this);
+    CameraParameters CameraHal::getParameters() const
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-    mPreviewRunning = true;
+        Mutex::Autolock lock(mLock);
+        return mParameters;
+    }
 
-    return NO_ERROR;
-}
+    status_t  CameraHal:: setParameters(const CameraParameters& params)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int w, h;
+        int framerate;
+        int max_zoom,zoom;
+        char tmp[128];
+        Mutex::Autolock lock(mLock);
+
+        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
+        zoom = params.getInt(CameraParameters::KEY_ZOOM);
+        if(zoom > max_zoom){
+            CAMERA_HAL_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
+            return BAD_VALUE;
+        }
+        if (!(strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
+                (strcmp(params.getPreviewFormat(), "yuv422i") == 0)) {
+            CAMERA_HAL_ERR("Only yuv420 or yuv420i is supported");
+            return BAD_VALUE;
+        }
 
-void CameraHal::stopPreview()
-{
-    LOG_FUNCTION_NAME
+        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
+            CAMERA_HAL_ERR("Only jpeg still pictures are supported");
+            return BAD_VALUE;
+        }
 
-    Mutex::Autolock lock(mLock);
-    /* Cannot stop preview in recording */
-    if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
-	    return;
-    cameraPreviewStop();
+        params.getPreviewSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
+        if (strstr(supportedPreviewSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
 
-	if (mPowerLock) {
-			release_wake_lock ("V4LCapture");
-			mPowerLock = false;
-	}
-}
+        params.getPictureSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
+        if (strstr(supportedPictureSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
 
-void CameraHal::cameraPreviewStop()
-{
-    sp<PreviewShowFrameThread> previewShowFrameThread;
-    sp<PreviewCaptureFrameThread> previewCaptureFrameThread;
-    struct v4l2_requestbuffers creqbuf;
+        framerate = params.getPreviewFrameRate();
+        CAMERA_HAL_LOG_INFO("##the set frame rate is %d ##", framerate);
+        if (framerate >30 || framerate<0 ){
+            CAMERA_HAL_ERR("The framerate is not corrected");
+            return BAD_VALUE;
+        }
 
-    LOG_FUNCTION_NAME
+        mParameters = params;
 
-    if (mPreviewRunning != 0) {
-        int ret;
-        struct v4l2_requestbuffers creqbuf;
-        struct v4l2_buffer cfilledbuffer;
+        return NO_ERROR;
+    }
 
-        mPreviewRunning = 0;
+    status_t CameraHal::setOverlay(const sp<Overlay> &overlay)
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-	{// scope for the lock
-//	Mutex::Autolock lock(mLock);
-        previewShowFrameThread = mPreviewShowFrameThread;
-	previewCaptureFrameThread = mPreviewCaptureFrameThread;
-	}
-
-	if (previewCaptureFrameThread != 0)
-	    previewCaptureFrameThread->requestExitAndWait();
-
-        if (previewShowFrameThread != 0)
-	    previewShowFrameThread->requestExitAndWait();
-
-	sem_destroy(&avaiable_show_frame);
-	sem_destroy(&avaible_dequeue_frame);
-
-//        /* Flush to release buffer used in overlay */
-//        if (mOverlay != 0) {
-//            if (is_overlay_pushmode) {
-                //    LOGD("overlay queueBuffer NULL failure");
-		/* FIXME: Cannot use queueBuffer here since overlay may be streamed off,
-		   delay some time here now*/
-//		usleep(30000);
-//                mOverlay = NULL;
-//            }
-//        }
-
-/* no need to DQBUF before STREAMOFF for UVC camera to improve performance */
-#if 0
-    if (!error_status) {
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-
-        while(nCameraBuffersQueued){
-            LOGD("DQUEUING UNDQUEUED BUFFERS enter = %d",nCameraBuffersQueued);
-            if (ioctl(camera_device, VIDIOC_DQBUF, &cfilledbuffer) < 0) {
-                LOGE("VIDIOC_DQBUF Failed!!!");
-            }
-            nCameraBuffersQueued--;
-            LOGD("DQUEUING UNDQUEUED BUFFERS exit = %d",nCameraBuffersQueued);
+        Mutex::Autolock lock(mLock);
+        if (overlay == NULL){
+            CAMERA_HAL_LOG_INFO("Trying to set overlay, but overlay is null!");
         }
+        else{
+            CAMERA_HAL_LOG_INFO("Get the overlay to display");
+            overlay->setParameter(OVERLAY_MODE, OVERLAY_PUSH_MODE);
+        }
+        pthread_mutex_lock(&mOverlayMutex);
+        mOverlay = overlay;
+        pthread_mutex_unlock(&mOverlayMutex);
+        return NO_ERROR;
     }
-#endif
 
-        creqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(camera_device, VIDIOC_STREAMOFF, &creqbuf.type) == -1) {
-            LOGE("VIDIOC_STREAMOFF Failed");
-        }
+    status_t CameraHal::startPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
 
-    /* Close device */
-	cameraClose();
-    }
-//    Mutex::Autolock lock(mLock);
-    if (mPreviewShowFrameThread != 0)
-        mPreviewShowFrameThread.clear();
-    if (mPreviewCaptureFrameThread != 0)
-        mPreviewCaptureFrameThread.clear();
-}
-
-bool CameraHal::previewEnabled()
-{
-    return mPreviewRunning;
-}
-
-status_t CameraHal::startRecording()
-{
-    LOG_FUNCTION_NAME 
-    int w,h;
-    int i = 0, mRecordingFrameSize= 0;
-
-    if (mRecordRunning !=0 ) {
-        LOGI("Recording is already existed\n");
-        return INVALID_OPERATION;
-    }
-
-    LOGD("Clear the old memory ");
-    mVideoHeap.clear();
-    for(i = 0; i < VIDEO_OUTPUT_BUFFER_NUM; i++) {
-        mVideoBuffers[i].clear();
-        mVideoBufferUsing[i] = 0;
-    }
-    LOGD("Init the video Memory %d", mRecordFrameSize);
-    mVideoHeap = new MemoryHeapBase(mRecordFrameSize * VIDEO_OUTPUT_BUFFER_NUM);
-    for(i = 0; i < VIDEO_OUTPUT_BUFFER_NUM; i++) {
-        LOGD("Init Video Buffer:%d ",i);
-        mVideoBuffers[i] = new MemoryBase(mVideoHeap,
-	                       mRecordFrameSize * i, mRecordFrameSize);
-    }
-    mRecordRunning = true;
-
-    return NO_ERROR;
-}
-
-void CameraHal::stopRecording()
-{
-    LOG_FUNCTION_NAME
-
-    mRecordRunning = false;
-    if(mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-        LOGD("Preview is still in progress\n");
-    }
-}
-
-bool CameraHal::recordingEnabled()
-{
-    LOG_FUNCTION_NAME
-    return (mPreviewRunning && mRecordRunning);
-}
-
-static void debugShowFPS()
-{
-    static int mFrameCount = 0;
-    static int mLastFrameCount = 0;
-    static nsecs_t mLastFpsTime = 0;
-    static float mFps = 0;
-    mFrameCount++;
-    if (!(mFrameCount & 0x1F)) {
-        nsecs_t now = systemTime();
-        nsecs_t diff = now - mLastFpsTime;
-        mFps =  ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;
-        mLastFpsTime = now;
-        mLastFrameCount = mFrameCount;
-        LOGD("####### [%d] Frames, %f FPS", mFrameCount, mFps);
-    }
-}
-
-void CameraHal::releaseRecordingFrame(const sp<IMemory>& mem)
-{
-    ssize_t offset;
-    size_t  size;
-    int index;
-
-    debugShowFPS();
-    offset = mem->offset();
-    size   = mem->size();
-    index = offset / size;
-
-    mVideoBufferUsing[index] = 0;
-}
-
-
-// ---------------------------------------------------------------------------
-
-int CameraHal::beginAutoFocusThread(void *cookie)
-{
-    LOG_FUNCTION_NAME
-
-    CameraHal *c = (CameraHal *)cookie;
-    return c->autoFocusThread();
-}
-
-int CameraHal::autoFocusThread()
-{
-    LOG_FUNCTION_NAME
-
-    if (mMsgEnabled & CAMERA_MSG_FOCUS)
-        mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
+        Mutex::Autolock lock(mLock);
+        if (mPreviewRunning) {
+            return NO_ERROR;
+        }
+        if ((ret == CameraHALStartPreview())<0)
+            return ret;
 
-    return UNKNOWN_ERROR;
-}
-
-status_t CameraHal::autoFocus()
-{
-    LOG_FUNCTION_NAME
-
-    Mutex::Autolock lock(mLock);
+        LockWakeLock();
+        return ret;
+    }
 
-    if (createThread(beginAutoFocusThread, this) == false)
-        return UNKNOWN_ERROR;
+    void CameraHal::stopPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timeval af_time, be_time;
+        Mutex::Autolock lock(mLock);
+        /* Cannot stop preview in recording */
+        //   if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
+        //       return;
 
-    return NO_ERROR;
-}
-
-status_t CameraHal::cancelAutoFocus()
-{
-    return NO_ERROR;
-}
-
-void CameraHal::convertYUYVtoI420(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
-{
-    /* Color space conversion from YUYV to YUV420SP */
-    int src_size = 0, out_size = 0;
-    uint8_t *p;
-    uint8_t *Y, *U, *V;
-
-    src_size = (width * height) << 1 ;//YUY2 4:2:2
-    p = inputBuffer;
-
-    out_size = width * height * 3 / 2;//YUV 4:2:0
-    Y = outputBuffer;
-    U = Y + width * height;
-    V = U + (width *  height >> 2);
-
-    memset(outputBuffer, 0, out_size);
-    for(int k = 0; k < height; ++k) {
-        for(int j = 0; j < (width >> 1); ++j) {
-            Y[j*2] = p[4*j];
-            Y[j*2+1] = p[4*j+2];
-            if (k %2 == 0) {
-                U[j] = p[4*j+1];
-                V[j] = p[4*j+3];
-            }
-        }
-        p = p + width * 2;
+        CameraHALStopPreview();
+        UnLockWakeLock();
 
-        Y = Y + width;
-        U = U + (width >> 2);
-        V = V + (width >> 2);
     }
-}
 
+    bool CameraHal::previewEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return mPreviewRunning;
+    }
 
+    status_t CameraHal::startRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
 
+        if (mRecordRunning == true ) {
+            CAMERA_HAL_LOG_INFO("Recording is already existed\n");
+            return ret;
+        }
+        if((ret = AllocateRecordVideoBuf())<0)
+            return ret;
 
-void CameraHal::convertI420toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
-{
-    /* Color space conversion from I420 to YUV420SP */
-    int Ysize = 0, UVsize = 0;
-    uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
+        mRecordRunning = true;
 
-    Ysize = width * height;
-	UVsize = width *  height >> 2;
+        return NO_ERROR;
+    }
 
-	Yin = inputBuffer;
-	Uin = Yin + Ysize;
-	Vin = Uin + UVsize;
+    void CameraHal::stopRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mRecordRunning = false;
+    }
 
-	Yout = outputBuffer;
-	Vout = Yout + Ysize;
-	Uout = Vout + 1;
+    void CameraHal::releaseRecordingFrame(const sp<IMemory>& mem)
+    {
+        ssize_t offset;
+        size_t  size;
+        int index;
 
-	memcpy(Yout, Yin, Ysize);
+        offset = mem->offset();
+        size   = mem->size();
+        index = offset / size;
 
-    for(int k = 0; k < UVsize; k++) {
-        *Uout = *Uin;
-        *Vout = *Vin;
-        Uin += 1;
-		Vin += 1;
-		Uout += 2;
-		Vout += 2;
+        mVideoBufferUsing[index] = 0;
     }
-}
 
-int CameraHal::cameraTakePicture()
-{
+    bool CameraHal::recordingEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return (mPreviewRunning && mRecordRunning);
+    }
 
-    int w, h, ret;
-    int pictureSize;
-    unsigned long base, offset;
-    struct v4l2_streamparm parm;
-    struct v4l2_format fmt;
-    sp<MemoryBase> mPictureBuffer;
-    sp<MemoryBase> memBase;
-    int target_size, count = 0;
-    uint8_t *buf1;
-    struct v4l2_requestbuffers creqbuf;
-    struct v4l2_buffer cfilledbuffer;
+    status_t CameraHal::autoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-    LOG_FUNCTION_NAME
+        Mutex::Autolock lock(mLock);
 
-    mParameters.getPictureSize(&w, &h);
-    LOGD("Picture Size: Width = %d \tHeight = %d", w, h);
-    mPictureWidth = w;
-    mPictureHeight = h;
+        if (mAutoFocusThread != NULL)
+            mAutoFocusThread.clear();
 
-    if(cameraTakePicConfig() < 0){
-        return -1;
+        mAutoFocusThread = new AutoFocusThread(this);
+        if (mAutoFocusThread == NULL)
+            return UNKNOWN_ERROR;
+        return NO_ERROR;
     }
 
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(camera_device, VIDIOC_G_FMT, &fmt) < 0) {
-        LOGE("get format failed\n");
-        return -1;
+    status_t CameraHal::cancelAutoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        return NO_ERROR;
     }
 
-    LOGD(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-    LOGD(" pixelformat = %d\n", fmt.fmt.pix.pixelformat);
+    status_t CameraHal::takePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        Mutex::Autolock lock(mLock);
 
-    target_size = fmt.fmt.pix.sizeimage;
+        if (mTakePicThread != NULL)
+            mTakePicThread.clear();
 
-    buf1 = (uint8_t *)malloc(target_size);
-    if (!buf1){
-        LOGE("buffer malloc error!\n");
-        free(buf1);
-        return -1;
+        mTakePicThread= new TakePicThread(this);
+        if (mTakePicThread == NULL)
+            return UNKNOWN_ERROR;
+        return NO_ERROR;
     }
-    memset(buf1, 0 ,target_size);
 
-    if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
-        LOGI("CAMERA_MSG_SHUTTER");
-        mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
+    status_t CameraHal::cancelPicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        return NO_ERROR;
     }
 
-#ifdef UVC_CAMERA
-    memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-    cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    cfilledbuffer.memory = V4L2_MEMORY_MMAP;
 
-    /* De-queue the next avaliable buffer in loop since timout is used in driver */
-    while ((ret = ioctl(camera_device, VIDIOC_DQBUF, &cfilledbuffer) == -1) &&
-            (count < 20000)) {
-        usleep(50);
-        count ++;
-    }
-    if (ret < 0){
-        LOGE("VIDIOC_DQBUF Failed!!!");
-        error_status = -1;
-    }
+    int CameraHal::autoFocusThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int FocusFlag = 0;
 
-    convertYUYVtoI420(mCaptureBuffers[cfilledbuffer.index].virt_start,
-                          buf1, mPictureWidth, mPictureHeight);
+        if (mMsgEnabled & CAMERA_MSG_FOCUS)
+            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
 
-    target_size = mPictureWidth * mPictureHeight * 3 / 2;
-#else
-    /* Use read to get one picture for on-board camera */
-    if (read(camera_device, buf1, target_size) != target_size) {
-        LOGE("v4l2 read error.\n");
-        free(buf1);
-        return -1;
+        return UNKNOWN_ERROR; //exit the thread
     }
 
-#endif
-    LOGD("Generated a picture");
+    int CameraHal::takepicThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_INFO("Camera is taking picture!");
 
-#ifdef UVC_CAMERA
-    creqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(camera_device, VIDIOC_STREAMOFF, &creqbuf.type) == -1) {
-        LOGE("VIDIOC_STREAMOFF Failed");
+        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
+        CameraHALStopPreview();
+        cameraHALTakePicture();
+
+        return UNKNOWN_ERROR;
     }
-#endif
-    /* Close device */
-    cameraClose();
 
-#ifdef USE_FSL_JPEG_ENC
-    sp<MemoryBase> jpegMemBase = encodeImage((void*)buf1, target_size);
+    int CameraHal :: cameraHALTakePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR;
+        unsigned int DeQueBufIdx = 0;
+        struct jpeg_encoding_conf JpegEncConf;
+        DMA_BUFFER Buf_input, Buf_output;
+        sp<MemoryBase> JpegMemBase = NULL;
+        sp<MemoryHeapBase> JpegImageHeap = NULL;
+
+        if (mJpegEncoder == NULL){
+            CAMERA_HAL_ERR("the jpeg encoder is NULL");
+            return BAD_VALUE;
+        }
+        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
+        mPPbufNum = 1;
+        mTakePicFlag = true;
+        mPPDeviceNeedForPic = 0;
+        if ((ret = GetJpegEncoderParam()) < 0)
+            return ret;
+        if ((ret = NegotiateCaptureFmt(true)) < 0)
+            return ret;
+        mCaptureDeviceCfg.fmt = mPictureCapturedFormat;
+        if ((ret = PrepareCaptureDevices()) < 0)
+            return ret;
+        if ((ret = PrepareJpegEncoder()) < 0)
+            return ret;
+
+        if (mCaptureDevice->DevStart()<0){
+            CAMERA_HAL_ERR("the capture start up failed !!!!");
+            return INVALID_OPERATION;
+        }
 
+        for (unsigned int i =0;;){
+            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
+                LOGE("VIDIOC_DQBUF Failed!!!");
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
 
-    if (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE) {
-        LOGI("==========CAMERA_MSG_COMPRESSED_IMAGE");
-        mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, jpegMemBase, mCallbackCookie);
-    }
-#else
-    LOGI("CameraHal::pictureThread get default image");
-    sp<MemoryHeapBase> heap = new MemoryHeapBase(kCannedJpegSize);
-    sp<MemoryBase> mem = new MemoryBase(heap, 0, kCannedJpegSize);
-    memcpy(heap->base(), kCannedJpeg, kCannedJpegSize);
-    if (mJpegPictureCallback)
-        mJpegPictureCallback(mem, mPictureCallbackCookie);
-#endif
+            if (++i == mCaptureDeviceCfg.picture_waite_number)
+                break;
 
-exit0:
-    if (buf1)
-            free(buf1);
+            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
+        }
 
-    return NO_ERROR;
-}
+        JpegImageHeap= new MemoryHeapBase(mCaptureFrameSize);
+        if (JpegImageHeap == NULL){
+            ret = NO_MEMORY;
+            goto Pic_out;
+        }
+        Buf_input = mCaptureBuffers[DeQueBufIdx];
+        Buf_output.virt_start = (unsigned char *)(JpegImageHeap->getBase());
 
-int CameraHal::beginPictureThread(void *cookie)
-{
-    CameraHal *c = (CameraHal *)cookie;
-    return c->pictureThread();
-}
 
-int CameraHal::pictureThread()
-{
-    LOG_FUNCTION_NAME
+        CAMERA_HAL_LOG_INFO("Generated a picture");
 
-    /* Camera video capture is used for UVC camera since read function
-       ins't realized on uvc_v4l2 driver, but, read function is called
-       for CSI camera */
-    LOGD("Camera is taking picture!");
-    /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
+        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
+            CAMERA_HAL_LOG_INFO("CAMERA_MSG_SHUTTER");
+            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
+        }
 
-    cameraPreviewStop();
-    cameraTakePicture();
+        if (mJpegEncoder->DoEncode(&Buf_input,&Buf_output,&JpegEncConf) < 0){
+            ret = UNKNOWN_ERROR;
+            goto Pic_out;
+        }
 
-    return NO_ERROR;
+        JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
 
-}
-status_t CameraHal::takePicture()
-{
-    if (createThread(beginPictureThread, this) == false)
-        return -1;
-    return NO_ERROR;
-}
+Pic_out:
+        mCaptureDevice->DevStop();
+        mCaptureDevice->DevDeAllocate();
+        CloseCaptureDevice();
 
-status_t CameraHal::cancelPicture()
-{
-    LOG_FUNCTION_NAME
+        if ((JpegMemBase != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
+            CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
+            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, mCallbackCookie);
+        }
 
-    return NO_ERROR;
-}
 
-status_t CameraHal::dump(int fd, const Vector<String16>& args) const
-{
-    return NO_ERROR;
-}
+        return ret;
 
-int CameraHal::validateSize(int w, int h)
-{
-    LOG_FUNCTION_NAME
+    }
 
-    if ((w < MIN_WIDTH) || (h < MIN_HEIGHT)){
-        return false;
+    int CameraHal :: GetJpegEncoderParam()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0;
+        memset(mEncoderSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+
+        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mEncoderSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0)
+            return UNKNOWN_ERROR;
+        return ret;
     }
+    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0, j = 0;
+
+
+        if(TakePicFlag){
+            mPictureCapturedFormat = 0;
+            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
+                    if (mEncoderSupportedFormat[j] == 0)
+                        break;
+                    if (mCaptureSupportedFormat[i] == mEncoderSupportedFormat[j]){
+                        mPictureCapturedFormat= mCaptureSupportedFormat[i];
+
+                        CAMERA_HAL_LOG_INFO(" Get the mPictureCapturedFormat :%c%c%c%c\n",
+                                mPictureCapturedFormat & 0xFF, (mPictureCapturedFormat >> 8) & 0xFF,
+                                (mPictureCapturedFormat >> 16) & 0xFF, (mPictureCapturedFormat >> 24) & 0xFF);
+                        break;
+                    }
+                }
+                if ((mPictureCapturedFormat != 0) || (mCaptureSupportedFormat[i] == 0))
+                    break;
+            }
+            if (i == MAX_QUERY_FMT_TIMES && j == MAX_QUERY_FMT_TIMES)
+                return UNKNOWN_ERROR;
+        }else{
+
+            CAMERA_HAL_LOG_INFO("mPreviewFormat :%c%c%c%c\n",
+                    mPreviewFormat & 0xFF, (mPreviewFormat >> 8) & 0xFF,
+                    (mPreviewFormat >> 16) & 0xFF, (mPreviewFormat >> 24) & 0xFF);
+            CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
+                    mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
+                    (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
+
+            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
+                if (mCaptureSupportedFormat[i] == mPreviewFormat){
+                    CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                    mPPDeviceNeed = false;
+                    mPreviewCapturedFormat = mPreviewFormat;
+                    break;
+                }
+            }
 
-    return true;
-}
+            if (i == MAX_QUERY_FMT_TIMES){
+                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                    //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
+                    if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
+                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                        mPPDeviceNeed = true;
+                        mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
+                        break;
+                    }
+                }
+            }
 
+            CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat :%c%c%c%c\n",
+                    mPreviewCapturedFormat & 0xFF, (mPreviewCapturedFormat >> 8) & 0xFF,
+                    (mPreviewCapturedFormat >> 16) & 0xFF, (mPreviewCapturedFormat >> 24) & 0xFF);
 
-status_t CameraHal::setParameters(const CameraParameters& params)
-{
-    LOG_FUNCTION_NAME
+            if ((i == MAX_QUERY_FMT_TIMES)){
+                CAMERA_HAL_ERR("Negotiate for the preview format error");
+                return BAD_VALUE;
+            }
+        }
 
-    int w, h;
-    int framerate;
-    int max_zoom,zoom;
-    Mutex::Autolock lock(mLock);
-    max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
-    zoom = params.getInt(CameraParameters::KEY_ZOOM);
-    if(zoom > max_zoom){
-	 LOGE("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
-        return -1;
-    }
-    if (!(strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-	(strcmp(params.getPreviewFormat(), "yuv422i") == 0)) {
-        LOGE("Only yuv420 or yuv420i is supported");
-        return -1;
-    }
 
-    if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
-        LOGE("Only jpeg still pictures are supported");
-        return -1;
+        return ret;
     }
 
-    params.getPreviewSize(&w, &h);
-    if (!validateSize(w, h)) {
-        LOGE("Preview size not supported");
-        return -1;
-    }
+    int CameraHal :: PrepareJpegEncoder()
+    {
+        int ret = NO_ERROR;
+        struct jpeg_enc_make_info_t make_info;
+        struct jpeg_enc_makernote_info_t makernote_info;
+        struct jpeg_enc_model_info_t model_info;
+        struct jpeg_enc_datetime_info_t datetime_info;
+        struct jpeg_enc_focallength_t focallength_info;
+        struct jpeg_enc_gps_param gps_info;
+
+        char temp_string[30], gps_datetime_string[11];
+        char format[30] = "%Y:%m:%d %k:%M:%S";
+        time_t clock;
+        struct tm *tm, *temp_tm;
+        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
+        double dAltitude;
+
+        mJpegEncCfg.BufFmt = mPictureCapturedFormat;
+        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
+        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
+        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
+        CAMERA_HAL_LOG_INFO("the pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
+        CAMERA_HAL_LOG_INFO("the thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
+        //set focallength info
+        focallength_info.numerator=10001;
+        focallength_info.denominator=1000;  // hardcode here for the cts
+        mJpegEncCfg.pFoclLength = &focallength_info;
+
+        //set the make info
+        make_info.make_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeInfo = &make_info;
+
+        //set makernote info
+        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeNote = &makernote_info;
+
+        //set model info
+        model_info.model_bytes=strlen(EXIF_MODEL);
+        strcpy((char *)model_info.model,EXIF_MODEL);
+        mJpegEncCfg.pModelInfo = &model_info;
+
+        //set datetime
+        time(&clock);
+        tm = localtime(&clock);
+        time_t GpsUtcTime;
+        strftime(temp_string, sizeof(temp_string), format, tm);
+        CAMERA_HAL_LOG_INFO("the date time is %s", temp_string);
+        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
+        mJpegEncCfg.pDatetimeInfo = &datetime_info;
+
+
+        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
+        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
+        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
+        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
+
+        if (cLatitude !=NULL && cLatitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
+
+            gps_info.version=0x02020000;
+
+            //latitude: dd/1,mm/1,ss/1
+            gps_info.latitude_degree[1]=1;
+            gps_info.latitude_minute[1]=1;
+            gps_info.latitude_second[1]=1;
+            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
+
+            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
+                //the ref is south
+                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
+            }
 
-    params.getPictureSize(&w, &h);
-    if (!validateSize(w, h)) {
-        LOGE("Picture size not supported");
-        return -1;
-    }
+            //longtitude: dd/1,mm/1,ss/1
+            gps_info.longtitude_degree[1]=1;
+            gps_info.longtitude_minute[1]=1;
+            gps_info.longtitude_second[1]=1;
+            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
 
-    framerate = params.getPreviewFrameRate();
+            if (stringTodegree(cLatitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
+                //the ref is Weston
+                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
+            }
 
-    mParameters = params;
+            //altitude(meters): aa/1
+            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
+            gps_info.altitude[0]=1000;
+            gps_info.altitude[1]=1;
+            if (cAltitude != NULL){
+                int intValue;
+                gps_info.altitude[1]=1000;	   // the precision is CM
+                dAltitude= atof(cAltitude);
+                CAMERA_HAL_LOG_RUNTIME("the altitude is %s", cAltitude);
+                intValue = (int)(dAltitude * 1000.0);
+                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
+                gps_info.altitude[0] = (unsigned long) intValue;
+                CAMERA_HAL_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
+            }
 
-    mParameters.getPreviewSize(&mRecordWidth, &mRecordHeight);
-    LOGD("mRecordWidth %d, mRecordHeight %d\n", mRecordWidth, mRecordHeight);
+            //timestamp: hh/1,mm/1,ss/1
+            gps_info.hour[1]=1;
+            gps_info.minute[1]=1;
+            gps_info.seconds[1]=1;
+            if (cTimeStamp != NULL){
+
+                GpsUtcTime = atol(cTimeStamp);
+                CAMERA_HAL_LOG_INFO("the Timestamp is %s", cTimeStamp);
+                temp_tm = gmtime((const time_t*)&GpsUtcTime);
+                if (temp_tm != NULL)
+                    tm = temp_tm;
+            }
 
-    mParameters.getPictureSize(&mPictureWidth, &mPictureHeight);
-    LOGD("mPictureWidth %d, mPictureHeight %d\n", mPictureWidth, mPictureHeight);
+            gps_info.hour[0] = tm->tm_hour;
+            gps_info.minute[0] = tm->tm_min;
+            gps_info.seconds[0] = tm->tm_sec;
 
-    if (!mPictureWidth || !mPictureHeight) {
-        /* This is a hack. MMS APP is not setting the resolution correctly. So hardcoding it. */
-        mParameters.setPictureSize(PICTURE_WIDTH, PICTURE_HEIGHT);
-        mParameters.getPictureSize(&mPictureWidth, &mPictureHeight);
-    }
+            strcpy (format, "%Y:%m:%d ");
 
-    return NO_ERROR;
-}
 
-CameraParameters CameraHal::getParameters() const
-{
-    LOG_FUNCTION_NAME
+            strftime((char *)temp_string, strlen(temp_string), format, tm);
+            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
 
-    Mutex::Autolock lock(mLock);
-    return mParameters;
-}
 
-status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
-                                         int32_t arg2)
-{
-    return BAD_VALUE;
-}
+            char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
+            if (progressMehod == NULL){
+                CAMERA_HAL_LOG_INFO("The progressMethod is NULL, add a fake");
+                progressMehod = (char *)"fsl_fake_method";
+            }
+            CAMERA_HAL_LOG_INFO("the progressMethod is %s", progressMehod);
 
-void CameraHal::release()
-{
-    LOG_FUNCTION_NAME
+            memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
 
-    cameraClose();
-}
+            gps_info.processmethod_bytes=strlen(progressMehod);
 
+            CAMERA_HAL_LOG_INFO("the method is %s", gps_info.processmethod);
 
-sp<CameraHardwareInterface> CameraHal::createInstance()
-{
-    LOG_FUNCTION_NAME
+            mJpegEncCfg.pGps_info = &gps_info;
+        }else{
+            mJpegEncCfg.pGps_info = NULL;
+        }
 
-    if (singleton != 0) {
-        sp<CameraHardwareInterface> hardware = singleton.promote();
-        if (hardware != 0) {
-            return hardware;
+        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
+            CAMERA_HAL_ERR("Jpeg Encoder Init error !!!");
+            return UNKNOWN_ERROR;
         }
-    }
 
-    sp<CameraHardwareInterface> hardware(new CameraHal());
+        return ret;
+    }
+    status_t CameraHal::CameraHALStartPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+
+        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
+        mPPbufNum = POST_PROCESS_BUFFER_NUM;
+        mTakePicFlag = false;
+
+        if ((ret = PrepareCaptureDevices()) < 0)
+            return ret;
+        if (mPPDeviceNeed){
+            if ((ret = PreparePostProssDevice()) < 0)
+                return ret;
+        }
+        if ((ret = PreparePreviwBuf()) < 0)
+            return ret;
 
-    singleton = hardware;
-    return hardware;
-}
+        if ((ret = PreparePreviwMisc()) < 0)
+            return ret;
 
-#ifdef USE_FSL_JPEG_ENC
-JPEG_ENC_UINT8 CameraHal::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
-    JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
-{
-    JPEG_ENC_UINT32 i;
-    if(*out_buf_ptrptr == NULL)
+        if ((ret = CameraHALPreviewStart()) < 0)
+            return ret;
+        return ret;
+    }
+    void CameraHal::CameraHALStopPreview()
     {
-        /* This function is called for the 1'st time from the
-         * codec */
-        *out_buf_ptrptr = g_JpegData;
-        *out_buf_len_ptr = g_JpegDataSize;
+        CAMERA_HAL_LOG_FUNC;
+        if (mPreviewRunning != 0)	{
+            CameraHALStopThreads();
+            CameraHALStopMisc();
+        }
+        return ;
     }
 
-    else if(flush == 1)
+    void CameraHal :: CameraHALStopThreads()
     {
-        /* Flush the buffer*/
-        g_JpegDataLen += *out_buf_len_ptr;
-        LOGI("jpeg output data len %d",(int)g_JpegDataLen);
+        CAMERA_HAL_LOG_FUNC;
+        mPreviewRunning = 0;
+        if (mCaptureFrameThread!= 0){
+            mCaptureFrameThread->requestExitAndWait();
+            mCaptureFrameThread.clear();
+        }
+        if (mPPDeviceNeed){
+            if (mPostProcessThread!= 0){
+                mPostProcessThread->requestExitAndWait();
+                mPostProcessThread.clear();
+            }
+        }
+        if (mPreviewShowFrameThread!= 0){
+            mPreviewShowFrameThread->requestExitAndWait();
+            mPreviewShowFrameThread.clear();
+        }
 
-        *out_buf_ptrptr = NULL;
-        *out_buf_len_ptr = NULL;
-    }
-    else
-    {
-        LOGI("Not enough buffer for encoding");
-        return 0;
+        if (mEncodeFrameThread!= 0){
+            mEncodeFrameThread->requestExitAndWait();
+            mEncodeFrameThread.clear();
+        }
+        return ;
     }
 
-    return(1); /* Success */
-}
-
-#if 1//support Exif format
+    void CameraHal :: CameraHALStopMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        sem_destroy(&avab_dequeue_frame);
+        sem_destroy(&avab_show_frame);
+        sem_destroy(&avab_enc_frame);
+        sem_destroy(&avab_enc_frame_finish);
+        if(mPPDeviceNeed){
+            sem_destroy(&avab_pp_in_frame);
+            sem_destroy(&avab_pp_out_frame);
+        }
+        if(mPPDeviceNeed){
+            for (unsigned int i = 0; i < mPPbufNum; i++){
+                mPmemAllocator->deAllocate(&mPPbuf[i]);
+            }
+            mPmemAllocator = NULL;
+        }
+        mCaptureDevice->DevStop();
+        mCaptureDevice->DevDeAllocate();
+        CloseCaptureDevice();
 
-int CameraHal::stringTodegree(char* cAttribute, unsigned long &degree, unsigned long &minute, unsigned long &second)
-{
-    double dAttribtute;
-    long intAttribute;
-    int ret  = 0;
-    if (cAttribute == NULL){
-        return -1;
     }
+    status_t CameraHal :: PrepareCaptureDevices()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int i =0;
+        unsigned int CaptureBufNum = mCaptureBufNum;
+        struct capture_config_t *pCapcfg;
+        if ((ret = OpenCaptureDevice())<0)
+            return ret;
+
+        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) //set the config and get the captured framesize
+            return BAD_VALUE;
+        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
+
+        if (mCaptureDevice->DevAllocateBuf(mCaptureBuffers,&CaptureBufNum)< 0)
+            return BAD_VALUE;
+
+        if(mCaptureBufNum != CaptureBufNum){
+            CAMERA_HAL_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
+        }
 
-    LOGD("the attribute is %s", cAttribute);
+        mCaptureBufNum = CaptureBufNum;
 
-    dAttribtute = atof(cAttribute);
+        if (mCaptureDevice->DevPrepare()< 0)
+            return BAD_VALUE;
+        nCameraBuffersQueued = mCaptureBufNum;
 
-    LOGD("the double of the attribute is %lf", dAttribtute);
-    intAttribute  = (long)(dAttribtute*(double)3600.0);
-    if (intAttribute < 0){
-        ret = 1;
-        intAttribute *=-1;
+        return ret;
     }
 
-    second = (unsigned long)(intAttribute%60);
-    minute = (unsigned long)((intAttribute%3600-second)/60);
-    degree = (unsigned long)(intAttribute/3600);
+    status_t CameraHal::PreparePostProssDevice()
+    {
 
-    LOGD("the degree is %lu, %lu, %lu", degree,minute,second);
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        pthread_mutex_lock(&mPPIOParamMutex);
 
-    return ret;
+        mPPInputParam.width = mCaptureDeviceCfg.width;
+        mPPInputParam.height= mCaptureDeviceCfg.height;
+        mPPInputParam.fmt   = mCaptureDeviceCfg.fmt;
+        mPPInputParam.input_crop_win.pos.x = 0;
+        mPPInputParam.input_crop_win.pos.y = 0;
+        mPPInputParam.input_crop_win.win_w = mCaptureDeviceCfg.width;
+        mPPInputParam.input_crop_win.win_h = mCaptureDeviceCfg.height;
 
-}
+        mPPOutputParam.width = mCaptureDeviceCfg.width;
+        mPPOutputParam.height= mCaptureDeviceCfg.height;
+        mPPOutputParam.fmt   = mPreviewFormat;
+        mPPOutputParam.rot   = 0;
+        mPPOutputParam.output_win.pos.x = 0;
+        mPPOutputParam.output_win.pos.y = 0;
+        mPPOutputParam.output_win.win_w = mCaptureDeviceCfg.width;
+        mPPOutputParam.output_win.win_h = mCaptureDeviceCfg.height;
 
-void CameraHal::createJpegExifTags(jpeg_enc_object * obj_ptr)
-{
-	jpeg_enc_make_info make_info;
-    jpeg_enc_makernote_info makernote_info;
-    jpeg_enc_model_info model_info;
-    jpeg_enc_datetime_info datetime_info;
-    jpeg_enc_focallength_info focallength_info;
-    jpeg_enc_gps_info gps_info;
-    char temp_string[30], gps_datetime_string[11];
+        pthread_mutex_unlock(&mPPIOParamMutex);
+        return ret;
+    }
 
-    char format[30] = "%Y:%m:%d %k:%M:%S";
-    time_t clock;
-    struct tm *tm, *temp_tm;
-    char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
-    double dAltitude;
-    //set the make info
-    make_info.make_bytes=strlen(EXIF_MAKENOTE);
-    strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
-    //set makernote info
-    makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
-    strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
-    //set model info
-    model_info.model_bytes=strlen(EXIF_MODEL);
-    strcpy((char *)model_info.model,EXIF_MODEL);
-    //set datetime
-    time(&clock);
-    tm = localtime(&clock);
-    time_t GpsUtcTime;
-    strftime(temp_string, sizeof(temp_string), format, tm);
-    LOGD("the date time is %s", temp_string);
-    memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
-
-    //set focallength info
-    focallength_info.numerator=10001;
-    focallength_info.denominator=1000;  // hardcode here for the cts
-
-	jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(&makernote_info));
-    jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(&makernote_info));
-    jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(&model_info));
-    jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(&datetime_info));
-    jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(&focallength_info));
-
-    //set gps info
-    cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
-    cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
-    cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
-    cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
+    status_t CameraHal::PreparePreviwBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int i =0;
+
+        //temply hard code here
+        if (mTakePicFlag == 0){
+            if(V4L2_PIX_FMT_NV12)
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
+            else 
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
+
+            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
+            mPreviewHeap.clear();
+            for (i = 0; i< mPreviewHeapBufNum; i++)
+                mPreviewBuffers[i].clear();
+            mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
+            if (mPreviewHeap == NULL)
+                return NO_MEMORY;
+            for (i = 0; i < mPreviewHeapBufNum; i++)
+                mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
+        }
+        /*allocate the buffer for IPU process*/
+        if (mPPDeviceNeed){
+            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
 
-    if(cLatitude==NULL || cLatitude==NULL || cAltitude==NULL || cTimeStamp==NULL){
-        LOGD("NO GPS info is set");
-        return;
+            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
+                return NO_MEMORY;
+            }
+            for (i = 0; i < mPPbufNum; i++){
+                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
+                    return NO_MEMORY;
+                }
+            }
+        }
+        return ret;
     }
 
-    gps_info.version=0x02020000;
+    status_t CameraHal ::PreparePreviwMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        dequeue_head = 0;
+        preview_heap_buf_head = 0;
+        display_head = 0;
+        enc_head     = 0;
+        pp_in_head   = 0;
+        pp_out_head  = 0;
+        error_status = 0;
+        is_first_buffer = 1;
+        last_display_index = 0;
+
+        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
+        sem_init(&avab_show_frame, 0, 0);
+        sem_init(&avab_enc_frame, 0, 0);
+        sem_init(&avab_enc_frame_finish, 0, 0);
+        if(mPPDeviceNeed){
+            sem_init(&avab_pp_in_frame, 0, 0);
+            sem_init(&avab_pp_out_frame, 0, mPPbufNum);
+        }
+        return ret;
+    }
 
+    status_t CameraHal ::CameraHALPreviewStart()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDevice->DevStart()<0)
+            return INVALID_OPERATION;
+
+        mCaptureFrameThread = new CaptureFrameThread(this);
+        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
+        mEncodeFrameThread = new EncodeFrameThread(this);
+        if(mPPDeviceNeed){
+            mPostProcessThread = new PostProcessThread(this);
+            if (mPostProcessThread == NULL)
+                return UNKNOWN_ERROR;
+        }
 
-    //latitude: dd/1,mm/1,ss/1
-    gps_info.latitude_degree[0]=100;
-    gps_info.latitude_degree[1]=1;
-    gps_info.latitude_minute[0]=101;
-    gps_info.latitude_minute[1]=1;
-    gps_info.latitude_second[0]=102;
-    gps_info.latitude_second[1]=1;
-    memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
+        if (mCaptureFrameThread == NULL ||
+                mPreviewShowFrameThread == NULL ||
+                mEncodeFrameThread == NULL){
+            return UNKNOWN_ERROR;
+        }
 
-    if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
-        //the ref is south
-        memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
+        mPreviewRunning = true;
+        return ret;
     }
 
-    //longtitude: dd/1,mm/1,ss/1
-    gps_info.longtitude_degree[0]=200;
-    gps_info.longtitude_degree[1]=1;
-    gps_info.longtitude_minute[0]=201;
-    gps_info.longtitude_minute[1]=1;
-    gps_info.longtitude_second[0]=202;
-    gps_info.longtitude_second[1]=1;
-    memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
 
-    if (stringTodegree(cLatitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
-        //the ref is Weston
-        memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
-    }
+    int CameraHal ::captureframeThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
 
-    //altitude(meters): aa/1
-    gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
-    gps_info.altitude[0]=1000;
-    gps_info.altitude[1]=1;
-    if (cAltitude != NULL){
-        int intValue;
-        gps_info.altitude[1]=1000;     // the precision is CM
-        dAltitude= atof(cAltitude);
-        LOGD("the altitude is %s", cAltitude);
-        intValue = (int)(dAltitude * 1000.0);
-        if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
-        gps_info.altitude[0] = (unsigned long) intValue;
-        LOGD("gps_info.altitude[0] is %lu, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
-    }
+        unsigned int DeqBufIdx = 0;
+        struct timespec ts;
 
-    //timestamp: hh/1,mm/1,ss/1
-    gps_info.hour[1]=1;
-    gps_info.minute[1]=1;
-    gps_info.seconds[1]=1;
-    if (cTimeStamp != NULL){
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_dequeue_frame, &ts) != 0) );
 
-        GpsUtcTime = atol(cTimeStamp);
-        LOGD("the Timestamp is %s", cTimeStamp);
-        temp_tm = gmtime((const time_t*)&GpsUtcTime);
-        if (temp_tm != NULL)
-            tm = temp_tm;
-    }
+        if(!mPreviewRunning || error_status)
+            return UNKNOWN_ERROR;
 
-    gps_info.hour[0] = tm->tm_hour;
-    gps_info.minute[0] = tm->tm_min;
-    gps_info.seconds[0] = tm->tm_sec;
+        mCaptureDevice->DevDequeue(&DeqBufIdx);
 
-    strcpy (format, "%Y:%m:%d ");
+        nCameraBuffersQueued--;
 
-    strftime((char *)temp_string, strlen(temp_string), format, tm);
-    memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
+        buffer_index_maps[dequeue_head]=DeqBufIdx;
+        dequeue_head ++;
+        dequeue_head %= mCaptureBufNum;
 
+        if(!mPPDeviceNeed){
+            sem_post(&avab_show_frame);
+            sem_post(&avab_enc_frame);
+        }else{
+            sem_post(&avab_pp_in_frame);
+        }
 
-    char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
-    if (progressMehod == NULL){
-        LOGD("The progressMethod is NULL, add a fake");
-        progressMehod = (char *)"fsl_fake_method";
+        return NO_ERROR;
     }
-	LOGD("the progressMethod is %s", progressMehod);
 
-    memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
+    int CameraHal::postprocessThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int PPInIdx = 0, PPoutIdx = 0;
+        pp_input_param_t pp_input;
+        pp_output_param_t pp_output;
+        DMA_BUFFER PPInBuf, PPoutBuf;
+        struct timespec ts;
 
-	gps_info.processmethod_bytes=strlen(progressMehod);
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_in_frame, &ts) != 0) );
 
-	LOGD("the method is %s", gps_info.processmethod);
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_out_frame, &ts) != 0) );
+
+
+        if(!mPreviewRunning || error_status)
+            return UNKNOWN_ERROR;
+        PPInIdx = buffer_index_maps[pp_in_head];
+        PPInBuf = mCaptureBuffers[PPInIdx];
+        pp_in_head ++;
+        pp_in_head %= mCaptureBufNum;
+
+        PPoutIdx = pp_out_head;
+        PPoutBuf = mPPbuf[PPoutIdx];
+        pp_out_head ++;
+        pp_out_head %= mPPbufNum;
+
+        pthread_mutex_lock(&mPPIOParamMutex);
+        mPPInputParam.user_def_paddr = PPInBuf.phy_offset;
+        mPPOutputParam.user_def_paddr = PPoutBuf.phy_offset;
+        mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+        mPPDevice->DoPorcess(&PPInBuf, &PPoutBuf);
+        mPPDevice->PPDeviceDeInit();
+        pthread_mutex_unlock(&mPPIOParamMutex);
+
+        sem_post(&avab_show_frame);
+        sem_post(&avab_enc_frame);
+
+        if (mCaptureDevice->DevQueue(PPInIdx) < 0){
+            CAMERA_HAL_ERR("queue buf back error");
+            return INVALID_OPERATION;
+        }
+        nCameraBuffersQueued ++;
+        sem_post(&avab_dequeue_frame);
 
-    jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(&gps_info));
+        return NO_ERROR;
+    }
+    int CameraHal ::previewshowFrameThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timespec ts;
+        int display_index = 0;
+        DMA_BUFFER InBuf;
+        int queue_back_index = 0;
 
-    return;
-}
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while (!error_status && mPreviewRunning &&(sem_timedwait(&avab_show_frame, &ts) != 0) );
 
-static int yuv_resize(char *dst_ptr, int dst_width, int dst_height, char *src_ptr, int src_width, int src_height)
-{
-    int i,j,s;
-    int h_offset;
-    int v_offset;
-    char *ptr,cc;
-    int h_scale_ratio;
-    int v_scale_ratio;
+        if ((mPreviewRunning == 0) || error_status)
+            return UNKNOWN_ERROR;
+
+        if (!mPPDeviceNeed){
+            display_index = buffer_index_maps[display_head];
+            InBuf = mCaptureBuffers[display_index];
+            display_head ++;
+            display_head %= mCaptureBufNum;
+        }else{
+            display_index = display_head;
+            InBuf = mPPbuf[display_index];
+            display_head ++;
+            display_head %= mPPbufNum;
+        }
 
-    s = 0;
+        if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+            convertNV12toYUV420SP((uint8_t*)(InBuf.virt_start),
+                    (uint8_t*)(mPreviewBuffers[preview_heap_buf_head]->pointer()),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+            mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewBuffers[preview_heap_buf_head], mCallbackCookie);
+            preview_heap_buf_head ++;
+            preview_heap_buf_head %= mPreviewHeapBufNum;
+        }
 
-_resize_begin:
+        pthread_mutex_lock(&mOverlayMutex);
 
-    if(!dst_width) return -1;
-    if(!dst_height) return -1;
+        if (mOverlay != 0) {
+            if (mOverlay->queueBuffer((overlay_buffer_t)InBuf.phy_offset) < 0){
+                CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
+            }
 
-    h_scale_ratio = src_width / dst_width;
-    if(!h_scale_ratio) return -1;
+            if (is_first_buffer) {
+                is_first_buffer = 0;
+                last_display_index = display_index;
+                pthread_mutex_unlock(&mOverlayMutex);
+                goto show_out;
+            }
+        }
 
-    v_scale_ratio = src_height / dst_height;
-    if(!v_scale_ratio) return -1;
+        if (!mPPDeviceNeed){
+            if (mOverlay != 0){
+                queue_back_index = last_display_index;
+            }else{
+                queue_back_index = display_index;
+            }
+        }
+        pthread_mutex_unlock(&mOverlayMutex);
 
-    h_offset = (src_width - dst_width * h_scale_ratio) / 2;
-    v_offset = (src_height - dst_height * v_scale_ratio) / 2;
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=200000; // 100ms
+        } while ((sem_timedwait(&avab_enc_frame_finish, &ts) != 0)&&!error_status && mPreviewRunning );
+
+        if (!mPPDeviceNeed){
+            //queue the v4l2 buf back
+            if(mCaptureDevice->DevQueue(queue_back_index) <0){
+                CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
+                return INVALID_OPERATION;
+            }
+            last_display_index = display_index;
+            nCameraBuffersQueued++;
+            sem_post(&avab_dequeue_frame);
+        }else{
+            sem_post(&avab_pp_out_frame);
+        }
 
-    for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
-    {
-        for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
-        {
-            ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
-            cc = ptr[0];
+show_out:
 
-            ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
-            ptr[0] = cc;
-        }
+        return NO_ERROR;
     }
 
-    src_ptr += src_width*src_height;
-    dst_ptr += dst_width*dst_height;
-
-    if(s < 2)
+    int CameraHal :: encodeframeThread()
     {
-        if(!s++)
-        {
-            src_width >>= 1;
-            src_height >>= 1;
+        CAMERA_HAL_LOG_FUNC;
+        struct timespec ts;
+        unsigned int enc_index = 0, i = 0;
+        DMA_BUFFER EncBuf;
+
+        do {
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_nsec +=100000; // 100ms
+        } while ((sem_timedwait(&avab_enc_frame, &ts) != 0) && !error_status &&  mPreviewRunning );
 
-            dst_width >>= 1;
-            dst_height >>= 1;
+        if ((mPreviewRunning == 0) || error_status)
+            return UNKNOWN_ERROR;
+
+        if (!mPPDeviceNeed){
+            enc_index = buffer_index_maps[enc_head];
+            EncBuf = mCaptureBuffers[enc_index];
+            enc_head ++;
+            enc_head %= mCaptureBufNum;
+        }else{
+            enc_index = enc_head;
+            EncBuf = mPPbuf[enc_index];
+            enc_head ++;
+            enc_head %= mPPbufNum;
         }
 
-        goto _resize_begin;
-    }
+        if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
+            nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
+            for(i = 0 ; i < mVideoBufNume; i ++) {
+                if(mVideoBufferUsing[i] == 0) {
+                    memcpy(mVideoBuffers[i]->pointer(),
+                            (void*)EncBuf.virt_start, mPreviewFrameSize);
 
-    return 0;
-}
+                    mVideoBufferUsing[i] = 1;
+                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoBuffers[i], mCallbackCookie);
+                    break;
+                }
+            }
+            if (i == mVideoBufNume)
+                CAMERA_HAL_LOG_INFO("no Buffer can be used for record\n");
+        }
 
-sp<MemoryBase> CameraHal::encodeImage(void *buffer, uint32_t bufflen)
-{
-    int width, height, size,index;
-    JPEG_ENC_UINT8 * i_buff = NULL;
-    JPEG_ENC_UINT8 * y_buff = NULL;
-    JPEG_ENC_UINT8 * u_buff = NULL;
-    JPEG_ENC_UINT8 * v_buff = NULL;
-    JPEG_ENC_RET_TYPE return_val;
-    jpeg_enc_parameters * params = NULL;
-    jpeg_enc_object * obj_ptr = NULL;
-    JPEG_ENC_UINT8 number_mem_info;
-    jpeg_enc_memory_info * mem_info = NULL;
-    sp<MemoryBase> jpegPtr = NULL;
-    void *thumbnail_buffer,*temp_buffer=NULL;
-    int thumbnail_width, thumbnail_height;
+        sem_post(&avab_enc_frame_finish);
+        return NO_ERROR;
 
-    bool mEncodeThumbnailFlag = true;
+    }
 
-    mParameters.getPictureSize(&width, &height);
 
-    thumbnail_width = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
-    thumbnail_height = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
+    status_t CameraHal :: AllocateRecordVideoBuf()
+    {
+        status_t ret = NO_ERROR;
+        unsigned int i = 0;
+        mVideoHeap.clear();
+        for(i = 0; i < mVideoBufNume; i++) {
+            mVideoBuffers[i].clear();
+            mVideoBufferUsing[i] = 0;
+        }
 
-    LOGD("the thumbnail is %d, %d", thumbnail_width, thumbnail_height);
+        CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
+        mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
+        if (mVideoHeap == NULL)
+            return NO_MEMORY;
+        for(i = 0; i < mVideoBufNume; i++) {
+            CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
+            mVideoBuffers[i] = new MemoryBase(mVideoHeap,
+                    mPreviewFrameSize * i, mPreviewFrameSize);
+        }
+
+        return ret;
+    }
 
-    if (thumbnail_width <= 0 || thumbnail_width <= 0)
-        mEncodeThumbnailFlag = false;
 
-    if((width== 0)||(height == 0)|!buffer||(bufflen == 0))
+    void CameraHal :: LockWakeLock()
     {
-        LOGI("Error!Invalid parameters");
-        return NULL;
+        if (!mPowerLock) {
+            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
+            mPowerLock = true;
+        }
     }
-    g_JpegDataSize = 0;//Total size of g_JpegData
-    g_JpegDataLen = 0;//Valid data len of g_JpegData
-    g_JpegData = NULL;//Buffer to hold jpeg data
-    size = width * height * 3 / 2;
-    LOGI("CameraHal::encodeImage:buffer 0x%x, bufflen %d,width %d,height %d",
-            (unsigned int)buffer,bufflen,width,height);
-    sp<MemoryHeapBase> mJpegImageHeap = new MemoryHeapBase(size);
-
-    g_JpegData = (JPEG_ENC_UINT8 *)(mJpegImageHeap->getBase());
-    g_JpegDataSize = size;
-    if(!g_JpegData)
+    void CameraHal :: UnLockWakeLock()
     {
-        LOGI("Cannot allocate jpeg data");
-        return NULL;
+        if (mPowerLock) {
+            release_wake_lock (V4LSTREAM_WAKE_LOCK);
+            mPowerLock = false;
+        }
     }
 
-    /* --------------------------------------------
-     * Allocate memory for Encoder Object
-     * -------------------------------------------*/
-    obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
-    if(!obj_ptr)
+    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
     {
-        LOGE("Error!Cannot allocate enc obj");
-        return NULL;
+        /* Color space conversion from I420 to YUV420SP */
+        int Ysize = 0, UVsize = 0;
+        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
+
+        Ysize = width * height;
+        UVsize = width *  height >> 2;
+
+        Yin = inputBuffer;
+        Uin = Yin + Ysize;
+        Vin = Uin + 1;
+
+        Yout = outputBuffer;
+        Vout = Yout + Ysize;
+        Uout = Vout + 1;
+
+        memcpy(Yout, Yin, Ysize);
+
+        for(int k = 0; k < UVsize; k++) {
+            *Uout = *Uin;
+            *Vout = *Vin;
+            Uout += 2;
+            Vout += 2;
+            Uin  += 2;
+            Vin += 2;
+        }
     }
-    memset(obj_ptr, 0, sizeof(jpeg_enc_object));
 
-    /* Assign the function for streaming output */
-    obj_ptr->jpeg_enc_push_output = pushJpegOutput;
-    obj_ptr->context=NULL;   //user can put private variables into it
-    /* --------------------------------------------
-     * Fill up the parameter structure of JPEG Encoder
-     * -------------------------------------------*/
-    params = &(obj_ptr->parameters);
 
-    if(mEncodeThumbnailFlag==true)
-    {
 
-        //need resizing code here!!!
-        thumbnail_buffer = (char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
-        if(!thumbnail_buffer)
-        {
-            LOGE("Error!Cannot allocate thumbnail buff");
-            return NULL;
+    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
+    {
+        double dAttribtute;
+        long intAttribute;
+        int ret  = 0;
+        if (cAttribute == NULL){
+            return -1;
         }
 
-        yuv_resize((char *)thumbnail_buffer, thumbnail_width, thumbnail_height, (char *)buffer, width, height);
-
-        width = thumbnail_width;
-        height = thumbnail_height;
-
-        temp_buffer = buffer;
-        buffer = thumbnail_buffer;
-
-        params->mode = JPEG_ENC_THUMB;
-    }
-    else
-    {
-        params->mode = JPEG_ENC_MAIN_ONLY;
-    }
-
-encodeframe:
-
-    params->compression_method = JPEG_ENC_SEQUENTIAL;
-    params->quality = 75;
-    params->restart_markers = 0;
-    params->y_width = width;
-    params->y_height = height;
-    params->u_width = params->y_width/2;
-    params->u_height = params->y_height/2;
-    params->v_width = params->y_width/2;
-    params->v_height = params->y_height/2;
-    params->primary_image_height = height;
-    params->primary_image_width = width;
-    params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
-    params->exif_flag = 1;
-
-    params->y_left = 0;
-    params->y_top = 0;
-    params->y_total_width = 0;
-    params->y_total_height = 0;
-    params->raw_dat_flag= 0;
-
-    if(params->y_total_width==0)
-    {
-        params->y_left=0;
-        params->u_left=0;
-        params->v_left=0;
-        params->y_total_width=params->y_width;  // no cropping
-        params->u_total_width=params->u_width;  // no cropping
-        params->v_total_width=params->v_width;  // no cropping
-    }
-
-    if(params->y_total_height==0)
-    {
-        params->y_top=0;
-        params->u_top=0;
-        params->v_top=0;
-        params->y_total_height=params->y_height; // no cropping
-        params->u_total_height=params->u_height; // no cropping
-        params->v_total_height=params->v_height; // no cropping
-    }
-
-    /* Pixel size is unknown by default */
-    params->jfif_params.density_unit = 0;
-    /* Pixel aspect ratio is square by default */
-    params->jfif_params.X_density = 1;
-    params->jfif_params.Y_density = 1;
-
-    y_buff = (JPEG_ENC_UINT8 *)buffer;
-    u_buff = y_buff+width*height;
-    v_buff = u_buff+width*height/4;
-    i_buff = NULL;
-    LOGI("version: %s\n", jpege_CodecVersionInfo());
-
-    /* --------------------------------------------
-     * QUERY MEMORY REQUIREMENTS
-     * -------------------------------------------*/
-    return_val = jpeg_enc_query_mem_req(obj_ptr);
-
-    if(return_val != JPEG_ENC_ERR_NO_ERROR)
-    {
-        LOGI("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
-    }
-    LOGI("jpeg_enc_query_mem_req success");
-    /* --------------------------------------------
-     * ALLOCATE MEMORY REQUESTED BY CODEC
-     * -------------------------------------------*/
-    number_mem_info = obj_ptr->mem_infos.no_entries;
-    for(index = 0; index < number_mem_info; index++)
-    {
-        /* This example code ignores the 'alignment' and
-         * 'memory_type', but some other applications might want
-         * to allocate memory based on them */
-        mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-        mem_info->memptr = (void *) malloc(mem_info->size);
-        if(mem_info->memptr==NULL) {
-            LOGI("Malloc error after query\n");
-            goto done;
-        }
-    }
+        CAMERA_HAL_LOG_RUNTIME("the attribute is %s", cAttribute);
 
-    return_val = jpeg_enc_init(obj_ptr);
-    if(return_val != JPEG_ENC_ERR_NO_ERROR)
-    {
-        LOGI("JPEG encoder returned an error when jpeg_enc_init was called \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
-    }
+        dAttribtute = atof(cAttribute);
 
-    LOGI("jpeg_enc_init success");
+        CAMERA_HAL_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
+        intAttribute  = (long)(dAttribtute*(double)3600.0);
+        if (intAttribute < 0){
+            ret = 1;
+            intAttribute *=-1;
+        }
 
-    createJpegExifTags(obj_ptr);
+        second = (unsigned int)(intAttribute%60);
+        minute = (unsigned int)((intAttribute%3600-second)/60);
+        degree = (unsigned int)(intAttribute/3600);
 
-    return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
-            y_buff, u_buff, v_buff);
+        CAMERA_HAL_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
+
+        return ret;
 
-    if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
-    {
-        LOGI("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
     }
 
-    if(params->mode == JPEG_ENC_THUMB)
+
+#define FACE_BACK_CAMERA_NAME "back_camera_name"
+#define FACE_FRONT_CAMERA_NAME "front_camera_name"
+#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
+#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
+#define DEFAULT_ERROR_NAME '#'
+#define DEFAULT_ERROR_NAME_str "#"
+#define UVC_NAME "uvc"
+#define MAX_SENSOR_NAME 10
+    static CameraInfo sCameraInfo[2];
+    static char Camera_name[2][MAX_SENSOR_NAME];
+
+    static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
     {
-        JPEG_ENC_UINT8 num_entries;
-        JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
-        JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
+        char orientStr[10];
 
-        jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
+        property_get (FACE_BACK_CAMERA_NAME,
+                pFaceBackCameraName,
+                DEFAULT_ERROR_NAME_str );
+        property_get (FACE_BACK_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
 
-        for(int i = 0; i < num_entries; i++)
-        {
-            *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
-        }
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceBackOrient = 0;
+        else 
+            *pFaceBackOrient = atoi(orientStr);
 
-        free(offset_tbl_ptr);
-        free(value_tbl_ptr);
+        LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
 
-        free(buffer);
-        buffer = temp_buffer;
-        mParameters.getPictureSize(&width, &height);
+        property_get (FACE_FRONT_CAMERA_NAME,
+                pFaceFrontCameraName,
+                DEFAULT_ERROR_NAME_str );
 
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            if(mem_info)
-                free(mem_info->memptr);
-        }
+        property_get (FACE_FRONT_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
 
-        g_JpegData += g_JpegDataLen;
-        g_JpegDataSize -= g_JpegDataLen;
 
-        params->mode = JPEG_ENC_MAIN;
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceFrontOrient = 0;
+        else 
+            *pFaceFrontOrient = atoi(orientStr);
 
-        goto encodeframe;
-    }
-    LOGI("jpeg_enc_encodeframe success");
-    // Make an IMemory for each frame
-    jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
+        LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
 
-done:
-    /* --------------------------------------------
-     * FREE MEMORY REQUESTED BY CODEC
-     * -------------------------------------------*/
-    if(obj_ptr)
-    {
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            if(mem_info)
-                free(mem_info->memptr);
-        }
-        free(obj_ptr);
-    }
-    return jpegPtr;
-}
-
-#else
-
-sp<MemoryBase> CameraHal::encodeImage(void *buffer, uint32_t bufflen)
-{
-    int width, height, size,index;
-    JPEG_ENC_UINT8 * i_buff = NULL;
-    JPEG_ENC_UINT8 * y_buff = NULL;
-    JPEG_ENC_UINT8 * u_buff = NULL;
-    JPEG_ENC_UINT8 * v_buff = NULL;
-    JPEG_ENC_RET_TYPE return_val;
-    jpeg_enc_parameters * params = NULL;
-    jpeg_enc_object * obj_ptr = NULL;
-    JPEG_ENC_UINT8 number_mem_info;
-    jpeg_enc_memory_info * mem_info = NULL;
-    sp<MemoryBase> jpegPtr = NULL;
-    
-    mParameters.getPictureSize(&width, &height);    
-
-    if((width== 0)||(height == 0)|!buffer||(bufflen == 0))
-    {
-        LOGI("Error!Invalid parameters");
-        return NULL;
     }
-    g_JpegDataSize = 0;//Total size of g_JpegData
-    g_JpegDataLen = 0;//Valid data len of g_JpegData
-    g_JpegData = NULL;//Buffer to hold jpeg data
-    size = width * height * 3 / 2;
-    LOGI("CameraHal::encodeImage:buffer 0x%x, bufflen %d,width %d,height %d",
-         (unsigned int)buffer,bufflen,width,height);
-    sp<MemoryHeapBase> mJpegImageHeap = new MemoryHeapBase(size);
 
-    g_JpegData = (JPEG_ENC_UINT8 *)(mJpegImageHeap->getBase());
-    g_JpegDataSize = size;
-    if(!g_JpegData)
+    int HAL_getNumberOfCameras()
     {
-        LOGI("Cannot allocate jpeg data");
-        return NULL;
-    }
-        
-    /* --------------------------------------------
-     * Allocate memory for Encoder Object
-     * -------------------------------------------*/
-    obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
-    if(!obj_ptr)
-    {
-        LOGE("Error!Cannot allocate enc obj");
-        return NULL;
-    }
-    memset(obj_ptr, 0, sizeof(jpeg_enc_object));
-    
-    /* Assign the function for streaming output */
-    obj_ptr->jpeg_enc_push_output = pushJpegOutput;
-    obj_ptr->context=NULL;   //user can put private variables into it
-    /* --------------------------------------------
-     * Fill up the parameter structure of JPEG Encoder
-     * -------------------------------------------*/
-    params = &(obj_ptr->parameters);
-
-    params->compression_method = JPEG_ENC_SEQUENTIAL;
-    params->mode = JPEG_ENC_MAIN_ONLY;
-    params->quality = 75;
-    params->restart_markers = 0;
-    params->y_width = width;
-    params->y_height = height;
-    params->u_width = params->y_width/2;
-    params->u_height = params->y_height/2;
-    params->v_width = params->y_width/2;
-    params->v_height = params->y_height/2;
-    params->primary_image_height = height;
-    params->primary_image_width = width;
-    params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
-    params->exif_flag = 0;
-
-    params->y_left = 0;
-    params->y_top = 0;
-    params->y_total_width = 0;
-    params->y_total_height = 0;
-    params->raw_dat_flag= 0;	
-
-    if(params->y_total_width==0)
-    {
-         params->y_left=0;
-	  params->u_left=0;
-	  params->v_left=0;
-    	  params->y_total_width=params->y_width;  // no cropping
-    	  params->u_total_width=params->u_width;  // no cropping
-    	  params->v_total_width=params->v_width;  // no cropping
-    }
-
-    if(params->y_total_height==0)
-    {
-        params->y_top=0;
-	  params->u_top=0;
-	  params->v_top=0;		
-    	  params->y_total_height=params->y_height; // no cropping
-    	  params->u_total_height=params->u_height; // no cropping
-    	  params->v_total_height=params->v_height; // no cropping
-    }
-
-     /* Pixel size is unknown by default */
-    params->jfif_params.density_unit = 0;
-    /* Pixel aspect ratio is square by default */
-    params->jfif_params.X_density = 1;
-    params->jfif_params.Y_density = 1;
-
-    y_buff = (JPEG_ENC_UINT8 *)buffer;
-    u_buff = y_buff+width*height;
-    v_buff = u_buff+width*height/4;
-    i_buff = NULL;
-    LOGI("version: %s\n", jpege_CodecVersionInfo());	
-    
-    /* --------------------------------------------
-     * QUERY MEMORY REQUIREMENTS
-     * -------------------------------------------*/
-    return_val = jpeg_enc_query_mem_req(obj_ptr);
-
-    if(return_val != JPEG_ENC_ERR_NO_ERROR)
-    {
-        LOGI("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
-    }
-    LOGI("jpeg_enc_query_mem_req success");
-    /* --------------------------------------------
-     * ALLOCATE MEMORY REQUESTED BY CODEC
-     * -------------------------------------------*/
-    number_mem_info = obj_ptr->mem_infos.no_entries;
-    for(index = 0; index < number_mem_info; index++)
-    {
-        /* This example code ignores the 'alignment' and
-         * 'memory_type', but some other applications might want
-         * to allocate memory based on them */
-        mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-        mem_info->memptr = (void *) malloc(mem_info->size);
-        if(mem_info->memptr==NULL) {
-            LOGI("Malloc error after query\n");
-            goto done;
+        int back_orient =0,  front_orient = 0;
+        int back_camera_num = 0, front_camera_num = 0;
+        GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
+        if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
+            sCameraInfo[0].facing = CAMERA_FACING_BACK;
+            sCameraInfo[0].orientation = back_orient;
+            back_camera_num++;
         }
-    }
-
+        if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
+            if(back_camera_num > 0){
+                sCameraInfo[1].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[1].orientation = front_orient;
+            }else{
+                sCameraInfo[0].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[0].orientation = front_orient;
+            }
+            front_camera_num ++;
+        }
+        return (back_camera_num + front_camera_num);					
 
-    return_val = jpeg_enc_init(obj_ptr);
-    if(return_val != JPEG_ENC_ERR_NO_ERROR)
-    {
-        LOGI("JPEG encoder returned an error when jpeg_enc_init was called \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
     }
-    LOGI("jpeg_enc_init success");
-    return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
-                                      y_buff, u_buff, v_buff);
 
-    if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
+    void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
     {
-        LOGI("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-        LOGI("Return Val %d\n",return_val);
-        goto done;
+        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));					
     }
-    LOGI("jpeg_enc_encodeframe success");    
-    // Make an IMemory for each frame
-    jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);    
-    
-done:
-    /* --------------------------------------------
-     * FREE MEMORY REQUESTED BY CODEC
-     * -------------------------------------------*/
-    if(obj_ptr)
+
+    sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
     {
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            if(mem_info)
-                free(mem_info->memptr);
+        char *SelectedCameraName;
+        int back_camera_num = 0, front_camera_num = 0;
+        sp<CaptureDeviceInterface> pCaptureDevice = NULL;
+        sp<PostProcessDeviceInterface> pPPDevice = NULL;
+        sp<JpegEncoderInterface>pJpegEncoder = NULL;
+
+        if (HAL_getNumberOfCameras() ==0 ){
+            CAMERA_HAL_ERR("There is no configure for Cameras");
+            return NULL;
         }
-        free(obj_ptr);
-    }
-    return jpegPtr;
-}
-#endif
 
-#endif
+        SelectedCameraName = Camera_name[sCameraInfo[cameraId].facing];
 
-sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
-{
-    LOGD("Opening Freescale Camera HAL\n");
+        pCaptureDevice = createCaptureDevice(SelectedCameraName);
+        pPPDevice = createPPDevice();
+        pJpegEncoder = createJpegEncoder(SOFTWARE_JPEG_ENC);
 
-    return CameraHal::createInstance();
-}
+        CameraHal *pCameraHal = new CameraHal();
+        if (pCameraHal->setCaptureDevice(pCaptureDevice) < 0 ||
+                pCameraHal->setPostProcessDevice(pPPDevice) < 0 ||
+                pCameraHal->setJpegEncoder(pJpegEncoder) < 0)
+            return NULL;
 
-int HAL_getNumberOfCameras()
-{
-    return 1;
-}
+        if (pCameraHal->Init() < 0)
+            return NULL;
+
+        sp<CameraHardwareInterface> hardware(pCameraHal);
+        CAMERA_HAL_LOG_INFO("created the fsl Camera hal");
+
+        return hardware;
+    }
 
-void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
-{
-	return;
-}
+};
 
 
-}; // namespace android
 
diff --git a/libcamera/CameraHal.h b/libcamera/CameraHal.h
index 6e7d4b7..eae17d2 100755
--- a/libcamera/CameraHal.h
+++ b/libcamera/CameraHal.h
@@ -1,30 +1,26 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * Copyright (C) Texas Instruments - http://www.ti.com/
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * Copyright (C) 2008 The Android Open Source Project
  *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
 
-#ifndef ANDROID_HARDWARE_CAMERA_HARDWARE_H
-#define ANDROID_HARDWARE_CAMERA_HARDWARE_H
+
+#ifndef CAMERA_HAL_BASE_H
+#define CAMERA_HAL_BASE_H
 
 #include <string.h>
 #include <unistd.h>
@@ -33,265 +29,335 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
-#include <utils/Log.h>
 #include <utils/threads.h>
 #include <binder/MemoryBase.h>
 #include <binder/MemoryHeapBase.h>
 #include <camera/CameraHardwareInterface.h>
 #include <ui/Overlay.h>
-#include <dirent.h>
-
 #include <semaphore.h>
 
+#include "Camera_pmem.h"
+#include "CaptureDeviceInterface.h"
+#include "PostProcessDeviceInterface.h"
+#include "JpegEncoderInterface.h"
 
-#define FB_DEVICE               "/dev/graphics/fb0"
-#define MIN_WIDTH               176
-#define MIN_HEIGHT              144
-
-#define PREVIEW_FRAMERATE       30
-#define PICTURE_WIDTH           640     //default picture width
-#define PICTURE_HEIGHT          480     //default picture height
-
-#define RECORDING_WIDTH_NORMAL  352    //default recording width
-#define RECORDING_HEIGHT_NORMAL 288     //default recording height
-
-#define CAPTURE_BUFFER_NUM      3
-#define VIDEO_OUTPUT_BUFFER_NUM	3
 
 #define EXIF_MAKENOTE "fsl_makernote"
 #define EXIF_MODEL    "fsl_model"
 
-#define LOG_FUNCTION_NAME       LOGD("%d: %s() Executing...", __LINE__, __FUNCTION__);
-
-//#define UVC_CAMERA              1
+#define CAMER_PARAM_BUFFER_SIZE 512
+#define MAX_QUERY_FMT_TIMES 20
+#define PARAMS_DELIMITER ","
+#define V4LSTREAM_WAKE_LOCK "V4LCapture"
 
-#define PARAM_BUFFER 		512
-#define FILENAME_LENGTH		256
+#define PREVIEW_HEAP_BUF_NUM    5
+#define VIDEO_OUTPUT_BUFFER_NUM 5
+#define POST_PROCESS_BUFFER_NUM 5
+#define TAKE_PIC_QUE_BUF_NUM 5
 
-#ifdef USE_FSL_JPEG_ENC
-#include "jpeg_enc_interface.h" 
-#endif
-#include "CannedJpeg.h"
-
-struct picbuffer
-{
-    unsigned char *virt_start;
-    size_t phy_offset;
-    unsigned int length;
-};
+#define PREVIEW_CAPTURE_BUFFER_NUM 5
+#define PICTURE_CAPTURE_BUFFER_NUM 3
 
 namespace android {
-class CameraHal : public CameraHardwareInterface {
-public:
-    virtual sp<IMemoryHeap> getPreviewHeap() const;
-    virtual sp<IMemoryHeap> getRawHeap() const;
-
-    virtual void        setCallbacks(notify_callback notify_cb,
-                                     data_callback data_cb,
-                                     data_callback_timestamp data_cb_timestamp,
-                                     void* user);
-
-    virtual void        enableMsgType(int32_t msgType);
-    virtual void        disableMsgType(int32_t msgType);
-    virtual bool        msgTypeEnabled(int32_t msgType);
-
-    virtual bool        useOverlay() { return true; }
-    virtual status_t    setOverlay(const sp<Overlay> &overlay);
-
-    virtual status_t    startPreview();
-    virtual void        stopPreview();
-    virtual bool        previewEnabled();
-
-    virtual status_t    startRecording();
-    virtual void        stopRecording();
-    virtual bool        recordingEnabled();
-    virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
-
-    virtual status_t    autoFocus();
-    virtual status_t    cancelAutoFocus();
-    virtual status_t    takePicture();
-    virtual status_t    cancelPicture();
-    virtual status_t    dump(int fd, const Vector<String16>& args) const;
-    virtual status_t    setParameters(const CameraParameters& params);
-    virtual CameraParameters  getParameters() const;
-    virtual status_t    sendCommand(int32_t command, int32_t arg1,
-                                    int32_t arg2);
-    virtual void release();
-
-    static sp<CameraHardwareInterface> createInstance();
-    
-#ifdef USE_FSL_JPEG_ENC   
-    static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
-                                            JPEG_ENC_UINT32 *out_buf_len_ptr,
-                                            JPEG_ENC_UINT8 flush, 
-                                            void * context, 
-                                            JPEG_ENC_MODE enc_mode);
-    void createJpegExifTags(jpeg_enc_object * obj_ptr);
-#endif
-
-private:
-                        CameraHal();
-    virtual             ~CameraHal();
 
-    static wp<CameraHardwareInterface> singleton;
-
-    class PreviewShowFrameThread : public Thread {
-        CameraHal* mHardware;
+    typedef enum{
+        CAMERA_HAL_ERR_NONE = 0,
+        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
+        CAMERA_HAL_ERR_GET_PARAM           = -2,
+        CAMERA_HAL_ERR_BAD_PARAM =-3,
+        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
+        CAMERA_HAL_ERR_INIT = -5,
+        CAMERA_HAL_ERR_ALLOC_BUF =-6,
+        CAMERA_HAL_ERR_PP_NULL = -7
+    }CAMERA_HAL_ERR_RET;
+
+    class CameraHal : public CameraHardwareInterface {
     public:
-        PreviewShowFrameThread(CameraHal* hw)
-            : Thread(false), mHardware(hw) { }
-        virtual void onFirstRef() {
-            run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
-        }
-        virtual bool threadLoop() {
-            mHardware->previewShowFrameThread();
-            // loop until we need to quit
-            return true;
-        }
-    };
+        virtual sp<IMemoryHeap> getPreviewHeap() const;
+        virtual sp<IMemoryHeap> getRawHeap() const;
+
+        virtual void        setCallbacks(notify_callback notify_cb,
+                data_callback data_cb,
+                data_callback_timestamp data_cb_timestamp,
+                void* user);
+
+        virtual void        enableMsgType(int32_t msgType);
+        virtual void        disableMsgType(int32_t msgType);
+        virtual bool        msgTypeEnabled(int32_t msgType);
+
+        virtual bool        useOverlay() { return true; }
+        virtual status_t    setOverlay(const sp<Overlay> &overlay);
+
+        virtual status_t    startPreview();
+        virtual void        stopPreview();
+        virtual bool        previewEnabled();
+
+        virtual status_t    startRecording();
+        virtual void        stopRecording();
+        virtual bool        recordingEnabled();
+        virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
+
+        virtual status_t    autoFocus();
+        virtual status_t    cancelAutoFocus();
+        virtual status_t    takePicture();
+        virtual status_t    cancelPicture();
+        virtual status_t    dump(int fd, const Vector<String16>& args) const;
+        virtual status_t    setParameters(const CameraParameters& params);
+        virtual CameraParameters  getParameters() const;
+        virtual status_t    sendCommand(int32_t command, int32_t arg1,
+                int32_t arg2);
+        virtual void release();
+
+        CAMERA_HAL_ERR_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
+        CAMERA_HAL_ERR_RET setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice);
+        CAMERA_HAL_ERR_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
+        CAMERA_HAL_ERR_RET  Init();
+
+        CameraHal();
+        virtual             ~CameraHal();
+
+    private:
+
+        class CaptureFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            CaptureFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->captureframeThread();
+                return true;
+            }
+        };
+
+        class PostProcessThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PostProcessThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->postprocessThread();
+                return true;
+            }
+        };
+
+
+        class PreviewShowFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PreviewShowFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->previewshowFrameThread();
+                return true;
+            }
+        };
+
+        class EncodeFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            EncodeFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->encodeframeThread();
+                return true;
+            }
+        };
+
+        class AutoFocusThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            AutoFocusThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                if (mHardware->autoFocusThread()>=0)
+                    return true;
+                else
+                    return false;
+            }
+        };
+
+
+        class TakePicThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            TakePicThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                if (mHardware->takepicThread()>=0)
+                    return true;
+                else
+                    return false;
+            }
+        };
+
+        void preInit();
+        void postDestroy();
+
+        status_t OpenCaptureDevice();
+        void CloseCaptureDevice();
+
+        CAMERA_HAL_ERR_RET AolLocForInterBuf();
+        void  FreeInterBuf();
+        CAMERA_HAL_ERR_RET InitCameraHalParam();
+        CAMERA_HAL_ERR_RET GetCameraBaseParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET GetPictureExifParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET CameraMiscInit();
+        CAMERA_HAL_ERR_RET CameraMiscDeInit();
+        status_t CameraHALPreviewStart();
+        int captureframeThread();
+        int postprocessThread();
+        int previewshowFrameThread();
+        int encodeframeThread();
+        status_t AllocateRecordVideoBuf();
+
+        status_t CameraHALStartPreview();
+        void     CameraHALStopPreview();
+
+        status_t PreparePreviwBuf();
+        status_t PrepareCaptureDevices();
+        status_t PreparePostProssDevice();
+        status_t PreparePreviwMisc();
+
+        void CameraHALStopThreads();
+        void LockWakeLock();
+
+        void UnLockWakeLock();
+
+        int autoFocusThread();
+        int takepicThread();
+
+        int GetJpegEncoderParam();
+        int NegotiateCaptureFmt(bool TakePicFlag);
+        int cameraHALTakePicture();
+        void CameraHALStopMisc();
+        int PrepareJpegEncoder();
+        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
+
+        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
+
+        CameraParameters    mParameters;
+        void               *mCallbackCookie;
+        notify_callback    mNotifyCb;
+        data_callback      mDataCb;
+        data_callback_timestamp mDataCbTimestamp;
+
+        sp<CaptureDeviceInterface> mCaptureDevice;
+        sp<PostProcessDeviceInterface> mPPDevice;
+        sp<JpegEncoderInterface> mJpegEncoder;
+
+
+        sp<CaptureFrameThread> mCaptureFrameThread;
+        sp<PostProcessThread>  mPostProcessThread;
+        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
+        sp<EncodeFrameThread> mEncodeFrameThread;
+        sp<AutoFocusThread>mAutoFocusThread;
+        sp<TakePicThread> mTakePicThread;
+
+        mutable Mutex       mLock;
+
+        char *supportedPictureSizes;
+        char *supportedPreviewSizes;
+        char *supportedFPS;
+        char *supprotedThumbnailSizes;
+
+        sp<Overlay>         mOverlay;
+        unsigned int        mMsgEnabled;
+
+        struct capture_config_t mCaptureDeviceCfg;
+        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        sp<MemoryHeapBase>  mPreviewHeap;
+        sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
+
+        /* the buffer for recorder */
+        unsigned int        mVideoBufNume;
+        sp<MemoryHeapBase>  mVideoHeap;
+        sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
+        volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
+
+
+        sp<PmemAllocator>   mPmemAllocator;
+        DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
+        unsigned int        mPPbufNum;
+        pp_input_param_t    mPPInputParam;
+        pp_output_param_t   mPPOutputParam;
+
+        volatile bool       mPreviewRunning;
+        unsigned int        mPreviewFormat;
+        unsigned int 		mPreviewFrameSize;
+        unsigned int        mPreviewCapturedFormat;
+
+        bool                mTakePicFlag;
+        unsigned int        mEncoderSupportedFormat[MAX_QUERY_FMT_TIMES];
+        enc_cfg_param       mJpegEncCfg;
+
+
+        unsigned int        mUvcSpecialCaptureFormat;
+        unsigned int        mCaptureSupportedFormat[MAX_QUERY_FMT_TIMES];
+        unsigned int        mPictureCapturedFormat;
+        unsigned int        mCaptureFrameSize;
+        unsigned int        mCaptureBufNum;
+        bool                mRecordRunning;
+        int                 mCurrentRecordFrame;
+        int 		        nCameraBuffersQueued;
+
+        unsigned int        mPreviewHeapBufNum;
+        unsigned int        mTakePicBufQueNum;
+
+        bool mCameraReady;
+        bool mCaptureDeviceOpen;
+        bool mPPDeviceNeed;
+        bool mPPDeviceNeedForPic;
+        bool mPreviewStopped;
+        bool mRecordStopped;
+        bool mPowerLock;
+
+        int error_status;
+        unsigned int preview_heap_buf_head;
+        unsigned int display_head;
+        unsigned int enc_head;
+        unsigned int dequeue_head;
+        unsigned int is_first_buffer;
+        unsigned int last_display_index;
+        unsigned int pp_in_head;
+        unsigned int pp_out_head;
+        unsigned int buffer_index_maps[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        sem_t avab_show_frame;
+        sem_t avab_dequeue_frame;
+        sem_t avab_enc_frame;
+        sem_t avab_enc_frame_finish;
+        sem_t avab_pp_in_frame;
+        sem_t avab_pp_out_frame;
+
+        pthread_mutex_t mOverlayMutex;
+        pthread_mutex_t mMsgMutex;
+        pthread_mutex_t mPPIOParamMutex;
 
-    class PreviewCaptureFrameThread : public Thread {
-        CameraHal* mHardware;
-    public:
-        PreviewCaptureFrameThread(CameraHal* hw)
-            : Thread(false), mHardware(hw) { }
-        virtual void onFirstRef() {
-            run("CameraPreviewCaptureFrameThread", PRIORITY_URGENT_DISPLAY);
-        }
-        virtual bool threadLoop() {
-            mHardware->previewCaptureFrameThread();
-            // loop until we need to quit
-            return true;
-        }
     };
 
-    void initDefaultParameters();
-    bool initHeapLocked();
-
-    int previewShowFrameThread();
-    int previewCaptureFrameThread();
-
-    static int beginAutoFocusThread(void *cookie);
-    int autoFocusThread();
-
-    static int beginPictureThread(void *cookie);
-    int pictureThread();
-
-    int validateSize(int w, int h);
-    void* cropImage(unsigned long buffer);
-
-    void convertYUYVtoI420(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
-	void convertI420toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
-    int uvcGetDeviceAndCapability(char *sizes_buf);
-
-    sp<MemoryBase> encodeImage(void *buffer, uint32_t bufflen);
-
-    int cameraOpen();
-    int cameraClose();
-
-    int cameraDestroy();
-    int cameraPreviewConfig();
-    int cameraPreviewStart();
-    void cameraPreviewStop();
-    int cameraTakePicConfig();
-    int cameraTakePicture();
-    void previewOneFrame();
-    int stringTodegree(char* cAttribute, unsigned long &degree, unsigned long &minute, unsigned long &second); //for the minus the return value will be 1
-
-    mutable Mutex       mLock;
-
-    CameraParameters    mParameters;
-
-    sp<MemoryHeapBase>  mPreviewHeap;
-    sp<MemoryBase>      mPreviewBuffers[CAPTURE_BUFFER_NUM]; // used when UVC camera
-    sp<MemoryHeapBase>  mPreviewConvertHeap;
-    sp<MemoryBase>      mPreviewConvertBuffers[CAPTURE_BUFFER_NUM];
-    bool                mPreviewRunning;
-    int                 mRecordHeight;
-    int                 mRecordWidth;
-    int                 mRecordFormat;
-
-    // protected by mLock
-    sp<Overlay>         mOverlay;
-    sp<PreviewShowFrameThread>   mPreviewShowFrameThread;
-    sp<PreviewCaptureFrameThread> mPreviewCaptureFrameThread;
-
-    notify_callback    mNotifyCb;
-    data_callback      mDataCb;
-    data_callback_timestamp mDataCbTimestamp;
-    void               *mCallbackCookie;
-
-    int32_t             mMsgEnabled;
-
-    bool                mCameraOpened;
-
-    int                 mPictureHeight;
-    int                 mPictureWidth;
-    int                 mPictureFormat;
-
-    int 		mRecordFrameSize;
-    bool                mRecordRunning;
-    int                 mCurrentRecordFrame;
-    int 		nCameraBuffersQueued;
-
-    /* These buffers are used to output captured video to upper layer,
-       eg, for to use video encoder */
-    sp<MemoryHeapBase>  mVideoHeap;
-    sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
-    int   		mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
-
-    bool previewStopped;
-    bool recordStopped;
-    bool doubledPreviewWidth;
-    bool doubledPreviewHeight;
-
-    static int camera_device;
-    static int g_camera_framerate;
-    static char dev_node[FILENAME_LENGTH];
-
-    static int g_rotate;
-    static int g_still_bpp;
-
-    //used for recording
-    struct picbuffer mCaptureBuffers[CAPTURE_BUFFER_NUM];
-    int    buffer_index_maps[CAPTURE_BUFFER_NUM];
-
-    static const char supportedPictureSizes[];
-    static const char supportedPreviewSizes[];
-    static const char supportedFPS[];
-    static const char supprotedThumbnailSizes[];
-    static const char PARAMS_DELIMITER[];
-
-    int error_status;
-    int display_head;
-    int dequeue_head;
-    int is_first_buffer;
-    int is_overlay_pushmode;
-    int last_display_index;
-
-    sem_t avaiable_show_frame;
-    sem_t avaible_dequeue_frame;
-    pthread_mutex_t mOverlay_sem;
-	bool mPowerLock;
-
-#ifdef DUMP_CAPTURE_YUV
-    static FILE *record_yuvFile;
-    static FILE *capture_yuvFile;
-#endif
-
-#ifdef USE_FSL_JPEG_ENC 
-    static JPEG_ENC_UINT32 g_JpegDataSize;//Total size of g_JpegData
-    static JPEG_ENC_UINT32 g_JpegDataLen;//Valid data len of g_JpegData
-    static JPEG_ENC_UINT8 *g_JpegData;//Buffer to hold jpeg data
-#endif
-};
-
 }; // namespace android
 
 #endif
diff --git a/libcamera/Camera_pmem.cpp b/libcamera/Camera_pmem.cpp
new file mode 100755
index 0000000..ef8da12
--- /dev/null
+++ b/libcamera/Camera_pmem.cpp
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <linux/android_pmem.h>
+#include "Camera_pmem.h"
+
+
+/*
+ *   input parameter: 
+ */
+
+using namespace android;
+
+PmemAllocator::PmemAllocator(int bufCount, int bufSize):
+    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
+    mVirBase(NULL),mPhyBase(NULL)
+{
+
+    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
+
+    int err;
+    struct pmem_region region;
+    mFD = open(PMEM_DEV, O_RDWR);
+    if (mFD < 0) {
+        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
+    if (err == 0)
+    {
+        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
+    }
+    else
+    {
+        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
+
+    mTotalSize = mBufSize*bufCount;
+    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
+        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
+    }
+    else
+    {
+        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
+                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
+
+        if (virtualbase == MAP_FAILED) {
+            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
+                    mFD, (unsigned int)mTotalSize, strerror(errno));
+            return;
+        }
+
+        memset(&region, 0, sizeof(region));
+
+        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
+        {
+            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
+            munmap(virtualbase, mTotalSize);
+            return;
+        }
+        mVirBase = (void *)virtualbase;
+        mPhyBase = region.offset;
+        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
+    }
+}
+
+PmemAllocator::~PmemAllocator()
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
+        }
+    }
+
+    if(mVirBase) {
+        munmap(mVirBase, mTotalSize);
+    }
+    if(mFD) {
+        close(mFD);
+    }
+
+}
+
+int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(!mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
+                    index,mBufSize,size);
+
+            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
+            pbuf->phy_offset= mPhyBase+index*mBufSize;
+            pbuf->length= mBufSize;
+            mSlotAllocated[index] = true;
+            return DMA_ALLOCATE_ERR_NONE;
+        }
+    }
+    return DMA_ALLOCATE_ERR_BAD_PARAM;
+}
+
+int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
+{
+    CAMERA_HAL_LOG_FUNC;
+    if((!mVirBase)||(!pbuf)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
+    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
+        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
+        mSlotAllocated[nSlot] = false;
+        return DMA_ALLOCATE_ERR_NONE;
+    }
+    else{
+        CAMERA_HAL_ERR("Error!Not a valid buffer");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+}
diff --git a/libcamera/Camera_pmem.h b/libcamera/Camera_pmem.h
new file mode 100755
index 0000000..c1c041f
--- /dev/null
+++ b/libcamera/Camera_pmem.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __CAMERA_MEM__H__
+#define __CAMERA_MEM__H__
+
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+
+#define DEFAULT_PMEM_ALIGN (4096)
+#define PMEM_DEV "/dev/pmem_adsp"
+#define MAX_SLOT 64
+
+namespace android {
+
+class PmemAllocator : public virtual RefBase
+{
+public:
+    PmemAllocator(int bufCount,int bufSize);
+    virtual ~PmemAllocator();
+    virtual int allocate(DMA_BUFFER *p_buf, int size);
+    virtual int deAllocate(DMA_BUFFER *p_buf);
+	int err_ret;
+private:
+    int mFD;
+    unsigned long mTotalSize;
+    int mBufCount;
+    int mBufSize;
+    void *mVirBase;
+    unsigned int mPhyBase;
+    bool mSlotAllocated[MAX_SLOT];
+	
+};
+};
+
+#endif
diff --git a/libcamera/Camera_utils.h b/libcamera/Camera_utils.h
new file mode 100755
index 0000000..6e01da3
--- /dev/null
+++ b/libcamera/Camera_utils.h
@@ -0,0 +1,60 @@
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAMERA_UTILS_H
+#define CAMERA_UTILS_H
+
+#undef LOG_TAG
+#define LOG_TAG "FslCameraHAL"
+#include <utils/Log.h>
+
+//#define CAMERA_HAL_DEBUG_LOG
+
+#ifdef CAMERA_HAL_DEBUG_LOG
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define CAMERA_HAL_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) 
+#define CAMERA_HAL_LOG_FUNC
+#endif
+
+#define CAMERA_HAL_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define CAMERA_HAL_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define CAMERA_HAL_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+namespace android {
+
+    typedef enum{
+        DMA_ALLOCATE_ERR_NONE = 0,
+        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
+
+    }DMA_ALLOCATE_ERR_RET;
+
+    typedef struct {
+        unsigned char *virt_start;
+        size_t phy_offset;
+        unsigned int length;
+    }DMA_BUFFER;
+
+}; //name space android
+
+#endif
+
diff --git a/libcamera/CaptureDeviceInterface.cpp b/libcamera/CaptureDeviceInterface.cpp
new file mode 100755
index 0000000..8adc966
--- /dev/null
+++ b/libcamera/CaptureDeviceInterface.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "V4l2UVCDevice.h"
+#include "V4l2CsiDevice.h"
+namespace android{
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
+    {
+        if(strstr(deviceName, UVC_NAME_STRING)){
+            CAMERA_HAL_LOG_INFO("It is the UVC device");
+
+            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }else{
+            CAMERA_HAL_LOG_INFO("It is the CSI device");
+            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }
+    }
+
+
+}
diff --git a/libcamera/CaptureDeviceInterface.h b/libcamera/CaptureDeviceInterface.h
new file mode 100755
index 0000000..6cb6567
--- /dev/null
+++ b/libcamera/CaptureDeviceInterface.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAPTURE_DEVICE_INTERFACE_H
+#define CAPTURE_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+
+
+namespace android {
+#define UVC_NAME_STRING "uvc"
+
+    typedef enum{
+        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
+        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
+        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
+        CAPTURE_DEVICE_ERR_NONE = 0,
+        CAPTURE_DEVICE_ERR_OPEN = -1,
+        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
+        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
+        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
+        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
+        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
+        CAPTURE_DEVICE_ERR_UNKNOWN = -100
+    }CAPTURE_DEVICE_ERR_RET;
+
+    typedef enum{
+        MOTION_MODE = 0,
+        HIGH_QUALITY_MODE = 1
+    }CAPTURE_MODE;
+
+    typedef enum{
+        OUTPU_FMT = 0,
+        FRAME_SIZE_FPS = 1
+    }DevParamType;
+
+    struct timeval_fract{
+        unsigned int numerator;
+        unsigned int denominator;
+    };
+
+    struct capture_config_t{
+        unsigned int fmt;
+        unsigned int width;
+        unsigned int height;
+        unsigned int framesize;   //out
+        unsigned int picture_waite_number;//out
+        struct timeval_fract tv;
+    };
+
+
+    class CaptureDeviceInterface : public virtual RefBase{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen()=0;
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStart()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue(unsigned int BufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
+
+        virtual ~ CaptureDeviceInterface(){}
+    };
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName);
+
+};
+#endif
+
diff --git a/libcamera/JpegEncoderInterface.cpp b/libcamera/JpegEncoderInterface.cpp
new file mode 100755
index 0000000..30b9d96
--- /dev/null
+++ b/libcamera/JpegEncoderInterface.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. 
+ */
+#include "JpegEncoderSoftware.h"
+namespace android{
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
+    {
+        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
+            CAMERA_HAL_LOG_INFO("Create the software encoder");
+            return JpegEncoderSoftware::createInstance();
+        }
+        else{
+            CAMERA_HAL_ERR("the hardware encoder is not supported");
+            return NULL;
+        }
+    }
+};
diff --git a/libcamera/JpegEncoderInterface.h b/libcamera/JpegEncoderInterface.h
new file mode 100755
index 0000000..c7b43c0
--- /dev/null
+++ b/libcamera/JpegEncoderInterface.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_INTERFACE_H
+#define JPEG_ENCODER_INTERFACE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+namespace android{
+
+
+#define MAX_JPEG_MAKE_BYTES 256
+#define MAX_JPEG_MAKERNOTE_BYTES 256
+#define MAX_JPEG_MODEL_BYTES 256
+#define TIME_FMT_LENGTH 20
+#define MAX_GPS_PROCESSING_BYTES	256
+
+
+    typedef enum{
+        SOFTWARE_JPEG_ENC = 0,
+        HARDWARE_JPEG_ENC = 1
+    }JPEG_ENCODER_TYPE;
+
+    typedef enum{
+        JPEG_ENC_ERROR_NONE = 0,
+        JPEG_ENC_ERROR_BAD_PARAM = -1,
+        JPEG_ENC_ERROR_ALOC_BUF = -2
+    }JPEG_ENC_ERR_RET;
+
+
+    typedef enum{
+        SUPPORTED_FMT = 0,
+    }JPEEG_QUERY_TYPE;
+
+    struct jpeg_enc_focallength_t
+    {
+        unsigned int numerator;
+        unsigned int denominator;	
+    };
+
+    struct jpeg_enc_make_info_t
+    {
+        unsigned char make_bytes;
+        unsigned char make[MAX_JPEG_MAKE_BYTES];
+    };
+    struct jpeg_enc_makernote_info_t
+    {
+        unsigned char makernote_bytes;
+        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
+    };
+
+    struct jpeg_enc_model_info_t
+    {
+        unsigned char model_bytes;
+        unsigned char model[MAX_JPEG_MODEL_BYTES];	
+    };
+
+    struct jpeg_enc_datetime_info_t
+    {
+        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
+    };
+
+    struct jpeg_enc_gps_param{
+        unsigned int version;			//GPSVersionID
+        char latitude_ref[2];		//GPSLatitudeRef: "N " is positive; "S " is negative
+        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
+        unsigned int latitude_degree[2];//GPSLatitude
+        unsigned int latitude_minute[2];
+        unsigned int latitude_second[2];
+        unsigned int longtitude_degree[2];//GPSLongitude
+        unsigned int longtitude_minute[2];
+        unsigned int longtitude_second[2];
+        char altitude_ref;		//GPSAltitudeRef: 0 or 1(negative)
+        unsigned int altitude[2];		//GPSAltitude: unit is meters
+        unsigned int hour[2];			//GPSTimeStamp
+        unsigned int minute[2];
+        unsigned int seconds[2];
+        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
+        char processmethod_bytes;
+        char datestamp[11];		//GPSDateStamp: "YYYY:MM:DD "
+    };
+
+    typedef struct{
+        unsigned int PicWidth;
+        unsigned int PicHeight;
+        unsigned int ThumbWidth;
+        unsigned int ThumbHeight;
+        unsigned int BufFmt;
+        struct jpeg_enc_focallength_t *pFoclLength;
+        struct jpeg_enc_make_info_t *pMakeInfo;
+        struct jpeg_enc_makernote_info_t *pMakeNote;
+        struct jpeg_enc_model_info_t *pModelInfo;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
+        struct jpeg_enc_gps_param *pGps_info;
+    }enc_cfg_param;
+
+    struct jpeg_encoding_conf{
+        unsigned int output_jpeg_size;
+    };
+
+    class JpegEncoderInterface : public virtual RefBase{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
+
+        virtual ~ JpegEncoderInterface(){}
+    }; 
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
+
+};
+
+#endif
diff --git a/libcamera/JpegEncoderSoftware.cpp b/libcamera/JpegEncoderSoftware.cpp
new file mode 100755
index 0000000..fbc9485
--- /dev/null
+++ b/libcamera/JpegEncoderSoftware.cpp
@@ -0,0 +1,656 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "JpegEncoderSoftware.h"
+
+namespace android{
+
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
+    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
+
+    JpegEncoderSoftware :: JpegEncoderSoftware()
+        :mSupportedTypeIdx(0),
+        pEncCfgLocal(NULL),
+        pEncObj(NULL)
+    {
+        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
+        mSupportedType[1] = v4l2_fourcc('Y','U','Y','V');
+    }
+
+    JpegEncoderSoftware :: ~JpegEncoderSoftware()
+    {
+
+    }
+
+    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
+    {
+
+        int * pSupportedType = (int *)pQueryRet;
+        switch(QueryType){	
+            case SUPPORTED_FMT:
+                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
+                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
+                    mSupportedTypeIdx ++;
+                }else{
+                    mSupportedTypeIdx = 0;
+                    return JPEG_ENC_ERROR_BAD_PARAM;
+                }
+                break;
+            default:
+                return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        return JPEG_ENC_ERROR_NONE;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        struct jpeg_enc_focallength_t * pFoclLength = NULL;
+        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
+        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
+        struct jpeg_enc_model_info_t *pModelInfo = NULL;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
+        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
+
+        if(pEncCfg == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
+
+        if (pEncCfgLocal == NULL){
+            CAMERA_HAL_ERR("Allocat buffer for EncCfg failed");
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+
+        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
+        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
+
+
+        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
+            goto INT_ERR_RET;
+        }
+
+        if (pEncCfg->pFoclLength != NULL){
+            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
+
+            if (pFoclLength == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pFoclLength failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
+            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
+            pEncCfgLocal->pFoclLength = pFoclLength;
+        }
+
+
+        if (pEncCfg->pMakeInfo != NULL){
+            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
+
+            if (pMakeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
+            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
+            pEncCfgLocal->pMakeInfo = pMakeInfo;
+        }
+
+        if (pEncCfg->pMakeNote != NULL){
+            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
+
+            if (pMakeNote == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeNote failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
+            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
+            pEncCfgLocal->pMakeNote = pMakeNote;
+        }
+
+        if (pEncCfg->pModelInfo != NULL){
+            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
+
+            if (pModelInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pModelInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
+            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
+            pEncCfgLocal->pModelInfo = pModelInfo;
+        }
+
+        if (pEncCfg->pDatetimeInfo != NULL){
+            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
+
+            if (pDatetimeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pDatetimeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
+            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
+            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
+        }
+
+        if (pEncCfg->pGps_info != NULL){
+            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
+
+            if (pGpsInfoLocal == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pGpsInfoLocal failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
+            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
+            pEncCfgLocal->pGps_info = pGpsInfoLocal;
+        }
+
+        return ret;
+
+INT_ERR_RET:
+        if(pEncCfgLocal)
+            free(pEncCfgLocal);
+        if(pFoclLength)
+            free(pFoclLength);
+        if(pMakeInfo)
+            free(pMakeInfo);
+        if(pMakeNote)
+            free(pMakeNote);
+        if(pModelInfo)
+            free(pModelInfo);
+        if(pDatetimeInfo)
+            free(pDatetimeInfo);
+        if(pGpsInfoLocal)
+            free(pGpsInfoLocal);
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
+        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }else{
+            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
+        }
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if (pEncCfgLocal != NULL ){
+            if (pEncCfgLocal->pFoclLength != NULL)
+                free(pEncCfgLocal->pFoclLength);
+            if (pEncCfgLocal->pMakeInfo != NULL)
+                free(pEncCfgLocal->pMakeInfo);
+            if (pEncCfgLocal->pMakeNote != NULL)
+                free(pEncCfgLocal->pMakeNote);
+            if (pEncCfgLocal->pModelInfo != NULL)
+                free(pEncCfgLocal->pModelInfo);
+            if (pEncCfgLocal->pDatetimeInfo != NULL)
+                free(pEncCfgLocal->pDatetimeInfo);
+            if (pEncCfgLocal->pGps_info != NULL)
+                free(pEncCfgLocal->pGps_info);
+            free(pEncCfgLocal);
+        }
+
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
+
+        CAMERA_HAL_LOG_FUNC;
+        int i = 0;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)|| 
+                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
+                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
+            if(pEncCfgLocal->BufFmt == mSupportedType[i])
+                break;
+        }
+
+        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
+            ret = JPEG_ENC_ERROR_BAD_PARAM;
+
+        return ret;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        int width, height, size,index;
+        JPEG_ENC_UINT8 * i_buff = NULL;
+        JPEG_ENC_UINT8 * y_buff = NULL;
+        JPEG_ENC_UINT8 * u_buff = NULL;
+        JPEG_ENC_UINT8 * v_buff = NULL;
+        JPEG_ENC_RET_TYPE return_val;
+        jpeg_enc_parameters * params = NULL;
+        jpeg_enc_object * obj_ptr = NULL;
+        JPEG_ENC_UINT8 number_mem_info;
+        jpeg_enc_memory_info * mem_info = NULL;
+        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
+        int thumbnail_width, thumbnail_height;
+        unsigned char *buffer = inBuf->virt_start;
+
+        bool mEncodeThumbnailFlag = true;
+
+        width = pEncCfgLocal->PicWidth;
+        height = pEncCfgLocal->PicHeight;
+
+        thumbnail_width = pEncCfgLocal->ThumbWidth;
+        thumbnail_height = pEncCfgLocal->ThumbHeight;
+
+
+        if (thumbnail_width <= 0 || thumbnail_width <= 0)
+            mEncodeThumbnailFlag = false;
+
+        g_JpegDataSize = 0;//Total size of g_JpegData
+        g_JpegDataLen = 0;//Valid data len of g_JpegData
+        g_JpegData = NULL;//Buffer to hold jpeg data
+        size = width * height * 3 / 2;
+
+        g_JpegData = outBuf->virt_start;
+        g_JpegDataSize = size;
+        if(!g_JpegData)
+        {
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        /* --------------------------------------------
+         * Allocate memory for Encoder Object
+         * -------------------------------------------*/
+        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
+        if(!obj_ptr)
+        {
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
+
+        /* Assign the function for streaming output */
+        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
+        obj_ptr->context=NULL;   //user can put private variables into it
+        /* --------------------------------------------
+         * Fill up the parameter structure of JPEG Encoder
+         * -------------------------------------------*/
+        params = &(obj_ptr->parameters);
+
+        if(mEncodeThumbnailFlag==true)
+        {
+
+            //need resizing code here!!!
+            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
+            if(!thumbnail_buffer)
+            {
+                return JPEG_ENC_ERROR_ALOC_BUF;
+            }
+
+            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
+
+            width = thumbnail_width;
+            height = thumbnail_height;
+
+            temp_buffer = buffer;
+            buffer = thumbnail_buffer;
+
+            params->mode = JPEG_ENC_THUMB;
+        }
+        else
+        {
+            params->mode = JPEG_ENC_MAIN_ONLY;
+        }
+
+encodeframe:
+
+        params->compression_method = JPEG_ENC_SEQUENTIAL;
+        params->quality = 75;
+        params->restart_markers = 0;
+        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height/2;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height/2;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
+        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
+        }
+        params->exif_flag = 1;
+
+        params->y_left = 0;
+        params->y_top = 0;
+        params->y_total_width = 0;
+        params->y_total_height = 0;
+        params->raw_dat_flag= 0;
+
+        if(params->y_total_width==0)
+        {
+            params->y_left=0;
+            params->u_left=0;
+            params->v_left=0;
+            params->y_total_width=params->y_width;  // no cropping
+            params->u_total_width=params->u_width;  // no cropping
+            params->v_total_width=params->v_width;  // no cropping
+        }
+
+        if(params->y_total_height==0)
+        {
+            params->y_top=0;
+            params->u_top=0;
+            params->v_top=0;
+            params->y_total_height=params->y_height; // no cropping
+            params->u_total_height=params->u_height; // no cropping
+            params->v_total_height=params->v_height; // no cropping
+        }
+
+        /* Pixel size is unknown by default */
+        params->jfif_params.density_unit = 0;
+        /* Pixel aspect ratio is square by default */
+        params->jfif_params.X_density = 1;
+        params->jfif_params.Y_density = 1;
+        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
+            y_buff = (JPEG_ENC_UINT8 *)buffer;
+            u_buff = y_buff+width*height;
+            v_buff = u_buff+width*height/4;
+            i_buff = NULL;
+        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
+            y_buff = NULL;
+            u_buff = NULL;
+            v_buff = NULL;
+            i_buff = (JPEG_ENC_UINT8 *)buffer;
+        }
+        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+
+        /* --------------------------------------------
+         * QUERY MEMORY REQUIREMENTS
+         * -------------------------------------------*/
+        return_val = jpeg_enc_query_mem_req(obj_ptr);
+
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_query_mem_req success");
+        /* --------------------------------------------
+         * ALLOCATE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        number_mem_info = obj_ptr->mem_infos.no_entries;
+        for(index = 0; index < number_mem_info; index++)
+        {
+            /* This example code ignores the 'alignment' and
+             * 'memory_type', but some other applications might want
+             * to allocate memory based on them */
+            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+            mem_info->memptr = (void *) malloc(mem_info->size);
+            if(mem_info->memptr==NULL) {
+                CAMERA_HAL_LOG_RUNTIME("Malloc error after query\n");
+                goto done;
+            }
+        }
+
+        return_val = jpeg_enc_init(obj_ptr);
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_init success");
+
+        createJpegExifTags(obj_ptr);
+
+        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
+                y_buff, u_buff, v_buff);
+
+        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        if(params->mode == JPEG_ENC_THUMB)
+        {
+            JPEG_ENC_UINT8 num_entries;
+            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
+            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
+
+            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
+
+            for(int i = 0; i < num_entries; i++)
+            {
+                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
+            }
+
+            free(offset_tbl_ptr);
+            free(value_tbl_ptr);
+
+            free(buffer);
+
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+
+            g_JpegData += g_JpegDataLen;
+            g_JpegDataSize -= g_JpegDataLen;
+
+
+            //recover to build the main jpeg
+            params->mode = JPEG_ENC_MAIN;
+
+            buffer = temp_buffer;
+            width = pEncCfgLocal->PicWidth;
+            height = pEncCfgLocal->PicHeight;
+
+            goto encodeframe;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_encodeframe success");
+        // Make an IMemory for each frame
+        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
+        *pEncSize = g_JpegDataLen;
+
+done:
+        /* --------------------------------------------
+         * FREE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        if(obj_ptr)
+        {
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+            free(obj_ptr);
+        }
+
+        return ret;
+    }
+
+    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
+            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
+    {
+        JPEG_ENC_UINT32 i;
+        if(*out_buf_ptrptr == NULL)
+        {
+            /* This function is called for the 1'st time from the
+             * codec */
+            *out_buf_ptrptr = g_JpegData;
+            *out_buf_len_ptr = g_JpegDataSize;
+        }
+
+        else if(flush == 1)
+        {
+            /* Flush the buffer*/
+            g_JpegDataLen += *out_buf_len_ptr;
+            CAMERA_HAL_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
+
+            *out_buf_ptrptr = NULL;
+            *out_buf_len_ptr = NULL;
+        }
+        else
+        {
+            CAMERA_HAL_LOG_RUNTIME("Not enough buffer for encoding");
+            return 0;
+        }
+
+        return(1); /* Success */
+    }
+
+    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
+    {
+        if(pEncCfgLocal->pMakeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
+        if(pEncCfgLocal->pMakeNote)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
+        if(pEncCfgLocal->pModelInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
+        if(pEncCfgLocal->pDatetimeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
+        if(pEncCfgLocal->pFoclLength)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
+
+        if (pEncCfgLocal->pGps_info)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
+
+        return;
+    }
+
+    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
+    {
+        int i,j,s;
+        int h_offset;
+        int v_offset;
+        unsigned char *ptr,cc;
+        int h_scale_ratio;
+        int v_scale_ratio;
+
+        s = 0;
+
+_resize_begin:
+
+        if(!dst_width) return -1;
+        if(!dst_height) return -1;
+
+        h_scale_ratio = src_width / dst_width;
+        if(!h_scale_ratio) return -1;
+
+        v_scale_ratio = src_height / dst_height;
+        if(!v_scale_ratio) return -1;
+
+        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
+        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
+
+        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
+        {
+            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
+            {
+                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
+                cc = ptr[0];
+
+                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
+                ptr[0] = cc;
+            }
+        }
+
+        src_ptr += src_width*src_height;
+        dst_ptr += dst_width*dst_height;
+
+        if(s < 2)
+        {
+            if(!s++)
+            {
+                src_width >>= 1;
+                src_height >>= 1;
+
+                dst_width >>= 1;
+                dst_height >>= 1;
+            }
+
+            goto _resize_begin;
+        }
+
+        return 0;
+    }
+
+    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
+        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
+        return hardware;
+    }
+
+
+};
diff --git a/libcamera/JpegEncoderSoftware.h b/libcamera/JpegEncoderSoftware.h
new file mode 100755
index 0000000..624d5b0
--- /dev/null
+++ b/libcamera/JpegEncoderSoftware.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_SOFTWARE_H
+#define JPEG_ENCODER_SOFTWARE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#include "JpegEncoderInterface.h"
+#include "jpeg_enc_interface.h"
+
+
+namespace android{
+#define MAX_ENC_SUPPORTED_YUV_TYPE  2
+
+    class JpegEncoderSoftware : public JpegEncoderInterface{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
+
+        static sp<JpegEncoderInterface>createInstance();
+    private:
+
+        JpegEncoderSoftware();
+        virtual ~JpegEncoderSoftware();
+
+        virtual JPEG_ENC_ERR_RET CheckEncParm();
+        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
+
+
+        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
+                JPEG_ENC_UINT32 *out_buf_len_ptr,
+                JPEG_ENC_UINT8 flush, 
+                void * context, 
+                JPEG_ENC_MODE enc_mode);
+        void createJpegExifTags(jpeg_enc_object * obj_ptr);
+        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
+
+
+        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
+        unsigned int mSupportedTypeIdx;
+        enc_cfg_param *pEncCfgLocal;
+        jpeg_enc_object *pEncObj;
+
+
+        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
+        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
+        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
+
+    }; 
+};
+
+#endif
diff --git a/libcamera/PP_ipulib.cpp b/libcamera/PP_ipulib.cpp
new file mode 100755
index 0000000..69d91ee
--- /dev/null
+++ b/libcamera/PP_ipulib.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h"
+#include <stdlib.h>
+#include <string.h>
+
+namespace android{
+
+    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
+
+    PPIpuLib :: PPIpuLib(){
+        return;
+    }
+
+    PPIpuLib :: ~PPIpuLib(){
+
+        singleton.clear();
+    }
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+        //Setting input format
+        mIPUInputParam.width = pp_input->width;
+        mIPUInputParam.height = pp_input->height;
+
+        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
+        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
+        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
+        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
+        mIPUInputParam.fmt = pp_input->fmt;
+        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
+
+        //Setting output format
+        mIPUOutputParam.fmt = pp_output->fmt;
+        mIPUOutputParam.width = pp_output->width;
+        mIPUOutputParam.height = pp_output->height;   
+        mIPUOutputParam.show_to_fb = 0;
+        //Output param should be same as input, since no resize,crop
+        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
+        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
+        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
+        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
+        mIPUOutputParam.rot = pp_output->rot;
+        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
+        CAMERA_HAL_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+                mIPUOutputParam.width,
+                mIPUOutputParam.height,
+                mIPUOutputParam.output_win.pos.x,
+                mIPUOutputParam.output_win.pos.y,
+                mIPUOutputParam.output_win.win_w,
+                mIPUOutputParam.output_win.win_h,
+                mIPUOutputParam.rot);
+
+        CAMERA_HAL_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+                mIPUInputParam.width,
+                mIPUInputParam.height,
+                mIPUInputParam.fmt,
+                mIPUInputParam.input_crop_win.pos.x,
+                mIPUInputParam.input_crop_win.pos.y,
+                mIPUInputParam.input_crop_win.win_w,
+                mIPUInputParam.input_crop_win.win_h);	  
+
+        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
+            return PPDEVICE_ERROR_INIT;
+        }  
+
+        return ret;
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
+
+        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
+
+        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset,NULL,NULL,NULL);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
+            mxc_ipu_lib_task_uninit(&mIPUHandle);
+            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+            return PPDEVICE_ERROR_PROCESS;
+        }
+
+        return ret;
+
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        mxc_ipu_lib_task_uninit(&mIPUHandle);
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+
+        return ret;
+    }
+
+    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
+        CAMERA_HAL_LOG_FUNC;
+        if (singleton != 0) {
+            sp<PostProcessDeviceInterface> device = singleton.promote();
+            if (device != 0) {
+                return device;
+            }
+        }
+        sp<PostProcessDeviceInterface> device(new PPIpuLib());
+
+        singleton = device;
+        return device;
+    }
+
+};
diff --git a/libcamera/PP_ipulib.h b/libcamera/PP_ipulib.h
new file mode 100755
index 0000000..39b0d4c
--- /dev/null
+++ b/libcamera/PP_ipulib.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef PP_IPU_LIB_H
+#define PP_IPU_LIB_H
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+} 
+
+#include "PostProcessDeviceInterface.h"
+
+namespace android{
+    class PPIpuLib : public PostProcessDeviceInterface
+    {
+    public:
+        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
+        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
+        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
+        static sp<PostProcessDeviceInterface> createInstance();
+    private:
+        PPIpuLib();
+        virtual ~PPIpuLib();
+        static wp<PostProcessDeviceInterface> singleton;
+
+        ipu_lib_input_param_t mIPUInputParam;	
+        ipu_lib_output_param_t mIPUOutputParam; 
+        ipu_lib_handle_t			mIPUHandle;
+    };
+};
+#endif
diff --git a/libcamera/PostProcessDeviceInterface.cpp b/libcamera/PostProcessDeviceInterface.cpp
new file mode 100755
index 0000000..3d7e752
--- /dev/null
+++ b/libcamera/PostProcessDeviceInterface.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h" 
+namespace android{
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
+        return PPIpuLib :: createInstance();
+    }
+
+};
diff --git a/libcamera/PostProcessDeviceInterface.h b/libcamera/PostProcessDeviceInterface.h
new file mode 100755
index 0000000..9d730b6
--- /dev/null
+++ b/libcamera/PostProcessDeviceInterface.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef POSTPROCESS_DEVICE_INTERFACE_H
+#define POSTPROCESS_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+#include <linux/videodev2.h>
+
+namespace android {
+
+    typedef enum{
+        PPDEVICE_ERROR_NONE = 0,
+        PPDEVICE_ERROR_INIT = -1,
+        PPDEVICE_ERROR_PROCESS  = -2,
+        PPDEVICE_ERROR_DEINIT = -3
+    }PPDEVICE_ERR_RET;
+
+    struct pp_fb_pos{
+        unsigned short x;
+        unsigned short y;
+    };
+
+    struct win_t{
+        struct pp_fb_pos pos;
+        unsigned int win_w;
+        unsigned int win_h;
+    } ;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        struct win_t input_crop_win;
+        int user_def_paddr;
+    } pp_input_param_t;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        unsigned int rot;
+        struct win_t output_win;
+        int user_def_paddr;
+    } pp_output_param_t;
+
+
+    class PostProcessDeviceInterface : public virtual RefBase{
+    public:
+        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
+        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
+        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
+
+        virtual ~PostProcessDeviceInterface(){}
+    }; 
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
+
+};
+#endif
+
diff --git a/libcamera/V4l2CapDeviceBase.cpp b/libcamera/V4l2CapDeviceBase.cpp
new file mode 100755
index 0000000..1d82f15
--- /dev/null
+++ b/libcamera/V4l2CapDeviceBase.cpp
@@ -0,0 +1,602 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CapDeviceBase.h"
+
+
+
+
+namespace android{
+
+    V4l2CapDeviceBase ::V4l2CapDeviceBase()
+        :mCameraDevice(0),
+        mFmtParamIdx(0),
+        mSizeFPSParamIdx(0),
+        mRequiredFmt(0),
+        mBufQueNum(0),
+        mQueuedBufNum(0)
+
+    {
+        mCaptureDeviceName[0] = '#';
+    }
+
+    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
+    {
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::SetDevName(char * deviceName){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        if(NULL == deviceName)
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        strcpy(mInitalDeviceName, deviceName);
+        return ret;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::DevOpen(){
+        CAMERA_HAL_LOG_FUNC;
+
+        return V4l2Open(); 
+    } 
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        CAMERA_HAL_LOG_FUNC;
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        else
+            return V4l2EnumParam(devParamType,retParam);
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mCapCfg = *pCapcfg;
+        return V4l2SetConfig(pCapcfg);
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
+    }
+
+    CAPTURE_DEVICE_ERR_RET  V4l2CapDeviceBase :: DevPrepare(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Prepare();
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStart(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Start();
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Dequeue(pBufQueIdx);
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Queue(BufQueIdx);
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStop(){
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Stop();
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDeAllocate(){
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2DeAlloc();
+        }
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevClose(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Close();
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char   dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_capability v4l2_cap;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
+                        close(fd);
+                        continue;
+                    } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
+                            (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
+                        break;
+                    } else
+                        close(fd);
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_RUNTIME("devParamType is %d", devParamType);
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        switch(devParamType){
+            case OUTPU_FMT: 
+                ret = V4l2EnumFmt(retParam);
+                break;
+            case FRAME_SIZE_FPS:
+                {
+                    ret = V4l2EnumSizeFps(retParam);
+                    break;
+                }
+            default:
+                {
+                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+                    break;
+                }
+        }
+        return ret;
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_fmtdesc vid_fmtdesc;
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        vid_fmtdesc.index = mFmtParamIdx;
+        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }else{
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
+            *pParamVal = vid_fmtdesc.pixelformat;
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+        struct v4l2_frmivalenum vid_frmval;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
+            vid_frmval.pixel_format = pCapCfg->fmt;
+            vid_frmval.width = vid_frmsize.discrete.width;
+            vid_frmval.height= vid_frmsize.discrete.height;
+            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
+                CAMERA_HAL_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
+                mSizeFPSParamIdx = 0;
+                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+            }else{
+                pCapCfg->width	= vid_frmsize.discrete.width;
+                pCapCfg->height = vid_frmsize.discrete.height;
+                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
+                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
+                mSizeFPSParamIdx ++;
+                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+            }
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        *pMode = 0;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        struct v4l2_format fmt;
+        struct v4l2_control ctrl;
+        struct v4l2_streamparm parm;
+
+        V4l2ConfigInput(pCapcfg);
+
+        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
+        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
+            CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+            CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator, 
+                    parm.parm.capture.timeperframe.denominator);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
+
+        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
+        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
+        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+        else
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+        fmt.fmt.pix.priv = 0;
+        fmt.fmt.pix.sizeimage = 0;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("set format failed\n");
+            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
+                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        if(V4l2SetRot(pCapcfg) < 0)
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }else{
+
+            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+        }
+        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+        unsigned int i;
+        struct v4l2_buffer buf;
+        enum v4l2_buf_type type;
+        struct v4l2_requestbuffers req;
+        int BufQueNum;
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mBufQueNum = *pBufQueNum;
+
+        memset(&req, 0, sizeof (req));
+        req.count = mBufQueNum;
+        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        req.memory = V4L2_MEMORY_MMAP;
+        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        /*the driver may can't meet the request, and return the buf num it can handle*/
+        *pBufQueNum = mBufQueNum = req.count;
+
+        for (i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (buf));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.index = i;
+            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } else {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF ok\n");
+            }
+
+            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
+            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
+            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
+            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Prepare(){
+        CAMERA_HAL_LOG_FUNC;
+        struct v4l2_buffer buf;
+        mQueuedBufNum = 0;
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (struct v4l2_buffer));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.memory = V4L2_MEMORY_MMAP;
+            buf.index = i;
+            buf.m.offset = mCaptureBuffers[i].phy_offset;
+
+            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } 
+            mQueuedBufNum ++;
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Start(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else
+            CAMERA_HAL_ERR("VIDIOC_STREAMON ok\n");
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
+        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        *pBufQueIdx = cfilledbuffer.index;
+
+        mQueuedBufNum --;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
+        cfilledbuffer.index = BufQueIdx;
+        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        mQueuedBufNum ++;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Stop(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else
+            CAMERA_HAL_LOG_INFO("VIDIOC_STREAMOFF ok\n");
+
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
+                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+                mCaptureBuffers[i].length = 0;
+                CAMERA_HAL_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
+            }
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Close(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0 ){
+            CAMERA_HAL_LOG_INFO("the device handle is error");
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        CAMERA_HAL_LOG_INFO("close the device");
+        close(mCameraDevice);
+        mCameraDevice = -1;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+};
diff --git a/libcamera/V4l2CapDeviceBase.h b/libcamera/V4l2CapDeviceBase.h
new file mode 100755
index 0000000..e43daaf
--- /dev/null
+++ b/libcamera/V4l2CapDeviceBase.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CAP_DEVICE_BASE_H
+#define V4L2_CAP_DEVICE_BASE_H
+#include <linux/videodev2.h>
+
+#include "CaptureDeviceInterface.h"
+
+#define CAMAERA_FILENAME_LENGTH     256
+#define MAX_CAPTURE_BUF_QUE_NUM     6
+
+namespace android{
+
+    class V4l2CapDeviceBase : public CaptureDeviceInterface{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen();
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare();
+        virtual CAPTURE_DEVICE_ERR_RET DevStart();
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue( unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevStop();
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate();
+        virtual CAPTURE_DEVICE_ERR_RET DevClose();
+
+    protected:
+
+        V4l2CapDeviceBase();
+        virtual ~V4l2CapDeviceBase();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Open();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Prepare();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Start();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Dequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Queue(unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Stop();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2DeAlloc();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Close();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
+        char         mInitalDeviceName[CAMAERA_FILENAME_LENGTH];
+        int          mCameraDevice;
+        unsigned int mFmtParamIdx;
+        unsigned int mSizeFPSParamIdx;
+        unsigned int mRequiredFmt;
+        unsigned int mBufQueNum;
+        int          mQueuedBufNum;
+        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
+        struct   capture_config_t mCapCfg;
+
+    };
+};
+
+#endif
diff --git a/libcamera/V4l2CsiDevice.cpp b/libcamera/V4l2CsiDevice.cpp
new file mode 100755
index 0000000..84c84d9
--- /dev/null
+++ b/libcamera/V4l2CsiDevice.cpp
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CsiDevice.h"
+
+namespace android{
+    V4l2CsiDevice :: V4l2CsiDevice(){
+        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
+        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
+        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
+
+    }
+    V4l2CsiDevice :: ~V4l2CsiDevice()
+    {
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char	dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_dbg_chip_ident vid_chip;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
+                        close(fd);
+                        continue;
+                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        strcpy(mInitalDeviceName, vid_chip.match.name);
+                        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
+                        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
+                        break;
+                    } else{
+                        close(fd);
+                        fd = 0;
+                    }
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
+            *pParamVal = mSupportedFmt[mFmtParamIdx];
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }else{
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            pCapCfg->width  = vid_frmsize.discrete.width;
+            pCapCfg->height = vid_frmsize.discrete.height;
+            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 15;
+            }else{
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 30;
+            }
+            mSizeFPSParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int input = 1;
+        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
+            CAMERA_HAL_ERR("set input failed");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        unsigned int capturemode = 0;
+        unsigned int capturewidth =  pCapcfg->width;
+        unsigned int captureheight = pCapcfg->height;
+        unsigned int pic_waite_buf_num = 0;
+        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
+                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
+            pic_waite_buf_num = 2;
+            if (capturewidth == 640 && captureheight == 480)
+                capturemode = 0;	/* VGA mode */
+            else if (capturewidth == 320 && captureheight == 240)
+                capturemode = 1;	/* QVGA mode */
+            else if (capturewidth == 720 && captureheight == 576)
+                capturemode = 3;	/* PAL mode */
+            else if (capturewidth == 1280 && captureheight == 720)
+                capturemode = 4;	/* 720P mode */
+            else if (capturewidth == 1920 && captureheight == 1080){
+                pic_waite_buf_num = 5;
+                capturemode = 5;	/* 1080P mode */
+            }
+            else if (capturewidth == 2592 && captureheight == 1944) {
+                pic_waite_buf_num = 5;
+                capturemode = 6;	/* 2592x1944 mode */
+            }
+            else{
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
+            pic_waite_buf_num = 2;
+            if (capturewidth == 320 && captureheight == 240)
+                capturemode = 1;	/* QVGA mode */
+            else if (capturewidth == 640 && captureheight == 480)
+                capturemode = 0;	/* VGA mode */
+            else if (capturewidth == 720 && captureheight == 480)
+                capturemode = 4;
+            else if (capturewidth == 720 && captureheight == 576)
+                capturemode = 5;
+            else if (capturewidth == 2048 && captureheight == 1536)
+            {
+                pic_waite_buf_num = 10;
+                capturemode = 3;	/* QXGA mode */
+            }
+            else
+            {
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else{
+            capturemode = 0;
+            pic_waite_buf_num = 0;
+        }
+
+        CAMERA_HAL_LOG_INFO("the mode is %d", capturemode);
+        *pMode = capturemode;
+        pCapcfg->picture_waite_number = pic_waite_buf_num;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        int g_rotate = 0;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        struct v4l2_control ctrl;
+
+        // Set rotation
+        ctrl.id = V4L2_CID_PRIVATE_BASE + 0;
+        ctrl.value = g_rotate;
+        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
+            CAMERA_HAL_ERR("set ctrl failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        return ret;
+    }
+};
+
diff --git a/libcamera/V4l2CsiDevice.h b/libcamera/V4l2CsiDevice.h
new file mode 100755
index 0000000..7ff5468
--- /dev/null
+++ b/libcamera/V4l2CsiDevice.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CSI_DEVICE_H
+#define V4L2_CSI_DEVICE_H
+
+#include <linux/videodev2.h>
+#include "V4l2CapDeviceBase.h"
+#define ENUM_SUPPORTED_FMT     3
+
+#define OV3640_NAME_STR   "ov3640"
+#define OV5640_NAME_STR   "ov5640"
+#define OV5642_NAME_STR   "ov5642"
+namespace android{
+
+class V4l2CsiDevice : public V4l2CapDeviceBase{
+    public:
+        
+        V4l2CsiDevice();
+        virtual ~V4l2CsiDevice();
+    protected:
+		
+		CAPTURE_DEVICE_ERR_RET V4l2Open();
+		CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+        CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
+   };
+
+};
+#endif
+
+
diff --git a/libcamera/V4l2UVCDevice.h b/libcamera/V4l2UVCDevice.h
new file mode 100755
index 0000000..f3af040
--- /dev/null
+++ b/libcamera/V4l2UVCDevice.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_UVC_DEVICE_H
+#define V4L2_UVC_DEVICE_H
+
+#include <linux/videodev2.h>
+
+
+#include "V4l2CapDeviceBase.h"
+
+#define MAX_DEV_NAME_LENGTH 10
+
+namespace android{
+
+    class V4l2UVCDevice : public V4l2CapDeviceBase{
+    public:
+        V4l2UVCDevice(){}
+        ~V4l2UVCDevice(){}
+
+    };
+
+};
+#endif
+
diff --git a/liboverlay/overlay_thread.h b/liboverlay/overlay_thread.h
index a6bf505..1e20999 100755
--- a/liboverlay/overlay_thread.h
+++ b/liboverlay/overlay_thread.h
@@ -419,7 +419,7 @@ class OverlayThread: public Thread {
                 mIPUInputParam.input_crop_win.win_h = crop_h0;
 
                 if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-                    mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+                    mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
                 }
                 else if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
                     mIPUInputParam.fmt = v4l2_fourcc('N', 'Y', '1', '2');
@@ -496,7 +496,7 @@ class OverlayThread: public Thread {
 
 
                 if(overlayObj1->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-                    mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+                    mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
                 }
                 else if(overlayObj1->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
                     mIPUInputParam.fmt = v4l2_fourcc('N', 'Y', '1', '2');
-- 
1.8.0

