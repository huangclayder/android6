From 7d1744a421bd6bd0b76b99ea582c76bbb146abac Mon Sep 17 00:00:00 2001
From: Oliver Brown <oliver.brown@freescale.com>
Date: Wed, 17 Oct 2012 15:03:04 -0500
Subject: [PATCH 352/635] ENGR00229443 - Need to add support for Vsync in iMX5
 Android Jelly Bean

The hardware composer for Android Jelly Bean needs to support Vsync events.
Hardware composer clears swap buffer to remove video artifacts.

Signed-off-by: Oliver Brown <oliver.brown@freescale.com>
---
 mx5x/hwcomposer/Android.mk        |  10 +-
 mx5x/hwcomposer/BG_device.cpp     | 174 ---------
 mx5x/hwcomposer/FG_device.cpp     | 313 -----------------
 mx5x/hwcomposer/README.android    |   3 -
 mx5x/hwcomposer/blit_gpu.cpp      |  57 ---
 mx5x/hwcomposer/blit_gpu.h        |  58 ---
 mx5x/hwcomposer/blit_ipu.cpp      | 294 ----------------
 mx5x/hwcomposer/blit_ipu.h        |  71 ----
 mx5x/hwcomposer/hwc_common.cpp    | 261 --------------
 mx5x/hwcomposer/hwc_common.h      | 250 -------------
 mx5x/hwcomposer/hwc_context.h     |  52 +++
 mx5x/hwcomposer/hwc_vsync.cpp     |  77 ++++
 mx5x/hwcomposer/hwc_vsync.h       |  61 ++++
 mx5x/hwcomposer/hwcomposer.cpp    | 719 +++++++-------------------------------
 mx5x/hwcomposer/output_device.cpp | 187 ----------
 15 files changed, 317 insertions(+), 2270 deletions(-)
 delete mode 100755 mx5x/hwcomposer/BG_device.cpp
 delete mode 100755 mx5x/hwcomposer/FG_device.cpp
 delete mode 100755 mx5x/hwcomposer/README.android
 delete mode 100755 mx5x/hwcomposer/blit_gpu.cpp
 delete mode 100755 mx5x/hwcomposer/blit_gpu.h
 delete mode 100755 mx5x/hwcomposer/blit_ipu.cpp
 delete mode 100755 mx5x/hwcomposer/blit_ipu.h
 delete mode 100755 mx5x/hwcomposer/hwc_common.cpp
 delete mode 100755 mx5x/hwcomposer/hwc_common.h
 create mode 100755 mx5x/hwcomposer/hwc_context.h
 create mode 100755 mx5x/hwcomposer/hwc_vsync.cpp
 create mode 100755 mx5x/hwcomposer/hwc_vsync.h
 delete mode 100755 mx5x/hwcomposer/output_device.cpp

diff --git a/mx5x/hwcomposer/Android.mk b/mx5x/hwcomposer/Android.mk
index 824b1cd..474afbe 100755
--- a/mx5x/hwcomposer/Android.mk
+++ b/mx5x/hwcomposer/Android.mk
@@ -21,12 +21,14 @@ ifeq ($(TARGET_HAVE_IMX_HWCOMPOSER),true)
 include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils libui libhardware
-LOCAL_SRC_FILES := hwcomposer.cpp BG_device.cpp FG_device.cpp hwc_common.cpp blit_gpu.cpp blit_ipu.cpp output_device.cpp
+LOCAL_SHARED_LIBRARIES := liblog libEGL libcutils libutils libui libhardware libhardware_legacy libGLESv1_CM
+LOCAL_SRC_FILES := hwcomposer.cpp hwc_vsync.cpp
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
 LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
-LOCAL_C_INCLUDES += external/linux-lib/ipu
 LOCAL_CFLAGS:= -DLOG_TAG=\"hwcomposer\"
-LOCAL_MODULE_TAGS := eng
+LOCAL_CFLAGS += -DENABLE_VSYNC 
+#LOCAL_CFLAGS += -DDEBUG_HWC_VSYNC_TIMING
+
+LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
 endif
diff --git a/mx5x/hwcomposer/BG_device.cpp b/mx5x/hwcomposer/BG_device.cpp
deleted file mode 100755
index a920e23..0000000
--- a/mx5x/hwcomposer/BG_device.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-#include <hardware/hardware.h>
-//#include <hardware/overlay.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-using namespace android;
-
-//note: the fb1 in mx5x is hdmi port and should use 1080p=1920_1080. 
-BG_device::BG_device(const char *dev_name, int usage) 
-			: output_device(dev_name, usage)
-{
-		init();
-}
-
-BG_device::~BG_device()
-{
-		uninit();
-}
-
-int BG_device::init()
-{
-	  int status = -EINVAL;
-	  int fbSize = 0;
-	  void *vaddr = NULL;
-
-    if(m_dev <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_init invalid parameter!");
-    	  return -1;       	
-    }
-    
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init VSCREENINFO getting failed!");
-    	  return -1;    	  
-    }
-    
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init FSCREENINFO getting failed!");
-    	  return -1;       	
-    }
-    
-   // m_left = 0;
-   // m_top = 0;
-    m_width = info.xres;
-    m_height = info.yres;
-    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
-  	
-  	info.reserved[0] = 0;
-  	info.reserved[1] = 0;
-  	info.reserved[2] = 0;  
-  	info.xoffset = 0;
-  	info.yoffset = 0;
-  	info.activate = FB_ACTIVATE_NOW;
-  	
-  	info.bits_per_pixel = fmt_to_bpp(m_format);
-  	info.nonstd = m_format;
-  	info.red.offset = 0;
-  	info.red.length = 0;
-  	info.green.offset = 0;
-  	info.green.length = 0;
-  	info.blue.offset = 0;
-  	info.blue.length = 0;
-  	info.transp.offset = 0;
-  	info.transp.length = 0;	 
-  	
-  	info.xres = m_width;
-  	info.yres = m_height;
-  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
-  	info.xres_virtual = ALIGN_PIXEL(info.xres);
-  	
-    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
-    	  return -1;    	  
-    }
-
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO getting failed!");
-    	  return -1;    	  
-    }
-
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 FSCREENINFO getting failed!");
-    	  return -1;       	
-    }
-  	
-  	if(finfo.smem_len <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init finfo.smem_len < 0!");
-    	  return -1;      		
-  	}
-  	
-  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
-  	if(vaddr == MAP_FAILED) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init mapping the framebuffer error(%s)!", strerror(errno));
-    	  return -1;    		
-  	}
-
-        hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format); 
-        int blank = FB_BLANK_UNBLANK;
-	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!BG_device::init UNBLANK FB1 failed!\n");
-        return -1;
-	} 	
-//  	key.enable = 1;
-//  	key.color_key = 0x00000000; //black
-//  	if(ioctl(m_dev, MXCFB_SET_CLR_KEY, &key) < 0) {
-//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-//    	  return -1;    		
-//  	}
-//  	
-//  	gbl_alpha.alpha = 255;
-//  	gbl_alpha.enable = 1;
-//  	if(ioctl(m_dev, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-//    	  return -1;    		
-//  	}  	
-  	
-  	mbuffer_count = DEFAULT_BUFFERS;
-  	mbuffer_cur = 0;
-  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
-  			(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
-  			(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
-  			(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
-  			(mbuffers[i]).format = m_format;
-  	}
-	
-    status = 0;
-    return status;
-}
-
-int BG_device::uninit()
-{
-	  //int status = -EINVAL;    
-    int blank = 1;
-    HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
-
-    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
-        //return -1;
-    }	  
-    munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
-    close(m_dev);
-
-    return 0;
-}
diff --git a/mx5x/hwcomposer/FG_device.cpp b/mx5x/hwcomposer/FG_device.cpp
deleted file mode 100755
index 4d07459..0000000
--- a/mx5x/hwcomposer/FG_device.cpp
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <linux/fb.h>
-#include <linux/mxcfb.h>
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-using namespace android;
-
-FG_device::FG_device(const char *dev_name, int usage)
-			: output_device(dev_name, usage)
-{
-		init();
-}
-
-FG_device::~FG_device()
-{
-		uninit();
-}
-
-static int switch_set(int fd0, int fd1, int flag)
-{
-    struct mxcfb_gbl_alpha gbl_alpha;
-    struct mxcfb_color_key key;
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-		  	key.enable = 1;
-		  	key.color_key = 0x00000000; //black
-		  	if(ioctl(fd0, MXCFB_SET_CLR_KEY, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-
-		  	gbl_alpha.alpha = 128;
-		  	gbl_alpha.enable = 1;
-		  	if(ioctl(fd0, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-  	}
-
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-		  	key.enable = 1;
-		  	key.color_key = 0x00000000; //black
-		  	if(ioctl(fd1, MXCFB_SET_CLR_KEY, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-
-		  	gbl_alpha.alpha = 255;
-		  	gbl_alpha.enable = 1;
-		  	if(ioctl(fd1, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-  	}
-
-		return 0;
-}
-
-static int overlay_switch(int fd0, int fd1, int fd2, int flag)
-{
-		int blank = 1;
-  	int fp_property;
-  	char overlayStr[32];
-  	// it may be modified in mx6x.
-
-		if(ioctl(fd2, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
-        return -1;
-		}
-
-		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB1 failed!\n");
-	      return -1;
-		}
-
-	  if(ioctl(fd0, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
-	      return -1;
-		}
-
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-  			//fp_property;
-
-		    HWCOMPOSER_LOG_ERR("Open fb0/fsl_disp_property");
-		    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0);
-		    if(fp_property < 0) {
-		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
-		         return -1;
-		    }
-
-		    memset(overlayStr, 0 ,32);
-		    strcpy(overlayStr, "1-layer-fb\n");
-		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb0/fsl_disp_property");
-		    write(fp_property, overlayStr, strlen(overlayStr)+1);
-		    close(fp_property);
-
-  	}
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-		    HWCOMPOSER_LOG_ERR("Open fb1/fsl_disp_property");
-		    fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0);
-		    if(fp_property < 0) {
-		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
-		         return -1;
-		    }
-
-		    memset(overlayStr, 0 ,32);
-		    strcpy(overlayStr, "1-layer-fb\n");
-		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb1/fsl_disp_property");
-		    write(fp_property, overlayStr, strlen(overlayStr)+1);
-		    close(fp_property);
-  	}
-
-    blank = FB_BLANK_UNBLANK;
-		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB1 failed!\n");
-	      return -1;
-		}
-
-		if(ioctl(fd0, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB0 failed!\n");
-	      return -1;
-		}
-
-		return 0;
-}
-
-int FG_device::init()
-{
-    int status = -EINVAL;
-    int fbSize = 0;
-    void *vaddr = NULL;
-    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
-    if(m_dev <= 0) {
-        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
-        return -1;
-    }
-#if 1
-    //fist open fb0 device that it is binded to.
-    //it may be modified in mx6x
-    int fd_def = -1;
-    if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-            HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
-	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_def < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
-	    	  return -1;
-	    }
-    }
-    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
-            HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb2-------------");
-	    fd_def = open(FB2_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_def < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB2_DEV_NAME);
-	    	  return -1;
-	    }
-    }
-    else {
-         HWCOMPOSER_LOG_ERR("Error! %s does not support usage=0x%x!", __FUNCTION__, m_usage);
-         return -1;
-    }
-  	//it may be modified in mx6x
-
-//    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
-
-    struct fb_var_screeninfo def_info;
-    if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
-    	  return -1;
-    }
-
-    struct fb_fix_screeninfo def_finfo;
-    if(ioctl(fd_def, FBIOGET_FSCREENINFO, &def_finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO def getting failed!");
-    	  return -1;
-    }
-
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-    m_width = def_info.xres;//info.xres;
-    m_height = def_info.yres;//info.yres;
-    m_format = fourcc('U', 'Y', 'V', 'Y');
-
-  	info.reserved[0] = def_info.reserved[0];
-  	info.reserved[1] = def_info.reserved[0];
-  	info.reserved[2] = def_info.reserved[0];
-  	info.xoffset = 0;
-  	info.yoffset = 0;
-  	info.activate = FB_ACTIVATE_NOW;
-
-  	info.bits_per_pixel = fmt_to_bpp(m_format);//def_info.bits_per_pixel;
-  	info.nonstd = m_format;
-  	info.red.offset = 0;//def_info.red.offset;
-  	info.red.length = 0;//def_info.red.length;
-  	info.green.offset = 0;//def_info.green.offset;
-  	info.green.length = 0;//def_info.green.length;
-  	info.blue.offset = 0;//def_info.blue.offset;
-  	info.blue.length = 0;//def_info.blue.length;
-  	info.transp.offset = 0;//def_info.transp.offset;
-  	info.transp.length = 0;//def_info.transp.length;
-
-  	info.xres = m_width;
-  	info.yres = m_height;
-  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
-  	info.xres_virtual = ALIGN_PIXEL(info.xres);
-
-    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO setting failed!");
-    	  return -1;
-    }
-
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 FSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-  	if(finfo.smem_len <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init finfo.smem_len < 0!");
-    	  return -1;
-  	}
-
-  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
-  	if(vaddr == MAP_FAILED) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init mapping the framebuffer error(%s)!", strerror(errno));
-    	  return -1;
-  	}
-    //memset(vaddr, 0, fbSize);
-    hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format);
-    int blank = FB_BLANK_UNBLANK;
-	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!FG_device::init UNBLANK FB1 failed!\n");
-        return -1;
-	}
-  	//do it after switch fb2 to fb1 or fb0
-  	//status = switch_set(fd_def, fd_fb1, m_usage);
-  	close(fd_def);
-
-  	mbuffer_count = DEFAULT_BUFFERS;
-  	mbuffer_cur = 0;
-  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
-		(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
-		(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
-		(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
-		(mbuffers[i]).width = m_width;
-        (mbuffers[i]).height = m_height;
-        (mbuffers[i]).format = m_format;
-  	}
-
-  	//pthread_mutex_init(&dev->buf_mutex, NULL);
-#endif
-    status = 0;
-    return status;
-}
-
-int FG_device::uninit()
-{
-	  //int status = -EINVAL;
-    int blank = 1;
-    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::uninit()------------");
-
-    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!FG_device::uninit BLANK FB2 failed!\n");
-        //return -1;
-	}
-	munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
-    close(m_dev);
-    return 0;
-}
-
diff --git a/mx5x/hwcomposer/README.android b/mx5x/hwcomposer/README.android
deleted file mode 100755
index 4aa7203..0000000
--- a/mx5x/hwcomposer/README.android
+++ /dev/null
@@ -1,3 +0,0 @@
-
-Skeleton for the "hwcomposer" HAL module.
-
diff --git a/mx5x/hwcomposer/blit_gpu.cpp b/mx5x/hwcomposer/blit_gpu.cpp
deleted file mode 100755
index 37e4a78..0000000
--- a/mx5x/hwcomposer/blit_gpu.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_gpu.h"
-/*****************************************************************************/
-using namespace android;
-
-blit_gpu::blit_gpu()
-{
-		init();
-}
-
-blit_gpu::~blit_gpu()
-{
-		uninit();
-}
-
-int blit_gpu::init()
-{
-		return 0;
-}
-
-int blit_gpu::uninit()
-{
-		return 0;
-}
-
-int blit_gpu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
-{
-		return 0;
-}
diff --git a/mx5x/hwcomposer/blit_gpu.h b/mx5x/hwcomposer/blit_gpu.h
deleted file mode 100755
index f191e68..0000000
--- a/mx5x/hwcomposer/blit_gpu.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#ifndef _BLIT_GPU_H_
-#define _BLIT_GPU_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-
-class blit_gpu : public blit_device{
-public:  
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
-
-		blit_gpu();
-		virtual ~blit_gpu();
-    
-private:
-		int init();
-    int uninit();
-	
-		blit_gpu& operator = (blit_gpu& out);
-		blit_gpu(const blit_gpu& out);  
-    //add private members.		    
-};
-
-
-//int gpu_init(struct blit_device *dev);
-//
-//int gpu_uninit(struct blit_device*dev);
-//
-//int gpu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
-
-#endif
diff --git a/mx5x/hwcomposer/blit_ipu.cpp b/mx5x/hwcomposer/blit_ipu.cpp
deleted file mode 100755
index 34afcc2..0000000
--- a/mx5x/hwcomposer/blit_ipu.cpp
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_ipu.h"
-
-/*****************************************************************************/
-using namespace android;
-
-int blit_device::isIPUDevice(const char *dev_name)
-{
-		return !strcmp(dev_name, BLIT_IPU);
-}
-
-int blit_device::isGPUDevice(const char *dev_name)
-{
-		return !strcmp(dev_name, BLIT_GPU);
-}
-
-blit_ipu::blit_ipu()
-{
-    memset(&mTask, 0, sizeof(mTask));
-	init();
-}
-
-blit_ipu::~blit_ipu()
-{
-	uninit();
-}
-
-int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
-{
-	int status = -EINVAL;
-    mIpuFd = open("/dev/mxc_ipu", O_RDWR, 0);
-    if(mIpuFd < 0) {
-        HWCOMPOSER_LOG_ERR("%s:%d,open ipu dev failed", __FUNCTION__, __LINE__);
-        return status;
-    }
-
-    return 0;
-}
-
-int blit_ipu::uninit()
-{
-	//int status = -EINVAL;
-    if(mIpuFd)
-        close(mIpuFd);
-
-	return 0;
-}
-
-static void fill_buffer(char *pbuf, int len)
-{
-    static int k = 0;
-    short * pframe = (short *)pbuf;
-    if(k == 0) {
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0xf800;
-        }
-    }
-
-    if(k == 1){
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0x001f;
-        }
-    }
-
-    if(k == 2){
-        for(int i=0; i<len; i+=2) {
-            *pframe = 0x07E0;
-        }
-    }
-
-    k = (k+1)%3;
-}
-
-static void dump_ipu_task(struct ipu_task *t)
-{
-    HWCOMPOSER_LOG_ERR("======ipu task=====");
-    HWCOMPOSER_LOG_ERR("input:");
-    HWCOMPOSER_LOG_ERR("\tbuffer: %d", t->input.paddr);
-    HWCOMPOSER_LOG_ERR("\twidth: %d", t->input.width);
-    HWCOMPOSER_LOG_ERR("\theight: %d", t->input.height);
-    HWCOMPOSER_LOG_ERR("\tcrop.w =%d", t->input.crop.w);
-    HWCOMPOSER_LOG_ERR("\tcrop.h =%d", t->input.crop.h);
-    HWCOMPOSER_LOG_ERR("\tcrop.pos.x =%d", t->input.crop.pos.x);
-    HWCOMPOSER_LOG_ERR("\tcrop.pos.y =%d", t->input.crop.pos.y);
-    HWCOMPOSER_LOG_ERR("output:");
-    HWCOMPOSER_LOG_ERR("\twidth: %d", t->output.width);
-    HWCOMPOSER_LOG_ERR("\theight: %d", t->output.height);
-    HWCOMPOSER_LOG_ERR("\tcrop.w =%d", t->output.crop.w);
-    HWCOMPOSER_LOG_ERR("\tcrop.h =%d", t->output.crop.h);
-    HWCOMPOSER_LOG_ERR("\tcrop.pos.x =%d", t->output.crop.pos.x);
-    HWCOMPOSER_LOG_ERR("\tcrop.pos.y =%d", t->output.crop.pos.y);
-}
-
-int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
-{
-	  int status = -EINVAL;
-          char value[10];
-          int hdmi_full_screen = 0;
-	  if(mIpuFd < 0 || layer == NULL || out_buf == NULL){
-	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
-	  	  return status;
-	  }
-	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
-
-      HWCOMPOSER_LOG_RUNTIME("%s start", __FUNCTION__);
-	  hwc_rect_t *src_crop = &(layer->sourceCrop);
-	  hwc_rect_t *disp_frame = &(layer->displayFrame);
-	  private_handle_t *handle = (private_handle_t *)(layer->handle);
-
-    //fill_buffer((char *)(handle->base), handle->size);
-
-    mTask.input.width = handle->width;//src_crop->right - src_crop->left;
-    mTask.input.height = handle->height;//src_crop->bottom - src_crop->top;
-    mTask.input.crop.pos.x = src_crop->left;
-    mTask.input.crop.pos.y = src_crop->top;
-    mTask.input.crop.w = src_crop->right - src_crop->left;
-    mTask.input.crop.h = src_crop->bottom - src_crop->top;
-
-    if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= NV12", __FUNCTION__);
-        mTask.input.format = v4l2_fourcc('N', 'V', '1', '2');
-    }
-    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
-        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= I420", __FUNCTION__);
-        mTask.input.format = v4l2_fourcc('I', '4', '2', '0');
-    }
-    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_422_I) {
-        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= 422P", __FUNCTION__);
-        mTask.input.format = v4l2_fourcc('4', '2', '2','P');
-    } else if (handle->format == HAL_PIXEL_FORMAT_YV12) {
-        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= 422P", __FUNCTION__);
-        mTask.input.format = v4l2_fourcc('Y', 'V', '1','2');
-    }
-    else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
-        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= RGBP", __FUNCTION__);
-        mTask.input.format = v4l2_fourcc('R', 'G', 'B', 'P');
-        //mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
-    }else{
-        HWCOMPOSER_LOG_ERR("%s, Error!Not supported input format %d", __FUNCTION__, handle->format);
-        return status;
-    }
-
-    mTask.input.paddr = handle->phys;
-    //out_buf should has width and height to be checked with the display_frame.
-    mTask.output.format = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
-
-    property_get("sys.HDMI_FULL_SCREEN", value, "");
-    if(strcmp(value, "1") == 0) {
-        hdmi_full_screen = 1;
-    }
-    else {
-        hdmi_full_screen = 0;
-    }
-
-    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK || (hdmi_full_screen && 
-                        (out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2))) { 
-	    mTask.output.width = out_buf->width;
-	    mTask.output.height = out_buf->height;
-	    mTask.output.crop.pos.x = 0;
-	    mTask.output.crop.pos.y = 0;
-	    mTask.output.crop.w = out_buf->width;
-	    mTask.output.crop.h = out_buf->height;
-    }
-    else if((out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) && 
-               (out_buf->width != m_def_disp_w || out_buf->height!= m_def_disp_h)){
-            int def_w,def_h;
-            int dst_w = out_buf->width;
-            int dst_h = out_buf->height;
-
-            mTask.output.width = out_buf->width;//disp_frame->right - disp_frame->left;
-            mTask.output.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
-
-            if(layer->transform == 0 || layer->transform == 3)
-            {
-                 def_w = m_def_disp_w;
-                 def_h = m_def_disp_h;
-
-                 mTask.output.crop.pos.x = (disp_frame->left >> 3) << 3;
-                 mTask.output.crop.pos.y = (disp_frame->top >> 3) << 3;
-                 mTask.output.crop.w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-                 mTask.output.crop.h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
-            }
-            else
-            {
-                 def_w = m_def_disp_h;
-                 def_h = m_def_disp_w;
-
-                 mTask.output.crop.pos.y = (disp_frame->left >> 3) << 3;
-                 mTask.output.crop.pos.x = (disp_frame->top >> 3) << 3;
-                 mTask.output.crop.h = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-                 mTask.output.crop.w = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
-             }
-             if(dst_w >= dst_h*def_w/def_h){
-                 dst_w = dst_h*def_w/def_h;
-             }
-             else{
-                 dst_h = dst_w*def_h/def_w;
-             }
-
-            mTask.output.crop.pos.x = mTask.output.crop.pos.x * dst_w / def_w;
-            mTask.output.crop.pos.y = mTask.output.crop.pos.y * dst_h / def_h;
-            mTask.output.crop.w = mTask.output.crop.w * dst_w / def_w;
-            mTask.output.crop.h = mTask.output.crop.h * dst_h / def_h;
-            mTask.output.crop.pos.x += (out_buf->width - dst_w) >> 1;
-            mTask.output.crop.pos.y += (out_buf->height - dst_h) >> 1;
-
-            mTask.output.crop.pos.x = (mTask.output.crop.pos.x >> 3) << 3;
-            mTask.output.crop.pos.y = (mTask.output.crop.pos.y >> 3) << 3;
-            mTask.output.crop.w = (mTask.output.crop.w >> 3) << 3;
-            mTask.output.crop.h = (mTask.output.crop.h >> 3) << 3;
-            mTask.output.rotate = layer->transform;
-    }
-    else {
-	    mTask.output.width = out_buf->width;//disp_frame->right - disp_frame->left;
-	    mTask.output.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
-	    mTask.output.crop.pos.x = (disp_frame->left >> 3) << 3;
-	    mTask.output.crop.pos.y = (disp_frame->top >> 3) << 3;
-	    mTask.output.crop.w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-	    mTask.output.crop.h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
-            mTask.output.rotate = layer->transform;
-    }
-    //mTask.output.rotate = layer->transform;
-    mTask.output.paddr = out_buf->phy_addr;
-    int ret = IPU_CHECK_ERR_INPUT_CROP; 
-    
-    while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
-        ret = ioctl(mIpuFd, IPU_CHECK_TASK, &mTask);
-        HWCOMPOSER_LOG_RUNTIME("%s:%d, IPU_CHECK_TASK ret=%d", __FUNCTION__, __LINE__, ret);
-        //dump_ipu_task(&mTask);
-        switch(ret) {
-            case IPU_CHECK_OK:
-                break;
-            case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
-                mTask.input.crop.w -= 8;
-                break;
-            case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
-                mTask.input.crop.h -= 8;
-                break;
-            case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
-                mTask.output.crop.w -= 8;
-                break;
-            case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
-                mTask.output.crop.h -= 8;;
-                break;
-            default:
-                //dump_ipu_task(&mTask);
-                HWCOMPOSER_LOG_ERR("%s:%d, IPU_CHECK_TASK ret=%d", __FUNCTION__, __LINE__, ret);
-                return status;
-        }
-    }
-
-    //if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
-        //status = mxc_ipu_lib_task_init(&mTask.input,NULL,&mTask.output,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-    //else
-        //status = mxc_ipu_lib_task_init(&mTask.input,NULL,&mTask.output,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-      status = ioctl(mIpuFd, IPU_QUEUE_TASK, &mTask);
-	  if(status < 0) {
-	  		HWCOMPOSER_LOG_ERR("%s:%d, IPU_QUEUE_TASK failed %d", __FUNCTION__, __LINE__ ,status);
-	  		return status;
-	  }
-	  status = 0;
-      HWCOMPOSER_LOG_RUNTIME("%s end", __FUNCTION__);
-	  return status;
-}
diff --git a/mx5x/hwcomposer/blit_ipu.h b/mx5x/hwcomposer/blit_ipu.h
deleted file mode 100755
index 8eae6b0..0000000
--- a/mx5x/hwcomposer/blit_ipu.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved. */
-
-#ifndef _BLIT_IPU_H_
-#define _BLIT_IPU_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include <linux/ipu.h>
-//extern "C" {
-//#include "mxc_ipu_hl_lib.h"
-//}
-/*****************************************************************************/
-
-#define BLIT_PIXEL_FORMAT_RGB_565  209
-
-class blit_ipu : public blit_device
-{
-public:
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
-
-	blit_ipu();
-	virtual ~blit_ipu();
-
-private:
-    struct ipu_task mTask;
-    int mIpuFd;
-	//ipu_lib_input_param_t  mIPUInputParam;
-    //ipu_lib_output_param_t mIPUOutputParam;
-    //ipu_lib_handle_t       mIPUHandle;
-//    int                    mIPURet;
-private:
-	int init();
-    int uninit();
-
-	blit_ipu& operator = (blit_ipu& out);
-	blit_ipu(const blit_ipu& out);
-};
-
-
-//int ipu_init(struct blit_device *dev);
-//
-//int ipu_uninit(struct blit_device*dev);
-//
-//int ipu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
-
-#endif // _BLIT_IPU_H_
diff --git a/mx5x/hwcomposer/hwc_common.cpp b/mx5x/hwcomposer/hwc_common.cpp
deleted file mode 100755
index ed93a3d..0000000
--- a/mx5x/hwcomposer/hwc_common.cpp
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_gpu.h"
-#include "blit_ipu.h"
-#include <linux/ipu.h>
-//extern "C" {
-//#include "mxc_ipu_hl_lib.h" 
-//}
-/*****************************************************************************/
-using namespace android;
-//int hwc_check_property(hwc_context_t *dev)
-//{
-//    bool bValue = false;
-//    char value[10];
-//    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
-//    if (strcmp(value, "1") == 0)
-//        bValue = true;
-//
-//    if((dev->display_mode == DISPLAY_MODE_TV)  !=  bValue){
-//        dev->display_mode = bValue ? DISPLAY_MODE_TV : DISPLAY_MODE_NORMAL;
-//        switchTvOut(dev);
-//        *mode_changed = true;
-//        return 0;
-//    }
-//
-//    bValue = false;
-//    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
-//    if (strcmp(value, "1") == 0)
-//        bValue = true;
-//
-//    if((dev->display_mode == DISPLAY_MODE_DUAL_DISP)  !=  bValue){
-//        dev->display_mode = bValue ? DISPLAY_MODE_DUAL_DISP : DISPLAY_MODE_NORMAL;
-//        switchDualDisp(dev);
-//        *mode_changed = true;
-//    }    	
-//		return 0;
-//}
-
-
-unsigned long fmt_to_bpp(unsigned long pixelformat)
-{
-	unsigned long bpp;
-
-	switch (pixelformat)
-	{
-		case OUT_PIX_FMT_RGB565:
-		/*interleaved 422*/
-		case OUT_PIX_FMT_YUYV:
-		case OUT_PIX_FMT_UYVY:
-		/*non-interleaved 422*/
-		case OUT_PIX_FMT_YUV422P:
-		case OUT_PIX_FMT_YVU422P:
-			bpp = 16;
-			break;
-		case OUT_PIX_FMT_BGR24:
-		case OUT_PIX_FMT_RGB24:
-		case OUT_PIX_FMT_YUV444:
-			bpp = 24;
-			break;
-		case OUT_PIX_FMT_BGR32:
-		case OUT_PIX_FMT_BGRA32:
-		case OUT_PIX_FMT_RGB32:
-		case OUT_PIX_FMT_RGBA32:
-		case OUT_PIX_FMT_ABGR32:
-			bpp = 32;
-			break;
-		/*non-interleaved 420*/
-		case OUT_PIX_FMT_YUV420P:
-		case OUT_PIX_FMT_YVU420P:
-		case OUT_PIX_FMT_YUV420P2:
-		case OUT_PIX_FMT_NV12:
-			bpp = 12;
-			break;
-		default:
-			bpp = 8;
-			break;
-	}
-	return bpp;
-}
-
-int hwc_fill_frame_back(char * frame,int frame_size, int xres,
-                           int yres, unsigned int pixelformat)
-{
-    int ret = 0;
-    char * base;
-    int j, screen_size;
-    short * tmp;
-    short color;
-    if((xres<=0)||(yres<=0)||(!frame)) {
-        HWCOMPOSER_LOG_ERR("Error!Not valid parameters in fill_frame_back");
-        return -1;
-    }
-    switch(pixelformat) {
-        case OUT_PIX_FMT_RGB565:
-            memset(frame, 0, frame_size);
-            break;
-        case OUT_PIX_FMT_YUYV:
-        case OUT_PIX_FMT_UYVY:
-            tmp = (short *) frame;
-            if(pixelformat == OUT_PIX_FMT_YUYV)
-               color = 0x8000;
-            else
-               color = 0x80;
-            for(int i = 0; i < frame_size/2;i++, tmp++)
-                *tmp = color;
-            break;
-        case OUT_PIX_FMT_YUV422P:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size; i++, base++)
-                *base = 0x80;
-            break;
-        case OUT_PIX_FMT_YUV420:
-        case OUT_PIX_FMT_YVU420:
-        case OUT_PIX_FMT_NV12:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size/2; i++, base++)
-                 *base = 0x80;
-            break;
-        defaule:
-            HWCOMPOSER_LOG_ERR("Error!Not supported pixel format");
-            ret = -1;
-            break;
-    }
-    return ret;
-}
-
-int blit_dev_open(const char *dev_name, blit_device **device)
-{
-	  int status = -EINVAL;
-	  
-	  int isIPU = blit_device::isIPUDevice(dev_name);	  
-	  if(isIPU) {
-	  	  blit_ipu *dev;
-	  	  dev = new blit_ipu();
-	  	  if(dev == NULL)
-	  	      return status;
-	  	  
-	  	  *device = (blit_device *)dev;
-	  	  return 0;
-	  }
-	  
-	  int isGPU = blit_device::isGPUDevice(dev_name);
-	  if(isGPU) {
-	  	  blit_gpu *dev;
-	  	  dev = new blit_gpu();
-	  	  if(dev == NULL)
-	  	      return status;
-	  	      	  	  
-	  	  *device = (blit_device *)dev;
-	  	  return 0;	  	  	  
-	  }	  
-	  
-	  return status;
-}
-
-int blit_dev_close(blit_device *dev)
-{
-		delete(dev);
-		return 0;
-}
-
-int output_dev_open(const char *dev_name, output_device **device, int flag)
-{
-   	int is_overlay = output_device::isFGDevice(dev_name);
-HWCOMPOSER_LOG_INFO("!!!!!!!!!!!!!!!!!!!!!!!!!output_dev_open: %s", dev_name);   	
-   	if(is_overlay < 0) {
-   			return HWC_EGL_ERROR;
-   	}
-   	
-    if(is_overlay == 1) {
-HWCOMPOSER_LOG_RUNTIME("******output_dev_open() is_overlay =1");    	
-			  FG_device *dev;
-			  dev = new FG_device(dev_name, flag);
-			  	  if(dev == NULL)
-			  	      return HWC_EGL_ERROR;
-			
-			  //dev->setUsage(flag);					   	
-    		*device = (output_device *)dev;
-    }
-		else {
-			  BG_device *dev;
-			  dev = new BG_device(dev_name, flag);
-			  	  if(dev == NULL)
-			  	      return HWC_EGL_ERROR;
-			
-			  //dev->setUsage(flag);	  	
-    		*device = (output_device *)dev;
-		}
-       
-    return 0;
-}
-
-int output_dev_close(output_device *dev)
-{
-  	delete(dev); 
-  	
-  	return 0;
-}
-
-blit_device::blit_device()
-{
-        int fd_def;
-
-        m_def_disp_w = 0;
-        m_def_disp_h = 0;
-
-        fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-
-        if(fd_def < 0) {
-          HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
-          return;
-        }
-
-        struct fb_var_screeninfo def_info;
-        if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
-          HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
-          return;
-        }
-
-        m_def_disp_w = def_info.xres;
-        m_def_disp_h = def_info.yres;
-
-        close(fd_def);
-
-        return;
-}
-
diff --git a/mx5x/hwcomposer/hwc_common.h b/mx5x/hwcomposer/hwc_common.h
deleted file mode 100755
index 5da570b..0000000
--- a/mx5x/hwcomposer/hwc_common.h
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#ifndef _HWC_FSL_H_
-#define _HWC_FSL_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <utils/threads.h>
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include <asm/page.h>
-#include <ui/Rect.h>
-#include <ui/Region.h>
-
-#undef LOG_TAG
-#define LOG_TAG "FslHwcomposer"
-#include <utils/Log.h>
-
-//#define HWCOMPOSER_DEBUG_LOG
-
-#ifdef HWCOMPOSER_DEBUG_LOG
-#define HWCOMPOSER_LOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define HWCOMPOSER_LOG_FUNC ALOGI("%s is excuting...",  __FUNCTION__)
-#else
-#define HWCOMPOSER_LOG_RUNTIME(format, ...)
-#define HWCOMPOSER_LOG_FUNC
-#endif
-
-#define HWCOMPOSER_LOG_TRACE   ALOGI("%s : %d", __FUNCTION__,__LINE__)
-#define HWCOMPOSER_LOG_INFO(format, ...) ALOGI((format), ## __VA_ARGS__)
-
-#define HWCOMPOSER_LOG_ERR(format, ...) ALOGE((format), ##__VA_ARGS__)
-/*****************************************************************************/
-#define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
-#define FB1_DEV_NAME "/dev/graphics/fb1"
-#define FB2_DEV_NAME "/dev/graphics/fb2"
-#define FB3_DEV_NAME "/dev/graphics/fb3"
-#define V4L_DEV_NAME "/dev/video16"
-#define MAX_OUTPUT_DISPLAY  10
-
-#define BLIT_IPU "blt_ipu"
-#define BLIT_GPU "blt_gpu"
-
-#define DEFAULT_BUFFERS  3 
-
-using namespace android;
-
-//typedef unsigned long __u32;
-#define fourcc(a, b, c, d)\
-	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
-
-#define OUT_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
-#define OUT_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
-#define OUT_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
-#define OUT_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
-#define OUT_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
-#define OUT_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
-#define OUT_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
-#define OUT_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
-
-#define OUT_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
-#define OUT_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
-#define OUT_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
-#define OUT_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
-#define OUT_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
-#define OUT_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
-#define OUT_PIX_FMT_YUV420  fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
-#define OUT_PIX_FMT_YVU420  fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
-
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-typedef enum {
-    DISPLAY_MODE_OVERLAY_DISP0 = 0x00000001,
-    DISPLAY_MODE_OVERLAY_DISP1 = 0x00000002,
-    DISPLAY_MODE_OVERLAY_DISP2 = 0x00000004,
-    DISPLAY_MODE_OVERLAY_DISP3 = 0x00000008,
-    DISPLAY_MODE_DISP1 = 0x00000010,
-    DISPLAY_MODE_DISP2 = 0x00000020,
-    DISPLAY_MODE_DISP3 = 0x00000040,
-}DISPLAY_MODE;
-
-//seperate into three groups. one group member can be or with other group member.
-//but the group member can not be or with that in the same group except display group.
-#define GRALLOC_USAGE_OVERLAY0_MASK   0x00300000
-#define GRALLOC_USAGE_OVERLAY1_MASK   0x00C00000
-#define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
-#define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
-
-#define LAYER_RECORD_NUM      8
-typedef struct {
-    void* handle;
-    hwc_rect_t outRect;
-    int outDev;
-}layer_record;
-
-typedef struct{
-    void *virt_addr;
-    unsigned long phy_addr;
-    unsigned long size;
-    int format;
-    int width;
-    int height;
-    int usage;
-    Region disp_region;
-}hwc_buffer;
-
-class output_device
-{
-public:
-		virtual int post(hwc_buffer *);
-		virtual int fetch(hwc_buffer *);
-
-		void setUsage(int usage);
-		int getUsage();
-		int getWidth();
-		int getHeight();
-        void setDisplayFrame(hwc_rect_t *disFrame);
-        int needFillBlack(hwc_buffer *buf);
-        void fillBlack(hwc_buffer *buf);
-
-		output_device(const char *dev_name, int usage);
-		virtual ~output_device();
-
-		static int isFGDevice(const char *dev_name);
-
-private:
-		output_device& operator = (output_device& out);
-		output_device(const output_device& out);
-
-protected:
-		int m_dev;
-		//int m_left;
-		//int m_top;
-		int m_usage;
-		int m_width;
-		int m_height;
-		int m_format;
-//		int is_overlay;
-
-        //Region orignRegion;
-        Region currenRegion;
-
-		mutable Mutex mLock;
-		hwc_buffer mbuffers[DEFAULT_BUFFERS];
-		unsigned long mbuffer_count;
-		unsigned long mbuffer_cur;
-
-};
-
-//the normal display device
-class BG_device : public output_device
-{
-public:
-//		virtual int post(hwc_buffer *);
-//		virtual int fetch(hwc_buffer *);
-
-		BG_device(const char *dev_name, int usage);
-		virtual ~BG_device();
-
-private:
-		BG_device& operator = (BG_device& out);
-		BG_device(const BG_device& out);
-
-		int init();
-		int uninit();
-
-public:
-		//add private data
-};
-
-//the overlay display device
-class FG_device : public output_device
-{
-public:
-//		virtual int post(hwc_buffer *);
-//		virtual int fetch(hwc_buffer *);
-
-		FG_device(const char *dev_name, int usage);
-		virtual ~FG_device();
-
-private:
-		FG_device& operator = (FG_device& out);
-		FG_device(const FG_device& out);
-
-		int init();
-		int uninit();
-
-private:
-		//add private data
-		//int m_flag; //for display number flag.
-};
-
-class blit_device{
-public:
-		static int isIPUDevice(const char *dev_name);
-		static int isGPUDevice(const char *dev_name);
-    		virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
-		blit_device();
-		virtual ~blit_device(){}
-
-                int m_def_disp_w;
-                int m_def_disp_h;
-};
-
-//int FG_init(struct output_device *dev);
-//int FG_uninit(struct output_device *dev);
-//int FG_fetch(struct output_device *dev, hwc_buffer *buf);
-//int FG_post(struct output_device *dev);
-//
-//int BG_init(struct output_device *dev);
-//int BG_uninit(struct output_device *dev);
-//int BG_fetch(struct output_device *dev, hwc_buffer *buf);
-//int BG_post(struct output_device *dev);
-unsigned long fmt_to_bpp(unsigned long pixelformat);
-int hwc_fill_frame_back(char * frame,int frame_size, int xres,
-                           int yres, unsigned int pixelformat);
-int blit_dev_open(const char *dev_name, blit_device **);
-int blit_dev_close(blit_device *);
-
-int output_dev_open(const char *dev_name, output_device **, int);
-int output_dev_close(output_device *);
-
-#endif
diff --git a/mx5x/hwcomposer/hwc_context.h b/mx5x/hwcomposer/hwc_context.h
new file mode 100755
index 0000000..a244213
--- /dev/null
+++ b/mx5x/hwcomposer/hwc_context.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef HWC_CONTEXT_H_
+#define HWC_CONTEXT_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+#include <utils/threads.h>
+#include <hardware/hwcomposer.h>
+#include <utils/StrongPointer.h>
+
+#include <linux/mxcfb.h>
+#include <linux/ioctl.h>
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_vsync.h"
+/*****************************************************************************/
+#define HWC_MAIN_FB "/dev/graphics/fb0"
+
+class VSyncThread;
+
+struct hwc_context_t {
+    hwc_composer_device_t device;
+    /* our private state goes below here */
+
+    int m_mainfb_fd;
+    float m_mainfb_fps;
+    hwc_procs_t* m_callback;
+    bool m_vsync_enable;
+    sp<VSyncThread> m_vsync_thread;
+};
+
+#endif
diff --git a/mx5x/hwcomposer/hwc_vsync.cpp b/mx5x/hwcomposer/hwc_vsync.cpp
new file mode 100755
index 0000000..b5f5d91
--- /dev/null
+++ b/mx5x/hwcomposer/hwc_vsync.cpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <sys/time.h>
+#include <cutils/log.h>
+
+#include "hwc_context.h"
+#include "hwc_vsync.h"
+
+/*****************************************************************************/
+
+using namespace android;
+
+VSyncThread::VSyncThread(hwc_context_t *ctx)
+: Thread(false), mCtx(ctx)
+{
+}
+
+void VSyncThread::onFirstRef()
+{
+    run("vsyncThread", PRIORITY_URGENT_DISPLAY);
+}
+
+void VSyncThread::setEnabled(bool enabled) {
+    Mutex::Autolock _l(mLock);
+    mEnabled = enabled;
+    mCondition.signal();
+}
+
+status_t VSyncThread::readyToRun()
+{
+    return NO_ERROR;
+}
+
+bool VSyncThread::threadLoop()
+{
+    { // scope for lock
+        Mutex::Autolock _l(mLock);
+        while (!mEnabled) {
+            mCondition.wait(mLock);
+        }
+    }
+
+    uint64_t timestamp = 0;
+    uint32_t crt = (uint32_t)&timestamp; 
+
+    int err = ioctl(mCtx->m_mainfb_fd, MXCFB_WAIT_FOR_VSYNC, crt);
+    if ( err < 0 ) {
+        ALOGE("FBIO_WAITFORVSYNC error: %s\n", strerror(errno));
+    } else {
+#ifdef DEBUG_HWC_VSYNC_TIMING
+        static nsecs_t last_time_ns;
+        nsecs_t cur_time_ns;
+
+        cur_time_ns  = systemTime(SYSTEM_TIME_MONOTONIC);
+        mCtx->m_callback->vsync(mCtx->m_callback, 0, timestamp);
+        ALOGE("Vsync %llu, %llu\n", cur_time_ns - last_time_ns, cur_time_ns - timestamp);
+        last_time_ns = cur_time_ns;
+#else
+        mCtx->m_callback->vsync(mCtx->m_callback, 0, timestamp);
+#endif
+    }
+    return true;
+}
+
diff --git a/mx5x/hwcomposer/hwc_vsync.h b/mx5x/hwcomposer/hwc_vsync.h
new file mode 100755
index 0000000..e024ebc
--- /dev/null
+++ b/mx5x/hwcomposer/hwc_vsync.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef HWC_VSYNC_H_
+#define HWC_VSYNC_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+#include <utils/threads.h>
+
+#include <hardware/hwcomposer.h>
+#include <utils/StrongPointer.h>
+
+#include <linux/mxcfb.h>
+#include <linux/ioctl.h>
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_context.h"
+/*****************************************************************************/
+
+using namespace android;
+
+struct hwc_context_t;
+
+class VSyncThread : public Thread
+{
+public:
+    VSyncThread(hwc_context_t *ctx);
+    void setEnabled(bool enabled);
+
+private:
+    virtual void onFirstRef();
+    virtual status_t readyToRun();
+    virtual bool threadLoop();
+    void handleUevent(const char *buff, int len);
+
+    hwc_context_t *mCtx;
+    mutable Mutex mLock;
+    Condition mCondition;
+    bool mEnabled;
+};
+
+#endif /* if !defined(HWC_VSYNC_H_)*/
diff --git a/mx5x/hwcomposer/hwcomposer.cpp b/mx5x/hwcomposer/hwcomposer.cpp
index 8af59ba..29b9412 100755
--- a/mx5x/hwcomposer/hwcomposer.cpp
+++ b/mx5x/hwcomposer/hwcomposer.cpp
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -12,7 +14,6 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #include <hardware/hardware.h>
 
@@ -22,33 +23,20 @@
 #include <cutils/log.h>
 #include <cutils/atomic.h>
 #include <cutils/properties.h>
-
+#include <utils/threads.h>
 #include <hardware/hwcomposer.h>
+#include <utils/StrongPointer.h>
 
+#include <linux/mxcfb.h>
+#include <linux/ioctl.h>
 #include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-using namespace android;
-
-struct hwc_context_t {
-    hwc_composer_device_t device;
-    /* our private state goes below here */
-    //now the blit device may only changed in hwc_composer_device open or close.
-    blit_device *blit;
+#include <GLES/gl.h>
 
-    output_device *m_out[MAX_OUTPUT_DISPLAY];
-    char m_using[MAX_OUTPUT_DISPLAY]; //0 indicates no output_device, 1 indicates related index;
-
-    //the system property for dual display and overlay switch.
-    int display_mode;
-    char ui_refresh;
-    char vd_refresh;
-    int second_display;
-
-    layer_record records[LAYER_RECORD_NUM];
-};
+#include "gralloc_priv.h"
+#include "hwc_context.h"
+#include "hwc_vsync.h"
 
+/*****************************************************************************/
 static int hwc_device_open(const struct hw_module_t* module, const char* name,
         struct hw_device_t** device);
 
@@ -59,15 +47,14 @@ static struct hw_module_methods_t hwc_module_methods = {
 hwc_module_t HAL_MODULE_INFO_SYM = {
     common: {
         tag: HARDWARE_MODULE_TAG,
-        version_major: 1,
+        version_major: 2,
         version_minor: 0,
         id: HWC_HARDWARE_MODULE_ID,
-        name: "Freescale iMX53 HW Composer module",
-        author: "Freescale",
+        name: "Freescale i.MX hwcomposer module",
+        author: "Freescale Semiconductor, Inc.",
         methods: &hwc_module_methods,
         dso: NULL,
-        reserved: {0},
-
+        reserved: {0}
     }
 };
 
@@ -87,593 +74,128 @@ static void dump_layer(hwc_layer_t const* l) {
 }
 
 /***********************************************************************/
-static void addRecord(hwc_context_t *dev, hwc_layer_list_t* list)
-{
-    int rec_index = 0;
-    if (list && dev) {
-        for(int n=0; n<LAYER_RECORD_NUM; n++) {
-            dev->records[n].handle = NULL;
-            memset(&(dev->records[n].outRect), 0, sizeof(dev->records[n].outRect));
-            dev->records[n].outDev = 0;
-        }
-
-        for (size_t i=0 ; i<list->numHwLayers ; i++) {
-            //dump_layer(&list->hwLayers[i]);
-            //list->hwLayers[i].compositionType = HWC_FRAMEBUFFER;
-            hwc_layer_t *layer = &list->hwLayers[i];
-            /*
-             *the private_handle_t should expand to have usage and format member.
-            */
-            if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
-                continue;//skip NULL pointer and other magic handler
-            }
-            if (private_handle_t::validate(layer->handle) < 0) {
-                //HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
-                continue;
-            }
-            //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
-            //HWCOMPOSER_LOG_ERR("-------hwc_prepare----layer[%d]-----displayID = %d", i, layer->displayId);
-            private_handle_t *handle = (private_handle_t *)(layer->handle);
-            if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
-                //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
-                continue;
-            }
-
-            if(rec_index >= LAYER_RECORD_NUM) {
-                HWCOMPOSER_LOG_ERR("******************Error:%s, too many video layers");
-                return;
-            }
-            dev->records[rec_index].handle = (void*)(layer->handle);
-            dev->records[rec_index].outRect = layer->displayFrame;
-            dev->records[rec_index].outDev = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
-            rec_index ++;
-        }// end for
-    }//end if
-}
 
-static int isRectEqual(hwc_rect_t* hs, hwc_rect_t* hd)
+static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) 
 {
-    return ((hs->left == hd->left) && (hs->top == hd->top)
-            && (hs->right == hd->right) && (hs->bottom == hd->bottom));
-}
-
-static int isInRecord(hwc_context_t *dev, hwc_layer_t *layer)
-{
-    if(dev && layer) {
-        private_handle_t *handle = (private_handle_t *)(layer->handle);
-        for(int i=0; i<LAYER_RECORD_NUM; i++) {
-            if(((int)(dev->records[i].handle) == (int)(layer->handle))
-                      && isRectEqual(&(dev->records[i].outRect), &(layer->displayFrame))
-                      && (dev->records[i].outDev == (handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK))) {
-                return 1;
-            }
-        }
-    }
     return 0;
 }
 
-static int hwc_check_property(hwc_context_t *dev)
-{
-    //bool bValue = false;
-    char value[10];
-
-    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
-    if (strcmp(value, "1") == 0) {
-        property_set("sys.VIDEO_OVERLAY_DISPLAY", "0");
-        property_set("sys.VIDEO_DISPLAY", "1");
-    }
-    else if (strcmp(value, "0") == 0)
-    {
-       property_set("sys.VIDEO_OVERLAY_DISPLAY", "1");
-       property_set("sys.VIDEO_DISPLAY", "0");
-    }
-
-    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
-    if (strcmp(value, "1") == 0) {
-       property_set("sys.VIDEO_OVERLAY_DISPLAY", "2");
-       property_set("sys.VIDEO_DISPLAY", "0");
-       dev->display_mode &= ~(DISPLAY_MODE_OVERLAY_DISP0 | DISPLAY_MODE_OVERLAY_DISP1 |
-                              DISPLAY_MODE_OVERLAY_DISP2 | DISPLAY_MODE_OVERLAY_DISP3);
-       dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP0;
-       dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
-       dev->second_display = 1;
-       return 0;
-    } 
-    else if (strcmp(value, "0") == 0)
-    {
-       dev->second_display = 0;
-       property_set("sys.VIDEO_OVERLAY_DISPLAY", "1");
-       property_set("sys.VIDEO_DISPLAY", "0");
-    }
-
-    /*note:sys.VIDEO_OVERLAY_DISPLAY means the overlay will be combined to which display.
-     *the default value is 0 and it indicates nothing.
-     *if the value is 1 and it indicates combined to display0.
-     *if the value is 2 and it indicates combined to display1.
-    */
-    property_get("sys.VIDEO_OVERLAY_DISPLAY", value, "");
-    dev->display_mode &= ~(DISPLAY_MODE_OVERLAY_DISP0 | DISPLAY_MODE_OVERLAY_DISP1 |
-        				DISPLAY_MODE_OVERLAY_DISP2 | DISPLAY_MODE_OVERLAY_DISP3);
-    if (strcmp(value, "1") == 0){
-        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP0;
-    }
-    else if (strcmp(value, "2") == 0){
-        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP1;
-    }
-
-    if (strcmp(value, "3") == 0){
-        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
-    }
-    else if (strcmp(value, "4") == 0){
-        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP3;
-    }
-    /*note:rw.VIDEO_DISPLAY means the display device.
-     *the default value is 0 and it indicates nothing.
-     *if the value is 1 and it indicates display1.
-     *if the value is 2 and it indicates display2.
-    */
-    property_get("sys.VIDEO_DISPLAY", value, "");
-    dev->display_mode &= ~(DISPLAY_MODE_DISP1 | DISPLAY_MODE_DISP2);
-    if (strcmp(value, "1") == 0){
-        dev->display_mode |= DISPLAY_MODE_DISP1;
-    }
-    if (strcmp(value, "2") == 0){
-        dev->display_mode |= DISPLAY_MODE_DISP2;
-    }
-    //HWCOMPOSER_LOG_ERR("************dev->display_mode=%x", dev->display_mode);
-	return 0;
-}
-
-static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
-{
-	handle->usage &= ~GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
-
-    if(dev->display_mode & DISPLAY_MODE_DISP1){
-            handle->usage |= GRALLOC_USAGE_HWC_DISP1;
-            dev->display_mode &= ~DISPLAY_MODE_DISP1;
-	    //return 0;
-    }
-
-    if(dev->display_mode & DISPLAY_MODE_DISP2)
-            handle->usage |= GRALLOC_USAGE_HWC_DISP2;
-
-	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP0){
-			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP0;
-			//dev->display_mode &= ~DISPLAY_MODE_OVERLAY_DISP0;
-	}
-	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP1)
-			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP1;
-
-	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP2)
-			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP2;
-	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP3)
-			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP3;
-
-    //HWCOMPOSER_LOG_ERR("************handle->usage=%x", handle->usage);
-	return 0;
-}
-
-/*paramters:
- * usage: devices need to open.
- * ufg:devices not open.
- * puse:index array when device open it need set.
- *check if the output device is exist.
- *return 0 indicates exist; 1 indicates not exist.
-*/
-static int checkOutputDevice(struct hwc_context_t *ctx, char *puse, int usage, int *ufg)//return -1 indicate not exist.
-{
-	output_device *out;
-	int uFlag = 0;
-	int usg = 0;
-
-	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(ctx->m_using[i]) {
-			out = ctx->m_out[i];
-			usg = out->getUsage();
-			if(usg & usage) {
-				uFlag |= (usg & usage);
-				if(puse) puse[i] = 1;
-			}
-		}
-	}
-	if(ufg != NULL)
-		*ufg = usage & ~uFlag;
-
-	return uFlag ^ usage;
-}
-
-static int findOutputDevice(struct hwc_context_t *ctx, int *index, int usage, int *ufg)
-{
-	output_device *out;
-	int uFlag = 0;
-	int usg = 0;
-    *index = -1;
-
-	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(ctx->m_using[i]) {
-			out = ctx->m_out[i];
-			usg = out->getUsage();
-			if(usg & usage) {
-				uFlag = (usg & usage);
-				*index = i;
-				break;
-			}
-		}
-	}
-	if(ufg != NULL)
-		*ufg = uFlag;
-
-	return (*ufg) ^ usage;
-}
-
-static int findEmpytIndex(struct hwc_context_t *ctx)
+static int hwc_set(hwc_composer_device_t *dev,
+        hwc_display_t dpy,
+        hwc_surface_t sur,
+        hwc_layer_list_t* list)
 {
-	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(!ctx->m_using[i])
-			return i;
-	}
-
-	HWCOMPOSER_LOG_ERR("the output device array not enough big.\n");
-	return -1;
-}
+    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
 
-//check the output device and delete unused device instance.
-static void deleteEmtpyIndex(struct hwc_context_t *ctx)
-{
-	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(!ctx->m_using[i]) {
-			if(ctx->m_out[i]) {
-				output_dev_close(ctx->m_out[i]);
-				ctx->m_out[i] = NULL;
-			}
-		}
-	}
-}
+    EGLBoolean success;
 
-static char* getDeviceName(hwc_context_t *dev, int usage, int *pUse)
-{
-    if(dev->second_display) {
-        if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
-            return (char *)FB1_DEV_NAME;
-        }
-        if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
-            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP2;
-            return (char *)FB3_DEV_NAME;
-        }
-    }
+    success = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
+    glClearColor(0, 0, 0, 0);
+    glClear(GL_COLOR_BUFFER_BIT);
 
-    if(usage & GRALLOC_USAGE_HWC_DISP1){
-    		*pUse = GRALLOC_USAGE_HWC_DISP1;
-    		return (char *)FB2_DEV_NAME;
-    }
-    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-    		*pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
-    		return (char *)FB1_DEV_NAME;
-    }
-    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-        *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP1;
-        return (char *)FB1_DEV_NAME;
-    }//end else if
-
-    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
-            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP2;
-            return (char *)FB3_DEV_NAME;
+    if (!success) {
+        return HWC_EGL_ERROR;
     }
 
-    return NULL;
-}
-
-#if 0
-static void setLayerFrame(hwc_layer_t *layer, output_device *out, int usage)
-{
-    if(usage & GRALLOC_USAGE_HWC_DISP1){
-    		layer->displayFrame.left = 0;
-    		layer->displayFrame.top = 0;
-    		layer->displayFrame.right = out->getWidth();
-    		layer->displayFrame.bottom = out->getHeight();
-    }
-//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP0) {
-//    		display_frame =;
-//    }
-//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP1) {
-//        display_frame =;
-//    }//end else if
-}
-#endif
-
-static int validate_displayFrame(hwc_layer_t *layer)
-{
-    int isValid = 0;
-    hwc_rect_t *disFrame = &(layer->displayFrame);
-    isValid = ((disFrame->left >= 0) && (disFrame->right >= 0) && (disFrame->top >= 0) &&
-            (disFrame->bottom >= 0) && ((disFrame->right - disFrame->left) >= 0) &&
-            ((disFrame->bottom  - disFrame->top) >= 0));
-    return isValid;
-}
-
-static void checkDisplayFrame(struct hwc_context_t *ctx, hwc_layer_t *layer, int usage)
-{
-    output_device *out;
-    int usg;
-    hwc_rect_t *disFrame = &(layer->displayFrame);
-
-    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-        if(ctx->m_using[i] && ctx->m_out[i] && (usage & (GRALLOC_USAGE_OVERLAY0_MASK | GRALLOC_USAGE_OVERLAY1_MASK))) {
-            out = ctx->m_out[i];
-            usg = out->getUsage();
-            if(usg & usage) {
-                out->setDisplayFrame(disFrame);
-            }
-        }
-    }//end for
-
+    return 0;
 }
 
-static int open_outputDevice(struct hwc_context_t *ctx, const char *dev_name, output_device **device, int flag) 
+static int hwc_device_close(struct hw_device_t *dev)
 {
-    int usage;
-    output_device *out;
-    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-        if(ctx->m_using[i] && ctx->m_out[i]) {
-            out = ctx->m_out[i];
-            usage = out->getUsage();
-            if(((usage | flag) == GRALLOC_USAGE_OVERLAY0_MASK) || ((usage | flag) == GRALLOC_USAGE_OVERLAY1_MASK)) {
-                output_dev_close(ctx->m_out[i]);
-                ctx->m_using[i] = 0;
-                ctx->m_out[i] = NULL;
-            }
+    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
+    if (ctx) {
+        if(ctx->m_vsync_thread != NULL) {
+            ctx->m_vsync_thread->requestExitAndWait();
         }
+        free(ctx);
     }
-    return output_dev_open(dev_name, device, flag);
-}
-
-static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
-    char out_using[MAX_OUTPUT_DISPLAY] = {0};
-
-    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
-
-    if (list && dev) {
-        for (size_t i=0 ; i<list->numHwLayers ; i++) {
-            //dump_layer(&list->hwLayers[i]);
-            //list->hwLayers[i].compositionType = HWC_FRAMEBUFFER;
-            hwc_layer_t *layer = &list->hwLayers[i];
-            /*
-             *the private_handle_t should expand to have usage and format member.
-            */
-            if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
-                continue;//skip NULL pointer and other magic handler
-            }
-	    if (private_handle_t::validate(layer->handle) < 0) {
-		//HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
-		continue;
-	    }
-	    //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
-            private_handle_t *handle = (private_handle_t *)(layer->handle);
-            if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
-                //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
-            	continue;
-            }
-            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---3>usage=%x, phy=%x>>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
-            hwc_check_property(ctx);
-	    layer->compositionType = HWC_OVERLAY;
-	    //if(handle->usage & GRALLOC_USAGE_HWC_DISP1)
-	    //handle the display frame position for tv out.
-	    hwc_modify_property(ctx, handle);
-
-            if(!validate_displayFrame(layer)) {
-                HWCOMPOSER_LOG_INFO("<<<<<<<<<<<<<<<hwc_prepare---3-2>>>>>>>>>>>>>>>>\n");
-                continue;
-            }
-
-            int status = -EINVAL;
-            int index = 0;
-            int retv = 0;
-            int m_usage = 0;
-            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
-            //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---3-3>>>>>usage=%x>>>i_usage=%x>>>>>>>>\n", handle->usage, i_usage);
-            retv = checkOutputDevice(ctx, out_using, i_usage, &m_usage);
-            while(retv && m_usage) {
-		    int ruse = 0;
-		    char *dev_name = NULL;
-		    dev_name = getDeviceName(ctx, m_usage, &ruse);
-	            m_usage &= ~ruse;
-	            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---4>>>>>>>>>>>>>>>>>\n");
-	            if(dev_name == NULL) {
-			HWCOMPOSER_LOG_INFO("****Warnning: layer buffer usage(%x) does not support!", handle->usage);
-			HWCOMPOSER_LOG_INFO("****Warnning:  the layer buffer will be handled in surfaceflinger");
-			layer->compositionType = HWC_FRAMEBUFFER;
-			continue;
-	            }//end else
-
-	            index = findEmpytIndex(ctx);
-	            if(index == -1) {
-            		HWCOMPOSER_LOG_ERR("Error:findEmpytIndex failed");
-            		return HWC_EGL_ERROR;
-	            }
-	            if(ctx->m_out[index])
-			deleteEmtpyIndex(ctx);
-
-		        status = open_outputDevice(ctx, dev_name, &(ctx->m_out[index]), ruse);//output_dev_open(dev_name, &(ctx->m_out[index]), ruse);
-		        if(status < 0){
-		            HWCOMPOSER_LOG_ERR("Error! open output device failed!");
-		            continue;
-		        }//end if
-		        out_using[index] = 1;
-		        ctx->m_using[index] = 1;
-		        //setLayerFrame(layer, ctx->m_out[index], ruse);
-            }//end while
-            checkDisplayFrame(ctx, layer, i_usage);
-        }//end for
-        for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(!out_using[i] && ctx->m_using[i]) {
-			ctx->m_using[i] = 0;
-			deleteEmtpyIndex(ctx);
-		}
-		//ctx->m_using[i] = out_using[i];
-	}
-    }//end if
     return 0;
 }
 
-static int releaseAllOutput(struct hwc_context_t *ctx)
-{
-		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-				if(ctx->m_using[i]) {
-						output_dev_close(ctx->m_out[i]);
-						ctx->m_using[i] = 0;
-						ctx->m_out[i] = NULL;
-				}
-		}
-
-		return 0;
-}
-
-static int getActiveOuputDevice(struct hwc_context_t *ctx)
-{
-		int num = 0;
-		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-				if(ctx->m_out[i] && ctx->m_using[i])
-						num ++;
-		}
-
-		return num;
-}
+#ifdef ENABLE_VSYNC
+static void hwc_registerProcs(struct hwc_composer_device* dev,
+            hwc_procs_t const* procs) {
+    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
+    if(ctx) {
+        ctx->m_callback = (hwc_procs_t*)procs;
+    }
+}
+
+static int hwc_eventControl(struct hwc_composer_device* dev, int event, int enabled)
+{
+     hwc_context_t *ctx = (hwc_context_t *) dev;
+#ifdef DEBUG_HWC_VSYNC_TIMING
+     static nsecs_t start_time_ns = systemTime(SYSTEM_TIME_MONOTONIC);
+#endif   
+     switch (event) {
+     case HWC_EVENT_VSYNC:
+         {
+             ctx->m_vsync_thread->setEnabled(enabled);
+#ifdef DEBUG_HWC_VSYNC_TIMING
+             if ( enabled ) 
+             {
+                 ALOGV("<%s,%d> paused time: %lld \n",__FUNCTION__, __LINE__, systemTime(SYSTEM_TIME_MONOTONIC)- start_time_ns);
+             } else {
+                 start_time_ns  = systemTime(SYSTEM_TIME_MONOTONIC);
+             }
+#endif /* if defined DEBUG_HWC_VSYNC_TIMING */
+             return 0;
+         }
+     default:
+         return -EINVAL;
+     }
+}   
+
+static const struct hwc_methods hwc_methods = {
+    eventControl: hwc_eventControl
+};
 
-static int hwc_setUpdateMode(hwc_composer_device_t *dev, char refresh, char vRefresh)
+static int hwc_query(struct hwc_composer_device* dev,
+        int what, int* value)
 {
-    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
-    if(ctx == NULL) return 0;
+    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
 
-    ctx->ui_refresh = refresh;
-    ctx->vd_refresh = vRefresh;
+    switch (what) {
+    case HWC_BACKGROUND_LAYER_SUPPORTED:
+        // we don't support the background layer yet
+        value[0] = 0;
+        break;
+    case HWC_VSYNC_PERIOD:
+        // vsync period in nanosecond
+        value[0] = 1000000000.0 / ctx->m_mainfb_fps;
+        break;
+    default:
+        // unsupported query
+        return -EINVAL;
+    }
     return 0;
 }
 
-static int hwc_set(hwc_composer_device_t *dev,
-        hwc_display_t dpy,
-        hwc_surface_t sur,
-        hwc_layer_list_t* list)
+static int hwc_get_framebuffer_info(struct hwc_context_t* ctx)
 {
-    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
-    //for (size_t i=0 ; i<list->numHwLayers ; i++) {
-    //    dump_layer(&list->hwLayers[i]);
-    //}
-    //hwc_buffer *outBuff[MAX_OUTPUT_DISPLAY];
-    //when displayhardware do releas function, it will come here.
-    if(ctx && (dpy == NULL) && (sur == NULL) && (list == NULL)) {
-	//close the output device.
-	releaseAllOutput(ctx);
-	//ctx->display_mode_changed = 1;
-
-	return 0;
-    }
-    ctx->ui_refresh = 1;
-    ctx->vd_refresh = 1;
-    if((ctx == NULL) || (ctx && ctx->ui_refresh)) {
-        EGLBoolean success;
-        success = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
-        if (!success) {
-            return HWC_EGL_ERROR;
-        }
-    }
-    if(list == NULL || dev == NULL || !ctx->vd_refresh) {
-    	return 0;
-    }
-    if(getActiveOuputDevice(ctx) == 0) {return 0;}//eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur); return 0;}
-    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
-
-    int status = -EINVAL;
-    hwc_buffer out_buffer[MAX_OUTPUT_DISPLAY];
-    char bufs_state[MAX_OUTPUT_DISPLAY];
-    memset(bufs_state, 0, sizeof(bufs_state));
-    memset(out_buffer, 0, sizeof(out_buffer));
-    blit_device *bltdev = ctx->blit;
-    for (size_t i=0 ; i<list->numHwLayers ; i++){
-	hwc_layer_t *layer = &list->hwLayers[i];
-        if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
-    	    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
-            continue;
-        }
-	if (private_handle_t::validate(layer->handle) < 0) {
-    	    HWCOMPOSER_LOG_RUNTIME("%s,%d, not a valide buffer handle", __FUNCTION__, __LINE__);
-    	    continue;
-	}
-
-        if(!validate_displayFrame(layer)) {
-    	    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
-            continue;
-        }
-        HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
-
-        //when GM do seek, it always queue the same buffer.
-        //so, we can not judge the reduplicated buffer by buffer handle now. 
-        if(isInRecord(ctx, layer)) {
-            HWCOMPOSER_LOG_RUNTIME("%s,%d, lost frames", __FUNCTION__, __LINE__);
-            //continue;
-        }
-
-	private_handle_t *handle = (private_handle_t *)(layer->handle);
-	if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY){
-            int retv = 0;
-            int m_usage = 0;
-            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
-            if(!i_usage) continue;
-            do {
-    		output_device *outdev = NULL;
-    		int index = 0;
-        	retv = findOutputDevice(ctx, &index, i_usage, &m_usage);
-                i_usage &= ~m_usage;
-                if((index >= 0) && (index < MAX_OUTPUT_DISPLAY)) {
-                    outdev = ctx->m_out[index];
-                }else {
-                    break;
-                }
-                
-    		if(outdev != NULL) {
-			if(!bufs_state[index] && ctx->m_using[index]) {
-				outdev->fetch(&out_buffer[index]);
-				bufs_state[index] = 1;
-			}
-			if(!bufs_state[index])
-				continue;
-			status = bltdev->blit(layer, &(out_buffer[index]));
-			if(status < 0){
-				HWCOMPOSER_LOG_ERR("Error! bltdev->blit() failed!");
-				continue;
-			}
-    		}//end if(outdev != NULL)
-            }while(retv);
-
-		}//end if
-    }//end for
-    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-	if(ctx->m_using[i] && bufs_state[i]) {
-		status = ctx->m_out[i]->post(&out_buffer[i]);
-		if(status < 0){
-			HWCOMPOSER_LOG_ERR("Error! output device post buffer failed!");
-			continue;
-		}
-	}
+    struct fb_var_screeninfo info;
+    if (ioctl(ctx->m_mainfb_fd, FBIOGET_VSCREENINFO, &info) == -1) {
+        ALOGE("<%s,%d> FBIOGET_VSCREENINFO failed", __FUNCTION__, __LINE__);
+        return -errno;
     }
-    addRecord(ctx, list);
 
-    return 0;
-}
+    int refreshRate = 1000000000000000LLU / (uint64_t(info.upper_margin +
+                                                      info.lower_margin +
+                                                      info.yres +
+                                                      info.vsync_len) *
+                                             (info.left_margin  +
+                                              info.right_margin +
+                                              info.xres +
+                                              info.hsync_len) * info.pixclock);
+    if (refreshRate == 0)
+        refreshRate = 60 * 1000;  // 60 Hz
 
-static int hwc_device_close(struct hw_device_t *dev)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-    if (ctx) {
-    		if(ctx->blit)
-    				blit_dev_close(ctx->blit);
-        releaseAllOutput(ctx);
-
-        free(ctx);
-    }
+    ctx->m_mainfb_fps = refreshRate / 1000.0f;
+    ALOGI("<%s,%d> Vsync rate %0.6f fps", __FUNCTION__, __LINE__, ctx->m_mainfb_fps);
     return 0;
 }
 
+#endif
 /*****************************************************************************/
 
 static int hwc_device_open(const struct hw_module_t* module, const char* name,
@@ -689,34 +211,35 @@ static int hwc_device_open(const struct hw_module_t* module, const char* name,
 
         /* initialize the procs */
         dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
         dev->device.common.module = const_cast<hw_module_t*>(module);
         dev->device.common.close = hwc_device_close;
 
         dev->device.prepare = hwc_prepare;
         dev->device.set = hwc_set;
-        dev->device.setUpdateMode = hwc_setUpdateMode;
-
-        *device = &dev->device.common;
+#ifdef ENABLE_VSYNC
+        dev->device.common.version = HWC_DEVICE_API_VERSION_0_3;
+        dev->device.registerProcs = hwc_registerProcs;
+        dev->device.methods = &hwc_methods;
+        dev->device.query = hwc_query;
 
         /* our private state goes below here */
-        status = blit_dev_open(BLIT_IPU, &(dev->blit));
-        if(status < 0){
-        	  HWCOMPOSER_LOG_ERR("Error! blit_dev_open failed!");
-        	  goto err_exit;
-        }
+        dev->m_mainfb_fd = open(HWC_MAIN_FB, O_RDWR);
+        dev->m_vsync_thread = new VSyncThread(dev);
+        hwc_get_framebuffer_info(dev);
+#else
+        dev->device.common.version = 0;
+#endif
+        const hw_module_t *hwc_module;
 
 nor_exit:
-	HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
+
+        *device = &dev->device.common;
+	ALOGI("<%s,%d>", __FUNCTION__, __LINE__);
         return 0;
 err_exit:
 	if(dev){
-		if(dev->blit) {
-			blit_dev_close(dev->blit);
-		}
-		free(dev);
+	    free(dev);
 	}
-				//status = -EINVAL;
         /****************************************/
     }
     return status;
diff --git a/mx5x/hwcomposer/output_device.cpp b/mx5x/hwcomposer/output_device.cpp
deleted file mode 100755
index cdbbdff..0000000
--- a/mx5x/hwcomposer/output_device.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-
-void output_device::setUsage(int usage)
-{
-    m_usage = usage;
-}
-
-int output_device::getUsage()
-{
-    return m_usage;
-}
-
-int output_device::getWidth()
-{
-    return m_width;
-}
-
-int output_device::getHeight()
-{
-    return m_height;
-}
-
-output_device::output_device(const char *dev_name, int usage)
-{
-    m_dev = open(dev_name, O_RDWR | O_NONBLOCK, 0);
-    if(m_dev < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device Open fb device %s failed!", dev_name);
-    }
-    m_usage = usage;
-}
-
-output_device::~output_device()
-{
-	if(m_dev > 0) {
-        close(m_dev);
-	}
-}
-
-int output_device::isFGDevice(const char *dev_name)
-{
-    int status = -EINVAL;
-    int fd = -1;
-    char fb_usage[32];
-    char fb_name[32];
-    int fd_n = 0;
-    int size = 0;
-    int is_overlay = 0;
-    char *psname;
-
-    memset(fb_name, 0, sizeof(fb_name));
-    psname = (char *)dev_name;
-    psname += (strlen(dev_name) - 1);
-    strcpy(fb_name, "/sys/class/graphics/fb");
-    strcat(fb_name, psname);
-    strcat(fb_name, "/name");
-    fd_n = open(fb_name, O_RDONLY, 0);
-    //fd_n = open("/sys/class/graphics/fb0/name", O_RDONLY, 0);
-    if(fd_n < 0) {
-		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice  open %s failed!", fb_name);
-		return -1;
-    }
-    memset(fb_usage, 0, sizeof(fb_usage));
-    size = read(fd_n, fb_usage, sizeof(fb_usage));
-    if(size < 0) {
-		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice read /sys/class/graphics/fb0/name failed!");
-		return -1;
-    }
-    close(fd_n);
-HWCOMPOSER_LOG_INFO("output_device::isFGDevice===%s, %s, %s", dev_name, fb_name, fb_usage);
-    if(strstr(fb_usage, "FG"))
-    	return 1;
- 	return 0;
-}
-
-void output_device::setDisplayFrame(hwc_rect_t *disFrame)
-{
-    if(disFrame == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::setDisplayFrame invalid parameter!");
-    }
-    Rect disRect(disFrame->left, disFrame->top, disFrame->right, disFrame->bottom);
-    currenRegion.orSelf(disRect);
-}
-
-int output_device::needFillBlack(hwc_buffer *buf)
-{
-    Rect orignBound(buf->disp_region.getBounds());
-    Rect currentBound(currenRegion.getBounds());
-    return currentBound != orignBound;
-}
-
-void output_device::fillBlack(hwc_buffer *buf)
-{
-    if(buf == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::fillBlack invalid parameter!");
-        return;
-    }
-
-    hwc_fill_frame_back((char *)buf->virt_addr, buf->size, buf->width, buf->height, buf->format);
-}
-
-int output_device::fetch(hwc_buffer *buf)
-{
-	  //int status = -EINVAL;
-    if(m_dev <= 0 || buf == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::fetch invalid parameter! usage=%x", m_usage);
-        return -1;
-    }
-
-	  Mutex::Autolock _l(mLock);
-	  buf->size = (mbuffers[mbuffer_cur]).size;
-	  buf->virt_addr = (mbuffers[mbuffer_cur]).virt_addr;
-	  buf->phy_addr = (mbuffers[mbuffer_cur]).phy_addr;
-	  buf->width = m_width;
-	  buf->height = m_height;
-	  buf->usage = m_usage;
-	  buf->format = m_format;
-	  //dev->buffer_cur = (dev->buffer_cur + 1) % DEFAULT_BUFFERS;
-      if((m_usage & (GRALLOC_USAGE_OVERLAY0_MASK | GRALLOC_USAGE_OVERLAY1_MASK)) && needFillBlack(&mbuffers[mbuffer_cur])) {
-          fillBlack(&mbuffers[mbuffer_cur]);
-          mbuffers[mbuffer_cur].disp_region = currenRegion;
-      }
-      //orignRegion = currenRegion;
-      currenRegion.clear();
-
-	  return 0;
-}
-
-int output_device::post(hwc_buffer *buf)
-{
-	  //int status = -EINVAL;
-    if(m_dev <= 0) {
-        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_post() invalid parameter! usage=%x", m_usage);
-        return -1;
-    }
-HWCOMPOSER_LOG_RUNTIME("#######output_device::post()############");
-
-	Mutex::Autolock _l(mLock);
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::post VSCREENINFO getting failed! usage=%x", m_usage);
-        return -1;
-    }
-
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::post FSCREENINFO getting failed! usage=%x", m_usage);
-        return -1;
-    }
-
-    info.yoffset = ((unsigned long)buf->virt_addr - (unsigned long)(mbuffers[0]).virt_addr) / finfo.line_length;
-    //info.yoffset = ((info.yres_virtual * finfo.line_length)/ DEFAULT_BUFFERS) * mbuffer_cur;
-    mbuffer_cur = (mbuffer_cur + 1) % DEFAULT_BUFFERS;
-    info.activate = FB_ACTIVATE_VBL;
-//HWCOMPOSER_LOG_RUNTIME("#######yoffset=%d, mbuffer_cur=%d######", info.yoffset, mbuffer_cur);
-    ioctl(m_dev, FBIOPAN_DISPLAY, &info);
-
-HWCOMPOSER_LOG_RUNTIME("#######output_device::post()##end##########");
-    return 0;
-}
-- 
1.8.0

