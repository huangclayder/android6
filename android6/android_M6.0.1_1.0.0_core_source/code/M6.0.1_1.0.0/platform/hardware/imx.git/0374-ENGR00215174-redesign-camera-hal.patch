From 5a299c04b38a85c21d0630684551f1ed7767653e Mon Sep 17 00:00:00 2001
From: Xiaowen Liu <b37945@freescale.com>
Date: Tue, 27 Nov 2012 13:53:42 +0800
Subject: [PATCH 374/635] ENGR00215174 redesign camera hal.

adopt object oriented design to refactor camera hal.
abstract class buffer provider, frame provider and event provider.
camera hal take charge of transfer function command from
camerea service. camera bridge receive frame and call back to
camera servece. device adapter provide frame. display adapter
receive and show frame on the display.

Change-Id: Icec23b1fe504da133f9726aae6f1d921e722e143
Signed-off-by: Xiaowen Liu <b37945@freescale.com>
---
 mx6/libcamera/Android.mk                     |   38 +-
 mx6/libcamera/CameraBridge.cpp               |  786 ++++++++
 mx6/libcamera/CameraBridge.h                 |  161 ++
 mx6/libcamera/CameraHal.cpp                  | 2677 +++++---------------------
 mx6/libcamera/CameraHal.h                    |  466 +----
 mx6/libcamera/CameraModule.cpp               |   57 +-
 mx6/libcamera/CameraUtil.cpp                 |  341 ++++
 mx6/libcamera/CameraUtil.h                   |  295 +++
 mx6/libcamera/Camera_utils.h                 |   78 -
 mx6/libcamera/CaptureDeviceInterface.cpp     |   37 -
 mx6/libcamera/CaptureDeviceInterface.h       |  116 --
 mx6/libcamera/DeviceAdapter.cpp              |  563 ++++++
 mx6/libcamera/DeviceAdapter.h                |  146 ++
 mx6/libcamera/DisplayAdapter.cpp             |  229 +++
 mx6/libcamera/DisplayAdapter.h               |   96 +
 mx6/libcamera/JpegBuilder.cpp                |  649 +++++++
 mx6/libcamera/JpegBuilder.h                  |  175 ++
 mx6/libcamera/JpegEncoderInterface.cpp       |   34 -
 mx6/libcamera/JpegEncoderInterface.h         |  173 --
 mx6/libcamera/JpegEncoderSoftware.cpp        |  662 -------
 mx6/libcamera/JpegEncoderSoftware.h          |   84 -
 mx6/libcamera/NV12_resize.c                  |  303 +++
 mx6/libcamera/NV12_resize.h                  |  148 ++
 mx6/libcamera/OvDevice.cpp                   |  299 +++
 mx6/libcamera/OvDevice.h                     |   50 +
 mx6/libcamera/PP_ipulib.cpp                  |  138 --
 mx6/libcamera/PP_ipulib.h                    |   47 -
 mx6/libcamera/PhysMemAdapter.cpp             |  144 ++
 mx6/libcamera/PhysMemAdapter.h               |   52 +
 mx6/libcamera/PostProcessDeviceInterface.cpp |   26 -
 mx6/libcamera/PostProcessDeviceInterface.h   |   78 -
 mx6/libcamera/SurfaceAdapter.cpp             |  370 ++++
 mx6/libcamera/SurfaceAdapter.h               |   63 +
 mx6/libcamera/UvcDevice.h                    |   51 +
 mx6/libcamera/V4l2CapDeviceBase.cpp          |  715 -------
 mx6/libcamera/V4l2CapDeviceBase.h            |   84 -
 mx6/libcamera/V4l2CsiDevice.cpp              |  414 ----
 mx6/libcamera/V4l2CsiDevice.h                |   59 -
 mx6/libcamera/V4l2UVCDevice.cpp              |  716 -------
 mx6/libcamera/V4l2UVCDevice.h                |   99 -
 mx6/libcamera/YuvToJpegEncoder.cpp           |  375 ++++
 mx6/libcamera/YuvToJpegEncoder.h             |  112 ++
 mx6/libcamera/messageQueue.cpp               |   64 +-
 mx6/libcamera/messageQueue.h                 |   58 +-
 44 files changed, 6044 insertions(+), 6284 deletions(-)
 create mode 100755 mx6/libcamera/CameraBridge.cpp
 create mode 100755 mx6/libcamera/CameraBridge.h
 create mode 100755 mx6/libcamera/CameraUtil.cpp
 create mode 100755 mx6/libcamera/CameraUtil.h
 delete mode 100755 mx6/libcamera/Camera_utils.h
 delete mode 100755 mx6/libcamera/CaptureDeviceInterface.cpp
 delete mode 100755 mx6/libcamera/CaptureDeviceInterface.h
 create mode 100755 mx6/libcamera/DeviceAdapter.cpp
 create mode 100755 mx6/libcamera/DeviceAdapter.h
 create mode 100755 mx6/libcamera/DisplayAdapter.cpp
 create mode 100755 mx6/libcamera/DisplayAdapter.h
 create mode 100755 mx6/libcamera/JpegBuilder.cpp
 create mode 100755 mx6/libcamera/JpegBuilder.h
 delete mode 100755 mx6/libcamera/JpegEncoderInterface.cpp
 delete mode 100755 mx6/libcamera/JpegEncoderInterface.h
 delete mode 100755 mx6/libcamera/JpegEncoderSoftware.cpp
 delete mode 100755 mx6/libcamera/JpegEncoderSoftware.h
 create mode 100644 mx6/libcamera/NV12_resize.c
 create mode 100755 mx6/libcamera/NV12_resize.h
 create mode 100755 mx6/libcamera/OvDevice.cpp
 create mode 100755 mx6/libcamera/OvDevice.h
 delete mode 100755 mx6/libcamera/PP_ipulib.cpp
 delete mode 100755 mx6/libcamera/PP_ipulib.h
 create mode 100644 mx6/libcamera/PhysMemAdapter.cpp
 create mode 100644 mx6/libcamera/PhysMemAdapter.h
 delete mode 100755 mx6/libcamera/PostProcessDeviceInterface.cpp
 delete mode 100755 mx6/libcamera/PostProcessDeviceInterface.h
 create mode 100755 mx6/libcamera/SurfaceAdapter.cpp
 create mode 100755 mx6/libcamera/SurfaceAdapter.h
 create mode 100755 mx6/libcamera/UvcDevice.h
 delete mode 100755 mx6/libcamera/V4l2CapDeviceBase.cpp
 delete mode 100755 mx6/libcamera/V4l2CapDeviceBase.h
 delete mode 100755 mx6/libcamera/V4l2CsiDevice.cpp
 delete mode 100755 mx6/libcamera/V4l2CsiDevice.h
 delete mode 100755 mx6/libcamera/V4l2UVCDevice.cpp
 delete mode 100755 mx6/libcamera/V4l2UVCDevice.h
 create mode 100755 mx6/libcamera/YuvToJpegEncoder.cpp
 create mode 100755 mx6/libcamera/YuvToJpegEncoder.h

diff --git a/mx6/libcamera/Android.mk b/mx6/libcamera/Android.mk
index 3e60b7e..6f5fe17 100755
--- a/mx6/libcamera/Android.mk
+++ b/mx6/libcamera/Android.mk
@@ -20,15 +20,19 @@ ifeq ($(BOARD_HAVE_IMX_CAMERA),true)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=    \
-	CameraHal.cpp    \
-	CameraModule.cpp \
-	CaptureDeviceInterface.cpp \
-	V4l2CsiDevice.cpp \
-	V4l2CapDeviceBase.cpp  \
-	JpegEncoderInterface.cpp \
-    JpegEncoderSoftware.cpp \
+    CameraHal.cpp    \
+    CameraModule.cpp \
+    CameraBridge.cpp \
+    CameraUtil.cpp \
+    DeviceAdapter.cpp \
+    DisplayAdapter.cpp \
+    SurfaceAdapter.cpp \
+    JpegBuilder.cpp \
     messageQueue.cpp \
-    V4l2UVCDevice.cpp
+    OvDevice.cpp \
+    PhysMemAdapter.cpp \
+    YuvToJpegEncoder.cpp \
+    NV12_resize.c
 
 LOCAL_CPPFLAGS +=
 
@@ -40,20 +44,24 @@ LOCAL_SHARED_LIBRARIES:= \
     libbinder \
     libmedia \
     libhardware_legacy \
-    libion \
     libdl \
-    libc
+    libc \
+    libjpeg \
+    libexif \
+    libion
 
 LOCAL_C_INCLUDES += \
 	frameworks/base/include/binder \
 	frameworks/base/include/ui \
 	frameworks/base/camera/libcameraservice \
-	hardware/imx/mx6/libgralloc_wrapper
+	hardware/imx/mx6/libgralloc_wrapper \
+	external/jpeg \
+	external/jhead
 
 ifeq ($(HAVE_FSL_IMX_CODEC),true)
-    LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
-    LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
-    LOCAL_C_INCLUDES += device/fsl-proprietary/codec/ghdr
+    #LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
+    #LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
+    #LOCAL_C_INCLUDES += device/fsl-proprietary/codec/ghdr
 endif
 ifeq ($(BOARD_CAMERA_NV12),true)
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
@@ -64,7 +72,7 @@ endif
 #Define this for switch the Camera through V4L2 MXC IOCTL
 #LOCAL_CPPFLAGS += -DV4L2_CAMERA_SWITCH
 
-LOCAL_CPPFLAGS += -Werror
+#LOCAL_CPPFLAGS += -Werror
 
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
 LOCAL_MODULE:= camera.$(TARGET_BOARD_PLATFORM)
diff --git a/mx6/libcamera/CameraBridge.cpp b/mx6/libcamera/CameraBridge.cpp
new file mode 100755
index 0000000..8e2ac91
--- /dev/null
+++ b/mx6/libcamera/CameraBridge.cpp
@@ -0,0 +1,786 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CameraBridge.h"
+
+CameraBridge::CameraBridge()
+    : mEventProvider(NULL),
+      mFrameProvider(NULL), mUseMetaDataBufferMode(false),
+      mNotifyCb(NULL), mDataCb(NULL),
+      mDataCbTimestamp(NULL), mRequestMemory(NULL), mCallbackCookie(NULL),
+      mMsgEnabled(0), mBridgeState(BRIDGE_INVALID),
+      mRecording(false), mVideoWidth(0), mVideoHeight(0),
+      mBufferCount(0), mBufferSize(0), mMetaDataBufsSize(0),
+      mPreviewMemory(NULL), mVideoMemory(NULL)
+{
+    memset(mSupprotedThumbnailSizes, 0, sizeof(mSupprotedThumbnailSizes));
+    mMetaDataBufsMap.clear();
+    mVpuSupportFmt[0] = v4l2_fourcc('N','V','1','2');
+    mVpuSupportFmt[1] = v4l2_fourcc('Y','U','1','2');
+}
+
+CameraBridge::~CameraBridge()
+{
+    if(mFrameProvider != NULL) {
+        mFrameProvider->removeFrameListener(this);
+    }
+
+    if(mEventProvider != NULL) {
+        mEventProvider->removeEventListener(this);
+    }
+
+    if(mBridgeThread != NULL) {
+        mThreadQueue.postSyncMessage(new SyncMessage(BridgeThread::BRIDGE_EXIT, 0));
+        mBridgeThread->requestExitAndWait();
+        mBridgeThread.clear();
+    }
+}
+
+status_t CameraBridge::initialize()
+{
+    ///Create the app notifier thread
+    mBridgeThread = new BridgeThread(this);
+    if(!mBridgeThread.get()) {
+        FLOGE("Couldn't create bridge thread");
+        return NO_MEMORY;
+    }
+
+    ///Start the display thread
+    status_t ret = mBridgeThread->run("BridgeThread", PRIORITY_URGENT_DISPLAY);
+    if(ret!=NO_ERROR) {
+        FLOGE("Couldn't run BridgeThread");
+        mBridgeThread.clear();
+        return ret;
+    }
+
+    mUseMetaDataBufferMode = false;
+    mBridgeState = CameraBridge::BRIDGE_INIT;
+    mJpegBuilder = new JpegBuilder();
+    if(mJpegBuilder == NULL) {
+        FLOGE("Couldn't create JpegBuilder");
+        return NO_MEMORY;
+    }
+    ret = mJpegBuilder->getSupportedPictureFormat(mPictureSupportFmt, MAX_PICTURE_SUPPORT_FORMAT);
+
+    return ret;
+}
+
+status_t CameraBridge::getSupportedRecordingFormat(int* pFormat, int len)
+{
+    if(pFormat != 0 && len > 0) {
+        memcpy(pFormat, mVpuSupportFmt, len * sizeof(pFormat[0]));
+        return NO_ERROR;
+    }
+
+    return BAD_VALUE;
+}
+
+status_t CameraBridge::getSupportedPictureFormat(int* pFormat, int len)
+{
+    if(pFormat != 0 && len > 0) {
+        memcpy(pFormat, mPictureSupportFmt, len * sizeof(pFormat[0]));
+        return NO_ERROR;
+    }
+
+    return BAD_VALUE;
+}
+
+status_t CameraBridge::initParameters(CameraParameters& params)
+{
+    char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
+
+    /*hard code here*/
+    params.set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
+    params.setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
+    params.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
+    params.set(CameraParameters::KEY_JPEG_QUALITY, 100);
+    strcpy(mSupprotedThumbnailSizes, "0x0,128x128,96x96");
+    params.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, mSupprotedThumbnailSizes);
+    params.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
+    params.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
+    params.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
+
+    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
+    params.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
+    params.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
+
+    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
+    params.set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
+    params.set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
+
+    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
+    params.set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
+    params.set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
+
+    params.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
+    params.set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
+
+    params.set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
+    params.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
+    params.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
+    params.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
+    params.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
+    params.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
+    params.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
+
+    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+    strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
+    params.set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
+    params.set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
+
+    memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+    strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
+    params.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
+    params.set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
+    params.set(CameraParameters::KEY_ZOOM_SUPPORTED, "true");
+    //params.set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
+    params.set(CameraParameters::KEY_MAX_ZOOM, "1");
+    // default zoom should be 0 as CTS defined
+    params.set(CameraParameters::KEY_ZOOM, "0");
+    //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+    //returned as 320. The number of elements is {@link
+    //#getMaxZoom} + 1. The list is sorted from small to large. The
+    //first element is always 100. The last element is the zoom
+    //ratio of the maximum zoom value.
+    params.set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
+
+    mParameters = params;
+    return NO_ERROR;
+}
+
+void CameraBridge::setCallbacks(camera_notify_callback notify_cb,
+                                camera_data_callback data_cb,
+                                camera_data_timestamp_callback data_cb_timestamp,
+                                camera_request_memory get_memory,
+                                void *user)
+{
+    Mutex::Autolock lock(mLock);
+
+    mNotifyCb = notify_cb;
+    mDataCb = data_cb;
+    mDataCbTimestamp = data_cb_timestamp;
+    mRequestMemory = get_memory;
+    mCallbackCookie = user;
+}
+
+status_t CameraBridge::setParameters(CameraParameters& params)
+{
+    Mutex::Autolock lock(mLock);
+
+    const char *pFlashStr;
+    pFlashStr = params.get(CameraParameters::KEY_FLASH_MODE);
+    if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0
+            && strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) != 0
+            && strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) != 0) {
+        FLOGE("The flash mode is not corrected");
+        return BAD_VALUE;
+    }
+
+    const char *pFocusStr;
+    pFocusStr = params.get(CameraParameters::KEY_FOCUS_MODE);
+    if(strcmp(pFocusStr, CameraParameters::FOCUS_MODE_AUTO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_INFINITY) != 0
+            && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_MACRO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_FIXED) != 0
+            && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_EDOF) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) != 0) {
+        FLOGE("The focus mode is not corrected");
+        return BAD_VALUE;
+    }
+
+    mParameters = params;
+    return NO_ERROR;
+}
+
+void CameraBridge::setCameraFrameProvider(CameraFrameProvider* frameProvider)
+{
+    if(frameProvider != NULL) {
+        frameProvider->addFrameListener(this);
+    }
+    mFrameProvider = frameProvider;
+}
+
+void CameraBridge::setCameraEventProvider(int32_t msgs, CameraEventProvider* eventProvider)
+{
+    if(eventProvider != NULL) {
+        eventProvider->addEventListener(this);
+    }
+    mEventProvider = eventProvider;
+}
+
+status_t CameraBridge::enableMsgType(int32_t msgType)
+{
+    {
+        Mutex::Autolock lock(mLock);
+        mMsgEnabled |= msgType;
+    }
+
+    return NO_ERROR;
+}
+
+status_t CameraBridge::disableMsgType(int32_t msgType)
+{
+    {
+        Mutex::Autolock lock(mLock);
+        mMsgEnabled &= ~msgType;
+    }
+
+    return NO_ERROR;
+}
+
+status_t CameraBridge::useMetaDataBufferMode(bool enable)
+{
+    mUseMetaDataBufferMode = enable;
+
+    return NO_ERROR;
+}
+
+status_t CameraBridge::startRecording()
+{
+    Mutex::Autolock lock(mRecordingLock);
+    if(mRecording) {
+        FLOGW("CameraBridge has started Recording");
+        return ALREADY_EXISTS;
+    }
+
+    status_t ret = allocateVideoBufs();
+    mRecording = true;
+
+    return ret;
+}
+
+status_t CameraBridge::stopRecording()
+{
+    Mutex::Autolock lock(mRecordingLock);
+    if(!mRecording) {
+        FLOGW("CameraBridge has not started Recording");
+        return NO_INIT;
+    }
+
+    mRecording = false;
+    releaseVideoBufs();
+
+    return NO_ERROR;
+}
+
+status_t CameraBridge::start()
+{
+    if(mBridgeState == CameraBridge::BRIDGE_STARTED) {
+        FLOGW("CameraBridge already running");
+        return ALREADY_EXISTS;
+    }
+
+    Mutex::Autolock lock(mLock);
+    if(!mFrameProvider) {
+        FLOGE("CameraBridge: frameProvider does not initialize");
+        return NO_INIT;
+    }
+    if(!mEventProvider) {
+        FLOGE("CameraBridge: eventProvider does not initialize");
+        return NO_INIT;
+    }
+
+    int bufSize = mFrameProvider->getFrameSize();
+    int bufCnt = mFrameProvider->getFrameCount();
+    if(mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+        if(mPreviewMemory != NULL) {
+            mPreviewMemory->release(mPreviewMemory);
+            mPreviewMemory = NULL;
+        }
+
+        mPreviewMemory = mRequestMemory(-1, bufSize, bufCnt, NULL);
+        if(mPreviewMemory == NULL) {
+            FLOGE("CameraBridge: notifyBufferCreat mRequestMemory failed");
+        }
+    }
+
+    mBufferSize = bufSize;
+    mBufferCount = bufCnt;
+    mThreadQueue.postSyncMessage(new SyncMessage(BridgeThread::BRIDGE_START, 0));
+    FSL_ASSERT(mFrameProvider.get() != NULL);
+    mFrameProvider->addFrameListener(this);
+
+    return NO_ERROR;
+}
+
+status_t CameraBridge::stop()
+{
+    if(mBridgeState == CameraBridge::BRIDGE_STOPPED) {
+        FLOGW("CameraBridge already stopped");
+        return ALREADY_EXISTS;
+    }
+
+    Mutex::Autolock lock(mLock);
+    mThreadQueue.postSyncMessage(new SyncMessage(BridgeThread::BRIDGE_STOP, 0));
+    FSL_ASSERT(mFrameProvider.get() != NULL);
+    mFrameProvider->removeFrameListener(this);
+
+    return NO_ERROR;
+}
+
+bool CameraBridge::bridgeThread()
+{
+    bool shouldLive = true;
+
+    sp<CMessage> msg = mThreadQueue.waitMessage();
+    if(msg == 0) {
+        FLOGE("displayThread: get invalid message");
+        return false;
+    }
+
+    switch(msg->what) {
+        case BridgeThread::BRIDGE_START:
+            FLOGI("BridgeThread received BRIDGE_START command from Camera HAL");
+            mBridgeState = CameraBridge::BRIDGE_STARTED;
+            break;
+
+        case BridgeThread::BRIDGE_STOP:
+            FLOGI("BridgeThread received BRIDGE_STOP command from Camera HAL");
+            mBridgeState = CameraBridge::BRIDGE_STOPPED;
+            break;
+
+        case BridgeThread::BRIDGE_EVENT:
+            FLOGI("BridgeThread received BRIDGE_EVENT command from Camera HAL");
+            if(mBridgeState == CameraBridge::BRIDGE_INIT) {
+                break;
+            }
+            if(mBridgeState == CameraBridge::BRIDGE_STARTED) {
+                shouldLive = processEvent((CameraEvent*)msg->arg0);
+            }
+            if(mBridgeState == CameraBridge::BRIDGE_EXITED) {
+                shouldLive = false;
+            }
+            break;
+
+        case BridgeThread::BRIDGE_FRAME:
+            //FLOGI("BridgeThread received BRIDGE_FRAME command from Camera HAL");
+            if(mBridgeState == CameraBridge::BRIDGE_INIT) {
+                break;
+            }
+            if(mBridgeState == CameraBridge::BRIDGE_STARTED) {
+                shouldLive = processFrame((CameraFrame*)msg->arg0);
+            }
+            if(mBridgeState == CameraBridge::BRIDGE_EXITED) {
+                shouldLive = false;
+            }
+            break;
+
+        case BridgeThread::BRIDGE_EXIT:
+            mBridgeState = CameraBridge::BRIDGE_EXITED;
+            FLOGI("Bridge Thread exiting...");
+            shouldLive = false;
+            break;
+    }
+
+    return shouldLive;
+}
+
+bool CameraBridge::processEvent(CameraEvent* event)
+{
+    ///Receive and send the event notifications to app
+    bool ret = true;
+
+    if(NULL == event) {
+        FLOGE("CameraBridge: processEvent receive null event");
+        return false;
+    }
+
+    switch(event->mEventType) {
+        case CameraEvent::EVENT_SHUTTER:
+            if((NULL != mNotifyCb) && (mMsgEnabled & CAMERA_MSG_SHUTTER)) {
+                mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
+            }
+
+            break;
+
+        case CameraEvent::EVENT_FOCUS:
+            if((NULL != mNotifyCb) && (mMsgEnabled & CAMERA_MSG_FOCUS)) {
+                mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
+            }
+
+            break;
+
+        default:
+            FLOGE("CameraBridge: processEvent does not support event now");
+            break;
+    }
+
+    event->decStrong(event);
+    return ret;
+}
+
+bool CameraBridge::processFrame(CameraFrame* frame)
+{
+    MemoryHeapBase *heap;
+    MemoryBase *buffer = NULL;
+    sp<MemoryBase> memBase;
+    void *buf = NULL;
+
+    bool ret = true;
+
+    if(!frame || !frame->mBufHandle) {
+        FLOGE("CameraBridge: processFrame receive null frame");
+        return false;
+    }
+
+    if((frame->mFrameType & CameraFrame::IMAGE_FRAME)) {
+        if((mMsgEnabled & CAMERA_MSG_RAW_IMAGE) && (NULL != mDataCb)) {
+            sendRawImageFrame(frame);
+        }
+
+        if(mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY && mNotifyCb != NULL) {
+            mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
+        }
+
+        if(mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE) {
+            ret = processImageFrame(frame);
+        }
+    }
+    else if(frame->mFrameType & CameraFrame::PREVIEW_FRAME) {
+        if((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && (NULL != mDataCbTimestamp)) {
+            sendVideoFrame(frame);
+        }
+
+        if((mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) && (NULL != mDataCb)) {
+            sendPreviewFrame(frame);
+        }
+    }
+
+    //the frame release from CameraBridge.
+    frame->release();
+    return ret;
+}
+
+bool CameraBridge::processImageFrame(CameraFrame* frame)
+{
+    FSL_ASSERT(frame);
+    status_t ret = NO_ERROR;
+    int encodeQuality = 100, thumbQuality = 100;
+    int thumbWidth, thumbHeight;
+    JpegParams *mainJpeg = NULL, *thumbJpeg = NULL;
+    void* rawBuf = NULL, *thumbBuf = NULL;
+
+    camera_memory_t* rawFrame = mRequestMemory(-1, frame->mSize, 1, NULL);
+    if(!rawFrame || !rawFrame->data) {
+        FLOGE("CameraBridge:processImageFrame mRequestMemory rawFrame failed");
+        return false;
+    }
+    rawBuf = rawFrame->data;
+
+    camera_memory_t* thumbFrame = mRequestMemory(-1, frame->mSize, 1, NULL);
+    if(!thumbFrame || !thumbFrame->data) {
+        FLOGE("CameraBridge:processImageFrame mRequestMemory thumbFrame failed");
+        return false;
+    }
+    thumbBuf = thumbFrame->data;
+
+    encodeQuality = mParameters.getInt(CameraParameters::KEY_JPEG_QUALITY);
+    if (encodeQuality < 0 || encodeQuality > 100) {
+        encodeQuality = 100;
+    }
+
+    thumbQuality = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY);
+    if (thumbQuality < 0 || thumbQuality > 100) {
+        thumbQuality = 100;
+    }
+
+    mainJpeg = new JpegParams((uint8_t*)frame->mVirtAddr, frame->mSize, (uint8_t*)rawBuf,
+        frame->mSize, encodeQuality, frame->mWidth, frame->mHeight, frame->mWidth,
+        frame->mHeight, mParameters.getPreviewFormat());
+
+    thumbWidth = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
+    thumbHeight = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
+
+    if ((thumbWidth > 0) && (thumbHeight > 0)) {
+
+        int thumbSize = 0;
+        int thumbFormat = convertStringToV4L2Format(mParameters.getPreviewFormat());
+        switch(thumbFormat) {
+            case v4l2_fourcc('N','V','1','2'):
+                thumbSize = thumbWidth * thumbHeight * 3/2;
+                break;
+            case v4l2_fourcc('Y','U','1','2'):
+                thumbSize = thumbWidth * thumbHeight * 3/2;
+                break;
+            case v4l2_fourcc('Y','U','Y','V'):
+                thumbSize = thumbWidth * thumbHeight * 2;
+                break;
+            default:
+                FLOGE("Error: format not supported int ion alloc");
+                return false;
+        }
+        thumbSize = frame->mSize;
+        thumbJpeg = new JpegParams((uint8_t*)frame->mVirtAddr, frame->mSize, (uint8_t*)thumbBuf,
+                thumbSize, thumbQuality, frame->mWidth, frame->mHeight, thumbWidth,
+                thumbHeight, mParameters.getPreviewFormat());
+    }
+
+    mJpegBuilder->prepareImage(mParameters);
+    ret = mJpegBuilder->encodeImage(mainJpeg, thumbJpeg);
+    if(ret != NO_ERROR) {
+        FLOGE("CameraBridge:processImageFrame encodeImage failed");
+        return false;
+    }
+
+    size_t imageSize = mJpegBuilder->getImageSize();
+    camera_memory_t* picture = NULL;
+    ret = mJpegBuilder->buildImage(mRequestMemory, &picture);
+    if(ret != NO_ERROR || !picture) {
+        FLOGE("CameraBridge:processImageFrame buildImage failed");
+        return false;
+    }
+    mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, picture, 0, NULL, mCallbackCookie);
+
+    if(mainJpeg) {
+        delete mainJpeg;
+    }
+
+    if(thumbJpeg) {
+        delete thumbJpeg;
+    }
+
+    if(rawFrame) {
+        rawFrame->release(rawFrame);
+        rawFrame = NULL;
+    }
+
+    if(thumbFrame) {
+        thumbFrame->release(thumbFrame);
+        thumbFrame = NULL;
+    }
+
+    if(picture) {
+        picture->release(picture);
+        picture = NULL;
+    }
+
+    return true;
+}
+
+void CameraBridge::sendRawImageFrame(CameraFrame* frame)
+{
+    FSL_ASSERT(frame);
+    camera_memory_t *RawMemBase = NULL;
+    RawMemBase = mRequestMemory(-1, frame->mSize, 1, NULL);
+    if(NULL == RawMemBase) {
+        FLOGE("CameraBridge: allocateRecordVideoBuf mRequestMemory failed");
+        return;
+    }
+
+    void *dest = RawMemBase->data;
+    if (NULL != dest) {
+        void *src = frame->mVirtAddr;
+        memcpy(dest, src, frame->mSize);
+    }
+
+    mDataCb(CAMERA_MSG_RAW_IMAGE, RawMemBase, 0, NULL, mCallbackCookie);
+    RawMemBase->release(RawMemBase);
+    RawMemBase = NULL;
+}
+
+void CameraBridge::sendPreviewFrame(CameraFrame* frame)
+{
+    FSL_ASSERT(frame);
+    FSL_ASSERT(mPreviewMemory);
+    int bufIdx = frame->mIndex;
+    FSL_ASSERT(bufIdx >= 0);
+
+    convertNV12toYUV420SP((uint8_t*)(frame->mVirtAddr),
+          (uint8_t*)((unsigned char*)mPreviewMemory->data + bufIdx * mBufferSize),
+          frame->mWidth, frame->mHeight);
+    mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, bufIdx, NULL, mCallbackCookie);
+}
+
+void CameraBridge::sendVideoFrame(CameraFrame* frame)
+{
+    FSL_ASSERT(frame);
+    if(!mRecording) {
+        FLOGE("CameraBridge: sendVideoFrame but mRecording not enable");
+        return;
+    }
+
+    mRecordingLock.lock();
+    nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
+    int bufIdx = frame->mIndex;
+    FSL_ASSERT(bufIdx >= 0);
+    FSL_ASSERT(mVideoMemory);
+
+    unsigned char* pVideoBuf = (unsigned char*)mVideoMemory->data + bufIdx * mMetaDataBufsSize;
+    if(mUseMetaDataBufferMode) {
+        VideoMetadataBuffer* pMetaBuf = (VideoMetadataBuffer*)pVideoBuf;
+        pMetaBuf->phyOffset = frame->mPhyAddr;
+        pMetaBuf->length = frame->mSize;
+    }
+    else {
+        memcpy(pVideoBuf, (void*)frame->mVirtAddr, mMetaDataBufsSize);
+    }
+
+    if(mMetaDataBufsMap.indexOfKey((int)pVideoBuf) >= 0) {
+        int fAddr = mMetaDataBufsMap.valueFor((int)pVideoBuf);
+        FSL_ASSERT(fAddr == (int)frame);
+    }
+    else {
+        mMetaDataBufsMap.add((int)pVideoBuf, (int)frame);
+    }
+
+    //the frame held in mediaRecorder.
+    frame->addReference();
+    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, bufIdx, mCallbackCookie);
+    mRecordingLock.unlock();
+}
+
+void CameraBridge::releaseRecordingFrame(const void* mem)
+{
+    CameraFrame* pFrame = (CameraFrame*)mMetaDataBufsMap.valueFor((int)mem);
+    //the frame release from mediaRecorder.
+    pFrame->release();
+}
+
+void CameraBridge::handleCameraFrame(CameraFrame* frame)
+{
+    if(!frame || !frame->mBufHandle) {
+        FLOGI("CameraBridge: notifyCameraFrame receive null frame");
+        return;
+    }
+
+    //the frame held in CameraBridge.
+    frame->addReference();
+    mThreadQueue.postMessage(
+        new CMessage(BridgeThread::BRIDGE_FRAME, (int)frame));
+}
+
+void CameraBridge::handleEvent(sp<CameraEvent>& event)
+{
+    event->incStrong(event.get());
+    mThreadQueue.postMessage(
+        new CMessage(BridgeThread::BRIDGE_EVENT, (int)event.get()));
+}
+
+status_t CameraBridge::allocateVideoBufs()
+{
+    if(mVideoMemory != NULL) {
+        mVideoMemory->release(mVideoMemory);
+        mVideoMemory = NULL;
+    }
+
+    if(mUseMetaDataBufferMode) {
+        mMetaDataBufsSize = sizeof(VideoMetadataBuffer);
+    }
+    else {
+        mMetaDataBufsSize = mBufferSize;
+    }
+
+    mVideoMemory = mRequestMemory(-1, mMetaDataBufsSize, mBufferCount, NULL);
+    if(mVideoMemory == NULL) {
+        FLOGE("CameraBridge: allocateRecordVideoBuf mRequestMemory failed");
+        return NO_MEMORY;
+    }
+
+    return NO_ERROR;
+}
+
+void CameraBridge::releaseVideoBufs()
+{
+    if(mVideoMemory != NULL) {
+        mVideoMemory->release(mVideoMemory);
+        mVideoMemory = NULL;
+    }
+
+    mMetaDataBufsMap.clear();
+}
+
+status_t CameraBridge::initImageCapture()
+{
+    mJpegBuilder->reset();
+    mJpegBuilder->setParameters(mParameters);
+    return NO_ERROR;
+}
+
+void CameraBridge::handleError(CAMERA_ERROR err)
+{
+    if(err == ERROR_FATAL) {
+        abort();
+        return;
+    }
+
+    if(mNotifyCb != NULL && (mMsgEnabled & CAMERA_MSG_ERROR)) {
+        mNotifyCb(CAMERA_MSG_ERROR, CAMERA_ERROR_UNKNOWN, 0, mCallbackCookie);
+    }
+}
+
+void CameraBridge::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
+{
+    /* Color space conversion from I420 to YUV420SP */
+    int Ysize = 0, UVsize = 0;
+    uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
+
+    Ysize = width * height;
+    UVsize = width *  height >> 2;
+
+    Yin = inputBuffer;
+    Uin = Yin + Ysize;
+    Vin = Uin + 1;
+
+    Yout = outputBuffer;
+    Vout = Yout + Ysize;
+    Uout = Vout + 1;
+
+    memcpy(Yout, Yin, Ysize);
+
+    for(int k = 0; k < UVsize; k++) {
+        *Uout = *Uin;
+        *Vout = *Vin;
+        Uout += 2;
+        Vout += 2;
+        Uin  += 2;
+        Vin += 2;
+    }
+}
+
+
diff --git a/mx6/libcamera/CameraBridge.h b/mx6/libcamera/CameraBridge.h
new file mode 100755
index 0000000..44b7104
--- /dev/null
+++ b/mx6/libcamera/CameraBridge.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _CAMERA_BRIDGE_H_
+#define _CAMERA_BRIDGE_H_
+
+#include "CameraUtil.h"
+#include <hardware/camera.h>
+#include "messageQueue.h"
+#include "JpegBuilder.h"
+
+using namespace android;
+
+#define MAX_THUMBNAIL_BUFFER_SIZE 32
+
+#define MAX_VPU_SUPPORT_FORMAT 2
+#define MAX_PICTURE_SUPPORT_FORMAT 2
+
+class CameraBridge : public CameraEventListener,
+    public CameraFrameListener,
+    public CameraErrorListener,
+    public LightRefBase<CameraBridge>
+{
+public:
+    enum BridgeState {
+        BRIDGE_INVALID = 0,
+        BRIDGE_INIT = 1,
+        BRIDGE_STARTED,
+        BRIDGE_STOPPED,
+        BRIDGE_EXITED
+    };
+
+    CameraBridge();
+    virtual ~CameraBridge();
+    status_t initialize();
+    status_t start();
+    status_t stop();
+
+    status_t initImageCapture();
+    status_t getSupportedRecordingFormat(int* pFormat, int len);
+    status_t getSupportedPictureFormat(int* pFormat, int len);
+
+    status_t enableMsgType(int32_t msgType);
+    status_t disableMsgType(int32_t msgType);
+
+    status_t startRecording();
+    status_t stopRecording();
+    status_t useMetaDataBufferMode(bool enable);
+    void releaseRecordingFrame(const void* mem);
+
+public:
+    void setCallbacks(camera_notify_callback notify_cb,
+                      camera_data_callback data_cb,
+                      camera_data_timestamp_callback data_cb_timestamp,
+                      camera_request_memory get_memory,
+                      void *user);
+
+    virtual status_t setParameters(CameraParameters& params);
+    virtual status_t initParameters(CameraParameters& params);
+
+    void setCameraFrameProvider(CameraFrameProvider* frameProvider);
+    void setCameraEventProvider(int32_t msgs, CameraEventProvider* eventProvider);
+
+protected:
+    void handleCameraFrame(CameraFrame* frame);
+    void handleEvent(sp<CameraEvent>& event);
+    void handleError(CAMERA_ERROR err);
+
+    virtual bool processImageFrame(CameraFrame* frame);
+
+private:
+    bool bridgeThread();
+    bool processEvent(CameraEvent* event);
+    bool processFrame(CameraFrame* frame);
+
+    void sendPreviewFrame(CameraFrame* frame);
+    void sendVideoFrame(CameraFrame* frame);
+    void sendRawImageFrame(CameraFrame* frame);
+
+    status_t allocateVideoBufs();
+    void releaseVideoBufs();
+    void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
+
+public:
+    class BridgeThread : public Thread {
+    public:
+        enum BridgeCommand {
+            BRIDGE_START,
+            BRIDGE_STOP,
+            BRIDGE_EVENT,
+            BRIDGE_FRAME,
+            BRIDGE_EXIT,
+        };
+
+    public:
+        BridgeThread(CameraBridge* camera)
+            : Thread(false), mCamera(camera)
+        {
+        }
+
+        virtual bool threadLoop() {
+            return mCamera->bridgeThread();
+        }
+
+    private:
+        CameraBridge* mCamera;
+    };
+
+private:
+    sp<BridgeThread> mBridgeThread;
+    CMessageQueue mThreadQueue;
+    CameraEventProvider* mEventProvider;
+    CameraFrameProvider* mFrameProvider;
+
+private:
+    bool mUseMetaDataBufferMode;
+    CameraParameters mParameters;
+    camera_notify_callback mNotifyCb;
+    camera_data_callback   mDataCb;
+    camera_data_timestamp_callback mDataCbTimestamp;
+    camera_request_memory mRequestMemory;
+    void *mCallbackCookie;
+
+private:
+    mutable Mutex mLock;
+    int32_t mMsgEnabled;
+    char mSupprotedThumbnailSizes[MAX_THUMBNAIL_BUFFER_SIZE];
+
+    BridgeState mBridgeState;
+    mutable Mutex mRecordingLock;
+    bool mRecording;
+    int mVideoWidth;
+    int mVideoHeight;
+
+    int mBufferCount;
+    int mBufferSize;
+    int mMetaDataBufsSize;
+    camera_memory_t* mPreviewMemory;
+    camera_memory_t* mVideoMemory;
+    KeyedVector<int, int> mMetaDataBufsMap;
+
+    int mVpuSupportFmt[MAX_VPU_SUPPORT_FORMAT];
+    int mPictureSupportFmt[MAX_PICTURE_SUPPORT_FORMAT];
+    sp<JpegBuilder> mJpegBuilder;
+};
+
+#endif
diff --git a/mx6/libcamera/CameraHal.cpp b/mx6/libcamera/CameraHal.cpp
index c436dd0..591fbe7 100755
--- a/mx6/libcamera/CameraHal.cpp
+++ b/mx6/libcamera/CameraHal.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,2381 +15,609 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-
-#include <cutils/properties.h>
 #include "CameraHal.h"
-#include <time.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dlfcn.h>
-#include <hardware_legacy/power.h>
-#include <ui/GraphicBufferMapper.h>
-#include <ui/Rect.h>
-#include "gralloc_priv.h"
-
-#include <ion/ion.h>
+#include "PhysMemAdapter.h"
 
 using namespace android;
 
-    CameraHal::CameraHal(int cameraid)
-        :
-        mCaptureRunning(0),
-        mExitCaptureThread(false),
-        mPreviewRunning(0),
-        mExitPreviewThread(false),
-        mExitEncodeThread(false),
-        mTakePictureInProcess(false),
-        mTakePictureAllocBuffer(false),
-        mParameters(),
-        mCallbackCookie(NULL),
-        mNotifyCb(NULL),
-        mDataCb(NULL),
-        mDataCbTimestamp(NULL),
-        mCaptureFrameThread(NULL),
-        mPreviewShowFrameThread(NULL),
-        mEncodeFrameThread(NULL),
-        mAutoFocusThread(NULL),
-        mTakePicThread(NULL),
-        mLock(),
-        mSupportedPictureSizes(NULL),
-        mSupportedPreviewSizes(NULL),
-        mSupportedFPS(NULL),
-        mSupprotedThumbnailSizes(NULL),
-        mSupportPreviewFormat(NULL),
-        mNativeWindow(NULL),
-        mMsgEnabled(0),
-        mPreviewMemory(NULL),
-        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
-        mVideoMemory(NULL),
-        mDefaultPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
-        mPreviewFrameSize(0),
-        mTakePicFlag(false),
-        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
-        mCaptureFrameSize(0),
-        mCaptureBufNum(0),
-        mEnqueuedBufs(0),
-        mRecordRunning(0),
-        mCurrentRecordFrame(0),
-        nCameraBuffersQueued(0),
-        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
-        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
-        mCameraReady(false),
-        mCaptureDeviceOpen(false),
-        mIsCaptureBufsAllocated(0),
-        mPowerLock(false),
-        mDirectInput(false),
-        mCameraid(cameraid),
-        mPreviewRotate(CAMERA_PREVIEW_BACK_REF),
-        mIonFd(-1),
-        mUseIon(true)
-   {
-        CAMERA_LOG_FUNC;
-
-        if(mUseIon) {
-            mIonFd = ion_open();
-            if(mIonFd <= 0) {
-                CAMERA_LOG_INFO("open ion failed.");
-            }
-        }
-        preInit();
-    }
-
-    CameraHal :: ~CameraHal()
-    {
-        CAMERA_LOG_FUNC;
-        if(mUseIon) {
-            ion_close(mIonFd);
-        }
-        CameraMiscDeInit();
-        CloseCaptureDevice();
-        FreeInterBuf();
-        postDestroy();
-        if(mVideoMemory != NULL) {
-            mVideoMemory->release(mVideoMemory);
-        }
-        if(mPreviewMemory != NULL) {
-            mPreviewMemory->release(mPreviewMemory);
-        }
-        status_t err;
-
-    }
-
-    void CameraHal :: release()
-    {
-        CAMERA_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
-
-        mCameraReady = false;
-        CameraHALStopPreview();
-        UnLockWakeLock();
-        return;
-    }
-
-    void CameraHal :: preInit()
-    {
-        CAMERA_LOG_FUNC;
-        mVpuSupportFmt[0] = v4l2_fourcc('N','V','1','2');
-        mVpuSupportFmt[1] = v4l2_fourcc('Y','U','1','2');
-    }
-    void CameraHal :: postDestroy()
-    {
-        CAMERA_LOG_FUNC;
+CameraHal::CameraHal(int cameraId)
+    : mPowerLock(false), mCameraId(cameraId), mPreviewEnabled(false),
+      mRecordingEnabled(false), mTakePictureInProcess(false),
+      mSetPreviewWindowCalled(false),
+      mPreviewStartInProgress(false), mMsgEnabled(0), mUseIon(true)
+{
+    if(mUseIon) {
+        mPhysAdapter = new PhysMemAdapter();
+    }
+}
+
+CameraHal::~CameraHal()
+{
+    release();
+    mCameraBridge.clear();
+    mDeviceAdapter.clear();
+    mDisplayAdapter.clear();
+    if(mUseIon && mPhysAdapter) {
+        delete mPhysAdapter;
+    }
+}
+
+status_t CameraHal::initialize(const CameraInfo& info)
+{
+    status_t ret = NO_ERROR;
+    FLOG_RUNTIME("initialize name:%s, path:%s", info.name, info.devPath);
+    mDeviceAdapter = DeviceAdapter::Create(info);
+    if(mDeviceAdapter == NULL) {
+        FLOGE("CameraHal: DeviceAdapter create failed");
+        return BAD_VALUE;
     }
 
-    CAMERA_HAL_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mCaptureDevice = capturedevice;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+    ret = mDeviceAdapter->initialize(info);
+    if(ret) {
+        FLOGE("CameraHal: DeviceAdapter initialize failed");
         return ret;
     }
 
-    CAMERA_HAL_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mJpegEncoder = jpegencoder;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
+    mCameraBridge = new CameraBridge();
+    if(mCameraBridge == NULL) {
+        FLOGE("CameraHal: new CameraBridge failed");
+        return BAD_VALUE;
     }
 
-    CAMERA_HAL_RET CameraHal::Init()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        mCameraReady == true;
-        mCaptureDevice->GetDevType(&mSensorType);
-
-        if ((ret = AllocInterBuf())<0)
-            return ret;
-        if ((ret = InitCameraHalParam()) < 0)
-            return ret;
-        if ((ret = CameraMiscInit()) < 0)
-            return ret;
-
+    ret = mCameraBridge->initialize();
+    if(ret) {
+        FLOGE("CameraHal: CameraBridge initialize failed");
         return ret;
     }
-    void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
-    {
-        CAMERA_LOG_FUNC;
-        mPreviewRotate = previewRotate;
-        return ;
-    }
-
-    CAMERA_HAL_RET  CameraHal :: AllocInterBuf()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        mSupportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        mSupportPreviewFormat = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-
-        if (mSupportedPictureSizes == NULL ||
-                mSupportedPreviewSizes == NULL ||
-                mSupportedFPS          == NULL ||
-                mSupprotedThumbnailSizes == NULL ||
-                mSupportPreviewFormat == NULL)
-            ret = CAMERA_HAL_ERR_ALLOC_BUF;
 
+    mCameraBridge->getSupportedRecordingFormat(mSupportedRecordingFormat, MAX_VPU_SUPPORT_FORMAT);
+    mCameraBridge->getSupportedPictureFormat(mSupportedPictureFormat, MAX_PICTURE_SUPPORT_FORMAT);
+    ret = mDeviceAdapter->initParameters(mParameters, mSupportedRecordingFormat,
+            MAX_VPU_SUPPORT_FORMAT, mSupportedPictureFormat, MAX_PICTURE_SUPPORT_FORMAT);
+    if(ret) {
+        FLOGE("CameraHal: DeviceAdapter initParameters failed");
         return ret;
     }
-    void  CameraHal :: FreeInterBuf()
-    {
-        CAMERA_LOG_FUNC;
-        if (mSupportedPictureSizes)
-            free(mSupportedPictureSizes);
-        if (mSupportedPreviewSizes)
-            free(mSupportedPreviewSizes);
-        if (mSupportedFPS)
-            free(mSupportedFPS);
-        if (mSupprotedThumbnailSizes)
-            free(mSupprotedThumbnailSizes);
-    }
-
-    CAMERA_HAL_RET CameraHal :: InitCameraHalParam()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        if ((ret = InitCameraBaseParam(&mParameters)) < 0)
-            return ret;
-
-        if ((ret = InitPictureExifParam(&mParameters)) < 0)
-            return ret;
 
+    ret = mCameraBridge->initParameters(mParameters);
+    if(ret) {
+        FLOGE("CameraHal: CameraBridge initParameters failed");
         return ret;
     }
 
-    CAMERA_HAL_RET CameraHal::CameraMiscInit()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-
-        mPreviewRunning = false;
-        mCaptureRunning = false;
-        mWaitForTakingPicture = false;
-        sem_init(&mCaptureStoppedCondition, 0, 0);
-        sem_init(&mPreviewStoppedCondition, 0, 0);
-        //sem_init(&mEncodeStoppedCondition, 0, 0);
-        sem_init(&mTakingPicture, 0, 0);
-        //mPostProcessRunning = false;
-        //mEncodeRunning = false;
-        mCaptureFrameThread = new CaptureFrameThread(this);
-        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
-        mEncodeFrameThread = new EncodeFrameThread(this);
-        mTakePicThread= new TakePicThread(this);
-
-        if (mCaptureFrameThread == NULL || mPreviewShowFrameThread == NULL ||
-                mEncodeFrameThread == NULL || mTakePicThread == NULL){
-            return CAMERA_HAL_ERR_INIT;
-        }
+    mDeviceAdapter->setErrorListener(mCameraBridge.get());
+    mCameraBridge->setCameraFrameProvider(mDeviceAdapter.get());
+    mCameraBridge->setCameraEventProvider(CameraEvent::EVENT_INVALID, mDeviceAdapter.get());
+    mBufferProvider = NULL;
+
+    return ret;
+}
+
+void CameraHal::setCallbacks(camera_notify_callback notify_cb,
+        camera_data_callback data_cb,
+        camera_data_timestamp_callback data_cb_timestamp,
+        camera_request_memory get_memory,
+        void* user)
+{
+    Mutex::Autolock lock(mLock);
+    return mCameraBridge->setCallbacks(notify_cb, data_cb, data_cb_timestamp, get_memory, user);
+}
+
+void CameraHal::enableMsgType(int32_t msgType)
+{
+    if(mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+        FLOGI("Enabling Preview Callback");
+    }
+    else {
+        FLOGI("Preview callback not enabled %x", msgType);
+    }
+
+    Mutex::Autolock lock(mLock);
+    mCameraBridge->enableMsgType(msgType);
+    FLOGI("enableMsgType 0x%x", msgType);
+    mMsgEnabled |= msgType;
+}
+
+void CameraHal::disableMsgType(int32_t msgType)
+{
+    if(msgType & CAMERA_MSG_PREVIEW_FRAME) {
+        FLOGI("Disabling Preview Callback");
+    }
+
+    Mutex::Autolock lock(mLock);
+    mCameraBridge->disableMsgType(msgType);
+    FLOGI("disableMsgType 0x%x", msgType);
+    mMsgEnabled &= ~msgType;
+}
+
+bool CameraHal::msgTypeEnabled(int32_t msgType)
+{
+    Mutex::Autolock lock(mLock);
+    return (mMsgEnabled & msgType);
+}
+
+void CameraHal::putParameters(char *params)
+{
+    free(params);
+}
+
+char* CameraHal::getParameters() const
+{
+    Mutex::Autolock lock(mLock);
+    char* params_string;
+    String8 params_str8;
+    CameraParameters mParams = mParameters;
+
+    params_str8 = mParams.flatten();
+    params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
+    strcpy(params_string, params_str8.string());
+    return params_string;
+}
+
+status_t CameraHal::setParameters(const char* params)
+{
+    CameraParameters parameters;
+    String8 str_params(params);
+
+    parameters.unflatten(str_params);
+    return setParameters(parameters);
+}
+
+status_t CameraHal::setParameters(CameraParameters& params)
+{
+    status_t ret = NO_ERROR;
+    Mutex::Autolock lock(mLock);
+    FSL_ASSERT(mDeviceAdapter.get() != NULL);
+    ret = mDeviceAdapter->setParameters(params);
+    if(ret) {
+        FLOGE("CameraHal: initialize mDevice->setParameters failed");
         return ret;
     }
-    CAMERA_HAL_RET CameraHal::CameraMiscDeInit()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
-        mCaptureThreadQueue.postQuitMessage();
-        //Make sure all thread been exit, in case they still
-        //access the message queue
-        if(mCaptureFrameThread != NULL)
-            mCaptureFrameThread->requestExitAndWait();
-
-        //Post Quite message to make sure the thread can be exited
-        //In case mCaptureFrameThread not been started yet in CTS test
-        mPreviewThreadQueue.postQuitMessage();
-        if(mPreviewShowFrameThread != NULL)
-            mPreviewShowFrameThread->requestExitAndWait();
-        mEncodeThreadQueue.postQuitMessage();
-        if(mEncodeFrameThread != NULL)
-            mEncodeFrameThread->requestExitAndWait();
-        if(mTakePicThread != NULL)
-            mTakePicThread->requestExitAndWait();
-        return ret;
-    }
-
-    CAMERA_HAL_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
-    {
-        CAMERA_LOG_FUNC;
-        int i, n;
-        unsigned int uFormat[MAX_QUERY_FMT_TIMES];
-        char fmtStr[40];
-
-        memset(fmtStr, 0, 40);
-        convertPreviewFormatToString(fmtStr, 40, mPreviewCapturedFormat);
-        mParameters.setPreviewFormat(fmtStr);
-        mParameters.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, fmtStr);
-
-        memset(uFormat, 0, sizeof(uFormat));
-        for(n = 0; n < nFmt; n++) {
-            uFormat[n] = mSensorSupportFmt[n];
-        }
-
-        memset(fmtStr, 0, 40);
-        for(i = 0; i < n; i++) {
-            for (int j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
-                //should report VPU support format.
-                if(uFormat[i] == mVpuSupportFmt[j]) {
-                    if(uFormat[i] == v4l2_fourcc('Y','U','1','2')) {
-                        strcat(fmtStr, "yuv420p");
-                        strcat(fmtStr, ",");
-                    }
-                    else if(uFormat[i] == v4l2_fourcc('N','V','1','2')) {
-                        strcat(fmtStr, "yuv420sp");
-                        strcat(fmtStr, ",");
-                    }
-                    //else if(mSensorSupportFmt[i] == v4l2_fourcc('Y','U','Y','V')) {
-                    //    strcat(fmtStr, "yuv422i-yuyv");
-                    //    strcat(fmtStr, ",");
-                    //}
-                }
-            }
-        }
-
-        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
-        return CAMERA_HAL_ERR_NONE;
-    }
-
-    CAMERA_HAL_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
-    {
-        CAMERA_LOG_FUNC;
-        char TmpStr[20];
-        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
-        struct capture_config_t CaptureSizeFps;
-        int  previewCnt= 0, pictureCnt = 0, i;
-        char previewFmt[20] = {0};
-
-        //the Camera Open here will not be close immediately, for later preview.
-        if (OpenCaptureDevice() < 0)
-            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
-
-        memset(mSensorSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mSensorSupportFmt[i])) < 0)
-                break;
-        }
-        if (i == 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        //InitCameraPreviewFormatToParam(i);
-
-        if (NegotiateCaptureFmt(false) < 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        //mCaptureDeviceCfg.fmt stores format related to driver.
-        CaptureSizeFps.fmt = mCaptureDeviceCfg.fmt;//mPreviewCapturedFormat;
-
-        //mPreviewCapturedFormat stores format report to app.
-        InitCameraPreviewFormatToParam(i);
-        //memset(TmpStr, 0, 20);
-        //mPreviewCapturedFormat stores format report to app.
-        //convertPreviewFormatToString(TmpStr, 20, mPreviewCapturedFormat);
-        //convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
-        //mParameters.setPreviewFormat(TmpStr);
-
-        CAMERA_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
-
-        for(;;){
-            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
-                CAMERA_LOG_RUNTIME("get the frame size and time interval error");
-                break;
-            }
-            memset(TmpStr, 0, 20);
-            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
-            CAMERA_LOG_INFO("Size: %s , Framerate: %d supported", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
-            if (pictureCnt == 0)
-                strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            else{
-                strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                strncat(mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            }
-            pictureCnt ++;
-
-            //Limite the FPS and resolution for preview setting
-            //Typically only max to 1080p for mipi, 720p for csi,
-            //and minum 15 fps need for preview.
-            unsigned int max_preview_w, max_preview_h;
-            char device_name[CAMERA_SENSOR_LENGTH];
-            memset(device_name, 0, CAMERA_SENSOR_LENGTH);
-            mCaptureDevice->GetDevName(device_name);
-            if(strstr(device_name, "mipi")) {
-                max_preview_w = MAX_MIPI_PREVIEW_W;
-                max_preview_h = MAX_MIPI_PREVIEW_H;
-            } else {
-                max_preview_w = MAX_CSI_PREVIEW_W;
-                max_preview_h = MAX_CSI_PREVIEW_H;
-            }
-
-            if ((CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator >= 15)&&
-                (CaptureSizeFps.width <= max_preview_w)&&(CaptureSizeFps.height <= max_preview_h)){
-                if (previewCnt == 0)
-                    strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                else{
-                    strncat(mSupportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                    strncat(mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                }
-                previewCnt ++;
-            }
-        }
-
-        /*hard code here*/
-        strcpy(mSupportedFPS, "15,30");
-        CAMERA_LOG_INFO("SupportedPictureSizes is %s", mSupportedPictureSizes);
-        CAMERA_LOG_INFO("SupportedPreviewSizes is %s", mSupportedPreviewSizes);
-        CAMERA_LOG_INFO("SupportedFPS is %s", mSupportedFPS);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(12000,17000),(25000,33000)");
-        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
-
-        pParam->setPreviewSize(DEFAULT_PREVIEW_W, DEFAULT_PREVIEW_H);
-        pParam->setPictureSize(DEFAULT_PICTURE_W, DEFAULT_PICTURE_H);
-        pParam->setPreviewFrameRate(DEFAULT_PREVIEW_FPS);
-
-        return CAMERA_HAL_ERR_NONE;
-
-    }
 
-    status_t CameraHal :: OpenCaptureDevice()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDeviceOpen){
-            CAMERA_LOG_INFO("The capture device already open");
-            return NO_ERROR;
-        }
-        else if (mCaptureDevice != NULL){
-            if ( mCaptureDevice->DevOpen(mCameraid)<0 )
-                return INVALID_OPERATION;
-            mCaptureDeviceOpen = true;
-        }else{
-            CAMERA_LOG_ERR("no capture device assigned");
-            return INVALID_OPERATION;
-        }
+    FSL_ASSERT(mCameraBridge.get() != NULL);
+    ret = mCameraBridge->setParameters(params);
+    if(ret) {
+        FLOGE("CameraHal: initialize mCameraBridge->setParameters failed");
         return ret;
     }
-    void CameraHal ::CloseCaptureDevice()
-    {
-        CAMERA_LOG_FUNC;
-        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
-            mCaptureDevice->DevClose();
-            mCaptureDeviceOpen = false;
-        }
-    }
 
-    CAMERA_HAL_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
-    {
-        CAMERA_LOG_FUNC;
-        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
-
-        /*hard code here*/
-        pParam->set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
-        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
-        strcpy(mSupprotedThumbnailSizes, "0x0,128x128,96x96");
-        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, mSupprotedThumbnailSizes);
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
-        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
-        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
-        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
-        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
-        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
-        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
-        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
-        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
-        // default zoom should be 0 as CTS defined
-        pParam->set(CameraParameters::KEY_ZOOM, "0");
-        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-        //returned as 320. The number of elements is {@link
-        //#getMaxZoom} + 1. The list is sorted from small to large. The
-        //first element is always 100. The last element is the zoom
-        //ratio of the maximum zoom value.
-        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
-
-        return CAMERA_HAL_ERR_NONE;
-    }
+    mParameters = params;
+    return ret;
+}
+status_t CameraHal::sendCommand(int32_t command, int32_t arg1, int32_t arg2)
+{
+    return BAD_VALUE;
+}
 
-    sp<IMemoryHeap> CameraHal::getRawHeap() const
-    {
-        return NULL;
-    }
-
-    status_t CameraHal::dump(int fd) const
-    {
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
-            int32_t arg2)
-    {
-        return BAD_VALUE;
-    }
-
-    void CameraHal::setCallbacks(camera_notify_callback notify_cb,
-            camera_data_callback data_cb,
-            camera_data_timestamp_callback data_cb_timestamp,
-            camera_request_memory get_memory,
-            void* user)
-    {
-        Mutex::Autolock lock(mLock);
-        mNotifyCb = notify_cb;
-        mDataCb = data_cb;
-        mDataCbTimestamp = data_cb_timestamp;
-        mRequestMemory = get_memory;
-        mCallbackCookie = user;
-    }
+status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
+{
+    status_t ret = NO_ERROR;
+    FLOG_RUNTIME("setPreviewWindow");
+    mSetPreviewWindowCalled = true;
 
-    void CameraHal::enableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_LOG_INFO("enableMsgType 0x%x", msgType);
-        mMsgEnabled |= msgType;
-    }
-
-    void CameraHal::disableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_LOG_INFO("disableMsgType 0x%x", msgType);
-        mMsgEnabled &= ~msgType;
-    }
-    bool CameraHal::msgTypeEnabled(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        return (mMsgEnabled & msgType);
-    }
-
-    void CameraHal::putParameters(char *params)
-    {
-        free(params);
-    }
-
-    char* CameraHal::getParameters() const
-    {
-        CAMERA_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-        char* params_string;
-        String8 params_str8;
-        CameraParameters mParams = mParameters;
-
-        params_str8 = mParams.flatten();
-        params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
-        strcpy(params_string, params_str8.string());
-        return params_string;
-    }
-
-    status_t  CameraHal:: setParameters(const char* params)
-    {
-        CAMERA_LOG_FUNC;
-        CameraParameters parameters;
-        String8 str_params(params);
-
-        parameters.unflatten(str_params);
-        return setParameters(parameters);
-    }
-
-    status_t  CameraHal:: setParameters(CameraParameters& params)
-    {
-        CAMERA_LOG_FUNC;
-        int w, h;
-        int framerate, local_framerate;
-        int max_zoom,zoom, max_fps, min_fps;
-        char tmp[128];
-        Mutex::Autolock lock(mLock);
-
-        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
-        zoom = params.getInt(CameraParameters::KEY_ZOOM);
-        if(zoom > max_zoom){
-            CAMERA_LOG_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
-            return BAD_VALUE;
-        }
-        if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)// || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)
-                )) {
-            CAMERA_LOG_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
-            return BAD_VALUE;
-        }
-
-        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
-            CAMERA_LOG_ERR("Only jpeg still pictures are supported");
-            return BAD_VALUE;
+    if(!window) {
+        if(mDisplayAdapter.get() != NULL) {
+            FLOGI("NULL window passed, destroying display adapter");
+            stopPreview();
+            mDisplayAdapter.clear();
+            mSetPreviewWindowCalled = false;
         }
 
-        params.getPreviewSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_LOG_INFO("Set preview size: %s", tmp);
-        if (strstr(mSupportedPreviewSizes, tmp) == NULL){
-            CAMERA_LOG_ERR("The preview size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        params.getPictureSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_LOG_INFO("Set picture size: %s", tmp);
-        if (strstr(mSupportedPictureSizes, tmp) == NULL){
-            CAMERA_LOG_ERR("The picture size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        params.getPreviewFpsRange(&min_fps, &max_fps);
-        CAMERA_LOG_INFO("FPS range: %d - %d",min_fps, max_fps);
-        if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-            CAMERA_LOG_ERR("The fps range from %d to %d is error", min_fps, max_fps);
-            return BAD_VALUE;
-        }
-
-        local_framerate = mParameters.getPreviewFrameRate();
-        CAMERA_LOG_INFO("get local frame rate:%d FPS", local_framerate);
-        if ((local_framerate > 30) || (local_framerate < 0) ){
-            CAMERA_LOG_ERR("The framerate is not corrected");
-            local_framerate = 15;
-        }
-
-        framerate = params.getPreviewFrameRate();
-        CAMERA_LOG_INFO("Set frame rate:%d FPS", framerate);
-        if ((framerate > 30) || (framerate < 0) ){
-            CAMERA_LOG_ERR("The framerate is not corrected");
-            return BAD_VALUE;
-        }
-        else if(local_framerate != framerate) {
-            if(framerate == 15) {
-                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "12000,17000");
-            }
-            else if (framerate == 30) {
-                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
-            }
-        }
-
-        const char *pFlashStr;
-        pFlashStr = params.get(CameraParameters::KEY_FLASH_MODE);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0
-                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) != 0
-                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) != 0) {
-            CAMERA_LOG_ERR("The flash mode is not corrected");
-            return BAD_VALUE;
-        }
-
-        const char *pFocusStr;
-        pFocusStr = params.get(CameraParameters::KEY_FOCUS_MODE);
-        if(strcmp(pFocusStr, CameraParameters::FOCUS_MODE_AUTO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_INFINITY) != 0
-                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_MACRO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_FIXED) != 0
-                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_EDOF) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) != 0) {
-            CAMERA_LOG_ERR("The focus mode is not corrected");
-            return BAD_VALUE;
-        }
-        mParameters = params;
-
+        FLOGI("NULL ANativeWindow passed to setPreviewWindow");
         return NO_ERROR;
     }
-
-    status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
-    {
-        CAMERA_LOG_FUNC;
-        if(window == NULL) {
-            mIsCaptureBufsAllocated = 0;
-            CAMERA_LOG_INFO("PreviewWindow is null");
-        }
-        else {
-            CAMERA_LOG_ERR("PreviewWindow is valid");
-        }
-        mNativeWindow = window;
-        if((mNativeWindow != NULL) && !mIsCaptureBufsAllocated && mCaptureBufNum) {
-            if(PrepareCaptureBufs() < 0) {
-                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
-                return BAD_VALUE;
+    else if(mDisplayAdapter.get() == NULL) {
+        mDisplayAdapter = new DisplayAdapter();
+        if(!mDisplayAdapter.get() || ((ret=mDisplayAdapter->initialize())!=NO_ERROR)) {
+            if(ret != NO_ERROR) {
+                mDisplayAdapter.clear();
+                FLOGE("DisplayAdapter initialize failed");
+                return ret;
             }
-            if(CameraHALPreviewStart() < 0) {
-                CAMERA_LOG_ERR("CameraHALPreviewStart() error");
-                return BAD_VALUE;
+            else {
+                FLOGE("Couldn't create DisplayAdapter");
+                return NO_MEMORY;
             }
         }
 
-        return NO_ERROR;
-    }
+        mDisplayAdapter->setCameraFrameProvider(mDeviceAdapter.get());
+        mDeviceAdapter->setCameraBufferProvide(mDisplayAdapter.get());
 
-    status_t CameraHal::freeBuffersToNativeWindow()
-    {
-        CAMERA_LOG_FUNC;
-        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
-            status_t err = freeBufferToIon();
-            if(err == NO_ERROR) {
-                return err;
-            }
-        }
+        mDisplayAdapter->setErrorListener(mCameraBridge.get());
 
-
-        if (mNativeWindow == NULL){
-            CAMERA_LOG_ERR("the native window is null!");
-            return BAD_VALUE;
+        ret = mDisplayAdapter->setPreviewWindow(window);
+        if(ret != NO_ERROR) {
+            FLOGE("DisplayAdapter setPreviewWindow returned error %d", ret);
         }
 
-        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
-        buffer_handle_t *handle;
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_DEQUEUED) {
-                handle = (buffer_handle_t *)mCaptureBuffers[i].native_buf;
-                if(handle != NULL) {
-                    if(mCaptureBuffers[i].virt_start != NULL) {
-                        mapper.unlock(*handle);
-                    }
-                    mNativeWindow->cancel_buffer(mNativeWindow, handle);
-                }
-            }
-            else
-                continue;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_INVALID;//WINDOW_BUFS_QUEUED;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].native_buf = NULL;
-            mCaptureBuffers[i].virt_start = NULL;
-            mCaptureBuffers[i].length = 0;
-            mCaptureBuffers[i].phy_offset = 0;
+        if(mPreviewStartInProgress) {
+            FLOGI("setPreviewWindow called when preview running");
+            ret = startPreview();
         }
-        mCaptureBufNum = 0;
-
-        return NO_ERROR;
     }
-
-    status_t CameraHal::freeBufferToIon()
-    {
-        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
-            CAMERA_LOG_ERR("try to free buffer from ion in preview or ion invalid");
-            return BAD_VALUE;
-        }
-
-        CAMERA_LOG_INFO("freeBufferToIon buffer num:%d", mCaptureBufNum);
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            struct ion_handle * ionHandle = (struct ion_handle *)mCaptureBuffers[i].native_buf;
-            ion_free(mIonFd, ionHandle);
-            munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-        }
-
-        return NO_ERROR;
+    else {
+        FLOGI("set new preview window but the last one has not been freed");
+        ret = mDisplayAdapter->setPreviewWindow(window);
     }
 
-    status_t CameraHal::allocateBufferFromIon()
-    {
-        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
-            CAMERA_LOG_ERR("try to allocate buffer from ion in preview or ion invalid");
-            return BAD_VALUE;
-        }
+    return ret;
 
-        int width = 0, height = 0, size = 0;
-        width = mCaptureDeviceCfg.width;
-        height = mCaptureDeviceCfg.height;
-        if(width == 0 || height == 0) {
-            CAMERA_LOG_ERR("allocateBufferFromIon: width or height = 0");
-            return BAD_VALUE;
-        }
+}
 
-        switch(mPreviewCapturedFormat) {
-            case v4l2_fourcc('N','V','1','2'):
-                size = width * height * 3/2;
-                break;
-            case v4l2_fourcc('Y','U','1','2'):
-                size = width * height * 3/2;
-                break;
-            case v4l2_fourcc('Y','U','Y','V'):
-                size = width * height * 2;
-                break;
-            default:
-                CAMERA_LOG_ERR("Error: format not supported int ion alloc");
-                return BAD_VALUE;
-        }
+status_t CameraHal::startPreview()
+{
+    FLOG_RUNTIME("startPreview");
+    status_t ret = NO_ERROR;
+    Mutex::Autolock lock(mLock);
 
-        unsigned char *ptr = NULL;
-        int sharedFd;
-        int phyAddr;
-        struct ion_handle * ionHandle;
-
-        CAMERA_LOG_INFO("allocateBufferFromIon buffer num:%d", mCaptureBufNum);
-        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            ionHandle = NULL;
-            size = (size + PAGE_SIZE)&(~(PAGE_SIZE-1));
-            int err = ion_alloc(mIonFd, size, 8, 1, &ionHandle);
-            if(err) {
-                CAMERA_LOG_ERR("ion_alloc failed.");
-                return BAD_VALUE;
-            }
-
-            err = ion_map(mIonFd, ionHandle, size, PROT_READ|PROT_WRITE, MAP_SHARED, 0, &ptr, &sharedFd);
-            if(err) {
-                CAMERA_LOG_ERR("ion_map failed.");
-                return BAD_VALUE;
-            }
-            phyAddr = ion_phys(mIonFd, ionHandle);
-            if(phyAddr == 0) {
-                CAMERA_LOG_ERR("ion_phys failed.");
-                return BAD_VALUE;
-            }
-
-            mCaptureBuffers[i].virt_start = ptr;
-            mCaptureBuffers[i].phy_offset = phyAddr;
-            mCaptureBuffers[i].length =  size;
-            mCaptureBuffers[i].native_buf = (void*)ionHandle;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
-            close(sharedFd);
-        }
-        return NO_ERROR;
+    if(mPreviewEnabled) {
+        FLOGE("Preview already running");
+        return ALREADY_EXISTS;
     }
 
-    int CameraHal::convertPreviewFormatToPixelFormat(unsigned int format)
-    {
-        int nFormat = 0;
-        switch(format) {
-            case v4l2_fourcc('N','V','1','2'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP;
-                break;
-            case v4l2_fourcc('Y','U','1','2'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_P;
-                break;
-            case v4l2_fourcc('Y','U','Y','V'):
-                nFormat = HAL_PIXEL_FORMAT_YCbCr_422_I;
-                break;
-            default:
-                CAMERA_LOG_ERR("Error: format not supported!");
-                break;
-        }
-        CAMERA_LOG_INFO("pixel format: 0x%x", nFormat);
-        return nFormat;
+    if(mTakePictureInProcess) {
+        FLOGI("stop takePicture");
+        stopPicture();
     }
 
-    status_t CameraHal::allocateBuffersFromNativeWindow()
-    {
-        CAMERA_LOG_FUNC;
-
-        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
-            status_t err = allocateBufferFromIon();
-            if(err == NO_ERROR) {
-                return err;
-            }
-        }
-
-        status_t err;
-        if (mNativeWindow == NULL){
-            CAMERA_LOG_ERR("the native window is null!");
-            return NO_ERROR;//BAD_VALUE;
-        }
-
-        //Make sure the buffer be physical continuous
-        err = mNativeWindow->set_usage(mNativeWindow,
-                GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_FORCE_CONTIGUOUS | GRALLOC_USAGE_HW_TEXTURE);
-        if(err != 0){
-            CAMERA_LOG_ERR("native_window_set_usage failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        //should use mPreviewCapturedFormat here.
-        int uFormat = convertPreviewFormatToPixelFormat(mPreviewCapturedFormat);
-        err = mNativeWindow->set_buffers_geometry(mNativeWindow,
-                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height,
-                uFormat);
-        if(err != 0){
-            CAMERA_LOG_ERR("native_window_set_buffers_geometry failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        int minUndequeueBufs = 0;
-        err = mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow,
-                &minUndequeueBufs);
-        if(err != 0) {
-            CAMERA_LOG_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        if(mCaptureBufNum > PREVIEW_CAPTURE_BUFFER_NUM) {
-            CAMERA_LOG_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
-            return BAD_VALUE;
-        }
-
-        err = mNativeWindow->set_buffer_count(mNativeWindow, mCaptureBufNum);
-        if(err != 0) {
-            CAMERA_LOG_ERR("native_window_set_buffer_count failed:%s(%d)",
-                    strerror(-err), -err);
-            return err;
-        }
-
-        unsigned int i;
-        Rect bounds(mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-        void *pVaddr = NULL;
-        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
-        for(i = 0; i < mCaptureBufNum; i++) {
-            buffer_handle_t* buf_h = NULL;
-            pVaddr = NULL;
-            int stride;
-            err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
-            if((err != 0) || (buf_h == NULL)) {
-                CAMERA_LOG_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
-                return BAD_VALUE;
-            }
-            private_handle_t *handle = (private_handle_t *)(*buf_h);
-            mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
-            if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
-                 CAMERA_LOG_ERR("%s: dequeue invalide Buffer, phys=0x%lx, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
-                 mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
-                 return BAD_VALUE;
-            }
-
-            mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
-            mCaptureBuffers[i].phy_offset = handle->phys;
-            //Calculate the buffer size, for GPU doesn't reply this value.
-            mCaptureBuffers[i].length =  handle->size;//mCaptureFrameSize
-            mCaptureBuffers[i].native_buf = (void *)buf_h;
-            mCaptureBuffers[i].refCount = 0;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
-            CAMERA_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%p, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-        }
-
+    if(!mSetPreviewWindowCalled || (mDisplayAdapter.get() == NULL)) {
+        FLOGI("Preview not started. Preview in progress flag set");
+        mPreviewStartInProgress = true;
         return NO_ERROR;
     }
 
-    status_t CameraHal::startPreview()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-
-        if(mTakePictureInProcess) {
-            mWaitForTakingPicture = true;
-            sem_wait(&mTakingPicture);
-            mWaitForTakingPicture = false;
-        }
-        Mutex::Autolock lock(mLock);
-        mEnqueuedBufs = 0;
-
-        mPreviewLock.lock();
-        if (mPreviewRunning) {
-            // already running
-            CAMERA_LOG_RUNTIME("%s : preview thread already running", __func__);
-            mPreviewLock.unlock();
-            return NO_ERROR;//INVALID_OPERATION;
-        }
-
-        if ((ret == CameraHALStartPreview())<0) {
-            CAMERA_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
-            mPreviewLock.unlock();
-            return ret;
-        }
-
-        mPreviewRunning = true;
-        mPreviewLock.unlock();
+    int frameRate = mParameters.getPreviewFrameRate();
+    int width, height;
+    mParameters.getPreviewSize(&width, &height);
 
-        mCaptureLock.lock();
-        if(mCaptureRunning) {
-            CAMERA_LOG_ERR("%s : preview thread already running", __func__);
-            mCaptureLock.unlock();
-            return NO_ERROR;
-        }
-        mCaptureRunning = true;
-        mCaptureLock.unlock();
+    FSL_ASSERT(mDeviceAdapter.get() != NULL);
+    PixelFormat format = mDeviceAdapter->getPreviewPixelFormat();
+    mDeviceAdapter->setDeviceConfig(width, height, format, frameRate);
 
-        LockWakeLock();
-        return ret;
+    FSL_ASSERT(mDisplayAdapter.get() != NULL);
+    mBufferProvider = mDisplayAdapter.get();
+    mDeviceAdapter->setCameraBufferProvide(mBufferProvider);
+    ret = mBufferProvider->allocatePreviewBuffer(width, height, format, MAX_PREVIEW_BUFFER);
+    if(NO_ERROR != ret) {
+        FLOGE("Couldn't allocate buffers for Preview");
+        goto error;
     }
 
-    void CameraHal::stopPreview()
-    {
-        CAMERA_LOG_FUNC;
-        struct timeval af_time, be_time;
-        Mutex::Autolock lock(mLock);
-        CameraHALStopPreview();
-        UnLockWakeLock();
-
+    FSL_ASSERT(mCameraBridge.get() != NULL);
+    ret = mCameraBridge->start();
+    if(ALREADY_EXISTS == ret) {
+        FLOGI("mCameraBridge already running");
+        ret = NO_ERROR;
     }
-
-    bool CameraHal::previewEnabled()
-    {
-        CAMERA_LOG_FUNC;
-        return mPreviewRunning;
+    else if(ret) {
+        FLOGE("Couldn't start mCameraBridge");
+        goto error;
     }
 
-    //update buffer for direct input in video recorder
-    status_t CameraHal::updateDirectInput(bool bDirect)
-    {
-        unsigned int i;
-        if (bDirect == true) {
-            if(mCaptureBufNum <= 0)
-                CAMERA_LOG_INFO("mCaptureBuf not allocated yet, will register it later");
-
-            for(i = 0 ; i < mCaptureBufNum; i ++) {
-                mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
-                CAMERA_LOG_INFO("Camera HAL physic address: %x", mCaptureBuffers[i].phy_offset);
-                mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
-                memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
-                        (void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-            }
-        }
-
-        return NO_ERROR;
+    FLOG_RUNTIME("start display");
+    ret = mDisplayAdapter->startDisplay(width, height);
+    if(ret != NO_ERROR) {
+        FLOGE("Couldn't enable display");
+        goto error;
     }
 
-    status_t CameraHal::storeMetaDataInBuffers(bool enable)
-    {
-        CAMERA_LOG_FUNC;
-        return -1;
+    FLOG_RUNTIME("Starting DeviceAdapter preview mode");
+    ret = mDeviceAdapter->startPreview();
+    if(ret!=NO_ERROR) {
+        FLOGE("Couldn't start preview for DeviceAdapter");
+        goto error;
     }
+    FLOG_RUNTIME("Started preview");
 
-    status_t CameraHal::startRecording()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int i;
-
-        mEncodeLock.lock();
-        if (mRecordRunning == true ) {
-            CAMERA_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
-            mEncodeLock.unlock();
-            return ret;
-        }
-
-        for(i = 0; i < mVideoBufNume; i++) {
-            mVideoBufferUsing[i] = 0;
-        }
-
-        mRecordRunning = true;
-        mEncodeLock.unlock();
+    mPreviewEnabled = true;
+    mPreviewStartInProgress = false;
+    LockWakeLock();
+    return ret;
 
-        return NO_ERROR;
-    }
+error:
+    FLOGE("Performing cleanup after error");
+    mDeviceAdapter->stopPreview();
 
-    void CameraHal::stopRecording()
-    {
-        CAMERA_LOG_FUNC;
-
-        mEncodeLock.lock();
-        if(mRecordRunning) {
-            mRecordRunning = false;
-            mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_STOP, 0));
-            //stopRecording() will holde mLock in camera service,
-            //when encodeframeThread() is in the call back mDataCbTimestamp.
-            //That call back will make a call of releaseRecordingFrame, which
-            //also try to acquire the lock mLock. It will make a dead lock between the two thread
-            //sem_wait(&mEncodeStoppedCondition);
-            CAMERA_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
-        }
-        mEncodeLock.unlock();
-    }
+    mDisplayAdapter->stopDisplay();
+    mBufferProvider->freeBuffer();
 
-    void CameraHal::releaseRecordingFrame(const void* mem)
-    {
-        //CAMERA_LOG_FUNC;
-        int index;
+    mCameraBridge->stop();
+    mBufferProvider = NULL;
+    mPreviewStartInProgress = false;
+    mPreviewEnabled = false;
 
-        index = ((size_t)mem - (size_t)mVideoMemory->data) / mPreviewFrameSize;
-        mVideoBufferUsing[index] = 0;
+    return ret;
+}
 
-        if(mCaptureBuffers[index].refCount == 0) {
-            CAMERA_LOG_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
-            return;
-        }
-        putBufferCount(&mCaptureBuffers[index]);
+void CameraHal::stopPreview()
+{
+    FLOG_RUNTIME("stopPreview");
+    Mutex::Autolock lock(mLock);
+    if(mTakePictureInProcess && !(mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
+        FLOGI("stop takePicture");
+        stopPicture();
     }
 
-    bool CameraHal::recordingEnabled()
-    {
-        CAMERA_LOG_FUNC;
-        return (mPreviewRunning && mRecordRunning);
+    if(!previewEnabled() || mRecordingEnabled) {
+        return;
     }
 
-    status_t CameraHal::autoFocus()
-    {
-        CAMERA_LOG_FUNC;
+    forceStopPreview();
+    UnLockWakeLock();
+}
 
-        Mutex::Autolock lock(mLock);
+bool CameraHal::previewEnabled()
+{
+    return (mPreviewEnabled || mPreviewStartInProgress);
+}
 
-        if (mAutoFocusThread != NULL)
-            mAutoFocusThread.clear();
-
-        mAutoFocusThread = new AutoFocusThread(this);
-        if (mAutoFocusThread == NULL)
-            return UNKNOWN_ERROR;
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::cancelAutoFocus()
-    {
-        CAMERA_LOG_FUNC;
-
-        return NO_ERROR;
-    }
+status_t CameraHal::restartPreview()
+{
+    status_t ret = NO_ERROR;
 
-    status_t CameraHal::takePicture()
-    {
-        CAMERA_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
+    forceStopPreview();
 
-        if(mTakePictureInProcess) {
-            CAMERA_LOG_ERR("%s: takePicture already in process", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
+    ret = startPreview();
 
-        if(mTakePicThread->run("takepicThread", PRIORITY_URGENT_DISPLAY) != NO_ERROR) {
-            CAMERA_LOG_ERR("%s: could't run take picture thread", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
-        mTakePictureInProcess = true;
+    return ret;
+}
 
-        return NO_ERROR;
+void CameraHal::forceStopPreview()
+{
+    FLOG_RUNTIME("forceStopPreview");
+    if (mDeviceAdapter.get() != NULL) {
+        mDeviceAdapter->stopPreview();
     }
 
-    status_t CameraHal::cancelPicture()
-    {
-        CAMERA_LOG_FUNC;
-        mTakePicThread->requestExitAndWait();
-
-        return NO_ERROR;
+    if(mDisplayAdapter.get() != NULL) {
+        mDisplayAdapter->stopDisplay();
     }
 
-
-    int CameraHal::autoFocusThread()
-    {
-        CAMERA_LOG_FUNC;
-        int FocusFlag = 0;
-
-        if (mMsgEnabled & CAMERA_MSG_FOCUS)
-            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
-
-        return UNKNOWN_ERROR; //exit the thread
+    if(mCameraBridge.get() != NULL) {
+        mCameraBridge->stop();
     }
 
-    int CameraHal::takepicThread()
-    {
-        CAMERA_LOG_FUNC;
-        CAMERA_LOG_INFO("Start taking picture!");
-
-        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
-        CameraHALStopPreview();
-        mTakePictureAllocBuffer = true;
-        cameraHALTakePicture();
-        mTakePictureAllocBuffer = false;
-        mTakePictureInProcess = false;
-
-        return UNKNOWN_ERROR;
+    if(mBufferProvider != NULL) {
+        mBufferProvider->freeBuffer();
     }
 
-    int CameraHal :: cameraHALTakePicture()
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR;
-        unsigned int DeQueBufIdx = 0;
-        struct jpeg_encoding_conf JpegEncConf;
-        DMA_BUFFER *Buf_input, Buf_output;
-        camera_memory_t* JpegMemBase = NULL;
-        camera_memory_t *RawMemBase = NULL;
-
-        int  max_fps, min_fps;
-        int actual_fps = 15;
-
-        if (mJpegEncoder == NULL){
-            CAMERA_LOG_ERR("the jpeg encoder is NULL");
-            return BAD_VALUE;
-        }
-        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-        //Default setting is 15FPS
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDeviceCfg.tv.denominator = 15;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-            //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
-            if((strstr(mCameraSensorName, "mipi") == NULL)&&
-                (mCaptureDeviceCfg.width == 1920)&&
-                (mCaptureDeviceCfg.height == 1080)) {
-                //Workaround for 1080p setting for csi camera, which only 15fps is valid
-                mCaptureDeviceCfg.tv.denominator = 15;
-            } else {
-                mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-                if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-                    if (mParameters.getPreviewFrameRate() >= 15){
-                        mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-                        CAMERA_LOG_INFO("Set Capture Fps %d", mParameters.getPreviewFrameRate());
-                    }
-                }
-                else{
-                    CAMERA_LOG_INFO("Set Capture Fps Range %d - %d",min_fps, max_fps);
-                    actual_fps = min_fps > 15000? 30:15;
-                    mCaptureDeviceCfg.tv.denominator = actual_fps;
-                }
-            }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-
-        if(mUseIon) {
-            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
-        }
-        else {
-            //surface texture requires larger than 2 buffers to work.
-            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM + 1;
-        }
-        mTakePicFlag = true;
-        if ((ret = GetJpegEncoderParam()) < 0)
-            return ret;
-        if ((ret = NegotiateCaptureFmt(true)) < 0)
-            return ret;
-
-        if ((ret = PrepareCaptureDevices()) < 0)
-            return ret;
-
-        if ((ret = PrepareJpegEncoder()) < 0)
-            return ret;
-
-        JpegMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
-        if (JpegMemBase == NULL || JpegMemBase->data == NULL){
-            ret = NO_MEMORY;
-            goto Pic_out;
-        }
-
-        if (mCaptureDevice->DevStart()<0){
-            CAMERA_LOG_ERR("the capture start up failed !!!!");
-            return INVALID_OPERATION;
-        }
-
-        for (unsigned int i =0;;){
-            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
-                ALOGE("VIDIOC_DQBUF Failed!!!");
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-            if (++i == mCaptureDeviceCfg.picture_waite_number)
-                break;
+    mBufferProvider = NULL;
+    mPreviewEnabled = false;
+    mPreviewStartInProgress = false;
+}
 
-            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-        }
+status_t CameraHal::autoFocus()
+{
+    status_t ret = NO_ERROR;
 
-        Buf_input = &mCaptureBuffers[DeQueBufIdx];
-
-        Buf_output.virt_start = (unsigned char *)(JpegMemBase->data);
-        CAMERA_LOG_INFO("Generated a picture with mMsgEnabled 0x%x", mMsgEnabled);
-
-        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
-            CAMERA_LOG_INFO("CAMERA_MSG_SHUTTER");
-            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
-        }
+    Mutex::Autolock lock(mLock);
+    mMsgEnabled |= CAMERA_MSG_FOCUS;
 
-        if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE) {
-            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE");
-            RawMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
-
-            if ( NULL == RawMemBase ) {
-                CAMERA_LOG_INFO("Raw buffer allocation failed!");
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-            void *dest = RawMemBase->data;
-
-            if (NULL != dest) {
-                void *src = &mCaptureBuffers[DeQueBufIdx];
-                memcpy(dest, src, mCaptureFrameSize);
-            }
+    if(mDeviceAdapter != NULL) {
+        ret = mDeviceAdapter->autoFocus();
+    }
+    else {
+        ret = BAD_VALUE;
+    }
 
-            mDataCb(CAMERA_MSG_RAW_IMAGE, RawMemBase, 0, NULL, mCallbackCookie);
+    return ret;
+}
 
-            RawMemBase->release(RawMemBase);
-        }
+status_t CameraHal::cancelAutoFocus()
+{
+    status_t ret = NO_ERROR;
+    Mutex::Autolock lock(mLock);
+    mMsgEnabled &= ~CAMERA_MSG_FOCUS;
 
-        if ( mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY ) {
-            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE_NOTIFY");
-            if(mNotifyCb)
-                mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
-        }
-
-        if (mJpegEncoder->DoEncode(Buf_input,&Buf_output,&JpegEncConf) < 0){
-            ret = UNKNOWN_ERROR;
-            goto Pic_out;
-        }
+    if(mDeviceAdapter != NULL) {
+        ret = mDeviceAdapter->cancelAutoFocus();
+    }
 
-Pic_out:
-        freeBuffersToNativeWindow();
-        if ((JpegMemBase != NULL) &&(JpegMemBase->data != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-            CAMERA_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
-            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, 0, NULL, mCallbackCookie);
-        }
+    return ret;
+}
 
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        if(mSensorType == CAMERA_TYPE_UVC) {
-            CloseCaptureDevice();
-        }
-
-        if(JpegMemBase) {
-            JpegMemBase->release(JpegMemBase);
-        }
-        if(mWaitForTakingPicture) {
-            sem_post(&mTakingPicture);
-        }
-        return ret;
+status_t CameraHal::storeMetaDataInBuffers(bool enable)
+{
+    //return mCameraBridge->useMetaDataBufferMode(enable);
+    return -1;
+}
 
+status_t CameraHal::startRecording()
+{
+    FLOG_RUNTIME("startRecording");
+    if(!previewEnabled()) {
+        FLOGE("startRecording: preview not enabled");
+        return NO_INIT;
     }
 
-    int CameraHal :: GetJpegEncoderParam()
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR, i = 0;
-        memset(mJpegEncoderSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mJpegEncoderSupportFmt[i])) < 0)
-                break;
-        }
-        if (i == 0){
-            CAMERA_LOG_ERR("Get the parameters error");
-            return UNKNOWN_ERROR;
-        }
+    status_t ret = NO_ERROR;
+    mEncodeLock.lock();
+    if(mRecordingEnabled == true) {
+        FLOGW("%s: Recording is already existed\n", __FUNCTION__);
+        mEncodeLock.unlock();
         return ret;
     }
-    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
-    {
-        CAMERA_LOG_FUNC;
-        int ret = NO_ERROR, i = 0, j = 0;
-        unsigned int nPickFormat = 0;
-
-        if(TakePicFlag){
-            //when take picture, only the mJpegEncoderSupportFmt impact it.
-            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
-                    if (mJpegEncoderSupportFmt[j] == 0)
-                        break;
-                    if (mSensorSupportFmt[i] == mJpegEncoderSupportFmt[j]){
-                        nPickFormat = mSensorSupportFmt[i];
-                        CAMERA_LOG_INFO("Get the Picture Encode Format :%c%c%c%c\n",
-                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
-                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
-                        break;
-                    }
-                }
-                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
-                    break;
-            }
-            if (nPickFormat == 0) {
-                CAMERA_LOG_ERR("NegotiateCaptureFmt failed");
-                return UNKNOWN_ERROR;
-            }
-            else {
-                mPictureEncodeFormat = nPickFormat;
-                mCaptureDeviceCfg.fmt = nPickFormat;
-            }
-            //should make mPictureEncodeFormat equal to mPreviewCapturedFormat.
-            //because allocate buffer should use it.
-            mPreviewCapturedFormat = mPictureEncodeFormat;
-        }//endif TakePicFlag
-        else{
-            //when preview or encoder, only mVpuSupportFmt impact it.
-            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                for (j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
-                    if(mVpuSupportFmt[j] == 0)
-                        break;
-                    if(mSensorSupportFmt[i] == mVpuSupportFmt[j]) {
-                        nPickFormat = mSensorSupportFmt[i];
-                        CAMERA_LOG_RUNTIME("get the priview format:%c%c%c%c\n",
-                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
-                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
-                        break;
-                    }
-                }//end for
-                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
-                    break;
-            }
-            if (nPickFormat == 0) {
-                CAMERA_LOG_ERR("NegotiateCaptureFmt2 failed");
-                return UNKNOWN_ERROR;
-            }
-            else {
-                mPreviewCapturedFormat = nPickFormat;
-                mCaptureDeviceCfg.fmt = nPickFormat;
-            }
-        }//end else
 
+    ret = mCameraBridge->startRecording();
+    if(ret) {
+        FLOGE("CameraBridge startRecording failed");
         return ret;
     }
 
-    int CameraHal :: PrepareJpegEncoder()
-    {
-        int ret = NO_ERROR;
-        struct jpeg_enc_make_info_t make_info;
-        struct jpeg_enc_makernote_info_t makernote_info;
-        struct jpeg_enc_model_info_t model_info;
-        struct jpeg_enc_datetime_info_t datetime_info;
-        struct jpeg_enc_focallength_t focallength_info;
-        struct jpeg_enc_gps_param gps_info;
-        int rotate_angle = 0;
-        JPEG_ENCODER_WHITEBALANCE whitebalance_info;
-        JPEG_ENCODER_FLASH flash_info;
-        const char * pWhiteBalanceStr, *pFlashStr;
-
-        char temp_string[30], gps_datetime_string[11];
-        char format[30] = "%Y:%m:%d %k:%M:%S";
-        time_t clock;
-        struct tm *tm, *temp_tm;
-        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
-        double dAltitude;
-
-        mJpegEncCfg.BufFmt = mPictureEncodeFormat;
-        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
-        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
-        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
-        CAMERA_LOG_INFO("pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
-        CAMERA_LOG_INFO("thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
-        //set focallength info
-        focallength_info.numerator=10001;
-        focallength_info.denominator=1000;  // hardcode here for the cts
-        mJpegEncCfg.pFoclLength = &focallength_info;
-
-        //set the make info
-        make_info.make_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)make_info.make, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeInfo = &make_info;
-
-        //set makernote info
-        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeNote = &makernote_info;
-
-        //set model info
-        model_info.model_bytes=strlen(EXIF_MODEL);
-        strcpy((char *)model_info.model,EXIF_MODEL);
-        mJpegEncCfg.pModelInfo = &model_info;
-
-        //set datetime
-        time(&clock);
-        tm = localtime(&clock);
-        time_t GpsUtcTime;
-        strftime(temp_string, sizeof(temp_string), format, tm);
-        CAMERA_LOG_INFO("date time: %s", temp_string);
-        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
-        mJpegEncCfg.pDatetimeInfo = &datetime_info;
-
-        rotate_angle = mParameters.getInt(CameraParameters::KEY_ROTATION);
-        if (rotate_angle == 0)
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL; //the android and the jpeg has the same define
-        else if (rotate_angle == 90)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_90;
-        else if (rotate_angle == 180)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_180;
-        else if (rotate_angle == 270)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
-        else
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
-        CAMERA_LOG_INFO("rotate: %d", rotate_angle);
-
-        pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
-        CAMERA_LOG_INFO("white balance: %s",pWhiteBalanceStr);
-        if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
-            whitebalance_info = WHITEBALANCE_AUTO;
-        }else{
-            whitebalance_info = WHITEBALANCE_MANUAL;
-        }
-        mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
-
-        pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
-        CAMERA_LOG_INFO("flash mode: %s", pFlashStr);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
-            flash_info = FLASH_NOT_FIRE;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
-            flash_info = FLASH_FIRED_AUTO;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) == 0){
-            flash_info = FLASH_FIRED;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) == 0){
-            flash_info = FLASH_FIRED_RED_EYE_REDUCE;
-        }
-        else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) == 0){
-            flash_info = FLASH_FIRED_COMPULOSORY;
-        }
-        else{
-            flash_info = FLASH_NOT_FIRE;
-        }
-        mJpegEncCfg.FlashInfo = flash_info;
-
-        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
-        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
-        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
-        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
-
-        if (cLatitude !=NULL && cLongtitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
-
-            gps_info.version=0x02020000;
-
-            //latitude: dd/1,mm/1,ss/1
-            gps_info.latitude_degree[1]=1;
-            gps_info.latitude_minute[1]=1;
-            gps_info.latitude_second[1]=1000;
-            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
-
-            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
-                //the ref is south
-                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
-            }
-
-            //longtitude: dd/1,mm/1,ss/1
-            gps_info.longtitude_degree[1]=1;
-            gps_info.longtitude_minute[1]=1;
-            gps_info.longtitude_second[1]=1000;
-            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
-
-            if (stringTodegree(cLongtitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
-                //the ref is Weston
-                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
-            }
-
-            //altitude(meters): aa/1
-            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
-            gps_info.altitude[0]=1000;
-            gps_info.altitude[1]=1;
-            if (cAltitude != NULL){
-                int intValue;
-                gps_info.altitude[1]=1000;	   // the precision is CM
-                dAltitude= atof(cAltitude);
-                CAMERA_LOG_RUNTIME("altitude: %s", cAltitude);
-                intValue = (int)(dAltitude * 1000.0);
-                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
-                gps_info.altitude[0] = (unsigned long) intValue;
-                CAMERA_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
-            }
-
-            //timestamp: hh/1,mm/1,ss/1
-            gps_info.hour[1]=1;
-            gps_info.minute[1]=1;
-            gps_info.seconds[1]=1;
-            if (cTimeStamp != NULL){
-
-                GpsUtcTime = atol(cTimeStamp);
-                CAMERA_LOG_INFO("Timestamp: %s", cTimeStamp);
-                temp_tm = gmtime((const time_t*)&GpsUtcTime);
-                if (temp_tm != NULL)
-                    tm = temp_tm;
-            }
-
-            gps_info.hour[0] = tm->tm_hour;
-            gps_info.minute[0] = tm->tm_min;
-            gps_info.seconds[0] = tm->tm_sec;
-
-            strcpy (format, "%Y:%m:%d ");
-
-
-            strftime((char *)temp_string, strlen(temp_string), format, tm);
-            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
-
-
-            char * processMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
-            if (processMehod == NULL){
-                CAMERA_LOG_INFO("processMethod is NULL, add a fake");
-                processMehod = (char *)"fsl_fake_method";
-            }
+    mRecordingEnabled = true;
+    mEncodeLock.unlock();
 
-            memcpy(gps_info.processmethod, processMehod, strlen(processMehod));
+    return NO_ERROR;
+}
 
-            gps_info.processmethod_bytes=strlen(processMehod);
-
-            CAMERA_LOG_INFO("processmethod: %s", gps_info.processmethod);
-
-            mJpegEncCfg.pGps_info = &gps_info;
-        }else{
-            mJpegEncCfg.pGps_info = NULL;
-        }
-
-        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
-            CAMERA_LOG_ERR("Jpeg Encoder Init error !!!");
-            return UNKNOWN_ERROR;
-        }
-
-        return ret;
+void CameraHal::stopRecording()
+{
+    FLOG_RUNTIME("stopRecording");
+    mEncodeLock.lock();
+    if(mRecordingEnabled) {
+        mRecordingEnabled = false;
+        mCameraBridge->stopRecording();
     }
+    mEncodeLock.unlock();
+}
 
-    status_t CameraHal::convertPreviewFormatToString(char *pStr, int length, unsigned int format)
-    {
-        CAMERA_LOG_FUNC;
-        if(pStr == NULL || length < 10) {
-            CAMERA_LOG_ERR("%s: invalide parameters", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        if(format == v4l2_fourcc('Y','U','1','2')) {
-            strcpy(pStr, "yuv420p");
-        }
-        else if(format == v4l2_fourcc('N','V','1','2')) {
-            strcpy(pStr, "yuv420sp");
-        }
-        //else if(format == v4l2_fourcc('Y','U','Y','V')) {
-        //    strcpy(pStr, "yuv422i-yuyv");
-        //}
-        else {
-            CAMERA_LOG_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        return NO_ERROR;
+void CameraHal::releaseRecordingFrame(const void* mem)
+{
+    if(mCameraBridge.get() != NULL) {
+        mCameraBridge->releaseRecordingFrame(mem);
     }
+}
 
-    status_t CameraHal::convertStringToPreviewFormat(unsigned int *pFormat)
-    {
-        CAMERA_LOG_FUNC;
-        if(!strcmp(mParameters.getPreviewFormat(), "yuv420p")) {
-            *pFormat = v4l2_fourcc('Y','U','1','2');
-        }
-        else if(!strcmp(mParameters.getPreviewFormat(), "yuv420sp")) {
-            *pFormat = v4l2_fourcc('N','V','1','2');
-        }
-        //else if(!strcmp(mParameters.getPreviewFormat(), "yuv422i-yuyv")) {
-        //    *pFormat = v4l2_fourcc('Y','U','Y','V');
-        //}
-        else {
-            CAMERA_LOG_ERR("Only yuv420sp or yuv420p is supported");
-            return BAD_VALUE;
-        }
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::CameraHALStartPreview()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int  max_fps, min_fps;
-        int actual_fps = 15;
-
-        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-
-        if ((ret = convertStringToPreviewFormat(&mPreviewCapturedFormat)) != 0) {
-            CAMERA_LOG_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
-            return ret;
-        }
-
-        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
-
-        CAMERA_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
-        mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
-        //Default setting is 15FPS
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDeviceCfg.tv.denominator = 15;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-            //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
-            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-            if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
-                if (mParameters.getPreviewFrameRate() >= 15){
-                    mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-                    CAMERA_LOG_INFO("Set Preview Fps %d", mParameters.getPreviewFrameRate());
-                }
-            }
-            else{
-                CAMERA_LOG_INFO("Set Preview Fps Range %d - %d",min_fps, max_fps);
-                actual_fps = min_fps > 15000? 30:15;
-                mCaptureDeviceCfg.tv.denominator = actual_fps;
-            }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
-        mTakePicFlag = false;
-
-        if(mCaptureDeviceCfg.fmt)
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
-            else
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
+bool CameraHal::recordingEnabled()
+{
+    return mRecordingEnabled;
+}
 
-        if ((ret = PrepareCaptureDevices()) < 0){
-            CAMERA_LOG_ERR("PrepareCaptureDevices error ");
-            return ret;
-        }
-        if ((ret = PreparePreviwBuf()) < 0){
-            CAMERA_LOG_ERR("PreparePreviwBuf error");
-            return ret;
-        }
-
-        if ((ret = PreparePreviwMisc()) < 0){
-            CAMERA_LOG_ERR("PreparePreviwMisc error");
-            return ret;
-        }
+status_t CameraHal::takePicture()
+{
+    FLOG_RUNTIME("takePicture");
+    status_t ret = NO_ERROR;
+    Mutex::Autolock lock(mLock);
 
-        if(mNativeWindow != NULL) {
-            if ((ret = CameraHALPreviewStart()) < 0){
-                CAMERA_LOG_ERR("CameraHALPreviewStart error");
-                return ret;
-            }
-        }
-
-        return ret;
-    }
-    void CameraHal::CameraHALStopPreview()
-    {
-        CAMERA_LOG_FUNC;
-        if (mPreviewRunning != 0)	{
-            CameraHALStopThreads();
-            CameraHALStopMisc();
-            mCaptureBufNum = 0;
-            CAMERA_LOG_INFO("camera hal stop preview done");
-        }else{
-            CAMERA_LOG_INFO("Camera hal already stop preview");
-        }
-        return ;
+    if(!previewEnabled()) {
+        FLOGE("takePicture: preview not start");
+        return NO_INIT;
     }
 
-    void CameraHal :: CameraHALStopThreads()
-    {
-        CAMERA_LOG_FUNC;
-
-        mCaptureLock.lock();
-        if(mCaptureRunning) {
-            CAMERA_LOG_INFO("%s :capture run", __FUNCTION__);
-            mCaptureThreadQueue.postStopMessage();
-            mCaptureRunning = false;
-            if(gettid()!= mCaptureFrameThread->mTID)
-                sem_wait(&mCaptureStoppedCondition);
-            else
-                CAMERA_LOG_INFO("Stop CaptureFrameThread in itself");
-        }else {
-            CAMERA_LOG_INFO("%s :capture not run", __FUNCTION__);
-        }
-        mCaptureLock.unlock();
-        CAMERA_LOG_INFO("%s :---------", __FUNCTION__);
-
-        mPreviewLock.lock();
-        if(mPreviewRunning) {
-            CAMERA_LOG_INFO("%s :preview run", __FUNCTION__);
-            mPreviewThreadQueue.postStopMessage();
-            mPreviewRunning = false;
-            if(gettid()!= mPreviewShowFrameThread->mTID)
-                sem_wait(&mPreviewStoppedCondition);
-            else
-                CAMERA_LOG_INFO("Stop PreviewShowThread in itself");
-        }else {
-            CAMERA_LOG_INFO("%s :preview not run", __FUNCTION__);
-        }
-        mPreviewLock.unlock();
-        CAMERA_LOG_INFO("%s :exit", __FUNCTION__);
-
-        return ;
+    if(mTakePictureInProcess) {
+        FLOGE("takePicture already running");
+        return ALREADY_EXISTS;
     }
 
-    void CameraHal :: CameraHALStopMisc()
-    {
-        CAMERA_LOG_FUNC;
-
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        freeBuffersToNativeWindow();
-        if(mSensorType == CAMERA_TYPE_UVC) {
-            CloseCaptureDevice();
-        }
-    }
-
-    status_t CameraHal :: PrepareCaptureBufs()
-    {
-        CAMERA_LOG_FUNC;
-        unsigned int CaptureBufNum = mCaptureBufNum;
-
-        if(allocateBuffersFromNativeWindow() < 0) {
-            CAMERA_LOG_ERR("allocateBuffersFromNativeWindow error");
-            return BAD_VALUE;
-        }
-
-        if (mCaptureDevice->DevRegisterBufs(mCaptureBuffers,&CaptureBufNum)< 0){
-            CAMERA_LOG_ERR("capture device allocat buf error");
-            return BAD_VALUE;
-        }
-        if(mCaptureBufNum != CaptureBufNum){
-            CAMERA_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
-        }
+    forceStopPreview();
 
-        mCaptureBufNum = CaptureBufNum;
+    FSL_ASSERT(mCameraBridge.get() != NULL);
+    mCameraBridge->initImageCapture();
 
-        if (mCaptureDevice->DevPrepare()< 0){
-            CAMERA_LOG_ERR("capture device prepare error");
-            return BAD_VALUE;
-        }
-        nCameraBuffersQueued = mCaptureBufNum;
-        mIsCaptureBufsAllocated = 1;
+    int frameRate = mParameters.getPreviewFrameRate();
+    int width, height;
+    mParameters.getPictureSize(&width, &height);
 
-        if((AllocateRecordVideoBuf())<0) {
-            CAMERA_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
-            return BAD_VALUE;
-        }
+    FSL_ASSERT(mDeviceAdapter.get() != NULL);
+    PixelFormat format = mDeviceAdapter->getPicturePixelFormat();
+    mDeviceAdapter->setDeviceConfig(width, height, format, frameRate);
 
-        return NO_ERROR;
+    FSL_ASSERT(mDisplayAdapter.get() != NULL);
+    if(mUseIon) {
+        FSL_ASSERT(mPhysAdapter);
+        mBufferProvider = mPhysAdapter;
+        mDeviceAdapter->setCameraBufferProvide(mBufferProvider);
+        FLOG_RUNTIME("mPhysAdapter allocatePictureBuffer w:%d, h:%d", width, height);
+        ret = mBufferProvider->allocatePictureBuffer(width, height, format, MAX_CAPTURE_BUFFER-1);
     }
-
-    status_t CameraHal :: PrepareCaptureDevices()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int i =0;
-        struct capture_config_t *pCapcfg;
-        if ((ret = OpenCaptureDevice())<0)
-            return ret;
-
-        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
-            CAMERA_LOG_ERR("Dev config failed");
-            return BAD_VALUE;
-        }
-        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
-
-        if(mNativeWindow != 0) {
-            if(PrepareCaptureBufs() < 0) {
-                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
-                return BAD_VALUE;
-            }
-        }
-
-        return ret;
+    else {
+        mBufferProvider = mDisplayAdapter.get();
+        mDeviceAdapter->setCameraBufferProvide(mBufferProvider);
+        FLOG_RUNTIME("mBufferProvider allocatePictureBuffer w:%d, h:%d", width, height);
+        ret = mBufferProvider->allocatePictureBuffer(width, height, format, MAX_CAPTURE_BUFFER);
     }
-
-    status_t CameraHal::PreparePreviwBuf()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int i =0;
-
-        //temply hard code here
-        if (mTakePicFlag == 0){
-            if(mPreviewMemory != NULL) {
-                mPreviewMemory->release(mPreviewMemory);
-            }
-
-            mPreviewMemory = mRequestMemory(-1, mPreviewFrameSize, mPreviewHeapBufNum, NULL);
-            if(mPreviewMemory == NULL) {
-                CAMERA_LOG_ERR("%s, allocate memory failed", __FUNCTION__);
-                return NO_MEMORY;
-            }
-        }
-        return ret;
+    if(NO_ERROR != ret) {
+        FLOGE("Couldn't allocate buffers for Picture");
+        goto error;
     }
 
-    status_t CameraHal ::PreparePreviwMisc()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        preview_heap_buf_head = 0;
-
-       return ret;
+    ret = mCameraBridge->start();
+    if(ALREADY_EXISTS == ret) {
+        FLOGI("mCameraBridge already running");
+        ret = NO_ERROR;
     }
-
-    status_t CameraHal ::CameraHALPreviewStart()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDevice->DevStart()<0)
-            return INVALID_OPERATION;
-
-        mIsCaptureBufsAllocated = 1;
-
-        unsigned int bufIndex = 0;
-        //skip 10 frames when doing preview
-        if(mSensorType != CAMERA_TYPE_UVC) {
-            for (int k = 0; k < 10; k++) {
-                mCaptureDevice->DevDequeue(&bufIndex);
-                mCaptureDevice->DevQueue(bufIndex);
-            }
-        }
-
-        for(unsigned int i=0; i < mCaptureBufNum; i++) {
-            mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
-        }
-        return ret;
+    else if(ret) {
+        FLOGE("Couldn't start mCameraBridge");
+        goto error;
     }
 
-    status_t CameraHal::putBufferCount(DMA_BUFFER *pBuf)
-    {
-        if(pBuf == NULL)
-            return INVALID_OPERATION;
-
-        unsigned int buf_index = pBuf - &mCaptureBuffers[0];
-
-        Mutex::Autolock _l(pBuf->mBufferLock);
-        if(!mRecordRunning &&  (mVideoBufferUsing[buf_index] == 1)
-                && (pBuf->refCount == 2)) {
-            pBuf->refCount --;
-            mVideoBufferUsing[buf_index] = 0;
-        }
-
-        pBuf->refCount --;
-        if(pBuf->refCount == 0) {
-            if(mCaptureRunning) {
-                if(buf_index < mCaptureBufNum) {
-                    if(mCaptureDevice->DevQueue(buf_index) <0){
-                        CAMERA_LOG_ERR("The Capture device queue buf %d error !!!!", buf_index);
-                        return INVALID_OPERATION;
-                    }
-                    //CAMERA_LOG_RUNTIME("Return buffer %d to Capture Device", buf_index);
-                    mCaptureBuffers[buf_index].refCount = 0;
-                    nCameraBuffersQueued++;
-                    mEnqueuedBufs --;
-                    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, buf_index));
-                }else {
-                    return INVALID_OPERATION;
-                }
-            }//end elseif
-        }
-        return NO_ERROR;
+    FLOG_RUNTIME("Starting DeviceAdapter ImageCapture mode");
+    ret = mDeviceAdapter->startImageCapture();
+    if(ret!=NO_ERROR) {
+        FLOGE("Couldn't start ImageCapture w/ DeviceAdapter");
+        goto error;
     }
+    FLOGI("Started ImageCapture");
+    mTakePictureInProcess = true;
 
-    void CameraHal ::getBufferCount(DMA_BUFFER *pBuf)
-    {
-        if(pBuf == NULL)
-            return;
-        Mutex::Autolock _l(pBuf->mBufferLock);
-        pBuf->refCount ++;
-    }
+    LockWakeLock();
+    return ret;
 
-    int CameraHal ::captureframeThreadWrapper()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitCaptureThread) {
-                CAMERA_LOG_INFO("%s: exiting normally", __FUNCTION__);
-                return 0;
-            }
-            ret = captureframeThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: capture thread exit with exception", __FUNCTION__);
-                return ret;
-            }
-        }
-        return ret;
-    }
+error:
+    FLOGE("Performing cleanup after error");
+    mDeviceAdapter->stopImageCapture();
 
-    int CameraHal ::captureframeThread()
-    {
-        //CAMERA_LOG_FUNC;
+    mBufferProvider->freeBuffer();
 
-        unsigned int bufIndex = -1;
-        status_t ret = NO_ERROR;
-        sp<CMessage> msg = mCaptureThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;
-        }
+    mCameraBridge->stop();
 
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                ret = mCaptureDevice->DevDequeue(&bufIndex);
-                //handle the error return.
-                if(ret < 0) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer", __FUNCTION__);
-                    //mCaptureRunning = false;
-                    mCaptureThreadQueue.clearMessage();
-                    sem_post(&mCaptureStoppedCondition);
-                    return NO_ERROR;
-                }
-                //CAMERA_LOG_RUNTIME("Get buffer %d from Capture Device", bufIndex);
-                //handle the normal return.
-                getBufferCount(&mCaptureBuffers[bufIndex]);
-                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-
-                if(mRecordRunning) {
-                    getBufferCount(&mCaptureBuffers[bufIndex]);
-                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-                }
-                break;
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: capture thread stop", __FUNCTION__);
-                mCaptureThreadQueue.clearMessage();
-                sem_post(&mCaptureStoppedCondition);
-                CAMERA_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitCaptureThread = 1;
-                CAMERA_LOG_INFO("%s: receive QUITE message", __FUNCTION__);
-                if (mExitPreviewThread == 0)
-                    mPreviewThreadQueue.postQuitMessage();
-                if (mExitEncodeThread == 0)
-                    mEncodeThreadQueue.postQuitMessage();
-                break;
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }//end switch
+    mBufferProvider = NULL;
+    mTakePictureInProcess = false;
 
-        return ret;
-    }
+    return ret;
+}
 
-    void CameraHal::SearchBuffer(void *pNativeBuf, int *pIndex)
-    {
-        //int index;
-        for(unsigned int i=0; i < mCaptureBufNum; i++){
-            if(mCaptureBuffers[i].native_buf == pNativeBuf) {
-                *pIndex = i;
-                return;
-            }
-        }
-
-        *pIndex = -1;
-        return;
+status_t CameraHal::stopPicture()
+{
+    FLOG_RUNTIME("stopPicture");
+    if(!mTakePictureInProcess) {
+        FLOGE("takePicture not running");
+        return NO_INIT;
     }
 
-    int CameraHal ::previewshowFrameThreadWrapper()
-    {
-        CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitPreviewThread) {
-                CAMERA_LOG_INFO("%s: exiting", __FUNCTION__);
-                return 0;
-            }
-            ret = previewshowFrameThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: preview thread exit with exception", __FUNCTION__);
-                mExitPreviewThread = 1;
-                return ret;
-            }
-        }
-        return ret;
-    }
-
-    static void bufferDump(DMA_BUFFER *pBufs)
-    {
-#ifdef FSL_CAMERAHAL_DUMP
-            //for test code
-            char value[10] = {0};
-            static int vflg = 0;
-            property_get("rw.camera.test", value, "");
-            if(strcmp(value, "1") == 0)
-                vflg = 1;
-            if(vflg){
-                FILE *pf = NULL;
-                pf = fopen("/sdcard/camera_tst.data", "wb");
-                if(pf == NULL) {
-                    CAMERA_LOG_ERR("open /sdcard/camera_tst.data failed");
-                }
-                else {
-                    fwrite(pInBuf->virt_start, pInBuf->length, 1, pf);
-                    fclose(pf);
-                }
-                vflg = 0;
-            }
-#endif
-    }
-
-    int CameraHal ::previewshowFrameThread()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int display_index = -1;
-        DMA_BUFFER *pInBuf = NULL;
-        buffer_handle_t *buf_h = NULL;
-        int buf_index = -1;
-        int stride = 0, err = 0;
-
-        sp<CMessage> msg = mPreviewThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            mPreviewRunning = false;
-            return BAD_VALUE;
-        }
-
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                display_index = msg->arg0;
-                if(display_index < 0 || (unsigned int)display_index >= mCaptureBufNum) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return BAD_VALUE;
-                }
-                pInBuf = &mCaptureBuffers[display_index];
-
-                if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-                    //CAMERA_LOG_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
-                    convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
-                            (uint8_t*)((unsigned char*)mPreviewMemory->data + preview_heap_buf_head*mPreviewFrameSize),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-                    mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, preview_heap_buf_head, NULL, mCallbackCookie);
-                    preview_heap_buf_head ++;
-                    preview_heap_buf_head %= mPreviewHeapBufNum;
-                }
-
-                if (mNativeWindow != 0) {
-                    if (mNativeWindow->enqueue_buffer(mNativeWindow, (buffer_handle_t * )pInBuf->native_buf) < 0){
-                        CAMERA_LOG_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
-                        mPreviewRunning = false;
-                        mPreviewThreadQueue.clearMessage();
-                        sem_post(&mPreviewStoppedCondition);
-                        return BAD_VALUE;
-                    }
-                    pInBuf->buf_state = WINDOW_BUFS_QUEUED;
-                    mEnqueuedBufs ++;
-                    bufferDump(pInBuf);
-                    if (mEnqueuedBufs <= 2) {
-                        return NO_ERROR;
-                    }
-                }
-                else {
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return BAD_VALUE;
-                }
-
-                err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
-                if((err != 0) || buf_h == NULL) {
-                    CAMERA_LOG_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return INVALID_OPERATION;
-                }
-
-                SearchBuffer((void *)buf_h, &buf_index);
-
-                if(buf_index >= (int)mCaptureBufNum || (buf_index < 0)) {
-                    mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
-                    CAMERA_LOG_ERR("dequeue invalide buffer!!!!");
-                    mPreviewRunning = false;
-                    mPreviewThreadQueue.clearMessage();
-                    sem_post(&mPreviewStoppedCondition);
-                    return INVALID_OPERATION;
-                }
-
-                mCaptureBuffers[buf_index].buf_state = WINDOW_BUFS_DEQUEUED;
-                ret = putBufferCount(&mCaptureBuffers[buf_index]);
-                break;
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: preview thread stop", __FUNCTION__);
-                mPreviewThreadQueue.clearMessage();
-                sem_post(&mPreviewStoppedCondition);
-                CAMERA_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitPreviewThread = 1;
-                CAMERA_LOG_INFO("%s: receive QUIT message", __FUNCTION__);
-                break;
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }
-
-        return ret;
+    if (mDeviceAdapter.get() != NULL) {
+        mDeviceAdapter->stopImageCapture();
     }
 
-    int CameraHal::encodeframeThreadWrapper()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        while(1) {
-            if(mExitEncodeThread) {
-                return 0;
-            }
-            ret = encodeframeThread();
-            if(ret < 0) {
-                CAMERA_LOG_ERR("%s: encode thread exit with exception", __FUNCTION__);
-                mExitEncodeThread = 1;
-                return ret;
-            }
-        }
-        return ret;
+    if(mCameraBridge.get() != NULL) {
+        mCameraBridge->stop();
     }
 
-    int CameraHal::encodeframeThread()
-    {
-        //CAMERA_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int enc_index;
-        sp<CMessage> msg = mEncodeThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;
-        }
-
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                enc_index = msg->arg0;
-                unsigned int i;
-                if(enc_index < 0 || (unsigned int)enc_index >= mCaptureBufNum) {
-                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
-                    mRecordRunning = false;
-                    mEncodeThreadQueue.clearMessage();
-                    //sem_post(&mEncodeStoppedCondition);
-                    return BAD_VALUE;
-                }
-
-                struct timespec ts;
-                DMA_BUFFER *EncBuf;
-                EncBuf = &mCaptureBuffers[enc_index];
-
-                if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
-                    nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-                    if (mDirectInput == true) {
-	                    memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
-                            (void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
-                    } else {
-                        memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
-                                (void*)EncBuf->virt_start, mPreviewFrameSize);
-                    }
-
-                    mVideoBufferUsing[enc_index] = 1;
-                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, enc_index, mCallbackCookie);
-                    break;
-                }
-                break;
-
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_LOG_INFO("%s: encode thread stop", __FUNCTION__);
-                mEncodeThreadQueue.clearMessage();
-                //sem_post(&mEncodeStoppedCondition);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitEncodeThread = 1;
-                break;
-
-            default:
-                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }
-
-        return ret;
+    if(mBufferProvider != NULL) {
+        mBufferProvider->freeBuffer();
     }
 
-    status_t CameraHal :: AllocateRecordVideoBuf()
-    {
-        status_t ret = NO_ERROR;
-        unsigned int i = 0;
-        if(mVideoMemory != NULL) {
-            mVideoMemory->release(mVideoMemory);
-        }
+    mBufferProvider = NULL;
+    mTakePictureInProcess = false;
+    UnLockWakeLock();
+    return NO_ERROR;
+}
 
-        CAMERA_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
-        mVideoMemory = mRequestMemory(-1, mPreviewFrameSize, mVideoBufNume, NULL);
-        if(mVideoMemory == NULL) {
-            CAMERA_LOG_ERR("%s, request video buffer failed", __FUNCTION__);
-            return NO_MEMORY;
-        }
+status_t CameraHal::cancelPicture()
+{
+    FLOG_RUNTIME("cancelPicture");
+    status_t ret = stopPicture();
+    return ret;
+}
 
-        //Make sure the buffer been updated for direct input
-        updateDirectInput(mDirectInput);
-        return ret;
+void CameraHal::release()
+{
+    Mutex::Autolock lock(mLock);
+    if(mPreviewEnabled) {
+        forceStopPreview();
     }
 
+    mSetPreviewWindowCalled = false;
+}
 
-    void CameraHal :: LockWakeLock()
-    {
-        if (!mPowerLock) {
-            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
-            mPowerLock = true;
-        }
-    }
-    void CameraHal :: UnLockWakeLock()
-    {
-        if (mPowerLock) {
-            release_wake_lock (V4LSTREAM_WAKE_LOCK);
-            mPowerLock = false;
-        }
-    }
-
-    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
-    {
-        /* Color space conversion from I420 to YUV420SP */
-        int Ysize = 0, UVsize = 0;
-        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
-
-        Ysize = width * height;
-        UVsize = width *  height >> 2;
-
-        Yin = inputBuffer;
-        Uin = Yin + Ysize;
-        Vin = Uin + 1;
-
-        Yout = outputBuffer;
-        Vout = Yout + Ysize;
-        Uout = Vout + 1;
-
-        memcpy(Yout, Yin, Ysize);
-
-        for(int k = 0; k < UVsize; k++) {
-            *Uout = *Uin;
-            *Vout = *Vin;
-            Uout += 2;
-            Vout += 2;
-            Uin  += 2;
-            Vin += 2;
-        }
+void CameraHal::LockWakeLock()
+{
+    if(!mPowerLock) {
+        acquire_wake_lock(PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
+        mPowerLock = true;
     }
+}
 
-
-
-    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
-    {
-        double dAttribtute;
-        double eAttr;
-        long intAttribute;
-        int ret  = 0;
-        if (cAttribute == NULL){
-            return -1;
-        }
-
-        CAMERA_LOG_RUNTIME("the attribute is %s", cAttribute);
-
-        dAttribtute = atof(cAttribute);
-
-        CAMERA_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
-        intAttribute  = (long)(dAttribtute*(double)3600.0);
-        if (intAttribute < 0){
-            ret = 1;
-            intAttribute *=-1;
-            dAttribtute *=-1;
-            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
-            eAttr = eAttr * (double)3600.0 *(double)1000.0;
-        }else {
-            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
-            eAttr = eAttr * (double)3600.0 *(double)1000.0;
-        }
-
-        second = (unsigned int)(intAttribute%60);
-        minute = (unsigned int)((intAttribute%3600-second)/60);
-        degree = (unsigned int)(intAttribute/3600);
-        second = (unsigned int)eAttr + second * 1000;
-
-        CAMERA_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
-
-        return ret;
-
+void CameraHal::UnLockWakeLock()
+{
+    if(mPowerLock) {
+        release_wake_lock(V4LSTREAM_WAKE_LOCK);
+        mPowerLock = false;
     }
+}
 
-//};
-
+status_t CameraHal::dump(int fd) const
+{
+    return NO_ERROR;
+}
 
diff --git a/mx6/libcamera/CameraHal.h b/mx6/libcamera/CameraHal.h
index 03bbda5..7f978b3 100755
--- a/mx6/libcamera/CameraHal.h
+++ b/mx6/libcamera/CameraHal.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,394 +15,90 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAMERA_HAL_BASE_H
-#define CAMERA_HAL_BASE_H
+#ifndef _CAMERA_HAL_H
+#define _CAMERA_HAL_H
 
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <binder/MemoryBase.h>
-#include <binder/MemoryHeapBase.h>
-#include <camera/CameraParameters.h>
+#include "CameraUtil.h"
+#include "CameraBridge.h"
+#include "DeviceAdapter.h"
+#include "DisplayAdapter.h"
 #include <hardware/camera.h>
-#include <semaphore.h>
-
-#include "CaptureDeviceInterface.h"
-#include "JpegEncoderInterface.h"
-#include "messageQueue.h"
-
-
-#define EXIF_MAKENOTE "fsl_makernote"
-#define EXIF_MODEL    "fsl_model"
-
-#define CAMER_PARAM_BUFFER_SIZE 512
-#define MAX_QUERY_FMT_TIMES 20
-#define PARAMS_DELIMITER ","
-#define V4LSTREAM_WAKE_LOCK "V4LCapture"
-
-#define PREVIEW_HEAP_BUF_NUM    6
-#define VIDEO_OUTPUT_BUFFER_NUM 6
-#define POST_PROCESS_BUFFER_NUM 6
-#define TAKE_PIC_QUE_BUF_NUM 6
-
-#define PREVIEW_CAPTURE_BUFFER_NUM 6
-#define PICTURE_CAPTURE_BUFFER_NUM 2
 
-#define DEFAULT_PREVIEW_FPS (15)
-#define DEFAULT_PREVIEW_W   (640)
-#define DEFAULT_PREVIEW_H   (480)
-#define MAX_MIPI_PREVIEW_W       (1920)
-#define MAX_MIPI_PREVIEW_H       (1080)
-#define MAX_CSI_PREVIEW_W       (1280)
-#define MAX_CSI_PREVIEW_H       (720)
-#define DEFAULT_PICTURE_W   (640)
-#define DEFAULT_PICTURE_H   (480)
-
-#define MAX_VPU_SUPPORT_FORMAT 2
 using namespace android;
-//namespace android {
-
-    typedef enum{
-        CAMERA_HAL_ERR_NONE = 0,
-        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
-        CAMERA_HAL_ERR_GET_PARAM           = -2,
-        CAMERA_HAL_ERR_BAD_PARAM =-3,
-        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
-        CAMERA_HAL_ERR_INIT = -5,
-        CAMERA_HAL_ERR_ALLOC_BUF =-6,
-        CAMERA_HAL_ERR_PP_NULL = -7
-    }CAMERA_HAL_RET;
-
-	typedef enum{
-        CAMERA_PREVIEW_BACK_REF = 0,
-        CAMERA_PREVIEW_VERT_FLIP = 1,
-        CAMERA_PREVIEW_HORIZ_FLIP = 2,
-        CAMERA_PREVIEW_ROATE_180 = 3,
-        CAMERA_PREVIEW_ROATE_LAST = 3
-	}CAMERA_PREVIEW_ROTATE;
-
-#ifndef container_of
-#define container_of(ptr, type, member) ({                      \
-        const typeof(((type *) 0)->member) *__mptr = (ptr);     \
-        (type *) ((char *) __mptr - (char *)(&((type *)0)->member)); })
-#endif
-
-    class CameraHal {
-    public:
-        virtual sp<IMemoryHeap> getRawHeap() const;
-
-        virtual status_t setPreviewWindow(struct preview_stream_ops *window);
-        virtual void        setCallbacks(camera_notify_callback notify_cb,
-                camera_data_callback data_cb,
-                camera_data_timestamp_callback data_cb_timestamp,
-                camera_request_memory get_memory,
-                void* user);
-
-        virtual void        enableMsgType(int32_t msgType);
-        virtual void        disableMsgType(int32_t msgType);
-        virtual bool        msgTypeEnabled(int32_t msgType);
 
-        status_t freeBufferToIon();
-        status_t allocateBufferFromIon();
-        virtual status_t    startPreview();
-        virtual void        stopPreview();
-        virtual bool        previewEnabled();
+class PhysMemAdapter;
+
+class CameraHal
+{
+public:
+    CameraHal(int cameraId);
+    ~CameraHal();
+    status_t initialize(const CameraInfo& info);
+
+    void setCallbacks(camera_notify_callback notify_cb,
+        camera_data_callback data_cb,
+        camera_data_timestamp_callback data_cb_timestamp,
+        camera_request_memory get_memory,
+        void* user);
+    void enableMsgType(int32_t msgType);
+    void disableMsgType(int32_t msgType);
+    bool msgTypeEnabled(int32_t msgType);
+    void putParameters(char *params);
+    char* getParameters() const;
+    status_t setParameters(const char* params);
+    status_t setParameters(CameraParameters& params);
+    status_t setPreviewWindow(struct preview_stream_ops *window);
+
+    bool previewEnabled();
+    status_t restartPreview();
+    status_t startPreview();
+    void stopPreview();
+    void forceStopPreview();
+
+    status_t autoFocus();
+    status_t cancelAutoFocus();
+
+    status_t startRecording();
+    void stopRecording();
+    void releaseRecordingFrame(const void* mem);
+    status_t storeMetaDataInBuffers(bool enable);
+    bool recordingEnabled();
+
+    status_t takePicture();
+    status_t stopPicture();
+    status_t cancelPicture();
+
+    status_t sendCommand(int32_t cmd, int32_t arg1, int32_t arg2);
+    void release();
+    status_t dump(int fd) const;
+
+    void LockWakeLock();
+    void UnLockWakeLock();
+
+private:
+    sp<CameraBridge> mCameraBridge;
+    sp<DeviceAdapter> mDeviceAdapter;
+    sp<DisplayAdapter> mDisplayAdapter;
+    CameraBufferProvider* mBufferProvider;
+
+private:
+    bool mPowerLock;
+    int mCameraId;
+    mutable Mutex mLock;
+    CameraParameters mParameters;
+    mutable Mutex mEncodeLock;
+    bool mPreviewEnabled;
+    bool mRecordingEnabled;
+    bool mTakePictureInProcess;
+
+    bool mSetPreviewWindowCalled;
+    bool mPreviewStartInProgress;
+    int32_t mMsgEnabled;
+
+    int mSupportedRecordingFormat[MAX_VPU_SUPPORT_FORMAT];
+    int mSupportedPictureFormat[MAX_PICTURE_SUPPORT_FORMAT];
+    PhysMemAdapter* mPhysAdapter;
+    bool mUseIon;
+};
 
-		virtual status_t  storeMetaDataInBuffers(bool enable);
-
-        virtual status_t    startRecording();
-        virtual void        stopRecording();
-        virtual bool        recordingEnabled();
-        virtual void        releaseRecordingFrame(const void*  mem);
-
-        virtual status_t    autoFocus();
-        virtual status_t    cancelAutoFocus();
-        virtual status_t    takePicture();
-        virtual status_t    cancelPicture();
-        virtual status_t    dump(int fd) const;
-        virtual status_t    setParameters(CameraParameters& params);
-        virtual status_t    setParameters(const char* params);
-        virtual char*  getParameters() const;
-        void putParameters(char *);
-        virtual status_t    sendCommand(int32_t command, int32_t arg1,
-                int32_t arg2);
-        virtual void release();
-
-        CAMERA_HAL_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
-        CAMERA_HAL_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
-        CAMERA_HAL_RET Init();
-        void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
-
-        CameraHal(int cameraid);
-        virtual             ~CameraHal();
-
-    private:
-
-        class CaptureFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            CaptureFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->captureframeThreadWrapper();
-                return false;
-            }
-            int mTID;
-        };
-
-        class PreviewShowFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            PreviewShowFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->previewshowFrameThreadWrapper();
-                return false;
-            }
-            int mTID;
-        };
-
-        class EncodeFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            EncodeFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->encodeframeThreadWrapper();
-                return true;
-            }
-            int mTID;
-        };
-
-        class AutoFocusThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            AutoFocusThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                if (mHardware->autoFocusThread()>=0)
-                    return true;
-                else
-                    return false;
-            }
-            int mTID;
-        };
-
-
-        class TakePicThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            TakePicThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0) { }
-#if 0
-            virtual void onFirstRef() {
-                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
-            }
 #endif
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->takepicThread();
-                return false;
-            }
-            int mTID;
-        };
-
-        void preInit();
-        void postDestroy();
-
-        status_t OpenCaptureDevice();
-        void CloseCaptureDevice();
-
-        CAMERA_HAL_RET AllocInterBuf();
-        void  FreeInterBuf();
-        CAMERA_HAL_RET InitCameraHalParam();
-        CAMERA_HAL_RET InitCameraBaseParam(CameraParameters *pParam);
-        CAMERA_HAL_RET InitPictureExifParam(CameraParameters *pParam);
-        CAMERA_HAL_RET CameraMiscInit();
-        CAMERA_HAL_RET CameraMiscDeInit();
-        status_t CameraHALPreviewStart();
-        int captureframeThread();
-        int previewshowFrameThread();
-        int encodeframeThread();
-        int captureframeThreadWrapper();
-        int previewshowFrameThreadWrapper();
-        int encodeframeThreadWrapper();
-        status_t AllocateRecordVideoBuf();
-
-        status_t CameraHALStartPreview();
-        void     CameraHALStopPreview();
-
-        status_t PreparePreviwBuf();
-        status_t PrepareCaptureDevices();
-        status_t PreparePreviwMisc();
-
-        void CameraHALStopThreads();
-        void LockWakeLock();
-        void UnLockWakeLock();
-
-        int autoFocusThread();
-        int takepicThread();
-
-        int GetJpegEncoderParam();
-        int NegotiateCaptureFmt(bool TakePicFlag);
-        int cameraHALTakePicture();
-        void CameraHALStopMisc();
-        int PrepareJpegEncoder();
-        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
-
-        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
-
-        status_t allocateBuffersFromNativeWindow();
-        void SearchBuffer(void *pNativeBuf, int *pIndex);
-        status_t freeBuffersToNativeWindow();
-        status_t PrepareCaptureBufs();
-        status_t updateDirectInput(bool bDirect);
-
-        status_t convertStringToPreviewFormat(unsigned int *pFormat);
-        status_t convertPreviewFormatToString(char *pStr, int length, unsigned int format);
-        int convertPreviewFormatToPixelFormat(unsigned int format);
-        status_t putBufferCount(DMA_BUFFER *pBuf);
-        void getBufferCount(DMA_BUFFER *pBuf);
-        CAMERA_HAL_RET InitCameraPreviewFormatToParam(int nFmt);
-
-        CMessageQueue mCaptureThreadQueue;
-        CMessageQueue mPreviewThreadQueue;
-        CMessageQueue mEncodeThreadQueue;
-
-        //For capture thread(queue/dequeue with v4l2 driver)
-        mutable Mutex mCaptureLock;
-        mutable sem_t mCaptureStoppedCondition;
-        bool mCaptureRunning;
-        bool mExitCaptureThread;
-
-        //For preview thread(queue/dequeue with NativeWindow)
-        mutable Mutex mPreviewLock;
-        mutable sem_t mPreviewStoppedCondition;
-        bool mPreviewRunning;
-        bool mExitPreviewThread;
-
-        //For video recording thread
-        mutable Mutex mEncodeLock;
-        mutable sem_t mEncodeStoppedCondition;
-        bool mExitEncodeThread;
-
-        //For picture taking thread
-        mutable sem_t mTakingPicture;
-        bool mWaitForTakingPicture;
-        bool mTakePictureInProcess;
-
-        bool mTakePictureAllocBuffer;
-        CameraParameters    mParameters;
-        void               *mCallbackCookie;
-        camera_notify_callback    mNotifyCb;
-        camera_data_callback      mDataCb;
-        camera_data_timestamp_callback mDataCbTimestamp;
-        camera_request_memory mRequestMemory;
-
-        sp<CaptureDeviceInterface> mCaptureDevice;
-        sp<JpegEncoderInterface> mJpegEncoder;
-
-
-        sp<CaptureFrameThread> mCaptureFrameThread;
-        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
-        sp<EncodeFrameThread> mEncodeFrameThread;
-        sp<AutoFocusThread>mAutoFocusThread;
-        sp<TakePicThread> mTakePicThread;
-
-        mutable Mutex       mLock;
-
-        char *mSupportedPictureSizes;
-        char *mSupportedPreviewSizes;
-        char *mSupportedFPS;
-        char *mSupprotedThumbnailSizes;
-        char *mSupportPreviewFormat;
-
-        preview_stream_ops_t*   mNativeWindow;
-        unsigned int        mMsgEnabled;
-
-        struct capture_config_t mCaptureDeviceCfg;
-        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
-
-        camera_memory_t* mPreviewMemory;
-
-        /* the buffer for recorder */
-        unsigned int        mVideoBufNume;
-        camera_memory_t* mVideoMemory;
-        int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
-		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
-
-        unsigned int        mDefaultPreviewFormat;
-        unsigned int 		mPreviewFrameSize;
-        unsigned int        mPreviewCapturedFormat;
-
-        bool                mTakePicFlag;
-        unsigned int        mJpegEncoderSupportFmt[MAX_QUERY_FMT_TIMES];
-        enc_cfg_param       mJpegEncCfg;
-
-        unsigned int        mUvcSpecialCaptureFormat;
-        unsigned int        mSensorSupportFmt[MAX_QUERY_FMT_TIMES];
-        unsigned int        mPictureEncodeFormat;
-        unsigned int        mCaptureFrameSize;
-        unsigned int        mCaptureBufNum;
-        unsigned int        mEnqueuedBufs;
-
-        bool                mRecordRunning;
-        int                 mCurrentRecordFrame;
-        int 		        nCameraBuffersQueued;
-
-        unsigned int        mPreviewHeapBufNum;
-        unsigned int        mTakePicBufQueNum;
-
-        char                mCameraSensorName[CAMERA_SENSOR_LENGTH];
-        bool mCameraReady;
-        bool mCaptureDeviceOpen;
-        bool mIsCaptureBufsAllocated;
-        bool mPreviewStopped;
-        bool mRecordStopped;
-        bool mPowerLock;
-        bool mDirectInput;
-        int mCameraid;
-
-        unsigned int preview_heap_buf_head;
-
-        CAMERA_PREVIEW_ROTATE mPreviewRotate;
-
-        unsigned int mVpuSupportFmt[MAX_VPU_SUPPORT_FORMAT];
-        CAMERA_TYPE mSensorType;
-        int mIonFd;
-        bool mUseIon;
-    };
-
-//}; // namespace android
-
-#endif
-
diff --git a/mx6/libcamera/CameraModule.cpp b/mx6/libcamera/CameraModule.cpp
index d28a3d3..dbcdee8 100755
--- a/mx6/libcamera/CameraModule.cpp
+++ b/mx6/libcamera/CameraModule.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) Freescale - http://www.Freescale.com/
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +15,6 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
 #define LOG_TAG "CameraHAL"
 #include <linux/videodev2.h>
 #include <linux/mxcfb.h>
@@ -29,10 +26,10 @@
 #include <utils/threads.h>
 #include <cutils/properties.h>
 #include "CameraHal.h"
-#include "Camera_utils.h"
+#include "CameraUtil.h"
 
 #define MAX_CAMERAS_SUPPORTED 2
-//static android::CameraProperties gCameraProperties;
+
 static CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
 static unsigned int gCamerasOpen = 0;
 static android::Mutex gCameraHalDeviceLock;
@@ -478,13 +475,8 @@ done:
 #define DEFAULT_ERROR_NAME '0'
 #define DEFAULT_ERROR_NAME_str "0"
 #define UVC_NAME "uvc"
-static struct camera_info sCameraInfo[2];
-//gCameraName[0]  for back camera name
-//gCameraName[1]  for front camera name
-static char gCameraName[2][CAMERA_SENSOR_LENGTH];
-static char gCameraDevPath[2][CAMAERA_FILENAME_LENGTH];
+static struct CameraInfo sCameraInfo[2];
 static int gCameraNum = 0;
-
 /*******************************************************************
  * implementation of camera_module functions
  *******************************************************************/
@@ -505,9 +497,6 @@ int camera_device_open(const hw_module_t* module, const char* name,
     camera_device_ops_t* camera_ops = NULL;
     CameraHal* camera = NULL;
     char *SelectedCameraName;
-    android::sp<android::CaptureDeviceInterface> pCaptureDevice = NULL;
-    android::sp<android::JpegEncoderInterface>pJpegEncoder = NULL;
-    //android::CameraProperties::Properties* properties = NULL;
 
     android::Mutex::Autolock lock(gCameraHalDeviceLock);
 
@@ -515,7 +504,7 @@ int camera_device_open(const hw_module_t* module, const char* name,
 
     if (name != NULL) {
         cameraid = atoi(name);
-        num_cameras = camera_get_number_of_cameras();//gCameraProperties.camerasSupported();
+        num_cameras = camera_get_number_of_cameras();
 
         if(cameraid > num_cameras)
         {
@@ -525,14 +514,7 @@ int camera_device_open(const hw_module_t* module, const char* name,
             rv = -EINVAL;
             goto fail;
         }
-#if 0
-        if(gCamerasOpen >= MAX_SIMUL_CAMERAS_SUPPORTED)
-        {
-            ALOGE("maximum number of cameras already open");
-            rv = -ENOMEM;
-            goto fail;
-        }
-#endif
+
         camera_device = (fsl_camera_device_t*)malloc(sizeof(*camera_device));
         if(!camera_device)
         {
@@ -585,11 +567,6 @@ int camera_device_open(const hw_module_t* module, const char* name,
         *device = &camera_device->base.common;
 
         camera_device->cameraid = cameraid;
-        SelectedCameraName = gCameraName[sCameraInfo[cameraid].facing];
-
-        pCaptureDevice = android::createCaptureDevice(SelectedCameraName,
-                gCameraDevPath[sCameraInfo[cameraid].facing]);
-        pJpegEncoder = android::createJpegEncoder(android::SOFTWARE_JPEG_ENC);
 
         camera = new CameraHal(cameraid);
 
@@ -600,13 +577,7 @@ int camera_device_open(const hw_module_t* module, const char* name,
             goto fail;
         }
 
-        if (camera->setCaptureDevice(pCaptureDevice) < 0 ||
-                camera->setJpegEncoder(pJpegEncoder) < 0) {
-            rv = -EINVAL;
-            goto fail;
-        }
-
-        if (camera->Init() < 0) {
+        if (camera->initialize(sCameraInfo[cameraid]) < 0) {
             rv = -EINVAL;
             goto fail;
         }
@@ -715,19 +686,19 @@ int camera_get_number_of_cameras()
 {
     int back_orient =0,  front_orient = 0;
     if(gCameraNum == 0) {
-        GetCameraPropery(gCameraName[0], gCameraName[1], &back_orient, &front_orient);
-        if (gCameraName[0][0] != DEFAULT_ERROR_NAME){
+        GetCameraPropery(sCameraInfo[0].name, sCameraInfo[1].name, &back_orient, &front_orient);
+        if (sCameraInfo[0].name[0] != DEFAULT_ERROR_NAME){
             sCameraInfo[gCameraNum].facing = CAMERA_FACING_BACK;
             sCameraInfo[gCameraNum].orientation = back_orient;
-            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
-            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
+            memset(sCameraInfo[gCameraNum].devPath, 0, CAMAERA_FILENAME_LENGTH);
+            GetDevPath(sCameraInfo[gCameraNum].name, sCameraInfo[gCameraNum].devPath, CAMAERA_FILENAME_LENGTH);
             gCameraNum++;
         }
-        if (gCameraName[1][0] != DEFAULT_ERROR_NAME){
+        if (sCameraInfo[1].name[0] != DEFAULT_ERROR_NAME){
             sCameraInfo[gCameraNum].facing = CAMERA_FACING_FRONT;
             sCameraInfo[gCameraNum].orientation = front_orient;
-            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
-            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
+            memset(sCameraInfo[gCameraNum].devPath, 0, CAMAERA_FILENAME_LENGTH);
+            GetDevPath(sCameraInfo[gCameraNum].name, sCameraInfo[gCameraNum].devPath, CAMAERA_FILENAME_LENGTH);
             gCameraNum++;
         }
     }
diff --git a/mx6/libcamera/CameraUtil.cpp b/mx6/libcamera/CameraUtil.cpp
new file mode 100755
index 0000000..dfa3f0f
--- /dev/null
+++ b/mx6/libcamera/CameraUtil.cpp
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CameraUtil.h"
+#include <sys/atomics.h>
+
+int convertPixelFormatToV4L2Format(PixelFormat format)
+{
+    int nFormat = 0;
+    switch(format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+            nFormat = v4l2_fourcc('N','V','1','2');
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_P:
+            nFormat = v4l2_fourcc('Y','U','1','2');
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_422_I:
+            nFormat = v4l2_fourcc('Y','U','Y','V');
+            break;
+        default:
+            FLOGE("Error: format not supported!");
+            break;
+    }
+    FLOGI("pixel format: 0x%x", nFormat);
+    return nFormat;
+}
+
+PixelFormat convertV4L2FormatToPixelFormat(unsigned int format)
+{
+    PixelFormat nFormat = 0;
+    switch(format) {
+        case v4l2_fourcc('N','V','1','2'):
+            nFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP;
+            break;
+        case v4l2_fourcc('Y','U','1','2'):
+            nFormat = HAL_PIXEL_FORMAT_YCbCr_420_P;
+            break;
+        case v4l2_fourcc('Y','U','Y','V'):
+            nFormat = HAL_PIXEL_FORMAT_YCbCr_422_I;
+            break;
+        default:
+            FLOGE("Error: format not supported!");
+            break;
+    }
+    FLOGI("pixel format: 0x%x", nFormat);
+    return nFormat;
+}
+
+int convertStringToPixelFormat(const char* pFormat)
+{
+    if(pFormat == NULL) {
+        return 0;
+    }
+
+    if(!strcmp(pFormat, "yuv420p")) {
+        return HAL_PIXEL_FORMAT_YCbCr_420_P;
+    }
+    else if(!strcmp(pFormat, "yuv420sp")) {
+        return HAL_PIXEL_FORMAT_YCbCr_420_SP;
+    }
+    else if(!strcmp(pFormat, "yuv422i-yuyv")) {
+      return HAL_PIXEL_FORMAT_YCbCr_422_I;
+    }
+    else {
+        FLOGE("format %s is not supported", pFormat);
+        return BAD_VALUE;
+    }
+}
+
+int convertStringToV4L2Format(const char* pFormat)
+{
+    if(pFormat == NULL) {
+        return 0;
+    }
+
+    if(!strcmp(pFormat, "yuv420p")) {
+        return v4l2_fourcc('Y','U','1','2');
+    }
+    else if(!strcmp(pFormat, "yuv420sp")) {
+        return v4l2_fourcc('N','V','1','2');
+    }
+    else if(!strcmp(pFormat, "yuv422i-yuyv")) {
+        return v4l2_fourcc('Y','U','Y','V');
+    }
+    else {
+        FLOGE("format %s is not supported", pFormat);
+        return BAD_VALUE;
+    }
+}
+
+CameraFrame::~CameraFrame()
+{
+    reset();
+}
+
+void CameraFrame::initialize(buffer_handle_t* buf_h, int index)
+{
+    FSL_ASSERT(buf_h);
+    private_handle_t *handle = (private_handle_t *)(*buf_h);
+    mBufHandle = buf_h;
+    mVirtAddr =  (void*)handle->base;
+    mPhyAddr =   handle->phys;
+    mSize =   handle->size;
+    mWidth =  handle->width;
+    mHeight = handle->height;
+    mFormat = handle->format;
+
+    mObserver = NULL;
+    mRefCount = 0;
+    mBufState = BUFS_CREATE;
+    mFrameType = INVALID_FRAME;
+    mIndex = index;
+}
+
+void CameraFrame::addState(CAMERA_BUFS_STATE state)
+{
+    mBufState |= state;
+}
+
+void CameraFrame::removeState(CAMERA_BUFS_STATE state)
+{
+    mBufState &= ~state;
+}
+
+void CameraFrame::addReference()
+{
+    __atomic_inc(&mRefCount);
+}
+
+void CameraFrame::release()
+{
+    FSL_ASSERT(mRefCount > 0, "mRefCount=%d invalid value", mRefCount);
+
+    int prevCount = __atomic_dec(&mRefCount);
+    if ((prevCount == 1) && (mObserver != NULL)) {
+        mObserver->handleFrameRelease(this);
+    }
+}
+
+void CameraFrame::setObserver(CameraFrameObserver *observer)
+{
+    mObserver = observer;
+}
+
+void CameraFrame::reset()
+{
+    mBufHandle = NULL;
+    mVirtAddr = NULL;
+    mPhyAddr = 0;
+    mObserver = NULL;
+    mRefCount = 0;
+    mBufState = BUFS_CREATE;
+    mFrameType = INVALID_FRAME;
+}
+
+////////////CameraBufferProvider////////////////////
+CameraBufferProvider::CameraBufferProvider()
+{
+    mBufferListeners.clear();
+}
+
+CameraBufferProvider::~CameraBufferProvider()
+{
+    mBufferListeners.clear();
+}
+
+void CameraBufferProvider::addBufferListener(CameraBufferListener* listener)
+{
+    CameraBufferListener *pNtf = NULL;
+    size_t nSize = mBufferListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraBufferListener*)mBufferListeners[i];
+        if(pNtf == listener) {
+            return;
+        }
+    }
+
+    mBufferListeners.push((int)listener);
+}
+
+void CameraBufferProvider::removeBufferListener(CameraBufferListener* listener)
+{
+    CameraBufferListener* pNtf;
+    size_t nSize = mBufferListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraBufferListener*)mBufferListeners[i];
+        if(pNtf == listener) {
+            mBufferListeners.removeAt(i);
+            //break;
+        }
+    }
+}
+
+void CameraBufferProvider::clearBufferListeners()
+{
+    mBufferListeners.clear();
+}
+
+void CameraBufferProvider::dispatchBuffers(CameraFrame* pBuffer, int num, BufferState bufState)
+{
+    CameraBufferListener *listener;
+    size_t nSize = mBufferListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        listener = (CameraBufferListener*)mBufferListeners[i];
+        switch(bufState) {
+            case BUFFER_CREATE:
+                FSL_ASSERT(pBuffer);
+                listener->onBufferCreat(pBuffer, num);
+                break;
+
+            case BUFFER_DESTROY:
+                listener->onBufferDestroy();
+                break;
+        }//end switch
+    }//end for
+}
+
+
+////////////CameraFrameProvider////////////////////
+CameraFrameProvider::CameraFrameProvider()
+{
+    mFrameListeners.clear();
+}
+
+CameraFrameProvider::~CameraFrameProvider()
+{
+    mFrameListeners.clear();
+}
+
+void CameraFrameProvider::addFrameListener(CameraFrameListener* listener)
+{
+    CameraFrameListener* pNtf;
+    size_t nSize = mFrameListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraFrameListener*)mFrameListeners[i];
+        if(pNtf == listener) {
+            return;
+        }
+    }
+
+    mFrameListeners.push((int)listener);
+}
+
+void CameraFrameProvider::removeFrameListener(CameraFrameListener* listener)
+{
+    CameraFrameListener* pNtf;
+    size_t nSize = mFrameListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraFrameListener*)mFrameListeners[i];
+        if(pNtf == listener) {
+            mFrameListeners.removeAt(i);
+            //break;
+        }
+    }
+}
+
+void CameraFrameProvider::clearFrameListeners()
+{
+    mFrameListeners.clear();
+}
+
+void CameraFrameProvider::dispatchCameraFrame(CameraFrame* frame)
+{
+    FSL_ASSERT(frame);
+    CameraFrameListener* listener;
+    size_t nSize = mFrameListeners.size();
+
+    //add reference here to avoid frame release too early.
+    frame->addReference();
+    for(size_t i=0; i<nSize; i++) {
+        listener = (CameraFrameListener*)mFrameListeners[i];
+        listener->handleCameraFrame(frame);
+    }
+    frame->release();
+}
+
+//----------------CameraEventProvider----------
+void CameraEventProvider::addEventListener(CameraEventListener* listener)
+{
+    CameraEventListener* pNtf;
+    size_t nSize = mEventListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraEventListener*)mEventListeners[i];
+        if(pNtf == listener) {
+            return;
+        }
+    }
+
+    mEventListeners.push((int)listener);
+}
+
+void CameraEventProvider::removeEventListener(CameraEventListener* listener)
+{
+    CameraEventListener* pNtf;
+    size_t nSize = mEventListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        pNtf = (CameraEventListener*)mEventListeners[i];
+        if(pNtf == listener) {
+            mEventListeners.removeAt(i);
+            //break;
+        }
+    }
+}
+
+void CameraEventProvider::clearEventListeners()
+{
+    mEventListeners.clear();
+}
+
+void CameraEventProvider::dispatchEvent(sp<CameraEvent>& event)
+{
+    FSL_ASSERT(event != NULL);
+    CameraEventListener* listener;
+    size_t nSize = mEventListeners.size();
+
+    for(size_t i=0; i<nSize; i++) {
+        listener = (CameraEventListener*)mEventListeners[i];
+        listener->handleEvent(event);
+    }
+}
diff --git a/mx6/libcamera/CameraUtil.h b/mx6/libcamera/CameraUtil.h
new file mode 100755
index 0000000..aacc91b
--- /dev/null
+++ b/mx6/libcamera/CameraUtil.h
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _CAMERA_UTILS_H
+#define _CAMERA_UTILS_H
+
+#undef LOG_TAG
+#define LOG_TAG "FslCameraHAL"
+#include <utils/Log.h>
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <utils/RefBase.h>
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/CameraParameters.h>
+#include <utils/Vector.h>
+#include <utils/KeyedVector.h>
+#include <cutils/properties.h>
+#include <hardware_legacy/power.h>
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+#include <ui/PixelFormat.h>
+#include "gralloc_priv.h"
+#include <linux/videodev2.h>
+#include <hardware/camera.h>
+
+using namespace android;
+
+#define CAMERA_HAL_DEBUG
+#ifdef CAMERA_HAL_DEBUG
+#define FLOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
+#define FLOG_TRACE(format, ...) ALOGI((format), ## __VA_ARGS__)
+#else
+#define FLOG_RUNTIME(format, ...)
+#define FLOG_TRACE(format, ...)
+#endif
+
+#define FLOGI(format, ...) ALOGI((format), ## __VA_ARGS__)
+#define FLOGW(format, ...) ALOGW((format), ## __VA_ARGS__)
+#define FLOGE(format, ...) ALOGE((format), ##__VA_ARGS__)
+
+#define FSL_ASSERT(cond, ...) ALOG_ASSERT((cond), ##__VA_ARGS__)
+
+#define UVC_NAME_STRING "uvc"
+#define V4LSTREAM_WAKE_LOCK "V4LCapture"
+
+#define MAX_PREVIEW_BUFFER      6
+#define MAX_CAPTURE_BUFFER      3
+#define DISPLAY_WAIT_TIMEOUT    5000
+#define CAMAERA_FILENAME_LENGTH 256
+#define CAMERA_SENSOR_LENGTH    32
+#define CAMERA_FORMAT_LENGTH    32
+#define CAMER_PARAM_BUFFER_SIZE 512
+#define PARAMS_DELIMITER ","
+
+#define CAMERA_GRALLOC_USAGE GRALLOC_USAGE_HW_TEXTURE | \
+                             GRALLOC_USAGE_HW_RENDER | \
+                             GRALLOC_USAGE_SW_READ_RARELY | \
+                             GRALLOC_USAGE_SW_WRITE_NEVER
+
+#define CAMERA_MAX(x, y) (x) > (y) ? (x) : (y)
+
+int convertPixelFormatToV4L2Format(PixelFormat format);
+PixelFormat convertV4L2FormatToPixelFormat(unsigned int format);
+int convertStringToPixelFormat(const char* pFormat);
+int convertStringToV4L2Format(const char* pFormat);
+
+struct VideoMetadataBuffer
+{
+    size_t phyOffset;
+    size_t length;
+};
+
+struct CameraInfo : public camera_info
+{
+    char name[CAMERA_SENSOR_LENGTH];
+    char devPath[CAMAERA_FILENAME_LENGTH];
+};
+
+struct VideoInfo
+{
+    struct v4l2_capability cap;
+    struct v4l2_format format;
+    struct v4l2_streamparm param;
+    struct v4l2_buffer buf;
+    struct v4l2_requestbuffers rb;
+    bool isStreamOn;
+    int width;
+    int height;
+    int formatIn;
+    int framesizeIn;
+};
+
+class CameraFrame;
+
+class CameraFrameObserver
+{
+public:
+    CameraFrameObserver() {}
+    virtual ~CameraFrameObserver() {}
+
+    virtual void handleFrameRelease(CameraFrame* buffer) = 0;
+
+private:
+    CameraFrameObserver(const CameraFrameObserver&);
+    CameraFrameObserver& operator=(const CameraFrameObserver&);
+};
+
+
+class CameraFrame
+{
+public:
+    enum CAMERA_BUFS_STATE {
+        BUFS_CREATE = 0,
+        BUFS_IN_CAPTURE = 1,
+        BUFS_IN_RECORDER = 2,
+        BUFS_IN_PREIVIEW = 4,
+        BUFS_IN_DRIVER = 8
+    };
+    enum FrameType {
+        INVALID_FRAME = 0,
+        IMAGE_FRAME = 1,
+        PREVIEW_FRAME = 2,
+    };
+
+    CameraFrame() {}
+    ~CameraFrame();
+
+    void initialize(buffer_handle_t* buf_h, int index);
+    void addState(CAMERA_BUFS_STATE state);
+    void removeState(CAMERA_BUFS_STATE state);
+    void release();
+    void addReference();
+    void setObserver(CameraFrameObserver *observer);
+    void reset();
+
+private:
+    CameraFrame(const CameraFrame&);
+    CameraFrame& operator=(const CameraFrame&);
+
+public:
+    buffer_handle_t* mBufHandle;
+    void*            mVirtAddr;
+    int              mPhyAddr;
+    size_t           mSize;
+    int              mWidth;
+    int              mHeight;
+    int              mFormat;
+    FrameType        mFrameType;
+    int              mIndex;
+
+private:
+    CameraFrameObserver* mObserver;
+    int                  mRefCount;
+    int                  mBufState;
+};
+
+enum CAMERA_ERROR {
+    ERROR_FATAL = 1,
+    ERROR_TINY = 2,
+};
+
+class CameraErrorListener
+{
+public:
+    virtual void handleError(CAMERA_ERROR err) = 0;
+    virtual ~CameraErrorListener() {}
+};
+
+class CameraBufferListener
+{
+public:
+    virtual void onBufferCreat(CameraFrame* pBuffer, int num) = 0;
+    virtual void onBufferDestroy() = 0;
+    virtual ~CameraBufferListener() {}
+};
+
+class CameraBufferProvider
+{
+public:
+    enum BufferState {
+        BUFFER_CREATE = 1,
+        BUFFER_DESTROY = 2,
+    };
+    CameraBufferProvider();
+    virtual ~CameraBufferProvider();
+
+    virtual int allocatePreviewBuffer(int width, int height, int format, int numBufs) = 0;
+    virtual int allocatePictureBuffer(int width, int height, int format, int numBufs) = 0;
+    virtual int freeBuffer() = 0;
+    virtual int maxQueueableBuffers() = 0;
+
+    void addBufferListener(CameraBufferListener* listener);
+    void removeBufferListener(CameraBufferListener* listener);
+    void clearBufferListeners();
+
+    void dispatchBuffers(CameraFrame* pBuffer, int num, BufferState bufState);
+
+private:
+    Vector<int> mBufferListeners;
+};
+
+class CameraFrameListener
+{
+public:
+    virtual void handleCameraFrame(CameraFrame* frame) = 0;
+    virtual ~CameraFrameListener() {}
+};
+
+class CameraFrameProvider
+{
+public:
+    CameraFrameProvider();
+    virtual ~CameraFrameProvider();
+
+    virtual int getFrameSize() = 0;
+    virtual int getFrameCount() = 0;
+    void addFrameListener(CameraFrameListener* listener);
+    void removeFrameListener(CameraFrameListener* listener);
+    void clearFrameListeners();
+
+    void dispatchCameraFrame(CameraFrame* frame);
+
+private:
+    Vector<int> mFrameListeners;
+};
+
+class CameraEvent : public LightRefBase<CameraEvent>
+{
+public:
+    enum CameraEventType {
+        EVENT_INVALID = 0x0,
+        EVENT_SHUTTER = 0x1,
+        EVENT_FOCUS = 0x2,
+        EVENT_ZOOM = 0x4,
+        EVENT_FACE = 0x8
+    };
+
+    CameraEvent()
+        : mData(NULL), mEventType(EVENT_INVALID)
+    {}
+
+    void* mData;
+    CameraEventType mEventType;
+};
+
+class CameraEventListener
+{
+public:
+    virtual void handleEvent(sp<CameraEvent>& event) = 0;
+    virtual ~CameraEventListener() {}
+};
+
+class CameraEventProvider
+{
+public:
+    CameraEventProvider() {mEventListeners.clear();};
+
+    void addEventListener(CameraEventListener* listerner);
+    void removeEventListener(CameraEventListener* listerner);
+    void clearEventListeners();
+    void dispatchEvent(sp<CameraEvent>& event);
+
+    virtual ~CameraEventProvider() {mEventListeners.clear();};
+
+private:
+    Vector<int> mEventListeners;
+};
+
+#endif
diff --git a/mx6/libcamera/Camera_utils.h b/mx6/libcamera/Camera_utils.h
deleted file mode 100755
index c1d1c45..0000000
--- a/mx6/libcamera/Camera_utils.h
+++ /dev/null
@@ -1,78 +0,0 @@
-
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAMERA_UTILS_H
-#define CAMERA_UTILS_H
-
-#undef LOG_TAG
-#define LOG_TAG "FslCameraHAL"
-#include <utils/Log.h>
-#include <utils/threads.h>
-
-//#define CAMERA_HAL_DEBUG_LOG
-#ifdef CAMERA_HAL_DEBUG_LOG
-#define CAMERA_LOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define CAMERA_LOG_FUNC ALOGI("%s is excuting...",  __FUNCTION__)
-#define CAMERA_LOG_TRACE   ALOGI("%s : %d", __FUNCTION__,__LINE__)
-#else
-#define CAMERA_LOG_RUNTIME(format, ...)
-#define CAMERA_LOG_FUNC
-#define CAMERA_LOG_TRACE
-#endif
-
-#define CAMERA_LOG_INFO(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define CAMERA_LOG_WARN(format, ...) ALOGW((format), ## __VA_ARGS__)
-#define CAMERA_LOG_ERR(format, ...) ALOGE((format), ##__VA_ARGS__)
-
-namespace android {
-
-    typedef enum{
-        DMA_ALLOCATE_ERR_NONE = 0,
-        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
-
-    }DMA_ALLOCATE_ERR_RET;
-
-    typedef enum{
-        WINDOW_BUFS_INVALID = 0,
-        WINDOW_BUFS_DEQUEUED = 1,
-        WINDOW_BUFS_QUEUED = 2,
-    }WINDOW_BUFS_STATE;
-
-    typedef struct {
-        unsigned char *virt_start;
-        size_t phy_offset;
-        unsigned int length;
-        void *native_buf;
-        Mutex mBufferLock;
-        unsigned int refCount;
-        WINDOW_BUFS_STATE buf_state;
-    }DMA_BUFFER;
-
-	// If struct change. Need info Camera Source.
-    typedef struct {
-        size_t phy_offset;
-        unsigned int length;
-    }VIDEOFRAME_BUFFER_PHY;
-
-}; //name space android
-
-#endif
-
diff --git a/mx6/libcamera/CaptureDeviceInterface.cpp b/mx6/libcamera/CaptureDeviceInterface.cpp
deleted file mode 100755
index 6f8c90a..0000000
--- a/mx6/libcamera/CaptureDeviceInterface.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "V4l2UVCDevice.h"
-#include "V4l2CsiDevice.h"
-namespace android{
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath)
-    {
-        if(strstr(deviceName, UVC_NAME_STRING)){
-            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
-            device->SetDevName(deviceName, devPath);
-            return device;
-        }else{
-            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
-            device->SetDevName(deviceName, devPath);
-            return device;
-        }
-    }
-
-
-}
diff --git a/mx6/libcamera/CaptureDeviceInterface.h b/mx6/libcamera/CaptureDeviceInterface.h
deleted file mode 100755
index dddb38f..0000000
--- a/mx6/libcamera/CaptureDeviceInterface.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef CAPTURE_DEVICE_INTERFACE_H
-#define CAPTURE_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-
-
-#define CAMAERA_FILENAME_LENGTH     256
-#define MAX_CAPTURE_BUF_QUE_NUM     6
-#define CAMERA_SENSOR_LENGTH       32
-#define MAX_DEQUEUE_WAIT_TIME  (5000)  //5000ms for uvc camera
-
-namespace android {
-#define UVC_NAME_STRING "uvc"
-
-    typedef enum{
-        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
-        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
-        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
-        CAPTURE_DEVICE_ERR_NONE = 0,
-        CAPTURE_DEVICE_ERR_OPEN = -1,
-        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
-        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
-        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
-        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
-        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
-        CAPTURE_DEVICE_ERR_OPT_TIMEOUT=-7,
-        CAPTURE_DEVICE_ERR_UNKNOWN = -100
-    }CAPTURE_DEVICE_RET;
-
-    typedef enum{
-        MOTION_MODE = 0,
-        HIGH_QUALITY_MODE = 1
-    }CAPTURE_MODE;
-
-    typedef enum{
-        CAMERA_TYPE_CSI = 0,
-        CAMERA_TYPE_UVC = 1,
-    }CAMERA_TYPE;
-
-    typedef enum{
-        OUTPU_FMT = 0,
-        FRAME_SIZE_FPS = 1
-    }DevParamType;
-
-	typedef enum{
-        SENSOR_PREVIEW_BACK_REF = 0,
-        SENSOR_PREVIEW_VERT_FLIP = 1,
-        SENSOR_PREVIEW_HORIZ_FLIP = 2,
-        SENSOR_PREVIEW_ROATE_180 = 3,
-        SENSOR_PREVIEW_ROATE_LAST = 3,
-        SENSOR_PREVIEW_ROATE_INVALID =4
-	}SENSOR_PREVIEW_ROTATE;
-
-    struct timeval_fract{
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct capture_config_t{
-        unsigned int fmt;
-        unsigned int width;
-        unsigned int height;
-        unsigned int framesize;   //out
-        unsigned int picture_waite_number;//out
-        struct timeval_fract tv;
-	SENSOR_PREVIEW_ROTATE rotate;
-    };
-
-
-    class CaptureDeviceInterface : public virtual RefBase{
-    public:
-
-        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char * devPath = NULL)=0;
-        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId)=0;
-        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
-        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
-        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_RET DevPrepare()=0;
-        virtual CAPTURE_DEVICE_RET DevStart()=0;
-        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx)=0;
-        virtual CAPTURE_DEVICE_RET DevQueue(unsigned int BufQueIdx)=0;
-        virtual CAPTURE_DEVICE_RET DevStop()=0;
-        virtual CAPTURE_DEVICE_RET DevDeAllocate()=0;
-        virtual CAPTURE_DEVICE_RET DevClose()=0;
-        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType)=0;
-
-        virtual ~ CaptureDeviceInterface(){}
-    };
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath);
-
-};
-#endif
-
diff --git a/mx6/libcamera/DeviceAdapter.cpp b/mx6/libcamera/DeviceAdapter.cpp
new file mode 100755
index 0000000..3ebe9c0
--- /dev/null
+++ b/mx6/libcamera/DeviceAdapter.cpp
@@ -0,0 +1,563 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "DeviceAdapter.h"
+#include "UvcDevice.h"
+#include "OvDevice.h"
+
+sp<DeviceAdapter> DeviceAdapter::Create(const CameraInfo& info)
+{
+    sp<DeviceAdapter> devAdapter;
+    if(strstr(info.name, UVC_NAME_STRING)) {
+        FLOGI("DeviceAdapter: Create uvc device");
+        devAdapter = new UvcDevice();
+    }
+    else {
+        FLOGI("DeviceAdapter: Create ov device");
+        devAdapter = new OvDevice();
+    }
+    return devAdapter;
+}
+
+DeviceAdapter::DeviceAdapter()
+    : mCameraHandle(-1), mQueued(0), mDequeued(0)
+{
+}
+
+DeviceAdapter::~DeviceAdapter()
+{
+    // Close the camera handle and free the video info structure
+    close(mCameraHandle);
+
+    if(mVideoInfo) {
+        delete mVideoInfo;
+        mVideoInfo = NULL;
+    }
+}
+
+status_t DeviceAdapter::initialize(const CameraInfo& info)
+{
+    if(info.name == NULL) {
+        FLOGE("invalid camera sensor name in initialize");
+        return BAD_VALUE;
+    }
+    if(info.devPath == NULL) {
+        FLOGE("invalid camera devpath in initialize");
+        return BAD_VALUE;
+    }
+
+    mCameraHandle = open(info.devPath, O_RDWR);
+    if(mCameraHandle < 0) {
+        FLOGE("can not open camera devpath:%s", info.devPath);
+        return BAD_VALUE;
+    }
+    mVideoInfo = new VideoInfo();
+    if(mVideoInfo == NULL) {
+        close(mCameraHandle);
+        FLOGE("new VideoInfo failed");
+        return NO_MEMORY;
+    }
+
+    int ret = NO_ERROR;
+    ret = ioctl(mCameraHandle, VIDIOC_QUERYCAP, &mVideoInfo->cap);
+    if(ret < 0) {
+        close(mCameraHandle);
+        delete mVideoInfo;
+        FLOGE("query v4l2 capability failed");
+        return BAD_VALUE;
+    }
+    if((mVideoInfo->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0)
+    {
+        close(mCameraHandle);
+        delete mVideoInfo;
+        FLOGE("v4l2 capability does not support capture");
+        return BAD_VALUE;
+    }
+
+    // Initialize flags
+    mPreviewing = false;
+    mVideoInfo->isStreamOn = false;
+    mImageCapture = false;
+
+    return NO_ERROR;
+}
+
+static int getCaptureMode(int width, int height)
+{
+    int capturemode = 0;
+
+    if(width == 640 && height == 480) {
+        capturemode = 0;
+    }
+    else if(width == 320 && height == 240) {
+        capturemode = 1;
+    }
+    else if(width == 720 && height == 480) {
+        capturemode = 2;
+    }
+    else if(width == 720 && height == 576) {
+        capturemode = 3;
+    }
+    else if(width == 1280 && height == 720) {
+        capturemode = 4;
+    }
+    else if(width == 1920 && height == 1080) {
+        capturemode = 5;
+    }
+    else if(width == 2592 && height == 1944) {
+        capturemode = 6;
+    }
+    else if(width == 176 && height == 144) {
+        capturemode = 7;
+    }
+    else if(width == 1024 && height == 768) {
+        capturemode = 8;
+    }
+    else {
+        FLOGE("width:%d height:%d is not supported.", width, height);
+    }
+    return capturemode;
+}
+
+status_t DeviceAdapter::setDeviceConfig(int width, int height, PixelFormat format, int fps)
+{
+    if(mCameraHandle <= 0) {
+        FLOGE("setDeviceConfig: DeviceAdapter uninitialized");
+        return BAD_VALUE;
+    }
+    if(width == 0 || height == 0) {
+        FLOGE("setDeviceConfig: invalid parameters");
+        return BAD_VALUE;
+    }
+
+    status_t ret = NO_ERROR;
+    int input = 1;
+    ret = ioctl(mCameraHandle, VIDIOC_S_INPUT, &input);
+    if (ret < 0) {
+        FLOGE("Open: VIDIOC_S_INPUT Failed: %s", strerror(errno));
+        return ret;
+    }
+
+    int vformat;
+    vformat = convertPixelFormatToV4L2Format(format);
+
+    if(width > 1920 || height > 1080) {
+        fps = 15;
+    }
+    FLOGI("Width * Height %d x %d format %d, fps: %d", width, height, vformat, fps);
+
+    mVideoInfo->width = width;
+    mVideoInfo->height = height;
+    mVideoInfo->framesizeIn = (width * height << 1);
+    mVideoInfo->formatIn = vformat;
+
+    mVideoInfo->param.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    mVideoInfo->param.parm.capture.timeperframe.numerator = 1;
+    mVideoInfo->param.parm.capture.timeperframe.denominator = fps;
+    mVideoInfo->param.parm.capture.capturemode = getCaptureMode(width, height);
+    ret = ioctl(mCameraHandle, VIDIOC_S_PARM, &mVideoInfo->param);
+    if (ret < 0) {
+        FLOGE("Open: VIDIOC_S_PARM Failed: %s", strerror(errno));
+        return ret;
+    }
+
+    mVideoInfo->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    mVideoInfo->format.fmt.pix.width = width & 0xFFFFFFF8;
+    mVideoInfo->format.fmt.pix.height = height & 0xFFFFFFF8;
+    mVideoInfo->format.fmt.pix.pixelformat = vformat;
+    mVideoInfo->format.fmt.pix.priv = 0;
+    mVideoInfo->format.fmt.pix.sizeimage = 0;
+    mVideoInfo->format.fmt.pix.bytesperline = 0;
+
+    ret = ioctl(mCameraHandle, VIDIOC_S_FMT, &mVideoInfo->format);
+    if (ret < 0) {
+        FLOGE("Open: VIDIOC_S_FMT Failed: %s", strerror(errno));
+        return ret;
+    }
+
+    return ret;
+}
+
+int DeviceAdapter::getFrameSize()
+{
+    return mPreviewBufferSize;
+}
+
+int DeviceAdapter::getFrameCount()
+{
+    return mPreviewBufferCount;
+}
+
+status_t DeviceAdapter::registerCameraFrames(CameraFrame* pBuffer, int& num)
+{
+    status_t ret = NO_ERROR;
+
+    if(pBuffer == NULL || num <= 0) {
+        FLOGE("requestCameraBuffers invalid pBuffer");
+        return BAD_VALUE;
+    }
+
+    mVideoInfo->rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    mVideoInfo->rb.memory = V4L2_MEMORY_USERPTR;
+    mVideoInfo->rb.count = num;
+
+    ret = ioctl(mCameraHandle, VIDIOC_REQBUFS, &mVideoInfo->rb);
+    if (ret < 0) {
+        FLOGE("VIDIOC_REQBUFS failed: %s", strerror(errno));
+        return ret;
+    }
+
+    for (int i = 0; i < num; i++) {
+        CameraFrame* buffer = pBuffer + i;
+        memset (&mVideoInfo->buf, 0, sizeof (struct v4l2_buffer));
+        mVideoInfo->buf.index = i;
+        mVideoInfo->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        mVideoInfo->buf.memory = V4L2_MEMORY_USERPTR;
+        mVideoInfo->buf.m.offset = buffer->mPhyAddr;
+        mVideoInfo->buf.length = buffer->mSize;
+
+        ret = ioctl (mCameraHandle, VIDIOC_QUERYBUF, &mVideoInfo->buf);
+        if (ret < 0) {
+            FLOGE("Unable to query buffer (%s)", strerror(errno));
+            return ret;
+        }
+        //Associate each Camera buffer
+        buffer->setObserver(this);
+        mPreviewBufs.add((int)buffer, i);
+    }
+
+    mPreviewBufferSize = pBuffer->mSize;
+    mPreviewBufferCount = num;
+
+    return ret;
+}
+
+status_t DeviceAdapter::fillCameraFrame(CameraFrame* frame)
+{
+
+    status_t ret = NO_ERROR;
+
+    if ( !mVideoInfo->isStreamOn ) {
+        return NO_ERROR;
+    }
+
+    int i = mPreviewBufs.valueFor(( unsigned int )frame);
+    if(i<0) {
+        return BAD_VALUE;
+    }
+
+    mVideoInfo->buf.index = i;
+    mVideoInfo->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    mVideoInfo->buf.memory = V4L2_MEMORY_USERPTR;
+    mVideoInfo->buf.m.offset = frame->mPhyAddr;
+
+    ret = ioctl(mCameraHandle, VIDIOC_QBUF, &mVideoInfo->buf);
+    if (ret < 0) {
+       FLOGE("fillCameraFrame: VIDIOC_QBUF Failed");
+       return BAD_VALUE;
+    }
+    mQueued++;
+
+    return ret;
+}
+
+status_t DeviceAdapter::startDeviceLocked()
+{
+    status_t ret = NO_ERROR;
+    FSL_ASSERT(!mPreviewBufs.isEmpty());
+    FSL_ASSERT(mBufferProvider != NULL);
+
+    int queueableBufs = mBufferProvider->maxQueueableBuffers();
+    FSL_ASSERT(queueableBufs > 0);
+
+    for(int i = 0; i < queueableBufs; i++) {
+        CameraFrame* frame = (CameraFrame*)mPreviewBufs.keyAt(i);
+        mVideoInfo->buf.index = i;
+        mVideoInfo->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        mVideoInfo->buf.memory = V4L2_MEMORY_USERPTR;
+        mVideoInfo->buf.m.offset = frame->mPhyAddr;
+
+        ret = ioctl(mCameraHandle, VIDIOC_QBUF, &mVideoInfo->buf);
+        if (ret < 0) {
+           FLOGE("VIDIOC_QBUF Failed");
+           return BAD_VALUE;
+        }
+
+        mQueued++;
+    }
+
+    enum v4l2_buf_type bufType;
+    if(!mVideoInfo->isStreamOn) {
+       bufType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+       ret = ioctl(mCameraHandle, VIDIOC_STREAMON, &bufType);
+       if (ret < 0) {
+           FLOGE("VIDIOC_STREAMON failed: %s", strerror(errno));
+           return ret;
+       }
+
+       mVideoInfo->isStreamOn = true;
+    }
+
+    mDeviceThread = new DeviceThread(this);
+
+    FLOGI("Created device thread");
+    return ret;
+}
+
+status_t DeviceAdapter::stopDeviceLocked()
+{
+    status_t ret = NO_ERROR;
+    enum v4l2_buf_type bufType;
+
+    mDeviceThread->requestExitAndWait();
+    mDeviceThread.clear();
+
+    if(mVideoInfo->isStreamOn) {
+        bufType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+        ret = ioctl(mCameraHandle, VIDIOC_STREAMOFF, &bufType);
+        if (ret < 0) {
+            FLOGE("StopStreaming: Unable to stop capture: %s", strerror(errno));
+            return ret;
+        }
+
+        mVideoInfo->isStreamOn = false;
+    }
+
+    mQueued = 0;
+    mDequeued = 0;
+    mPreviewBufs.clear();
+
+    return ret;
+}
+
+status_t DeviceAdapter::startPreview()
+{
+    status_t ret = NO_ERROR;
+
+    if(mPreviewing) {
+        FLOGE("DeviceAdapter: startPreview but preview running");
+        return BAD_VALUE;
+    }
+
+    Mutex::Autolock lock(mPreviewBufsLock);
+    ret = startDeviceLocked();
+
+    mPreviewing = true;
+
+    return ret;
+}
+
+status_t DeviceAdapter::stopPreview()
+{
+    int ret = NO_ERROR;
+
+    if(!mPreviewing) {
+        FLOGE("DeviceAdapter: stopPreview but preview not running");
+        return NO_INIT;
+    }
+
+    Mutex::Autolock lock(mPreviewBufsLock);
+    mPreviewing = false;
+    ret = stopDeviceLocked();
+
+    return ret;
+}
+
+status_t DeviceAdapter::startImageCapture()
+{
+    status_t ret = NO_ERROR;
+
+    if(mImageCapture) {
+        FLOGE("DeviceAdapter: startPreview but preview running");
+        return BAD_VALUE;
+    }
+
+    Mutex::Autolock lock(mPreviewBufsLock);
+    mImageCapture = true;
+    ret = startDeviceLocked();
+
+    return ret;
+}
+
+status_t DeviceAdapter::stopImageCapture()
+{
+    int ret = NO_ERROR;
+
+    if(!mImageCapture) {
+        FLOGE("DeviceAdapter: stopPreview but preview not running");
+        return NO_INIT;
+    }
+
+    Mutex::Autolock lock(mPreviewBufsLock);
+    mImageCapture = false;
+    ret = stopDeviceLocked();
+
+    return ret;
+}
+
+CameraFrame* DeviceAdapter::acquireCameraFrame()
+{
+    int ret;
+
+    mVideoInfo->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    mVideoInfo->buf.memory = V4L2_MEMORY_USERPTR;
+
+    /* DQ */
+    ret = ioctl(mCameraHandle, VIDIOC_DQBUF, &mVideoInfo->buf);
+    if (ret < 0) {
+        FLOGE("GetFrame: VIDIOC_DQBUF Failed");
+        return NULL;
+    }
+    mDequeued++;
+
+    int index = mVideoInfo->buf.index;
+    FSL_ASSERT(!mPreviewBufs.isEmpty(), "mPreviewBufs is empty");
+    return (CameraFrame*)mPreviewBufs.keyAt(index);
+}
+
+//#define FSL_CAMERAHAL_DUMP
+static void bufferDump(CameraFrame* frame)
+{
+#ifdef FSL_CAMERAHAL_DUMP
+   //for test code
+    char value[100];
+    memset(value, 0, sizeof(value));
+    static int vflg = 0;
+    property_get("rw.camera.test", value, "");
+    if(strcmp(value, "1") == 0)
+	vflg = 1;
+    if(vflg){
+	FILE *pf = NULL;
+	pf = fopen("/sdcard/camera_tst.data", "wb");
+	if(pf == NULL) {
+	    FLOGI("open /sdcard/camera_tst.data failed");
+	}
+	else {
+            FLOGI("-----write-----");
+	    fwrite(frame->mVirtAddr, frame->mSize, 1, pf);
+	    fclose(pf);
+	}
+	vflg = 0;
+    }
+#endif
+}
+
+
+int DeviceAdapter::deviceThread()
+{
+    CameraFrame* frame = NULL;
+
+        frame = acquireCameraFrame();
+        if(!frame) {
+            if(mQueued - mDequeued <= 0) {
+                //if stop preview, then exit.
+                if(!mPreviewing) {
+                    FLOGI("preview stop, so exit device thread");
+                    return BAD_VALUE;
+                }
+                else {
+                    //to check buffer in another cycle.
+                    FLOGI("no buffer in v4l driver, check it next time");
+                    return NO_ERROR;
+                }
+            }
+            FLOGE("device thread exit with frame = null, %d buffers still in v4l", mQueued - mDequeued);
+            if(mErrorListener != NULL) {
+                mErrorListener->handleError(ERROR_FATAL);
+            }
+            return BAD_VALUE;
+        }
+
+    if(mImageCapture) {
+        sp<CameraEvent> cameraEvt = new CameraEvent();
+        cameraEvt->mEventType = CameraEvent::EVENT_SHUTTER;
+        dispatchEvent(cameraEvt);
+
+        frame->mFrameType = CameraFrame::IMAGE_FRAME;
+    }
+    else {
+        frame->mFrameType = CameraFrame::PREVIEW_FRAME;
+    }
+
+    dispatchCameraFrame(frame);
+    if(mImageCapture) {
+        FLOGI("device thread exit after take picture");
+        return ALREADY_EXISTS;
+    }
+
+    return NO_ERROR;
+}
+
+status_t DeviceAdapter::autoFocus()
+{
+    if(mAutoFocusThread != NULL) {
+        mAutoFocusThread.clear();
+    }
+
+    mAutoFocusThread = new AutoFocusThread(this);
+    if(mAutoFocusThread == NULL) {
+        return UNKNOWN_ERROR;
+    }
+    return NO_ERROR;
+}
+
+status_t DeviceAdapter::cancelAutoFocus()
+{
+    return NO_ERROR;
+}
+
+int DeviceAdapter::autoFocusThread()
+{
+    sp<CameraEvent> cameraEvt = new CameraEvent();
+    cameraEvt->mEventType = CameraEvent::EVENT_FOCUS;
+    dispatchEvent(cameraEvt);
+
+    //exit the thread.
+    return UNKNOWN_ERROR;
+}
+
+void DeviceAdapter::handleFrameRelease(CameraFrame* buffer)
+{
+    if(mPreviewing) {
+        fillCameraFrame(buffer);
+    }
+}
+
+void DeviceAdapter::setErrorListener(CameraErrorListener* listener)
+{
+    mErrorListener = listener;
+}
+
+void DeviceAdapter::setCameraBufferProvide(CameraBufferProvider* bufferProvider)
+{
+    if(bufferProvider != NULL) {
+        bufferProvider->addBufferListener(this);
+    }
+    mBufferProvider = bufferProvider;
+}
+
+void DeviceAdapter::onBufferCreat(CameraFrame* pBuffer, int num)
+{
+    registerCameraFrames(pBuffer, num);
+}
+
+void DeviceAdapter::onBufferDestroy()
+{
+    mPreviewBufs.clear();
+}
diff --git a/mx6/libcamera/DeviceAdapter.h b/mx6/libcamera/DeviceAdapter.h
new file mode 100755
index 0000000..ed3de67
--- /dev/null
+++ b/mx6/libcamera/DeviceAdapter.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _DEVICE_ADAPTER_H_
+#define _DEVICE_ADAPTER_H_
+
+#include "CameraUtil.h"
+
+using namespace android;
+
+class DeviceAdapter : public CameraFrameProvider, public CameraBufferListener,
+        public CameraEventProvider,
+        public CameraFrameObserver, public LightRefBase<DeviceAdapter>
+{
+public:
+    static sp<DeviceAdapter> Create(const CameraInfo& info);
+    DeviceAdapter();
+    ~DeviceAdapter();
+
+public:
+    virtual int getFrameSize();
+    virtual int getFrameCount();
+
+    void setErrorListener(CameraErrorListener* listener);
+    void setCameraBufferProvide(CameraBufferProvider* bufferProvider);
+    virtual status_t initialize(const CameraInfo& info);
+    status_t setDeviceConfig(int width, int height, PixelFormat format, int fps);
+    PixelFormat getPreviewPixelFormat() {return mPicturePixelFormat;}
+    PixelFormat getPicturePixelFormat() {return mPreviewPixelFormat;}
+
+    virtual status_t setParameters(CameraParameters& params) = 0;
+    virtual status_t initParameters(CameraParameters& params, int* supportRecordingFormat, int rfmtLen,
+                        int* supportPictureFormat, int pfmtLen) = 0;
+
+    //API to send a command to the camera
+    //virtual status_t sendCommand(CameraCommands operation, int value1 = 0, int value2 = 0, int value3 = 0 );
+    status_t autoFocus();
+    status_t cancelAutoFocus();
+
+    virtual status_t startPreview();
+    virtual status_t stopPreview();
+
+    virtual status_t startImageCapture();
+    virtual status_t stopImageCapture();
+
+protected:
+    void onBufferCreat(CameraFrame* pBuffer, int num);
+    void onBufferDestroy();
+    virtual status_t registerCameraFrames(CameraFrame* pBuffer, int& num);
+    virtual void handleFrameRelease(CameraFrame* buffer);
+
+private:
+    class AutoFocusThread : public Thread {
+    public:
+        AutoFocusThread(DeviceAdapter* hw) :
+                Thread(false), mAdapter(hw) { }
+
+        virtual void onFirstRef() {
+            run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
+        }
+
+        virtual bool threadLoop() {
+            int ret = 0;
+            ret = mAdapter->autoFocusThread();
+            if(ret != 0) {
+                return false;
+            }
+            // loop until we need to quit
+            return true;
+        }
+
+    private:
+        DeviceAdapter* mAdapter;
+    };
+
+    class DeviceThread : public Thread {
+    public:
+        DeviceThread(DeviceAdapter* hw) :
+                Thread(false), mAdapter(hw) { }
+
+        virtual void onFirstRef() {
+            run("DeviceThread", PRIORITY_URGENT_DISPLAY);
+        }
+
+        virtual bool threadLoop() {
+            int ret = 0;
+            ret = mAdapter->deviceThread();
+            if(ret != 0) {
+                return false;
+            }
+            // loop until we need to quit
+            return true;
+        }
+
+    private:
+        DeviceAdapter* mAdapter;
+    };
+
+private:
+    status_t fillCameraFrame(CameraFrame* frame);
+    CameraFrame* acquireCameraFrame();
+
+    status_t startDeviceLocked();
+    status_t stopDeviceLocked();
+    int deviceThread();
+    int autoFocusThread();
+
+protected:
+    CameraBufferProvider* mBufferProvider;
+    CameraErrorListener* mErrorListener;
+    int mPreviewBufferCount;
+    int mPreviewBufferSize;
+    KeyedVector<int, int> mPreviewBufs;
+    mutable Mutex mPreviewBufsLock;
+
+    mutable Mutex mLock;
+    CameraParameters mParams;
+    bool mPreviewing;
+    bool mImageCapture;
+    sp<DeviceThread> mDeviceThread;
+    sp<AutoFocusThread> mAutoFocusThread;
+
+    struct VideoInfo *mVideoInfo;
+    int mCameraHandle;
+    int mQueued;
+    int mDequeued;
+
+    PixelFormat mPicturePixelFormat;
+    PixelFormat mPreviewPixelFormat;
+};
+
+#endif
diff --git a/mx6/libcamera/DisplayAdapter.cpp b/mx6/libcamera/DisplayAdapter.cpp
new file mode 100755
index 0000000..bd93c9b
--- /dev/null
+++ b/mx6/libcamera/DisplayAdapter.cpp
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "DisplayAdapter.h"
+
+DisplayAdapter::DisplayAdapter()
+    : mDisplayThread(NULL),
+      mDisplayState(DisplayAdapter::DISPLAY_INVALID),
+      mDisplayEnabled(false)
+{
+    mFrameProvider = NULL;
+
+    mPreviewWidth = 0;
+    mPreviewHeight = 0;
+}
+
+DisplayAdapter::~DisplayAdapter()
+{
+    if(mFrameProvider) {
+        mFrameProvider->removeFrameListener(this);
+        mFrameProvider = NULL;
+    }
+
+    ///The ANativeWindow object will get destroyed here
+    destroy();
+
+    ///If Display thread exists
+    if(mDisplayThread.get()) {
+        mThreadQueue.postSyncMessage(new SyncMessage(DisplayThread::DISPLAY_EXIT, 0));
+        mDisplayThread->requestExitAndWait();
+
+        mDisplayThread.clear();
+    }
+
+}
+
+status_t DisplayAdapter::initialize()
+{
+    mDisplayThread = new DisplayThread(this);
+    if (!mDisplayThread.get()) {
+        FLOGE("Couldn't create display thread");
+        return NO_MEMORY;
+    }
+
+    ///Start the display thread
+    status_t ret = mDisplayThread->run("DisplayThread", PRIORITY_URGENT_DISPLAY);
+    if (ret != NO_ERROR) {
+        FLOGE("Couldn't run display thread");
+        return ret;
+    }
+
+    mDisplayState = DISPLAY_INIT;
+
+    return ret;
+}
+
+int DisplayAdapter::setCameraFrameProvider(CameraFrameProvider* frameProvider)
+{
+    mFrameProvider = frameProvider;
+    return NO_ERROR;
+}
+
+int DisplayAdapter::startDisplay(int width, int height)
+{
+    if(mDisplayEnabled) {
+        FLOGW("Display is already enabled");
+        return NO_ERROR;
+    }
+
+    mThreadQueue.postSyncMessage(new SyncMessage(DisplayThread::DISPLAY_START, 0));
+    //Send START_DISPLAY COMMAND to display thread. Display thread will start and then wait for a message
+
+    // Register with the frame provider for frames
+    FSL_ASSERT(mFrameProvider);
+    mFrameProvider->addFrameListener(this);
+
+    mDisplayEnabled = true;
+    mPreviewWidth = width;
+    mPreviewHeight = height;
+
+    FLOGI("mPreviewWidth = %d mPreviewHeight = %d", mPreviewWidth, mPreviewHeight);
+
+    return NO_ERROR;
+}
+
+int DisplayAdapter::stopDisplay()
+{
+    status_t ret = NO_ERROR;
+    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+
+    if(!mDisplayEnabled) {
+        FLOGW("Display is already disabled");
+        return ALREADY_EXISTS;
+    }
+
+    // Unregister with the frame provider here
+    if(mFrameProvider != NULL) {
+        mFrameProvider->removeFrameListener(this);
+    }
+
+    if(NULL != mDisplayThread.get()) {
+        //Send STOP_DISPLAY COMMAND to display thread. Display thread will stop and dequeue all messages
+        // and then wait for message
+        mThreadQueue.postSyncMessage(new SyncMessage(DisplayThread::DISPLAY_STOP, 0));
+    }
+
+    Mutex::Autolock lock(mLock);
+    {
+        ///Reset the display enabled flag
+        mDisplayEnabled = false;
+
+        ///Reset the frame width and height values
+        mFrameWidth =0;
+        mFrameHeight = 0;
+        mPreviewWidth = 0;
+        mPreviewHeight = 0;
+    }
+
+    return NO_ERROR;
+}
+
+bool DisplayAdapter::displayThread()
+{
+    bool shouldLive = true;
+
+    sp<CMessage> msg = mThreadQueue.waitMessage();
+    if(msg == 0) {
+        FLOGE("displayThread: get invalid message");
+        return false;
+    }
+
+    switch(msg->what) {
+        case DisplayThread::DISPLAY_FRAME:
+            //FLOGI("Display thread received DISPLAY_FRAME command from Camera HAL");
+            if(mDisplayState== DisplayAdapter::DISPLAY_INIT) {
+                break;
+            }
+            if(mDisplayState == DisplayAdapter::DISPLAY_STARTED)
+            {
+                shouldLive = requestFrameBuffer();
+            }
+
+            if(mDisplayState == DisplayAdapter::DISPLAY_EXITED)
+            {
+                ///we exit the thread even though there are frames still to dequeue. They will be dequeued
+                ///in stopDisplay
+                shouldLive = false;
+            }
+            break;
+
+        case DisplayThread::DISPLAY_START:
+            FLOGI("Display thread received DISPLAY_START command from Camera HAL");
+            mDisplayState = DisplayAdapter::DISPLAY_STARTED;
+
+            break;
+
+        case DisplayThread::DISPLAY_STOP:
+            FLOGI("Display thread received DISPLAY_STOP command from Camera HAL");
+            mDisplayState = DisplayAdapter::DISPLAY_STOPPED;
+
+            break;
+
+        case DisplayThread::DISPLAY_EXIT:
+            FLOGI("display thread exiting...");
+            mDisplayState = DisplayAdapter::DISPLAY_EXITED;
+            ///Note that the SF can have pending buffers when we disable the display
+            ///This is normal and the expectation is that they may not be displayed.
+            ///This is to ensure that the user experience is not impacted
+            shouldLive = false;
+            break;
+
+        default:
+            FLOGE("Invalid Display Thread Command 0x%x.", msg->what);
+            break;
+    }//end switch
+
+    return shouldLive;
+}
+
+bool DisplayAdapter::requestFrameBuffer()
+{
+    CameraFrame* frame = requestBuffer();
+    if(frame == NULL) {
+        FLOGE("requestBuffer return null buffer");
+        return false;
+    }
+
+    //the frame release from SurfaceAdapter.
+    frame->release();
+    return true;
+}
+
+void DisplayAdapter::handleCameraFrame(CameraFrame* frame)
+{
+    if(!frame || !frame->mBufHandle) {
+        FLOGI("DisplayAdapter: notifyCameraFrame receive null frame");
+        return;
+    }
+
+    //the frame held in SurfaceAdapter.
+    frame->addReference();
+    if(mDisplayState == DisplayAdapter::DISPLAY_STARTED) {
+        Mutex::Autolock lock(mLock);
+
+        renderBuffer(frame->mBufHandle);
+    }
+    else {
+        Mutex::Autolock lock(mLock);
+
+        cancelBuffer(frame->mBufHandle);
+    }
+
+    mThreadQueue.postMessage(new CMessage(DisplayThread::DISPLAY_FRAME));
+}
+
diff --git a/mx6/libcamera/DisplayAdapter.h b/mx6/libcamera/DisplayAdapter.h
new file mode 100755
index 0000000..cc24338
--- /dev/null
+++ b/mx6/libcamera/DisplayAdapter.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _DISPLAY_ADAPTER_H_
+#define _DISPLAY_ADAPTER_H_
+
+#include "CameraUtil.h"
+#include "SurfaceAdapter.h"
+#include "messageQueue.h"
+
+using namespace android;
+
+class DisplayAdapter : public SurfaceAdapter, public CameraFrameListener
+{
+public:
+    enum DisplayStates {
+        DISPLAY_INVALID = 0,
+        DISPLAY_INIT = 1,
+        DISPLAY_STARTED,
+        DISPLAY_STOPPED,
+        DISPLAY_EXITED
+    };
+
+    DisplayAdapter();
+    virtual ~DisplayAdapter();
+
+    virtual status_t initialize();
+
+    virtual int startDisplay(int width, int height);
+    virtual int stopDisplay();
+
+    int setCameraFrameProvider(CameraFrameProvider* frameProvider);
+
+protected:
+    void handleCameraFrame(CameraFrame* frame);
+    bool displayThread();
+
+private:
+    bool requestFrameBuffer();
+
+public:
+    class DisplayThread : public Thread {
+    public:
+        DisplayThread(DisplayAdapter* da)
+                 : Thread(false), mDisplayAdapter(da) { }
+
+        virtual bool threadLoop()
+        {
+            return mDisplayAdapter->displayThread();
+        }
+
+        enum DisplayThreadCommands {
+            DISPLAY_START,
+            DISPLAY_STOP,
+            DISPLAY_FRAME,
+            DISPLAY_EXIT
+        };
+
+        private:
+            DisplayAdapter* mDisplayAdapter;
+    };
+
+friend class DisplayThread;
+
+private:
+    int postBuffer(void* displayBuf);
+
+private:
+    uint32_t mPreviewWidth;
+    uint32_t mPreviewHeight;
+    CameraFrameProvider* mFrameProvider;
+
+    sp<DisplayThread> mDisplayThread;
+
+    CMessageQueue mThreadQueue;
+    unsigned int mDisplayState;
+
+    mutable Mutex mLock;
+    bool mDisplayEnabled;
+};
+
+#endif
diff --git a/mx6/libcamera/JpegBuilder.cpp b/mx6/libcamera/JpegBuilder.cpp
new file mode 100755
index 0000000..e48d8de
--- /dev/null
+++ b/mx6/libcamera/JpegBuilder.cpp
@@ -0,0 +1,649 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "CameraHAL"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <math.h>
+
+#include "JpegBuilder.h"
+
+extern "C" {
+    #include "jpeglib.h"
+    #include "jerror.h"
+}
+
+#define ARRAY_SIZE(array) (sizeof((array)) / sizeof((array)[0]))
+
+namespace android {
+
+struct string_pair {
+    const char* string1;
+    const char* string2;
+};
+
+static string_pair degress_to_exif_lut [] = {
+    // degrees, exif_orientation
+    {"0",   "1"},
+    {"90",  "6"},
+    {"180", "3"},
+    {"270", "8"},
+};
+
+/* public static functions */
+const char* JpegBuilder::degreesToExifOrientation(const char* degrees) {
+    for(unsigned int i = 0; i < ARRAY_SIZE(degress_to_exif_lut); i++) {
+        if(!strcmp(degrees, degress_to_exif_lut[i].string1)) {
+            return degress_to_exif_lut[i].string2;
+        }
+    }
+    return NULL;
+}
+
+void JpegBuilder::stringToRational(const char* str, unsigned int* num, unsigned int* den) {
+    int len;
+    char * tempVal = NULL;
+
+    if(str != NULL) {
+        len = strlen(str);
+        tempVal = (char*) malloc( sizeof(char) * (len + 1));
+    }
+
+    if(tempVal != NULL) {
+        // convert the decimal string into a rational
+        size_t den_len;
+        char *ctx;
+        unsigned int numerator = 0;
+        unsigned int denominator = 0;
+        char* temp = NULL;
+
+        memset(tempVal, '\0', len + 1);
+        strncpy(tempVal, str, len);
+        temp = strtok_r(tempVal, ".", &ctx);
+
+        if(temp != NULL)
+            numerator = atoi(temp);
+
+        if(!numerator)
+            numerator = 1;
+
+        temp = strtok_r(NULL, ".", &ctx);
+        if(temp != NULL) {
+            den_len = strlen(temp);
+            if(HUGE_VAL == den_len ) {
+                den_len = 0;
+            }
+
+            denominator = static_cast<unsigned int>(pow(10, den_len));
+            numerator = numerator * denominator + atoi(temp);
+        }
+        else {
+            denominator = 1;
+        }
+
+        free(tempVal);
+
+        *num = numerator;
+        *den = denominator;
+    }
+}
+
+bool JpegBuilder::isAsciiTag(const char* tag) {
+    // TODO(XXX): Add tags as necessary
+    return (strcmp(tag, TAG_GPS_PROCESSING_METHOD) == 0);
+}
+
+void JpegBuilder::insertExifToJpeg(unsigned char* jpeg, size_t jpeg_size) {
+    ReadMode_t read_mode = (ReadMode_t)(READ_METADATA | READ_IMAGE);
+
+    ResetJpgfile();
+    if(ReadJpegSectionsFromBuffer(jpeg, jpeg_size, read_mode)) {
+        jpeg_opened = true;
+        create_EXIF(table, exif_tag_count, gps_tag_count, has_datetime_tag);
+    }
+}
+
+status_t JpegBuilder::insertExifThumbnailImage(const char* thumb, int len) {
+    status_t ret = NO_ERROR;
+
+    if((len > 0) && jpeg_opened) {
+        ret = ReplaceThumbnailFromBuffer(thumb, len);
+        FLOGI("insertExifThumbnailImage. ReplaceThumbnail(). ret=%d", ret);
+    }
+
+    return ret;
+}
+
+void JpegBuilder::saveJpeg(unsigned char* jpeg, size_t jpeg_size) {
+    if(jpeg_opened) {
+       WriteJpegToBuffer(jpeg, jpeg_size);
+       DiscardData();
+       jpeg_opened = false;
+    }
+}
+
+status_t JpegBuilder::insertElement(const char* tag, const char* value) {
+    int value_length = 0;
+    status_t ret = NO_ERROR;
+
+    if(!value || !tag) {
+        return -EINVAL;
+    }
+
+    if(position >= MAX_EXIF_TAGS_SUPPORTED) {
+        FLOGE("Max number of EXIF elements already inserted");
+        return NO_MEMORY;
+    }
+
+    if(isAsciiTag(tag)) {
+        value_length = sizeof(ExifAsciiPrefix) + strlen(value + sizeof(ExifAsciiPrefix));
+    }
+    else {
+        value_length = strlen(value);
+    }
+
+    if(IsGpsTag(tag)) {
+        table[position].GpsTag = TRUE;
+        table[position].Tag = GpsTagNameToValue(tag);
+        gps_tag_count++;
+    }
+    else {
+        table[position].GpsTag = FALSE;
+        table[position].Tag = TagNameToValue(tag);
+        exif_tag_count++;
+
+        if(strcmp(tag, TAG_DATETIME) == 0) {
+            has_datetime_tag = true;
+        }
+    }
+
+    table[position].DataLength = 0;
+    table[position].Value = (char*) malloc(sizeof(char) * (value_length + 1));
+
+    if(table[position].Value) {
+        memcpy(table[position].Value, value, value_length + 1);
+        table[position].DataLength = value_length + 1;
+    }
+
+    position++;
+    return ret;
+}
+
+JpegBuilder::JpegBuilder()
+   : gps_tag_count(0), exif_tag_count(0), position(0),
+     jpeg_opened(false), has_datetime_tag(false)
+{
+    reset();
+}
+
+void JpegBuilder::reset()
+{
+    gps_tag_count = 0;
+    exif_tag_count = 0;
+    position = 0;
+    jpeg_opened = false;
+    has_datetime_tag = false;
+    mMainInput = NULL;
+    mThumbnailInput = NULL;
+    mCancelEncoding = false;
+    memset(&mEXIFData, 0, sizeof(mEXIFData));
+    memset(&table, 0, sizeof(table));
+}
+
+JpegBuilder::~JpegBuilder()
+{
+    int num_elements = gps_tag_count + exif_tag_count;
+
+    for(int i = 0; i < num_elements; i++) {
+        if(table[i].Value) {
+            free(table[i].Value);
+        }
+    }
+
+    if(jpeg_opened) {
+        DiscardData();
+    }
+}
+
+void JpegBuilder::prepareImage(const CameraParameters& params)
+{
+    status_t ret = NO_ERROR;
+    int eError = 0;
+    struct timeval sTv;
+    struct tm *pTime;
+
+    if((NO_ERROR == ret) && (mEXIFData.mModelValid)) {
+        ret = insertElement(TAG_MODEL, EXIF_MODEL);
+    }
+
+     if((NO_ERROR == ret) && (mEXIFData.mMakeValid)) {
+        ret = insertElement(TAG_MAKE, EXIF_MAKENOTE);
+     }
+
+    if((NO_ERROR == ret)) {
+        unsigned int numerator = 0, denominator = 0;
+        JpegBuilder::stringToRational(params.get(CameraParameters::KEY_FOCAL_LENGTH),
+                                            &numerator, &denominator);
+        if(numerator || denominator) {
+            char temp_value[256]; // arbitrarily long string
+            snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char),
+                 "%u/%u", numerator, denominator);
+            ret = insertElement(TAG_FOCALLENGTH, temp_value);
+
+        }
+    }
+
+    if((NO_ERROR == ret)) {
+        int status = gettimeofday (&sTv, NULL);
+        pTime = gmtime (&sTv.tv_sec);
+        char temp_value[EXIF_DATE_TIME_SIZE + 1];
+        if((0 == status) && (NULL != pTime)) {
+            snprintf(temp_value, EXIF_DATE_TIME_SIZE,
+                     "%04d:%02d:%02d %02d:%02d:%02d",
+                     pTime->tm_year + 1900,
+                     pTime->tm_mon + 1,
+                     pTime->tm_mday,
+                     pTime->tm_hour,
+                     pTime->tm_min,
+                     pTime->tm_sec );
+
+            ret = insertElement(TAG_DATETIME, temp_value);
+        }
+     }
+
+    int width, height;
+    params.getPictureSize(&width, &height);
+    if((NO_ERROR == ret)) {
+        char temp_value[5];
+        snprintf(temp_value, sizeof(temp_value)/sizeof(char), "%lu", (unsigned long)width);
+        ret = insertElement(TAG_IMAGE_WIDTH, temp_value);
+     }
+
+    if((NO_ERROR == ret)) {
+        char temp_value[5];
+        snprintf(temp_value, sizeof(temp_value)/sizeof(char), "%lu", (unsigned long)height);
+        ret = insertElement(TAG_IMAGE_LENGTH, temp_value);
+     }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mLatValid)) {
+        char temp_value[256]; // arbitrarily long string
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d/%d,%d/%d,%d/%d",
+                 abs(mEXIFData.mGPSData.mLatDeg), 1,
+                 abs(mEXIFData.mGPSData.mLatMin), 1,
+                 abs(mEXIFData.mGPSData.mLatSec), abs(mEXIFData.mGPSData.mLatSecDiv));
+        ret = insertElement(TAG_GPS_LAT, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mLatValid)) {
+        ret = insertElement(TAG_GPS_LAT_REF, mEXIFData.mGPSData.mLatRef);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mLongValid)) {
+        char temp_value[256]; // arbitrarily long string
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d/%d,%d/%d,%d/%d",
+                 abs(mEXIFData.mGPSData.mLongDeg), 1,
+                 abs(mEXIFData.mGPSData.mLongMin), 1,
+                 abs(mEXIFData.mGPSData.mLongSec), abs(mEXIFData.mGPSData.mLongSecDiv));
+        ret = insertElement(TAG_GPS_LONG, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mLongValid)) {
+        ret = insertElement(TAG_GPS_LONG_REF, mEXIFData.mGPSData.mLongRef);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mAltitudeValid)) {
+        char temp_value[256]; // arbitrarily long string
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d/%d",
+                 abs( mEXIFData.mGPSData.mAltitude), 1);
+        ret = insertElement(TAG_GPS_ALT, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mAltitudeValid)) {
+        char temp_value[5];
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d", mEXIFData.mGPSData.mAltitudeRef);
+        ret = insertElement(TAG_GPS_ALT_REF, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mMapDatumValid)) {
+        ret = insertElement(TAG_GPS_MAP_DATUM, mEXIFData.mGPSData.mMapDatum);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mProcMethodValid)) {
+        char temp_value[GPS_PROCESSING_SIZE];
+        memcpy(temp_value, ExifAsciiPrefix, sizeof(ExifAsciiPrefix));
+        memcpy(temp_value + sizeof(ExifAsciiPrefix),
+               mEXIFData.mGPSData.mProcMethod,
+               (GPS_PROCESSING_SIZE - sizeof(ExifAsciiPrefix)));
+        ret = insertElement(TAG_GPS_PROCESSING_METHOD, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mVersionIdValid)) {
+        char temp_value[256]; // arbitrarily long string
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d,%d,%d,%d",
+                 mEXIFData.mGPSData.mVersionId[0],
+                 mEXIFData.mGPSData.mVersionId[1],
+                 mEXIFData.mGPSData.mVersionId[2],
+                 mEXIFData.mGPSData.mVersionId[3]);
+        ret = insertElement(TAG_GPS_VERSION_ID, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mTimeStampValid)) {
+        char temp_value[256]; // arbitrarily long string
+        snprintf(temp_value,
+                 sizeof(temp_value)/sizeof(char) - 1,
+                 "%d/%d,%d/%d,%d/%d",
+                 mEXIFData.mGPSData.mTimeStampHour, 1,
+                 mEXIFData.mGPSData.mTimeStampMin, 1,
+                 mEXIFData.mGPSData.mTimeStampSec, 1);
+        ret = insertElement(TAG_GPS_TIMESTAMP, temp_value);
+    }
+
+    if((NO_ERROR == ret) && (mEXIFData.mGPSData.mDatestampValid)) {
+        ret = insertElement(TAG_GPS_DATESTAMP, mEXIFData.mGPSData.mDatestamp);
+    }
+
+    if((NO_ERROR == ret) && params.get(CameraParameters::KEY_ROTATION)) {
+        const char* exif_orient =
+           JpegBuilder::degreesToExifOrientation(params.get(CameraParameters::KEY_ROTATION));
+
+        if(exif_orient) {
+           ret = insertElement(TAG_ORIENTATION, exif_orient);
+        }
+    }
+}
+
+void JpegBuilder::setParameters(const CameraParameters &params)
+{
+    status_t ret = NO_ERROR;
+    const char *valstr = NULL;
+    double gpsPos;
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_LATITUDE)) != NULL) {
+        gpsPos = strtod(valstr, NULL);
+
+        if(convertGPSCoord(gpsPos,
+                             mEXIFData.mGPSData.mLatDeg,
+                             mEXIFData.mGPSData.mLatMin,
+                             mEXIFData.mGPSData.mLatSec,
+                             mEXIFData.mGPSData.mLatSecDiv ) == NO_ERROR) {
+
+            if (0 < gpsPos) {
+                strncpy(mEXIFData.mGPSData.mLatRef, GPS_NORTH_REF, GPS_REF_SIZE);
+            }
+            else {
+                strncpy(mEXIFData.mGPSData.mLatRef, GPS_SOUTH_REF, GPS_REF_SIZE);
+            }
+
+            mEXIFData.mGPSData.mLatValid = true;
+        }
+        else {
+            mEXIFData.mGPSData.mLatValid = false;
+        }
+    }
+    else {
+        mEXIFData.mGPSData.mLatValid = false;
+    }
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_LONGITUDE)) != NULL) {
+        gpsPos = strtod(valstr, NULL);
+
+        if(convertGPSCoord(gpsPos,
+                             mEXIFData.mGPSData.mLongDeg,
+                             mEXIFData.mGPSData.mLongMin,
+                             mEXIFData.mGPSData.mLongSec,
+                             mEXIFData.mGPSData.mLongSecDiv) == NO_ERROR) {
+
+            if(0 < gpsPos) {
+                strncpy(mEXIFData.mGPSData.mLongRef, GPS_EAST_REF, GPS_REF_SIZE);
+            }
+            else {
+                strncpy(mEXIFData.mGPSData.mLongRef, GPS_WEST_REF, GPS_REF_SIZE);
+            }
+
+            mEXIFData.mGPSData.mLongValid= true;
+        }
+        else {
+            mEXIFData.mGPSData.mLongValid = false;
+        }
+    }
+    else {
+        mEXIFData.mGPSData.mLongValid = false;
+    }
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_ALTITUDE)) != NULL) {
+        gpsPos = strtod(valstr, NULL);
+        mEXIFData.mGPSData.mAltitude = floor(fabs(gpsPos));
+        if(gpsPos < 0) {
+            mEXIFData.mGPSData.mAltitudeRef = 1;
+        }
+        else {
+            mEXIFData.mGPSData.mAltitudeRef = 0;
+        }
+        mEXIFData.mGPSData.mAltitudeValid = true;
+    }
+    else {
+        mEXIFData.mGPSData.mAltitudeValid= false;
+    }
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_TIMESTAMP)) != NULL) {
+        long gpsTimestamp = strtol(valstr, NULL, 10);
+        struct tm *timeinfo = gmtime((time_t *) & (gpsTimestamp));
+        if(NULL != timeinfo) {
+            mEXIFData.mGPSData.mTimeStampHour = timeinfo->tm_hour;
+            mEXIFData.mGPSData.mTimeStampMin = timeinfo->tm_min;
+            mEXIFData.mGPSData.mTimeStampSec = timeinfo->tm_sec;
+            mEXIFData.mGPSData.mTimeStampValid = true;
+        }
+        else {
+            mEXIFData.mGPSData.mTimeStampValid = false;
+        }
+    }
+    else {
+        mEXIFData.mGPSData.mTimeStampValid = false;
+    }
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_TIMESTAMP)) != NULL) {
+        long gpsDatestamp = strtol(valstr, NULL, 10);
+        struct tm *timeinfo = gmtime((time_t *) & (gpsDatestamp));
+        if(NULL != timeinfo) {
+            strftime(mEXIFData.mGPSData.mDatestamp, GPS_DATESTAMP_SIZE, "%Y:%m:%d", timeinfo);
+            mEXIFData.mGPSData.mDatestampValid = true;
+        }
+        else {
+            mEXIFData.mGPSData.mDatestampValid = false;
+        }
+    }
+    else {
+        mEXIFData.mGPSData.mDatestampValid = false;
+    }
+
+    if((valstr = params.get(CameraParameters::KEY_GPS_PROCESSING_METHOD)) != NULL) {
+        memset(mEXIFData.mGPSData.mProcMethod, 0, GPS_PROCESSING_SIZE);
+        strncpy(mEXIFData.mGPSData.mProcMethod, valstr, GPS_PROCESSING_SIZE-1);
+        mEXIFData.mGPSData.mProcMethodValid = true;
+    }
+    else {
+        mEXIFData.mGPSData.mProcMethodValid = false;
+    }
+
+    mEXIFData.mGPSData.mMapDatumValid = false;
+    mEXIFData.mGPSData.mVersionIdValid = false;
+    mEXIFData.mModelValid= true;
+    mEXIFData.mMakeValid = true;
+}
+
+status_t JpegBuilder::encodeImage(JpegParams* mainJpeg, JpegParams* thumbNail)
+{
+    status_t ret = NO_ERROR;
+
+    mMainInput = mainJpeg;
+    mThumbnailInput = thumbNail;
+    if(thumbNail) {
+        ret = encodeJpeg(thumbNail);
+    }
+
+    if(ret != NO_ERROR) {
+        FLOGE("JpegBuilder:encodeImage failed");
+        return ret;
+    }
+
+    return encodeJpeg(mainJpeg);
+}
+
+status_t JpegBuilder::encodeJpeg(JpegParams* input)
+{
+    PixelFormat format = convertStringToPixelFormat(input->format);
+    YuvToJpegEncoder* encoder = YuvToJpegEncoder::create(format);
+    if(encoder == NULL) {
+        return BAD_VALUE;
+    }
+
+    int res = 0;
+    res = encoder->encode(input->src, input->in_width, input->in_height, input->quality,
+            input->dst, input->dst_size, input->out_width, input->out_height);
+
+    delete encoder;
+    if(res) {
+        input->jpeg_size = res;
+        return NO_ERROR;
+    }
+    else {
+        return BAD_VALUE;
+    }
+}
+
+size_t JpegBuilder::getImageSize()
+{
+    size_t jpeg_size, image_size;
+    Section_t* exif_section = NULL;
+
+    jpeg_size = mMainInput->jpeg_size;
+
+    exif_section = FindSection(M_EXIF);
+    if(exif_section != NULL) {
+        image_size = jpeg_size + exif_section->Size;
+    }
+    else {
+        image_size = jpeg_size;
+    }
+    return image_size;
+}
+
+status_t JpegBuilder::buildImage(camera_request_memory get_memory, camera_memory_t** image)
+{
+    size_t jpeg_size;
+    uint8_t* src = NULL;
+    camera_memory_t* picture = NULL;
+
+    if(!image || !mMainInput) {
+        return BAD_VALUE;
+    }
+
+    jpeg_size = mMainInput->jpeg_size;
+    src = mMainInput->src;
+
+    if(mMainInput->dst && (jpeg_size > 0)) {
+        if(position > 0) {
+            Section_t* exif_section = NULL;
+
+            insertExifToJpeg((unsigned char*)mMainInput->dst, jpeg_size);
+
+            if(mThumbnailInput) {
+                insertExifThumbnailImage((const char*)mThumbnailInput->dst,
+                                               (int)mThumbnailInput->jpeg_size);
+            }
+
+            exif_section = FindSection(M_EXIF);
+            if(exif_section) {
+                int imageSize = jpeg_size + exif_section->Size;
+                picture = get_memory(-1, imageSize, 1, NULL);
+                if(!picture || !picture->data) {
+                    FLOGE("CameraBridge:processImageFrame mRequestMemory picture failed");
+                    return false;
+                }
+
+                saveJpeg((unsigned char*)picture->data, jpeg_size + exif_section->Size);
+            }
+        } else {
+            int imageSize = jpeg_size;
+            picture = get_memory(-1, imageSize, 1, NULL);
+            if(!picture || !picture->data) {
+                FLOGE("CameraBridge:processImageFrame mRequestMemory picture failed");
+                return false;
+            }
+            memcpy(picture->data, mMainInput->dst, jpeg_size);
+        }
+    }
+
+    *image = picture;
+    return NO_ERROR;
+}
+
+status_t JpegBuilder::getSupportedPictureFormat(int* pFormat, int len)
+{
+    return YuvToJpegEncoder::getSupportedPictureFormat(pFormat, len);
+}
+
+status_t JpegBuilder::convertGPSCoord(double coord, int &deg, int &min, int &sec, int &secDivisor)
+{
+    double tmp;
+
+    if(coord == 0) {
+
+        FLOGE("Invalid GPS coordinate");
+
+        return -EINVAL;
+    }
+
+    deg = (int) floor(fabs(coord));
+    tmp = ( fabs(coord) - floor(fabs(coord)) ) * GPS_MIN_DIV;
+    min = (int) floor(tmp);
+    tmp = ( tmp - floor(tmp) ) * ( GPS_SEC_DIV * GPS_SEC_ACCURACY );
+    sec = (int) floor(tmp);
+    secDivisor = GPS_SEC_ACCURACY;
+
+    if(sec >= (GPS_SEC_DIV * GPS_SEC_ACCURACY)) {
+        sec = 0;
+        min += 1;
+    }
+
+    if(min >= 60) {
+        min = 0;
+        deg += 1;
+    }
+
+    return NO_ERROR;
+}
+
+};
diff --git a/mx6/libcamera/JpegBuilder.h b/mx6/libcamera/JpegBuilder.h
new file mode 100755
index 0000000..0d2d703
--- /dev/null
+++ b/mx6/libcamera/JpegBuilder.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _JPEG_BUILDER_H_
+#define _JPEG_BUILDER_H_
+
+#include "CameraUtil.h"
+#include <utils/RefBase.h>
+#include "YuvToJpegEncoder.h"
+
+extern "C" {
+#include "jhead.h"
+}
+
+namespace android {
+
+#define EXIF_MAKENOTE "fsl_makernote"
+#define EXIF_MODEL    "fsl_model"
+
+#define MAX_EXIF_TAGS_SUPPORTED 30
+
+static const char TAG_MODEL[] = "Model";
+static const char TAG_MAKE[] = "Make";
+static const char TAG_FOCALLENGTH[] = "FocalLength";
+static const char TAG_DATETIME[] = "DateTime";
+static const char TAG_IMAGE_WIDTH[] = "ImageWidth";
+static const char TAG_IMAGE_LENGTH[] = "ImageLength";
+static const char TAG_GPS_LAT[] = "GPSLatitude";
+static const char TAG_GPS_LAT_REF[] = "GPSLatitudeRef";
+static const char TAG_GPS_LONG[] = "GPSLongitude";
+static const char TAG_GPS_LONG_REF[] = "GPSLongitudeRef";
+static const char TAG_GPS_ALT[] = "GPSAltitude";
+static const char TAG_GPS_ALT_REF[] = "GPSAltitudeRef";
+static const char TAG_GPS_MAP_DATUM[] = "GPSMapDatum";
+static const char TAG_GPS_PROCESSING_METHOD[] = "GPSProcessingMethod";
+static const char TAG_GPS_VERSION_ID[] = "GPSVersionID";
+static const char TAG_GPS_TIMESTAMP[] = "GPSTimeStamp";
+static const char TAG_GPS_DATESTAMP[] = "GPSDateStamp";
+static const char TAG_ORIENTATION[] = "Orientation";
+
+#define GPS_MIN_DIV                 60
+#define GPS_SEC_DIV                 60
+#define GPS_SEC_ACCURACY            1000
+
+#define GPS_NORTH_REF               "N"
+#define GPS_SOUTH_REF               "S"
+#define GPS_EAST_REF                "E"
+#define GPS_WEST_REF                "W"
+
+#define EXIF_DATE_TIME_SIZE         20
+
+#define GPS_DATESTAMP_SIZE          11
+#define GPS_REF_SIZE                2
+#define GPS_MAPDATUM_SIZE           100
+#define GPS_PROCESSING_SIZE         100
+#define GPS_VERSION_SIZE            4
+
+struct GPSData
+{
+    int mLongDeg, mLongMin, mLongSec, mLongSecDiv;
+    char mLongRef[GPS_REF_SIZE];
+    bool mLongValid;
+    int mLatDeg, mLatMin, mLatSec, mLatSecDiv;
+    char mLatRef[GPS_REF_SIZE];
+    bool mLatValid;
+    int mAltitude;
+    unsigned char mAltitudeRef;
+    bool mAltitudeValid;
+    char mMapDatum[GPS_MAPDATUM_SIZE];
+    bool mMapDatumValid;
+    char mVersionId[GPS_VERSION_SIZE];
+    bool mVersionIdValid;
+    char mProcMethod[GPS_PROCESSING_SIZE];
+    bool mProcMethodValid;
+    char mDatestamp[GPS_DATESTAMP_SIZE];
+    bool mDatestampValid;
+    uint32_t mTimeStampHour;
+    uint32_t mTimeStampMin;
+    uint32_t mTimeStampSec;
+    bool mTimeStampValid;
+};
+
+struct EXIFData
+{
+    GPSData mGPSData;
+    bool mMakeValid;
+    bool mModelValid;
+};
+
+struct JpegParams {
+    JpegParams(uint8_t* uSrc, int srcSize, uint8_t* uDst, int dstSize,
+            int quality, int inWidth, int inHeight, int outWidth,
+            int outHeight, const char* format)
+        : src(uSrc), src_size(srcSize), dst(uDst), dst_size(dstSize),
+          quality(quality), in_width(inWidth), in_height(inHeight),
+          out_width(outWidth), out_height(outHeight), format(format),
+          jpeg_size(0)
+    {}
+
+    uint8_t* src;
+    int src_size;
+    uint8_t* dst;
+    int dst_size;
+    int quality;
+    int in_width;
+    int in_height;
+    int out_width;
+    int out_height;
+    const char* format;
+    size_t jpeg_size;
+ };
+
+
+class JpegBuilder : public LightRefBase<JpegBuilder>
+{
+public:
+    JpegBuilder();
+    ~JpegBuilder();
+
+    status_t getSupportedPictureFormat(int* pFormat, int len);
+    void prepareImage(const CameraParameters& params);
+    void setParameters(const CameraParameters &params);
+
+    status_t encodeImage(JpegParams* mainJpeg, JpegParams* thumbNail);
+    size_t getImageSize();
+    status_t buildImage(camera_request_memory get_memory, camera_memory_t** image);
+    void reset();
+
+private:
+    status_t insertElement(const char* tag, const char* value);
+    void insertExifToJpeg(unsigned char* jpeg, size_t jpeg_size);
+    status_t insertExifThumbnailImage(const char*, int);
+    void saveJpeg(unsigned char* picture, size_t jpeg_size);
+
+private:
+    status_t encodeJpeg(JpegParams* input);
+    const char* degreesToExifOrientation(const char*);
+    void stringToRational(const char*, unsigned int*, unsigned int*);
+    bool isAsciiTag(const char* tag);
+    status_t convertGPSCoord(double coord, int &deg, int &min, int &sec, int &secDivisor);
+
+private:
+    JpegParams* mMainInput;
+    JpegParams* mThumbnailInput;
+
+    bool mCancelEncoding;
+    CameraFrame::FrameType mType;
+    EXIFData mEXIFData;
+
+private:
+    ExifElement_t table[MAX_EXIF_TAGS_SUPPORTED];
+    unsigned int gps_tag_count;
+    unsigned int exif_tag_count;
+    unsigned int position;
+    bool jpeg_opened;
+    bool has_datetime_tag;
+};
+
+};
+
+#endif
diff --git a/mx6/libcamera/JpegEncoderInterface.cpp b/mx6/libcamera/JpegEncoderInterface.cpp
deleted file mode 100755
index 65ac721..0000000
--- a/mx6/libcamera/JpegEncoderInterface.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "JpegEncoderSoftware.h"
-namespace android{
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
-    {
-        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
-            CAMERA_LOG_INFO("Create the software encoder");
-            return JpegEncoderSoftware::createInstance();
-        }
-        else{
-            CAMERA_LOG_ERR("the hardware encoder is not supported");
-            return NULL;
-        }
-    }
-};
diff --git a/mx6/libcamera/JpegEncoderInterface.h b/mx6/libcamera/JpegEncoderInterface.h
deleted file mode 100755
index 3f1a857..0000000
--- a/mx6/libcamera/JpegEncoderInterface.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef JPEG_ENCODER_INTERFACE_H
-#define JPEG_ENCODER_INTERFACE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-namespace android{
-
-
-#define MAX_JPEG_MAKE_BYTES 256
-#define MAX_JPEG_MAKERNOTE_BYTES 256
-#define MAX_JPEG_MODEL_BYTES 256
-#define TIME_FMT_LENGTH 20
-#define MAX_GPS_PROCESSING_BYTES	256
-
-    typedef enum{
-    ORIENTATION_UNDEFINED = 0,
-    ORIENTATION_NORMAL = 1,
-    ORIENTATION_FLIP_HORIZONTAL = 2,
-    ORIENTATION_ROTATE_180 = 3,
-    ORIENTATION_FLIP_VERTICAL = 4,
-    ORIENTATION_TRANSPOSE = 5,
-    ORIENTATION_ROTATE_90 = 6,
-    ORIENTATION_TRANSVERSE = 7,
-    ORIENTATION_ROTATE_270 = 8
-    }JPEG_ENCODER_ROTATION;
-
-    typedef enum{
-    WHITEBALANCE_AUTO = 0,
-    WHITEBALANCE_MANUAL = 1
-    }JPEG_ENCODER_WHITEBALANCE;
-
-    typedef enum{
-    FLASH_NOT_FIRE = 0x00,
-    FLASH_FIRED    = 0x01,
-    FLASH_FIRED_AUTO = 0x19,
-    FLASH_FIRED_RED_EYE_REDUCE = 0x41,
-    FLASH_FIRED_COMPULOSORY = 0x09
-    }JPEG_ENCODER_FLASH;
-
-    typedef enum{
-        SOFTWARE_JPEG_ENC = 0,
-        HARDWARE_JPEG_ENC = 1
-    }JPEG_ENCODER_TYPE;
-
-    typedef enum{
-        JPEG_ENC_ERROR_NONE = 0,
-        JPEG_ENC_ERROR_BAD_PARAM = -1,
-        JPEG_ENC_ERROR_ALOC_BUF = -2
-    }JPEG_ENC_ERR_RET;
-
-
-    typedef enum{
-        SUPPORTED_FMT = 0,
-    }JPEEG_QUERY_TYPE;
-
-    struct jpeg_enc_focallength_t
-    {
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct jpeg_enc_make_info_t
-    {
-        unsigned char make_bytes;
-        unsigned char make[MAX_JPEG_MAKE_BYTES];
-    };
-    struct jpeg_enc_makernote_info_t
-    {
-        unsigned char makernote_bytes;
-        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
-    };
-
-    struct jpeg_enc_model_info_t
-    {
-        unsigned char model_bytes;
-        unsigned char model[MAX_JPEG_MODEL_BYTES];	
-    };
-
-    struct jpeg_enc_datetime_info_t
-    {
-        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
-    };
-
-    struct jpeg_enc_gps_param{
-        unsigned int version;//GPSVersionID
-        char latitude_ref[2];//GPSLatitudeRef: "N " is positive; "S " is negative
-        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
-        unsigned int latitude_degree[2];//GPSLatitude
-        unsigned int latitude_minute[2];
-        unsigned int latitude_second[2];
-        unsigned int longtitude_degree[2];//GPSLongitude
-        unsigned int longtitude_minute[2];
-        unsigned int longtitude_second[2];
-        char altitude_ref;//GPSAltitudeRef: 0 or 1(negative)
-        unsigned int altitude[2];//GPSAltitude: unit is meters
-        unsigned int hour[2];//GPSTimeStamp
-        unsigned int minute[2];
-        unsigned int seconds[2];
-        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
-        char processmethod_bytes;
-        char datestamp[11];//GPSDateStamp: "YYYY:MM:DD "
-    };
-
-    typedef struct{
-        unsigned int PicWidth;
-        unsigned int PicHeight;
-        unsigned int ThumbWidth;
-        unsigned int ThumbHeight;
-        unsigned int BufFmt;
-        JPEG_ENCODER_ROTATION RotationInfo;
-        JPEG_ENCODER_WHITEBALANCE WhiteBalanceInfo;
-        JPEG_ENCODER_FLASH FlashInfo;
-        struct jpeg_enc_focallength_t *pFoclLength;
-        struct jpeg_enc_make_info_t *pMakeInfo;
-        struct jpeg_enc_makernote_info_t *pMakeNote;
-        struct jpeg_enc_model_info_t *pModelInfo;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
-        struct jpeg_enc_gps_param *pGps_info;
-    }enc_cfg_param;
-
-    struct jpeg_encoding_conf{
-        unsigned int output_jpeg_size;
-    };
-
-    class JpegEncoderInterface : public virtual RefBase{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
-
-        virtual ~ JpegEncoderInterface(){}
-    }; 
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
-
-};
-
-#endif
diff --git a/mx6/libcamera/JpegEncoderSoftware.cpp b/mx6/libcamera/JpegEncoderSoftware.cpp
deleted file mode 100755
index 49868d7..0000000
--- a/mx6/libcamera/JpegEncoderSoftware.cpp
+++ /dev/null
@@ -1,662 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "JpegEncoderSoftware.h"
-
-namespace android{
-
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
-    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
-
-    JpegEncoderSoftware :: JpegEncoderSoftware()
-        :mSupportedTypeIdx(0),
-        pEncCfgLocal(NULL),
-        pEncObj(NULL)
-    {
-        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
-        mSupportedType[1] = v4l2_fourcc('Y','U','Y','V');
-    }
-
-    JpegEncoderSoftware :: ~JpegEncoderSoftware()
-    {
-
-    }
-
-    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
-    {
-
-        int * pSupportedType = (int *)pQueryRet;
-        switch(QueryType){
-            case SUPPORTED_FMT:
-                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
-                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
-                    mSupportedTypeIdx ++;
-                }else{
-                    mSupportedTypeIdx = 0;
-                    return JPEG_ENC_ERROR_BAD_PARAM;
-                }
-                break;
-            default:
-                return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        return JPEG_ENC_ERROR_NONE;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
-    {
-        CAMERA_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        struct jpeg_enc_focallength_t * pFoclLength = NULL;
-        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
-        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
-        struct jpeg_enc_model_info_t *pModelInfo = NULL;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
-        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
-
-        if(pEncCfg == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
-
-        if (pEncCfgLocal == NULL){
-            CAMERA_LOG_ERR("Allocat buffer for EncCfg failed");
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-
-        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
-        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
-
-
-        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
-            goto INT_ERR_RET;
-        }
-
-        if (pEncCfg->pFoclLength != NULL){
-            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
-
-            if (pFoclLength == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pFoclLength failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
-            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
-            pEncCfgLocal->pFoclLength = pFoclLength;
-        }
-
-
-        if (pEncCfg->pMakeInfo != NULL){
-            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
-
-            if (pMakeInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pMakeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
-            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
-            pEncCfgLocal->pMakeInfo = pMakeInfo;
-        }
-
-        if (pEncCfg->pMakeNote != NULL){
-            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
-
-            if (pMakeNote == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pMakeNote failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
-            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
-            pEncCfgLocal->pMakeNote = pMakeNote;
-        }
-
-        if (pEncCfg->pModelInfo != NULL){
-            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
-
-            if (pModelInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pModelInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
-            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
-            pEncCfgLocal->pModelInfo = pModelInfo;
-        }
-
-        if (pEncCfg->pDatetimeInfo != NULL){
-            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
-
-            if (pDatetimeInfo == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pDatetimeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
-            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
-            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
-        }
-
-        if (pEncCfg->pGps_info != NULL){
-            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
-
-            if (pGpsInfoLocal == NULL){
-                CAMERA_LOG_ERR("Allocat buffer for pGpsInfoLocal failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
-            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
-            pEncCfgLocal->pGps_info = pGpsInfoLocal;
-        }
-
-        return ret;
-
-INT_ERR_RET:
-        if(pEncCfgLocal)
-            free(pEncCfgLocal);
-        if(pFoclLength)
-            free(pFoclLength);
-        if(pMakeInfo)
-            free(pMakeInfo);
-        if(pMakeNote)
-            free(pMakeNote);
-        if(pModelInfo)
-            free(pModelInfo);
-        if(pDatetimeInfo)
-            free(pDatetimeInfo);
-        if(pGpsInfoLocal)
-            free(pGpsInfoLocal);
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
-        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }else{
-            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
-        }
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
-        CAMERA_LOG_FUNC;
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if (pEncCfgLocal != NULL ){
-            if (pEncCfgLocal->pFoclLength != NULL)
-                free(pEncCfgLocal->pFoclLength);
-            if (pEncCfgLocal->pMakeInfo != NULL)
-                free(pEncCfgLocal->pMakeInfo);
-            if (pEncCfgLocal->pMakeNote != NULL)
-                free(pEncCfgLocal->pMakeNote);
-            if (pEncCfgLocal->pModelInfo != NULL)
-                free(pEncCfgLocal->pModelInfo);
-            if (pEncCfgLocal->pDatetimeInfo != NULL)
-                free(pEncCfgLocal->pDatetimeInfo);
-            if (pEncCfgLocal->pGps_info != NULL)
-                free(pEncCfgLocal->pGps_info);
-            free(pEncCfgLocal);
-        }
-
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
-
-        CAMERA_LOG_FUNC;
-        int i = 0;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
-            CAMERA_LOG_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)||
-                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
-                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
-            CAMERA_LOG_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
-            if(pEncCfgLocal->BufFmt == mSupportedType[i])
-                break;
-        }
-
-        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
-            ret = JPEG_ENC_ERROR_BAD_PARAM;
-
-        return ret;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
-
-        CAMERA_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        int width, height, size,index;
-        JPEG_ENC_UINT8 * i_buff = NULL;
-        JPEG_ENC_UINT8 * y_buff = NULL;
-        JPEG_ENC_UINT8 * u_buff = NULL;
-        JPEG_ENC_UINT8 * v_buff = NULL;
-        JPEG_ENC_RET_TYPE return_val;
-        jpeg_enc_parameters * params = NULL;
-        jpeg_enc_object * obj_ptr = NULL;
-        JPEG_ENC_UINT8 number_mem_info;
-        jpeg_enc_memory_info * mem_info = NULL;
-        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
-        int thumbnail_width, thumbnail_height;
-        unsigned char *buffer = inBuf->virt_start;
-
-        bool mEncodeThumbnailFlag = true;
-
-        width = pEncCfgLocal->PicWidth;
-        height = pEncCfgLocal->PicHeight;
-
-        thumbnail_width = pEncCfgLocal->ThumbWidth;
-        thumbnail_height = pEncCfgLocal->ThumbHeight;
-
-
-        if (thumbnail_width <= 0 || thumbnail_height<= 0)
-            mEncodeThumbnailFlag = false;
-
-        g_JpegDataSize = 0;//Total size of g_JpegData
-        g_JpegDataLen = 0;//Valid data len of g_JpegData
-        g_JpegData = NULL;//Buffer to hold jpeg data
-        size = width * height * 3 / 2;
-
-        g_JpegData = outBuf->virt_start;
-        g_JpegDataSize = size;
-        if(!g_JpegData)
-        {
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        /* --------------------------------------------
-         * Allocate memory for Encoder Object
-         * -------------------------------------------*/
-        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
-        if(!obj_ptr)
-        {
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
-
-        /* Assign the function for streaming output */
-        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
-        obj_ptr->context=NULL;   //user can put private variables into it
-        /* --------------------------------------------
-         * Fill up the parameter structure of JPEG Encoder
-         * -------------------------------------------*/
-        params = &(obj_ptr->parameters);
-
-        if(mEncodeThumbnailFlag==true)
-        {
-
-            //need resizing code here!!!
-            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
-            if(!thumbnail_buffer)
-            {
-                return JPEG_ENC_ERROR_ALOC_BUF;
-            }
-
-            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
-
-            width = thumbnail_width;
-            height = thumbnail_height;
-
-            temp_buffer = buffer;
-            buffer = thumbnail_buffer;
-
-            params->mode = JPEG_ENC_THUMB;
-        }
-        else
-        {
-            params->mode = JPEG_ENC_MAIN_ONLY;
-        }
-
-encodeframe:
-
-        params->compression_method = JPEG_ENC_SEQUENTIAL;
-        params->quality = 75;
-        params->restart_markers = 0;
-        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height/2;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height/2;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
-        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
-        }
-        params->exif_flag = 1;
-
-        params->y_left = 0;
-        params->y_top = 0;
-        params->y_total_width = 0;
-        params->y_total_height = 0;
-        params->raw_dat_flag= 0;
-
-        if(params->y_total_width==0)
-        {
-            params->y_left=0;
-            params->u_left=0;
-            params->v_left=0;
-            params->y_total_width=params->y_width;  // no cropping
-            params->u_total_width=params->u_width;  // no cropping
-            params->v_total_width=params->v_width;  // no cropping
-        }
-
-        if(params->y_total_height==0)
-        {
-            params->y_top=0;
-            params->u_top=0;
-            params->v_top=0;
-            params->y_total_height=params->y_height; // no cropping
-            params->u_total_height=params->u_height; // no cropping
-            params->v_total_height=params->v_height; // no cropping
-        }
-
-        /* Pixel size is unknown by default */
-        params->jfif_params.density_unit = 0;
-        /* Pixel aspect ratio is square by default */
-        params->jfif_params.X_density = 1;
-        params->jfif_params.Y_density = 1;
-        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
-            y_buff = (JPEG_ENC_UINT8 *)buffer;
-            u_buff = y_buff+width*height;
-            v_buff = u_buff+width*height/4;
-            i_buff = NULL;
-        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
-            y_buff = NULL;
-            u_buff = NULL;
-            v_buff = NULL;
-            i_buff = (JPEG_ENC_UINT8 *)buffer;
-        }
-        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        /* --------------------------------------------
-         * QUERY MEMORY REQUIREMENTS
-         * -------------------------------------------*/
-        return_val = jpeg_enc_query_mem_req(obj_ptr);
-
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-        CAMERA_LOG_RUNTIME("jpeg_enc_query_mem_req success");
-        /* --------------------------------------------
-         * ALLOCATE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            /* This example code ignores the 'alignment' and
-             * 'memory_type', but some other applications might want
-             * to allocate memory based on them */
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            mem_info->memptr = (void *) malloc(mem_info->size);
-            if(mem_info->memptr==NULL) {
-                CAMERA_LOG_RUNTIME("Malloc error after query\n");
-                goto done;
-            }
-        }
-
-        return_val = jpeg_enc_init(obj_ptr);
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        CAMERA_LOG_RUNTIME("jpeg_enc_init success");
-        if(params->mode == JPEG_ENC_THUMB)
-            createJpegExifTags(obj_ptr);
-
-        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
-                y_buff, u_buff, v_buff);
-
-        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
-        {
-            CAMERA_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        if(params->mode == JPEG_ENC_THUMB)
-        {
-            JPEG_ENC_UINT8 num_entries;
-            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
-            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
-
-            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
-
-            for(int i = 0; i < num_entries; i++)
-            {
-                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
-            }
-
-            free(offset_tbl_ptr);
-            free(value_tbl_ptr);
-
-            free(buffer);
-
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-
-            g_JpegData += g_JpegDataLen;
-            g_JpegDataSize -= g_JpegDataLen;
-
-
-            //recover to build the main jpeg
-            params->mode = JPEG_ENC_MAIN;
-
-            buffer = temp_buffer;
-            width = pEncCfgLocal->PicWidth;
-            height = pEncCfgLocal->PicHeight;
-
-            goto encodeframe;
-        }
-        CAMERA_LOG_RUNTIME("jpeg_enc_encodeframe success");
-        // Make an IMemory for each frame
-        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
-        *pEncSize = g_JpegDataLen;
-
-done:
-        /* --------------------------------------------
-         * FREE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        if(obj_ptr)
-        {
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-            free(obj_ptr);
-        }
-
-        return ret;
-    }
-
-    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
-            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
-    {
-        JPEG_ENC_UINT32 i;
-        if(*out_buf_ptrptr == NULL)
-        {
-            /* This function is called for the 1'st time from the
-             * codec */
-            *out_buf_ptrptr = g_JpegData;
-            *out_buf_len_ptr = g_JpegDataSize;
-        }
-
-        else if(flush == 1)
-        {
-            /* Flush the buffer*/
-            g_JpegDataLen += *out_buf_len_ptr;
-            CAMERA_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
-
-            *out_buf_ptrptr = NULL;
-            *out_buf_len_ptr = 0;
-        }
-        else
-        {
-            CAMERA_LOG_RUNTIME("Not enough buffer for encoding");
-            return 0;
-        }
-
-        return(1); /* Success */
-    }
-
-    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
-    {
-        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FLASH, (unsigned int)(&(pEncCfgLocal->FlashInfo)));
-
-        if(pEncCfgLocal->pMakeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
-        if(pEncCfgLocal->pMakeNote)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
-        if(pEncCfgLocal->pModelInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
-        if(pEncCfgLocal->pDatetimeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
-        if(pEncCfgLocal->pFoclLength)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
-
-        if (pEncCfgLocal->pGps_info)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
-
-        return;
-    }
-
-    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
-    {
-        int i,j,s;
-        int h_offset;
-        int v_offset;
-        unsigned char *ptr,cc;
-        int h_scale_ratio;
-        int v_scale_ratio;
-
-        s = 0;
-
-_resize_begin:
-
-        if(!dst_width) return -1;
-        if(!dst_height) return -1;
-
-        h_scale_ratio = src_width / dst_width;
-        if(!h_scale_ratio) return -1;
-
-        v_scale_ratio = src_height / dst_height;
-        if(!v_scale_ratio) return -1;
-
-        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
-        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
-
-        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
-        {
-            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
-            {
-                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
-                cc = ptr[0];
-
-                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
-                ptr[0] = cc;
-            }
-        }
-
-        src_ptr += src_width*src_height;
-        dst_ptr += dst_width*dst_height;
-
-        if(s < 2)
-        {
-            if(!s++)
-            {
-                src_width >>= 1;
-                src_height >>= 1;
-
-                dst_width >>= 1;
-                dst_height >>= 1;
-            }
-
-            goto _resize_begin;
-        }
-
-        return 0;
-    }
-
-    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
-        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
-        return hardware;
-    }
-
-
-};
diff --git a/mx6/libcamera/JpegEncoderSoftware.h b/mx6/libcamera/JpegEncoderSoftware.h
deleted file mode 100755
index 7e22dff..0000000
--- a/mx6/libcamera/JpegEncoderSoftware.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef JPEG_ENCODER_SOFTWARE_H
-#define JPEG_ENCODER_SOFTWARE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-
-#include "JpegEncoderInterface.h"
-#include "jpeg_enc_interface.h"
-
-
-namespace android{
-#define MAX_ENC_SUPPORTED_YUV_TYPE  2
-
-    class JpegEncoderSoftware : public JpegEncoderInterface{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
-
-        static sp<JpegEncoderInterface>createInstance();
-    private:
-
-        JpegEncoderSoftware();
-        virtual ~JpegEncoderSoftware();
-
-        virtual JPEG_ENC_ERR_RET CheckEncParm();
-        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
-
-
-        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
-                JPEG_ENC_UINT32 *out_buf_len_ptr,
-                JPEG_ENC_UINT8 flush,
-                void * context,
-                JPEG_ENC_MODE enc_mode);
-        void createJpegExifTags(jpeg_enc_object * obj_ptr);
-        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
-
-
-        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
-        unsigned int mSupportedTypeIdx;
-        enc_cfg_param *pEncCfgLocal;
-        jpeg_enc_object *pEncObj;
-
-
-        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
-        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
-        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
-
-    };
-};
-
-#endif
diff --git a/mx6/libcamera/NV12_resize.c b/mx6/libcamera/NV12_resize.c
new file mode 100644
index 0000000..cdd11bc
--- /dev/null
+++ b/mx6/libcamera/NV12_resize.c
@@ -0,0 +1,303 @@
+#include "NV12_resize.h"
+
+//#define LOG_NDEBUG 0
+#define LOG_NIDEBUG 0
+#define LOG_NDDEBUG 0
+
+#define LOG_TAG "NV12_resize"
+#define STRIDE 4096
+#include <utils/Log.h>
+
+/*==========================================================================
+* Function Name  : VT_resizeFrame_Video_opt2_lp
+*
+* Description    : Resize a yuv frame.
+*
+* Input(s)       : input_img_ptr        -> Input Image Structure
+*                : output_img_ptr       -> Output Image Structure
+*                : cropout             -> crop structure
+*
+* Value Returned : mmBool               -> FALSE on error TRUE on success
+* NOTE:
+*            Not tested for crop funtionallity.
+*            faster version.
+============================================================================*/
+mmBool
+VT_resizeFrame_Video_opt2_lp
+(
+ structConvImage* i_img_ptr,        /* Points to the input image           */
+ structConvImage* o_img_ptr,        /* Points to the output image          */
+ IC_rect_type*  cropout,          /* how much to resize to in final image */
+ mmUint16 dummy                         /* Transparent pixel value              */
+ )
+{
+  ALOGV("VT_resizeFrame_Video_opt2_lp+");
+
+  mmUint16 row,col;
+  mmUint32 resizeFactorX;
+  mmUint32 resizeFactorY;
+
+
+  mmUint16 x, y;
+
+  mmUchar* ptr8;
+  mmUchar *ptr8Cb, *ptr8Cr;
+
+
+  mmUint16 xf, yf;
+  mmUchar* inImgPtrY;
+  mmUchar* inImgPtrU;
+  mmUchar* inImgPtrV;
+  mmUint32 cox, coy, codx, cody;
+  mmUint16 idx,idy, idxC;
+
+  if(i_img_ptr->uWidth == o_img_ptr->uWidth)
+	{
+		if(i_img_ptr->uHeight == o_img_ptr->uHeight)
+			{
+				ALOGV("************************f(i_img_ptr->uHeight == o_img_ptr->uHeight) are same *********************\n");
+				ALOGV("************************(i_img_ptr->width == %d" , i_img_ptr->uWidth );
+				ALOGV("************************(i_img_ptr->uHeight == %d" , i_img_ptr->uHeight );
+				ALOGV("************************(o_img_ptr->width == %d" ,o_img_ptr->uWidth );
+				ALOGV("************************(o_img_ptr->uHeight == %d" , o_img_ptr->uHeight );
+			}
+	}
+
+  if (!i_img_ptr || !i_img_ptr->imgPtr ||
+    !o_img_ptr || !o_img_ptr->imgPtr)
+  {
+	ALOGE("Image Point NULL");
+	ALOGV("VT_resizeFrame_Video_opt2_lp-");
+	return FALSE;
+  }
+  inImgPtrY = (mmUchar *) i_img_ptr->imgPtr + i_img_ptr->uOffset;
+  inImgPtrU = (mmUchar *) i_img_ptr->clrPtr + i_img_ptr->uOffset/2;
+  inImgPtrV = (mmUchar*)inImgPtrU + 1;
+
+  if (cropout == NULL)
+  {
+    cox = 0;
+    coy = 0;
+    codx = o_img_ptr->uWidth;
+    cody = o_img_ptr->uHeight;
+  }
+  else
+  {
+    cox = cropout->x;
+    coy = cropout->y;
+    codx = cropout->uWidth;
+    cody = cropout->uHeight;
+  }
+  idx = i_img_ptr->uWidth;
+  idy = i_img_ptr->uHeight;
+
+  /* make sure valid input size */
+  if (idx < 1 || idy < 1 || i_img_ptr->uStride < 1)
+	{
+	ALOGE("idx or idy less then 1 idx = %d idy = %d stride = %d", idx, idy, i_img_ptr->uStride);
+	ALOGV("VT_resizeFrame_Video_opt2_lp-");
+	return FALSE;
+	}
+
+  resizeFactorX = ((idx-1)<<9) / codx;
+  resizeFactorY = ((idy-1)<<9) / cody;
+
+  if(i_img_ptr->eFormat == IC_FORMAT_YCbCr420_lp &&
+    o_img_ptr->eFormat == IC_FORMAT_YCbCr420_lp)
+  {
+    ptr8 = (mmUchar*)o_img_ptr->imgPtr + cox + coy*o_img_ptr->uWidth;
+
+
+    ////////////////////////////for Y//////////////////////////
+    for (row=0; row < cody; row++)
+    {
+        mmUchar *pu8Yrow1 = NULL;
+        mmUchar *pu8Yrow2 = NULL;
+        y  = (mmUint16) ((mmUint32) (row*resizeFactorY) >> 9);
+        yf = (mmUchar)  ((mmUint32)((row*resizeFactorY) >> 6) & 0x7);
+        pu8Yrow1 = inImgPtrY + (y) * i_img_ptr->uStride;
+        pu8Yrow2 = pu8Yrow1 + i_img_ptr->uStride;
+
+        for (col=0; col < codx; col++)
+        {
+            mmUchar in11, in12, in21, in22;
+            mmUchar *pu8ptr1 = NULL;
+            mmUchar *pu8ptr2 = NULL;
+            mmUchar w;
+            mmUint16 accum_1;
+            //mmUint32 accum_W;
+
+
+
+            x  = (mmUint16) ((mmUint32)  (col*resizeFactorX) >> 9);
+            xf = (mmUchar)  ((mmUint32) ((col*resizeFactorX) >> 6) & 0x7);
+
+
+            //accum_W = 0;
+            accum_1 =  0;
+
+            pu8ptr1 = pu8Yrow1 + (x);
+            pu8ptr2 = pu8Yrow2 + (x);
+
+            /* A pixel */
+            //in = *(inImgPtrY + (y)*idx + (x));
+            in11 = *(pu8ptr1);
+
+            w = bWeights[xf][yf][0];
+            accum_1 = (w * in11);
+            //accum_W += (w);
+
+            /* B pixel */
+            //in = *(inImgPtrY + (y)*idx + (x+1));
+            in12 = *(pu8ptr1+1);
+            w = bWeights[xf][yf][1];
+            accum_1 += (w * in12);
+            //accum_W += (w);
+
+            /* C pixel */
+            //in = *(inImgPtrY + (y+1)*idx + (x));
+            in21 = *(pu8ptr2);
+            w = bWeights[xf][yf][3];
+            accum_1 += (w * in21);
+            //accum_W += (w);
+
+            /* D pixel */
+            //in = *(inImgPtrY + (y+1)*idx + (x+1));
+            in22 = *(pu8ptr2+1);
+            w = bWeights[xf][yf][2];
+            accum_1 += (w * in22);
+            //accum_W += (w);
+
+            /* divide by sum of the weights */
+            //accum_1 /= (accum_W);
+            //accum_1 = (accum_1/64);
+            accum_1 = (accum_1>>6);
+            *ptr8 = (mmUchar)accum_1 ;
+
+
+            ptr8++;
+        }
+        ptr8 = ptr8 + (o_img_ptr->uStride - codx);
+    }
+    ////////////////////////////for Y//////////////////////////
+
+    ///////////////////////////////for Cb-Cr//////////////////////
+
+    ptr8Cb = (mmUchar*)o_img_ptr->clrPtr + cox + coy*o_img_ptr->uWidth;
+
+    ptr8Cr = (mmUchar*)(ptr8Cb+1);
+
+    idxC = (idx>>1);
+    for (row=0; row < (((cody)>>1)); row++)
+    {
+        mmUchar *pu8Cbr1 = NULL;
+        mmUchar *pu8Cbr2 = NULL;
+        mmUchar *pu8Crr1 = NULL;
+        mmUchar *pu8Crr2 = NULL;
+
+        y  = (mmUint16) ((mmUint32) (row*resizeFactorY) >> 9);
+        yf = (mmUchar)  ((mmUint32)((row*resizeFactorY) >> 6) & 0x7);
+
+        pu8Cbr1 = inImgPtrU + (y) * i_img_ptr->uStride;
+        pu8Cbr2 = pu8Cbr1 + i_img_ptr->uStride;
+        pu8Crr1 = inImgPtrV + (y) * i_img_ptr->uStride;
+        pu8Crr2 = pu8Crr1 + i_img_ptr->uStride;
+
+        for (col=0; col < (((codx)>>1)); col++)
+        {
+            mmUchar in11, in12, in21, in22;
+            mmUchar *pu8Cbc1 = NULL;
+            mmUchar *pu8Cbc2 = NULL;
+            mmUchar *pu8Crc1 = NULL;
+            mmUchar *pu8Crc2 = NULL;
+
+            mmUchar w;
+            mmUint16 accum_1Cb, accum_1Cr;
+            //mmUint32 accum_WCb, accum_WCr;
+
+
+            x  = (mmUint16) ((mmUint32)  (col*resizeFactorX) >> 9);
+            xf = (mmUchar)  ((mmUint32) ((col*resizeFactorX) >> 6) & 0x7);
+
+
+            //accum_WCb = accum_WCr =  0;
+            accum_1Cb = accum_1Cr =  0;
+
+            pu8Cbc1 = pu8Cbr1 + (x*2);
+            pu8Cbc2 = pu8Cbr2 + (x*2);
+	    pu8Crc1 = pu8Crr1 + (x*2);
+            pu8Crc2 = pu8Crr2 + (x*2);
+
+            /* A pixel */
+            w = bWeights[xf][yf][0];
+
+            in11 = *(pu8Cbc1);
+            accum_1Cb = (w * in11);
+            //    accum_WCb += (w);
+
+			in11 = *(pu8Crc1);
+            accum_1Cr = (w * in11);
+            //accum_WCr += (w);
+
+            /* B pixel */
+            w = bWeights[xf][yf][1];
+
+            in12 = *(pu8Cbc1+2);
+            accum_1Cb += (w * in12);
+            //accum_WCb += (w);
+
+            in12 = *(pu8Crc1+2);
+            accum_1Cr += (w * in12);
+            //accum_WCr += (w);
+
+            /* C pixel */
+            w = bWeights[xf][yf][3];
+
+            in21 = *(pu8Cbc2);
+            accum_1Cb += (w * in21);
+            //accum_WCb += (w);
+
+			in21 = *(pu8Crc2);
+            accum_1Cr += (w * in21);
+            //accum_WCr += (w);
+
+            /* D pixel */
+            w = bWeights[xf][yf][2];
+
+            in22 = *(pu8Cbc2+2);
+            accum_1Cb += (w * in22);
+            //accum_WCb += (w);
+
+            in22 = *(pu8Crc2+2);
+            accum_1Cr += (w * in22);
+            //accum_WCr += (w);
+
+            /* divide by sum of the weights */
+            //accum_1Cb /= (accum_WCb);
+            accum_1Cb = (accum_1Cb>>6);
+            *ptr8Cb = (mmUchar)accum_1Cb ;
+
+            accum_1Cr = (accum_1Cr >> 6);
+            *ptr8Cr = (mmUchar)accum_1Cr ;
+
+            ptr8Cb++;
+            ptr8Cr++;
+
+            ptr8Cb++;
+            ptr8Cr++;
+        }
+        ptr8Cb = ptr8Cb + (o_img_ptr->uStride-codx);
+        ptr8Cr = ptr8Cr + (o_img_ptr->uStride-codx);
+    }
+    ///////////////////For Cb- Cr////////////////////////////////////////
+  }
+  else
+  {
+	ALOGE("eFormat not supported");
+	ALOGV("VT_resizeFrame_Video_opt2_lp-");
+	return FALSE;
+  }
+  ALOGV("success");
+  ALOGV("VT_resizeFrame_Video_opt2_lp-");
+  return TRUE;
+}
diff --git a/mx6/libcamera/NV12_resize.h b/mx6/libcamera/NV12_resize.h
new file mode 100755
index 0000000..927faf8
--- /dev/null
+++ b/mx6/libcamera/NV12_resize.h
@@ -0,0 +1,148 @@
+#ifndef NV12_RESIZE_H_
+#define NV12_RESIZE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef unsigned char       mmBool;
+typedef unsigned char       mmUchar;
+typedef unsigned char       mmUint8;
+typedef unsigned char       mmByte;
+typedef unsigned short      mmUint16;
+typedef unsigned int        mmUint32;
+typedef unsigned long       mmUint64;
+typedef signed char         mmInt8;
+typedef char		        mmChar;
+typedef signed short        mmInt16;
+typedef signed int          mmInt32;
+typedef signed long         mmLong;
+typedef signed int          mmHandle;
+typedef float        mmFloat;
+typedef double       mmDouble;
+typedef int 		    HObj;
+typedef HObj		    HFile;
+typedef int 		    HDir;
+typedef void* mmMutexHandle;
+typedef struct _fstat
+{
+      mmInt32 fileSize;
+}VE_FileAttribute;
+
+typedef struct
+{
+	mmInt32		second;
+	mmInt32 	millisecond;
+}tsVE_Time;
+
+typedef struct
+{
+	mmInt32 	year;
+	mmInt32 	month;
+	mmInt32 	day;
+	mmInt32 	hour;
+	mmInt32 	minute;
+	mmInt32 	second;
+} TmDateTime;
+
+/*----------------------------------------------------------------------------
+    Define : TRUE/FALSE for boolean operations
+----------------------------------------------------------------------------*/
+
+#ifndef TRUE
+    #define TRUE    1
+#endif
+
+#ifndef FALSE
+    #define FALSE   0
+#endif
+
+#ifndef NULL
+   #define NULL        0
+#endif
+
+const mmUint8 bWeights[8][8][4] = {
+  {{64, 0, 0, 0}, {56, 0, 0, 8}, {48, 0, 0,16}, {40, 0, 0,24},
+   {32, 0, 0,32}, {24, 0, 0,40}, {16, 0, 0,48}, { 8, 0, 0,56}},
+
+  {{56, 8, 0, 0}, {49, 7, 1, 7}, {42, 6, 2,14}, {35, 5, 3,21},
+   {28, 4, 4,28}, {21, 3, 5,35}, {14, 2, 6,42}, { 7, 1, 7,49}},
+
+  {{48,16, 0, 0}, {42,14, 2, 6}, {36,12,4 ,12}, {30,10,6 ,18},
+   {24, 8, 8,24}, {18, 6,10,30}, {12,4 ,12,36}, { 6, 2,14,42}},
+
+  {{40,24,0 ,0 }, {35,21, 3, 5}, {30,18, 6,10}, {25,15, 9,15},
+   {20,12,12,20}, {15, 9,15,25}, {10, 6,18,30}, { 5, 3,21,35}},
+
+  {{32,32, 0,0 }, {28,28, 4, 4}, {24,24, 8, 8}, {20,20,12,12},
+   {16,16,16,16}, {12,12,20,20}, { 8, 8,24,24}, { 4, 4,28,28}},
+
+  {{24,40,0 ,0 }, {21,35, 5, 3}, {18,30,10, 6}, {15,25,15, 9},
+   {12,20,20,12}, { 9,15,25,15}, { 6,10,30,18}, { 3, 5,35,21}},
+
+  {{16,48, 0,0 }, {14,42, 6, 2}, {12,36,12, 4}, {10,30,18, 6},
+   {8 ,24,24,8 }, { 6,18,30,10}, { 4,12,36,12}, { 2, 6,42,14}},
+
+  {{ 8,56, 0,0 }, { 7,49, 7, 1}, { 6,42,14, 2}, { 5,35,21, 3},
+   { 4,28,28,4 }, { 3,21,35, 5}, { 2,14,42, 6}, { 1,7 ,49, 7}}
+};
+
+typedef enum
+{
+    IC_FORMAT_NONE,
+    IC_FORMAT_RGB565,
+    IC_FORMAT_RGB888,
+    IC_FORMAT_YCbCr420_lp,
+    IC_FORMAT_YCbCr,
+    IC_FORMAT_YCbCr420_FRAME_PK,
+    IC_FORMAT_MAX
+}enumImageFormat;
+
+/* This structure defines the format of an image */
+typedef struct
+{
+  mmInt32                       uWidth;
+  mmInt32                       uHeight;
+  mmInt32                       uStride;
+  enumImageFormat               eFormat;
+  mmByte                        *imgPtr;
+  mmByte                        *clrPtr;
+  mmInt32                       uOffset;
+} structConvImage;
+
+typedef struct IC_crop_struct
+{
+  mmUint32 x;             /* x pos of rectangle                              */
+  mmUint32 y;             /* y pos of rectangle                              */
+  mmUint32 uWidth;        /* dx of rectangle                                 */
+  mmUint32 uHeight;       /* dy of rectangle                                 */
+} IC_rect_type;
+
+/*==========================================================================
+* Function Name  : VT_resizeFrame_Video_opt2_lp
+*
+* Description    : Resize a yuv frame.
+*
+* Input(s)       : input_img_ptr        -> Input Image Structure
+*                : output_img_ptr       -> Output Image Structure
+*                : cropout             -> crop structure
+*
+* Value Returned : mmBool               -> FALSE on error TRUE on success
+* NOTE:
+*            Not tested for crop funtionallity.
+*            faster version.
+============================================================================*/
+mmBool
+VT_resizeFrame_Video_opt2_lp
+(
+ structConvImage* i_img_ptr,        /* Points to the input image           */
+ structConvImage* o_img_ptr,        /* Points to the output image          */
+ IC_rect_type*  cropout,          /* how much to resize to in final image */
+ mmUint16 dummy                         /* Transparent pixel value              */
+ );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //#define NV12_RESIZE_H_
diff --git a/mx6/libcamera/OvDevice.cpp b/mx6/libcamera/OvDevice.cpp
new file mode 100755
index 0000000..39e01d2
--- /dev/null
+++ b/mx6/libcamera/OvDevice.cpp
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "CameraUtil.h"
+#include "OvDevice.h"
+
+PixelFormat OvDevice::getMatchFormat(int* sfmt, int slen, int* dfmt, int dlen)
+{
+    if(sfmt == NULL || slen == 0 || dfmt == NULL || dlen == 0) {
+        FLOGE("setSupportedPreviewFormats invalid parameters");
+        return 0;
+    }
+
+    PixelFormat matchFormat = 0;
+    bool live = true;
+    for(int i=0; i<slen && live; i++) {
+        for(int j=0; j<dlen; j++) {
+            FLOG_RUNTIME("sfmt[%d]=%c%c%c%c, dfmt[%d]=%c%c%c%c", i, sfmt[i]&0xFF,
+                (sfmt[i]>>8)&0xFF, (sfmt[i]>>16)&0xFF, (sfmt[i]>>24)&0xFF, j,
+                dfmt[j]&0xFF, (dfmt[j]>>8)&0xFF, (dfmt[j]>>16)&0xFF, (dfmt[j]>>24)&0xFF);
+            if(sfmt[i] == dfmt[j]) {
+                matchFormat = convertV4L2FormatToPixelFormat(dfmt[j]);
+                live = false;
+                break;
+            }
+        }
+    }
+
+    return matchFormat;
+}
+
+status_t OvDevice::setSupportedPreviewFormats(int* sfmt, int slen, int* dfmt, int dlen)
+{
+    if(sfmt == NULL || slen == 0 || dfmt == NULL || dlen == 0) {
+        FLOGE("setSupportedPreviewFormats invalid parameters");
+        return BAD_VALUE;
+    }
+
+    char fmtStr[FORMAT_STRING_LEN];
+    memset(fmtStr, 0, FORMAT_STRING_LEN);
+    for(int i = 0; i < slen; i++) {
+        for (int j = 0; j < dlen; j++) {
+            //should report VPU support format.
+            if(sfmt[i] == dfmt[j]) {
+                if(sfmt[i] == v4l2_fourcc('Y','U','1','2')) {
+                    strcat(fmtStr, "yuv420p");
+                    strcat(fmtStr, ",");
+                }
+                else if(sfmt[i] == v4l2_fourcc('N','V','1','2')) {
+                    strcat(fmtStr, "yuv420sp");
+                    strcat(fmtStr, ",");
+                }
+                else if(sfmt[i] == v4l2_fourcc('Y','U','Y','V')) {
+                    strcat(fmtStr, "yuv422i-yuyv");
+                    strcat(fmtStr, ",");
+                }
+            }
+        }
+    }
+    mParams.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
+
+    return NO_ERROR;
+}
+
+status_t OvDevice::setPreviewStringFormat(PixelFormat format)
+{
+    const char* pformat = NULL;
+    if(format == HAL_PIXEL_FORMAT_YCbCr_420_P) {
+        pformat = "yuv420p";
+    }
+    else if(format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
+        pformat = "yuv420sp";
+    }
+    else if(format == HAL_PIXEL_FORMAT_YCbCr_422_I) {
+        pformat = "yuv422i-yuyv";
+    }
+    else {
+        FLOGE("format %d is not supported", format);
+        return BAD_VALUE;
+    }
+
+    mParams.setPreviewFormat(pformat);
+    mParams.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, pformat);
+    return NO_ERROR;
+}
+
+status_t OvDevice::initParameters(CameraParameters& params, int* supportRecordingFormat, int rfmtLen,
+                        int* supportPictureFormat, int pfmtLen)
+{
+    if(mCameraHandle < 0) {
+        FLOGE("OvDevice: initParameters sensor has not been opened");
+        return BAD_VALUE;
+    }
+    if(supportRecordingFormat == NULL || rfmtLen == 0 ||
+            supportPictureFormat == NULL || pfmtLen == 0) {
+        FLOGE("OvDevice: initParameters invalid parameters");
+        return BAD_VALUE;
+    }
+
+    //first read sensor format.
+    int ret = 0, index = 0;
+    int sensorFormat[MAX_SENSOR_FORMAT];
+#if 0
+    struct v4l2_fmtdesc vid_fmtdesc;
+    while(ret == 0) {
+        vid_fmtdesc.index = index;
+        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        ret = ioctl(mCameraHandle, VIDIOC_ENUM_FMT, &vid_fmtdesc);
+        FLOG_RUNTIME("index:%d,ret:%d, format:%c%c%c%c", index, ret, 
+             vid_fmtdesc.pixelformat&0xFF, (vid_fmtdesc.pixelformat>>8)&0xFF,
+            (vid_fmtdesc.pixelformat>>16)&0xFF, (vid_fmtdesc.pixelformat>>24)&0xFF);
+        if(ret == 0) {
+            sensorFormat[index++] = vid_fmtdesc.pixelformat;
+        }
+    }
+#endif
+    //v4l2 does not support enum format, now hard code here.
+    sensorFormat[0] = v4l2_fourcc('N','V','1','2');
+    sensorFormat[1] = v4l2_fourcc('Y','U','1','2');
+    sensorFormat[2] = v4l2_fourcc('Y','U','Y','V');
+    index = 3;
+    //second check match sensor format with vpu support format and picture format.
+    mPreviewPixelFormat = getMatchFormat(supportRecordingFormat, rfmtLen, sensorFormat, index);
+    mPicturePixelFormat = getMatchFormat(supportPictureFormat, pfmtLen, sensorFormat, index);
+    setPreviewStringFormat(mPreviewPixelFormat);
+    ret = setSupportedPreviewFormats(supportRecordingFormat, rfmtLen, sensorFormat, index);
+    if(ret) {
+        FLOGE("setSupportedPreviewFormats failed");
+        return ret;
+    }
+
+    index = 0;
+    char TmpStr[20];
+    int  previewCnt= 0, pictureCnt = 0;
+    struct v4l2_frmsizeenum vid_frmsize;
+    struct v4l2_frmivalenum vid_frmval;
+    while(ret == 0) {
+        memset(TmpStr, 0, 20);
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = index ++;
+        vid_frmsize.pixel_format = v4l2_fourcc('N','V','1','2');
+        ret = ioctl(mCameraHandle, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize);
+        if(ret == 0) {
+            FLOG_RUNTIME("enum frame size w:%d, h:%d",
+                vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
+            vid_frmval.index = 0;
+            vid_frmval.pixel_format = vid_frmsize.pixel_format;
+            vid_frmval.width = vid_frmsize.discrete.width;
+            vid_frmval.height= vid_frmsize.discrete.height;
+
+            //ret = ioctl(mCameraHandle, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval);
+            //v4l2 does not support, now hard code here.
+            if(ret == 0) {
+                FLOG_RUNTIME("vid_frmval denominator:%d, numeraton:%d",
+                   vid_frmval.discrete.denominator, vid_frmval.discrete.numerator);
+                if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720) {
+                    vid_frmval.discrete.denominator = 15;
+                    vid_frmval.discrete.numerator = 1;
+                }
+                else {
+                    vid_frmval.discrete.denominator = 30;
+                    vid_frmval.discrete.numerator = 1;
+                }
+
+                sprintf(TmpStr, "%dx%d", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+                if (pictureCnt == 0)
+                    strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                else{
+                    strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                }
+                pictureCnt ++;
+
+                if (vid_frmval.discrete.denominator/vid_frmval.discrete.numerator >= 15){
+                    if (previewCnt == 0)
+                        strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                    else{
+                        strncat(mSupportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                        strncat(mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                    }
+                    previewCnt ++;
+                }
+            }
+        }
+    }//end while
+
+    strcpy(mSupportedFPS, "15,30");
+    FLOGI("SupportedPictureSizes is %s", mSupportedPictureSizes);
+    FLOGI("SupportedPreviewSizes is %s", mSupportedPreviewSizes);
+    FLOGI("SupportedFPS is %s", mSupportedFPS);
+
+    mParams.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
+    mParams.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
+    mParams.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
+    mParams.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(12000,17000),(25000,33000)");
+    mParams.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
+
+    mParams.setPreviewSize(DEFAULT_PREVIEW_W, DEFAULT_PREVIEW_H);
+    mParams.setPictureSize(DEFAULT_PICTURE_W, DEFAULT_PICTURE_H);
+    mParams.setPreviewFrameRate(DEFAULT_PREVIEW_FPS);
+
+    params = mParams;
+    return NO_ERROR;
+}
+
+status_t OvDevice::setParameters(CameraParameters& params)
+{
+    int w, h;
+    int framerate, local_framerate;
+    int max_zoom,zoom, max_fps, min_fps;
+    char tmp[128];
+
+    Mutex::Autolock lock(mLock);
+
+    max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
+    zoom = params.getInt(CameraParameters::KEY_ZOOM);
+    if(zoom > max_zoom){
+        FLOGE("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
+        return BAD_VALUE;
+    }
+    if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
+            (strcmp(params.getPreviewFormat(), "yuv420p") == 0) ||
+            (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0))) {
+        FLOGE("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
+        return BAD_VALUE;
+    }
+
+    if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
+        FLOGE("Only jpeg still pictures are supported");
+        return BAD_VALUE;
+    }
+
+    params.getPreviewSize(&w, &h);
+    sprintf(tmp, "%dx%d", w, h);
+    FLOGI("Set preview size: %s", tmp);
+    if (strstr(mSupportedPreviewSizes, tmp) == NULL){
+        FLOGE("The preview size w %d, h %d is not corrected", w, h);
+        return BAD_VALUE;
+    }
+
+    params.getPictureSize(&w, &h);
+    sprintf(tmp, "%dx%d", w, h);
+    FLOGI("Set picture size: %s", tmp);
+    if (strstr(mSupportedPictureSizes, tmp) == NULL){
+        FLOGE("The picture size w %d, h %d is not corrected", w, h);
+        return BAD_VALUE;
+    }
+
+    local_framerate = params.getPreviewFrameRate();
+    FLOGI("get local frame rate:%d FPS", local_framerate);
+    if ((local_framerate > 30) || (local_framerate < 0) ){
+        FLOGE("The framerate is not corrected");
+        local_framerate = 15;
+    }
+
+    framerate = params.getPreviewFrameRate();
+    FLOGI("Set frame rate:%d FPS", framerate);
+    if ((framerate > 30) || (framerate < 0) ){
+        FLOGE("The framerate is not corrected");
+        return BAD_VALUE;
+    }
+    else if(local_framerate != framerate) {
+        if(framerate == 15) {
+            params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "12000,17000");
+        }
+        else if (framerate == 30) {
+            params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
+        }
+    }
+
+    int actual_fps = 15;
+    params.getPreviewFpsRange(&min_fps, &max_fps);
+    FLOGI("FPS range: %d - %d",min_fps, max_fps);
+    if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
+        FLOGE("The fps range from %d to %d is error", min_fps, max_fps);
+        return BAD_VALUE;
+    }
+    actual_fps = min_fps > 15000? 30:15;
+    FLOGI("setParameters: actual_fps=%d", actual_fps);
+    params.setPreviewFrameRate(actual_fps);
+
+    mParams = params;
+    return NO_ERROR;
+}
diff --git a/mx6/libcamera/OvDevice.h b/mx6/libcamera/OvDevice.h
new file mode 100755
index 0000000..a4f44fc
--- /dev/null
+++ b/mx6/libcamera/OvDevice.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _OV_DEVICE_H_
+#define _OV_DEVICE_H_
+
+#include "CameraUtil.h"
+#include "DeviceAdapter.h"
+
+#define DEFAULT_PREVIEW_FPS (15)
+#define DEFAULT_PREVIEW_W   (640)
+#define DEFAULT_PREVIEW_H   (480)
+#define DEFAULT_PICTURE_W   (640)
+#define DEFAULT_PICTURE_H   (480)
+#define MAX_SENSOR_FORMAT 20
+#define FORMAT_STRING_LEN 64
+
+class OvDevice : public DeviceAdapter
+{
+public:
+    virtual status_t initParameters(CameraParameters& params, int* supportRecordingFormat, int rfmtLen,
+                        int* supportPictureFormat, int pfmtLen);
+    virtual status_t setParameters(CameraParameters& params);
+
+private:
+    PixelFormat getMatchFormat(int* sfmt, int slen, int* dfmt, int dlen);
+    status_t setSupportedPreviewFormats(int* sfmt, int slen, int* dfmt, int dlen);
+    status_t setPreviewStringFormat(PixelFormat format);
+
+private:
+    char mSupportedFPS[MAX_SENSOR_FORMAT];
+    char mSupportedPictureSizes[CAMER_PARAM_BUFFER_SIZE];
+    char mSupportedPreviewSizes[CAMER_PARAM_BUFFER_SIZE];
+};
+
+#endif
diff --git a/mx6/libcamera/PP_ipulib.cpp b/mx6/libcamera/PP_ipulib.cpp
deleted file mode 100755
index 07e72a4..0000000
--- a/mx6/libcamera/PP_ipulib.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include "PP_ipulib.h"
-#include <stdlib.h>
-#include <string.h>
-
-namespace android{
-
-    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
-
-    PPIpuLib :: PPIpuLib(){
-        return;
-    }
-
-    PPIpuLib :: ~PPIpuLib(){
-
-        singleton.clear();
-    }
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-        //Setting input format
-        mIPUInputParam.width = pp_input->width;
-        mIPUInputParam.height = pp_input->height;
-
-        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
-        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
-        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
-        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
-        mIPUInputParam.fmt = pp_input->fmt;
-        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
-
-        //Setting output format
-        mIPUOutputParam.fmt = pp_output->fmt;
-        mIPUOutputParam.width = pp_output->width;
-        mIPUOutputParam.height = pp_output->height;   
-        mIPUOutputParam.show_to_fb = 0;
-        //Output param should be same as input, since no resize,crop
-        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
-        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
-        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
-        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
-        mIPUOutputParam.rot = pp_output->rot;
-        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
-        CAMERA_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                mIPUOutputParam.width,
-                mIPUOutputParam.height,
-                mIPUOutputParam.output_win.pos.x,
-                mIPUOutputParam.output_win.pos.y,
-                mIPUOutputParam.output_win.win_w,
-                mIPUOutputParam.output_win.win_h,
-                mIPUOutputParam.rot);
-
-        CAMERA_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                mIPUInputParam.width,
-                mIPUInputParam.height,
-                mIPUInputParam.fmt,
-                mIPUInputParam.input_crop_win.pos.x,
-                mIPUInputParam.input_crop_win.pos.y,
-                mIPUInputParam.input_crop_win.win_w,
-                mIPUInputParam.input_crop_win.win_h);	  
-
-        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-        if (mIPURet < 0) {
-            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
-            return PPDEVICE_ERROR_INIT;
-        }  
-
-        return ret;
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
-
-        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
-
-        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset, 0,NULL,NULL);
-        if (mIPURet < 0) {
-            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
-            mxc_ipu_lib_task_uninit(&mIPUHandle);
-            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-            return PPDEVICE_ERROR_PROCESS;
-        }
-
-        return ret;
-
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
-        CAMERA_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        mxc_ipu_lib_task_uninit(&mIPUHandle);
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-
-        return ret;
-    }
-
-    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
-        CAMERA_LOG_FUNC;
-        if (singleton != 0) {
-            sp<PostProcessDeviceInterface> device = singleton.promote();
-            if (device != 0) {
-                return device;
-            }
-        }
-        sp<PostProcessDeviceInterface> device(new PPIpuLib());
-
-        singleton = device;
-        return device;
-    }
-
-};
diff --git a/mx6/libcamera/PP_ipulib.h b/mx6/libcamera/PP_ipulib.h
deleted file mode 100755
index ee5fe03..0000000
--- a/mx6/libcamera/PP_ipulib.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef PP_IPU_LIB_H
-#define PP_IPU_LIB_H
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-#include "PostProcessDeviceInterface.h"
-
-namespace android{
-    class PPIpuLib : public PostProcessDeviceInterface
-    {
-    public:
-        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
-        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
-        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
-        static sp<PostProcessDeviceInterface> createInstance();
-    private:
-        PPIpuLib();
-        virtual ~PPIpuLib();
-        static wp<PostProcessDeviceInterface> singleton;
-
-        ipu_lib_input_param_t mIPUInputParam;	
-        ipu_lib_output_param_t mIPUOutputParam; 
-        ipu_lib_handle_t			mIPUHandle;
-    };
-};
-#endif
diff --git a/mx6/libcamera/PhysMemAdapter.cpp b/mx6/libcamera/PhysMemAdapter.cpp
new file mode 100644
index 0000000..2b492a7
--- /dev/null
+++ b/mx6/libcamera/PhysMemAdapter.cpp
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "PhysMemAdapter.h"
+#include <ion/ion.h>
+
+PhysMemAdapter::PhysMemAdapter()
+    : mIonFd(-1), mFrameWidth(0), mFrameHeight(0),
+      mBufferCount(0), mBufferSize(0), mFormat(0), mQueueableCount(0)
+{
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+    mIonFd = ion_open();
+}
+
+PhysMemAdapter::~PhysMemAdapter()
+{
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+    clearBufferListeners();
+    ion_close(mIonFd);
+}
+
+int PhysMemAdapter::allocatePreviewBuffer(int width, int height, int format, int numBufs)
+{
+    return BAD_VALUE;
+}
+
+int PhysMemAdapter::allocatePictureBuffer(int width, int height, int format, int numBufs)
+{
+    if(mIonFd <= 0) {
+        FLOGE("try to allocate buffer from ion in preview or ion invalid");
+        return BAD_VALUE;
+    }
+
+    int size = 0;
+    if(width == 0 || height == 0) {
+        FLOGE("allocateBufferFromIon: width or height = 0");
+        return BAD_VALUE;
+    }
+    switch(format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+            size = width * ((height + 16)&(~15)) * 3/2;
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_P:
+            size = width * height * 3/2;
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_422_I:
+            size = width * height * 2;
+            break;
+        default:
+            FLOGE("Error: format not supported int ion alloc");
+            return BAD_VALUE;
+    }
+
+    unsigned char *ptr = NULL;
+    int sharedFd;
+    int phyAddr;
+    struct ion_handle * ionHandle;
+    size = (size + PAGE_SIZE)&(~(PAGE_SIZE-1));
+
+    FLOGI("allocateBufferFromIon buffer num:%d", numBufs);
+    for(int i = 0; i < numBufs; i++) {
+        ionHandle = NULL;
+        int err = ion_alloc(mIonFd, size, 8, 1, &ionHandle);
+        if(err) {
+            FLOGE("ion_alloc failed.");
+            return BAD_VALUE;
+        }
+
+        err = ion_map(mIonFd, ionHandle, size, PROT_READ|PROT_WRITE, MAP_SHARED, 0, &ptr, &sharedFd);
+        if(err) {
+            FLOGE("ion_map failed.");
+            return BAD_VALUE;
+        }
+        phyAddr = ion_phys(mIonFd, ionHandle);
+        if(phyAddr == 0) {
+            FLOGE("ion_phys failed.");
+            return BAD_VALUE;
+        }
+        FLOG_RUNTIME("phyalloc ptr:0x%x, phy:0x%x, size:%d", (int)ptr, phyAddr, size);
+        mCameraBuffer[i].reset();
+        mCameraBuffer[i].mIndex = i;
+        mCameraBuffer[i].mWidth = width;
+        mCameraBuffer[i].mHeight = height;
+        mCameraBuffer[i].mFormat = format;
+        mCameraBuffer[i].mVirtAddr = ptr;
+        mCameraBuffer[i].mPhyAddr = phyAddr;
+        mCameraBuffer[i].mSize =  size;
+        mCameraBuffer[i].mBufHandle = (buffer_handle_t*)ionHandle;
+        close(sharedFd);
+    }
+
+    mBufferCount = numBufs;
+    mQueueableCount = numBufs;
+    mFormat = format;
+    mBufferSize = mCameraBuffer[0].mSize;
+    mFrameWidth = width;
+    mFrameHeight = height;
+
+    dispatchBuffers(&mCameraBuffer[0], numBufs, BUFFER_CREATE);
+
+    return NO_ERROR;
+
+}
+
+int PhysMemAdapter::freeBuffer()
+{
+    if(mIonFd <= 0) {
+        FLOGE("try to free buffer from ion in preview or ion invalid");
+        return BAD_VALUE;
+    }
+
+    FLOGI("freeBufferToIon buffer num:%d", mBufferCount);
+    for(int i = 0; i < mBufferCount; i++) {
+        struct ion_handle * ionHandle = (struct ion_handle *)mCameraBuffer[i].mBufHandle;
+        ion_free(mIonFd, ionHandle);
+        munmap(mCameraBuffer[i].mVirtAddr, mCameraBuffer[i].mSize);
+    }
+
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+    dispatchBuffers(NULL, 0, BUFFER_DESTROY);
+    return NO_ERROR;
+
+}
+
+int PhysMemAdapter::maxQueueableBuffers()
+{
+    return mQueueableCount;
+}
+
diff --git a/mx6/libcamera/PhysMemAdapter.h b/mx6/libcamera/PhysMemAdapter.h
new file mode 100644
index 0000000..4907675
--- /dev/null
+++ b/mx6/libcamera/PhysMemAdapter.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _PHYS_MEM_ADAPTER_H_
+#define _PHYS_MEM_ADAPTER_H_
+
+#include "CameraUtil.h"
+
+using namespace android;
+
+class PhysMemAdapter : public CameraBufferProvider
+{
+public:
+    PhysMemAdapter();
+    virtual ~PhysMemAdapter();
+
+    virtual int allocatePreviewBuffer(int width, int height, int format, int numBufs);
+    virtual int allocatePictureBuffer(int width, int height, int format, int numBufs);
+    virtual int freeBuffer();
+    virtual int maxQueueableBuffers();
+
+    //void setErrorListener(CameraErrorListener* listener);
+
+protected:
+    int mIonFd;
+    CameraErrorListener* mErrorListener;
+
+    CameraFrame mCameraBuffer[MAX_PREVIEW_BUFFER];
+
+    uint32_t mFrameWidth;
+    uint32_t mFrameHeight;
+    int mBufferCount;
+    int mBufferSize;
+    PixelFormat mFormat;
+    int mQueueableCount;
+};
+
+#endif
diff --git a/mx6/libcamera/PostProcessDeviceInterface.cpp b/mx6/libcamera/PostProcessDeviceInterface.cpp
deleted file mode 100755
index df3a494..0000000
--- a/mx6/libcamera/PostProcessDeviceInterface.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc.
- */
-#include "PP_ipulib.h" 
-namespace android{
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
-        return PPIpuLib :: createInstance();
-    }
-
-};
diff --git a/mx6/libcamera/PostProcessDeviceInterface.h b/mx6/libcamera/PostProcessDeviceInterface.h
deleted file mode 100755
index d7cf58a..0000000
--- a/mx6/libcamera/PostProcessDeviceInterface.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#ifndef POSTPROCESS_DEVICE_INTERFACE_H
-#define POSTPROCESS_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-#include <linux/videodev2.h>
-
-namespace android {
-
-    typedef enum{
-        PPDEVICE_ERROR_NONE = 0,
-        PPDEVICE_ERROR_INIT = -1,
-        PPDEVICE_ERROR_PROCESS  = -2,
-        PPDEVICE_ERROR_DEINIT = -3
-    }PPDEVICE_ERR_RET;
-
-    struct pp_fb_pos{
-        unsigned short x;
-        unsigned short y;
-    };
-
-    struct win_t{
-        struct pp_fb_pos pos;
-        unsigned int win_w;
-        unsigned int win_h;
-    } ;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        struct win_t input_crop_win;
-        int user_def_paddr;
-    } pp_input_param_t;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        unsigned int rot;
-        struct win_t output_win;
-        int user_def_paddr;
-    } pp_output_param_t;
-
-
-    class PostProcessDeviceInterface : public virtual RefBase{
-    public:
-        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
-        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
-        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
-
-        virtual ~PostProcessDeviceInterface(){}
-    }; 
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
-
-};
-#endif
-
diff --git a/mx6/libcamera/SurfaceAdapter.cpp b/mx6/libcamera/SurfaceAdapter.cpp
new file mode 100755
index 0000000..64f6cdc
--- /dev/null
+++ b/mx6/libcamera/SurfaceAdapter.cpp
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "SurfaceAdapter.h"
+
+SurfaceAdapter::SurfaceAdapter()
+    : mNativeWindow(NULL), mFrameWidth(0), mFrameHeight(0),
+      mBufferCount(0), mBufferSize(0), mFormat(0), mQueueableCount(0)
+{
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+}
+
+SurfaceAdapter::~SurfaceAdapter()
+{
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+    clearBufferListeners();
+}
+
+int SurfaceAdapter::setNativeWindowAttribute(int width, int height, int format, int numBufs)
+{
+    status_t err = NO_ERROR;
+
+    if(NULL == mNativeWindow) {
+        FLOGE("SurfaceAdapter: allocateBuffer invalid parameters");
+        return BAD_VALUE;
+    }
+
+    // Set gralloc usage bits for window.
+    err = mNativeWindow->set_usage(mNativeWindow, CAMERA_GRALLOC_USAGE);
+    if (err != 0) {
+        FLOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
+        if(ENODEV == err) {
+            FLOGE("Preview surface abandoned!");
+            mNativeWindow = NULL;
+        }
+
+        return BAD_VALUE;
+    }
+
+    FLOGI("Number of buffers set to NativeWindow %d", numBufs);
+    ///Set the number of buffers needed for camera preview
+    err = mNativeWindow->set_buffer_count(mNativeWindow, numBufs);
+    if(err != 0) {
+        FLOGE("native_window_set_buffer_count failed: %s (%d)", strerror(-err), -err);
+        if (ENODEV == err) {
+            FLOGE("Preview surface abandoned!");
+            mNativeWindow = NULL;
+        }
+
+        return BAD_VALUE;
+    }
+
+    // Set window geometry
+    err = mNativeWindow->set_buffers_geometry(mNativeWindow,
+            width, height, format);
+
+    if(err != 0) {
+        FLOGE("native_window_set_buffers_geometry failed: %s (%d)", strerror(-err), -err);
+        if(ENODEV == err) {
+            FLOGE("Preview surface abandoned!");
+            mNativeWindow = NULL;
+        }
+
+        return BAD_VALUE;
+    }
+
+
+    return err;
+}
+
+int SurfaceAdapter::allocatePreviewBuffer(int width, int height, int format, int numBufs)
+{
+    status_t err = NO_ERROR;
+    int undequeued = 0;
+
+    if(NULL == mNativeWindow || numBufs == 0) {
+        FLOGE("allocatePreviewBuffer invalid parameters");
+        return BAD_VALUE;
+    }
+
+    err = setNativeWindowAttribute(width, height, format, numBufs);
+    if(err) {
+        FLOGE("setNativeWindowAttribute failed.");
+        return err;
+    }
+
+    mBufferCount = numBufs;
+    mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow, &undequeued);
+    mQueueableCount = mBufferCount - undequeued;
+
+    err = allocateBuffer(width, height, format, numBufs, mQueueableCount);
+    return err;
+}
+
+int SurfaceAdapter::allocatePictureBuffer(int width, int height, int format, int numBufs)
+{
+    status_t err = NO_ERROR;
+
+    if(NULL == mNativeWindow || numBufs == 0) {
+        FLOGE("allocatePictureBuffer invalid parameters");
+        return BAD_VALUE;
+    }
+
+    err = setNativeWindowAttribute(width, height, format, numBufs);
+    if(err) {
+        FLOGE("setNativeWindowAttribute failed.");
+        return err;
+    }
+
+    mBufferCount = numBufs;
+    mQueueableCount = numBufs;
+
+    err = allocateBuffer(width, height, format, numBufs, mQueueableCount);
+    return err;
+}
+
+int SurfaceAdapter::allocateBuffer(int width, int height, int format, int numBufs, int maxQCount)
+{
+    status_t err;
+    int i = -1;
+    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+    Rect bounds;
+
+    if(NULL == mNativeWindow || numBufs == 0) {
+        FLOGE("allocateBuffer invalid parameters");
+        return BAD_VALUE;
+    }
+
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+   // lock the initial queueable buffers
+    bounds.left = 0;
+    bounds.top = 0;
+    bounds.right = width;
+    bounds.bottom = height;
+    void *pVaddr = NULL;
+    int stride = 0;
+
+    for(i=0; i < numBufs; i++) {
+        buffer_handle_t* buf_h = NULL;
+        stride = 0;
+        pVaddr = NULL;
+        // TODO(XXX): Do we need to keep stride information in camera hal?
+
+        err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
+        if(err != 0) {
+            FLOGE("dequeueBuffer failed: %s (%d)", strerror(-err), -err);
+            if(ENODEV == err) {
+                FLOGE("Preview surface abandoned!");
+                mNativeWindow = NULL;
+            }
+            goto fail;
+        }
+
+        mapper.lock(*buf_h, CAMERA_GRALLOC_USAGE, bounds, &pVaddr);
+        mCameraBuffer[i].initialize(buf_h, i);
+        mCameraBuffer[i].mWidth = width;
+        mCameraBuffer[i].mHeight = height;
+    }
+
+    for(i = 0; i < maxQCount; i++) {
+        mNativeWindow->lock_buffer(mNativeWindow, mCameraBuffer[i].mBufHandle);
+    }
+
+    // return the rest of the buffers back to ANativeWindow
+    for(i = maxQCount; i >= 0 && i < numBufs; i++) {
+        err = mNativeWindow->cancel_buffer(mNativeWindow, mCameraBuffer[i].mBufHandle);
+        if(err != 0) {
+            FLOGE("cancel_buffer failed: %s (%d)", strerror(-err), -err);
+            if(ENODEV == err) {
+                FLOGE("Preview surface abandoned!");
+                mNativeWindow = NULL;
+            }
+
+            goto fail;
+        }
+        mapper.unlock(*mCameraBuffer[i].mBufHandle);
+        //the frame held in SurfaceAdapter.
+        mCameraBuffer[i].addReference();
+    }
+
+    dispatchBuffers(&mCameraBuffer[0], numBufs, BUFFER_CREATE);
+
+    mFormat = format;
+    mBufferSize = mCameraBuffer[0].mSize;
+    mFrameWidth = width;
+    mFrameHeight = height;
+
+    return NO_ERROR;
+
+fail:
+    // need to cancel buffers if any were dequeued
+    for (int start = 0; start < i && i > 0; start++) {
+        int err = mNativeWindow->cancel_buffer(mNativeWindow, mCameraBuffer[start].mBufHandle);
+        if(err != 0) {
+            FLOGE("cancelBuffer failed w/ error 0x%08x", err);
+            break;
+        }
+    }
+
+    freeBuffer();
+    FLOGE("Error occurred, performing cleanup");
+
+    if (NULL != mErrorListener) {
+        mErrorListener->handleError(ERROR_TINY);
+    }
+
+    return BAD_VALUE;
+}
+
+int SurfaceAdapter::freeBuffer()
+{
+    status_t ret = NO_ERROR;
+
+     GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+    //Give the buffers back to display here -  sort of free it
+    if(mNativeWindow) {
+        for(int i = 0; i < mBufferCount; i++) {
+            mapper.unlock(*mCameraBuffer[i].mBufHandle);
+            ret = mNativeWindow->cancel_buffer(mNativeWindow, mCameraBuffer[i].mBufHandle);
+            if(ENODEV == ret) {
+                 FLOGE("Preview surface abandoned!");
+                 mNativeWindow = NULL;
+                 return -ret;
+            }
+            else if(NO_ERROR != ret) {
+                 FLOGE("cancel_buffer() failed: %s (%d)", strerror(-ret), -ret);
+                return -ret;
+            }
+        }
+    }
+    else {
+        FLOGE("mNativeWindow is NULL");
+    }
+
+    memset(mCameraBuffer, 0, sizeof(mCameraBuffer));
+
+    ///Clear the frames with camera adapter map
+    dispatchBuffers(NULL, 0, BUFFER_DESTROY);
+
+    return ret;
+}
+
+void SurfaceAdapter::setErrorListener(CameraErrorListener* listener)
+{
+    mErrorListener = listener;
+}
+
+int SurfaceAdapter::setPreviewWindow(preview_stream_ops_t* window)
+{
+    ///Note that Display Adapter cannot work without a valid window object
+    if(!window) {
+        FLOGE("NULL window object passed to DisplayAdapter");
+        return BAD_VALUE;
+    }
+
+    ///Destroy the existing window object, if it exists
+    destroy();
+
+    ///Move to new window obj
+    mNativeWindow = window;
+
+    return NO_ERROR;
+}
+
+void SurfaceAdapter::destroy()
+{
+    mNativeWindow = NULL;
+    mBufferCount = 0;
+    mBufferSize = 0;
+}
+
+int SurfaceAdapter::maxQueueableBuffers()
+{
+    return mQueueableCount;
+}
+
+void SurfaceAdapter::renderBuffer(buffer_handle_t* bufHandle)
+{
+    status_t ret = NO_ERROR;
+
+    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+    // unlock buffer before sending to display
+    mapper.unlock(*bufHandle);
+
+    ret = mNativeWindow->enqueue_buffer(mNativeWindow, bufHandle);
+    if (ret != 0) {
+        FLOGE("Surface::queueBuffer returned error %d", ret);
+    }
+}
+
+void SurfaceAdapter::cancelBuffer(buffer_handle_t* bufHandle)
+{
+    status_t ret = NO_ERROR;
+
+    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+    mapper.unlock(*bufHandle);
+
+    ret = mNativeWindow->cancel_buffer(mNativeWindow, bufHandle);
+    if(ret != 0) {
+        FLOGE("Surface::queueBuffer returned error %d", ret);
+    }
+}
+
+CameraFrame* SurfaceAdapter::requestBuffer()
+{
+    status_t err;
+    buffer_handle_t* buf;
+    int i = 0;
+    int stride;  // dummy variable to get stride
+    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+    Rect bounds;
+    void *pVaddr;
+
+    if(NULL == mNativeWindow) {
+        FLOGE("mNativeWindow is null");
+        return NULL;
+    }
+
+    err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf, &stride);
+    if(err != 0) {
+        FLOGE("dequeueBuffer failed: %s (%d)", strerror(-err), -err);
+        if (ENODEV == err) {
+            FLOGE("Preview surface abandoned!");
+            mNativeWindow = NULL;
+        }
+
+        return NULL;
+    }
+
+    err = mNativeWindow->lock_buffer(mNativeWindow, buf);
+    if(err != 0) {
+        FLOGE("lockbuffer failed: %s (%d)", strerror(-err), -err);
+        if (ENODEV == err) {
+            FLOGE("Preview surface abandoned!");
+            mNativeWindow = NULL;
+        }
+
+        return NULL;
+    }
+
+    for(i=0; i < mBufferCount; i++) {
+        if(mCameraBuffer[i].mBufHandle == buf)
+            break;
+    }
+
+    // lock buffer before sending to FrameProvider for filling
+    bounds.left = 0;
+    bounds.top = 0;
+    bounds.right = mFrameWidth;
+    bounds.bottom = mFrameHeight;
+
+    mapper.lock(*mCameraBuffer[i].mBufHandle, CAMERA_GRALLOC_USAGE, bounds, &pVaddr);
+
+    return &mCameraBuffer[i];
+}
+
diff --git a/mx6/libcamera/SurfaceAdapter.h b/mx6/libcamera/SurfaceAdapter.h
new file mode 100755
index 0000000..aa7e4b2
--- /dev/null
+++ b/mx6/libcamera/SurfaceAdapter.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SURFACE_ADAPTER_H_
+#define _SURFACE_ADAPTER_H_
+
+#include "CameraUtil.h"
+
+using namespace android;
+
+class SurfaceAdapter : public CameraBufferProvider, public LightRefBase<SurfaceAdapter>
+{
+public:
+    SurfaceAdapter();
+    virtual ~SurfaceAdapter();
+
+    virtual int allocatePreviewBuffer(int width, int height, int format, int numBufs);
+    virtual int allocatePictureBuffer(int width, int height, int format, int numBufs);
+    virtual int freeBuffer();
+    virtual int maxQueueableBuffers();
+    virtual int setPreviewWindow(struct preview_stream_ops *window);
+
+    void setErrorListener(CameraErrorListener* listener);
+
+protected:
+    void destroy();
+    void renderBuffer(buffer_handle_t* bufHandle);
+    void cancelBuffer(buffer_handle_t* bufHandle);
+    CameraFrame* requestBuffer();
+
+private:
+    int setNativeWindowAttribute(int width, int height, int format, int numBufs);
+    int allocateBuffer(int width, int height, int format, int numBufs, int maxQCount);
+
+protected:
+    CameraErrorListener* mErrorListener;
+    preview_stream_ops_t* mNativeWindow;
+
+    CameraFrame mCameraBuffer[MAX_PREVIEW_BUFFER];
+
+    uint32_t mFrameWidth;
+    uint32_t mFrameHeight;
+    int mBufferCount;
+    int mBufferSize;
+    PixelFormat mFormat;
+    int mQueueableCount;
+};
+
+#endif
diff --git a/mx6/libcamera/UvcDevice.h b/mx6/libcamera/UvcDevice.h
new file mode 100755
index 0000000..ed6c234
--- /dev/null
+++ b/mx6/libcamera/UvcDevice.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _UVC_DEVICE_H
+#define _UVC_DEVICE_H
+
+#include "CameraUtil.h"
+
+#define DEFAULT_PREVIEW_FPS (15)
+#define DEFAULT_PREVIEW_W   (640)
+#define DEFAULT_PREVIEW_H   (480)
+#define DEFAULT_PICTURE_W   (640)
+#define DEFAULT_PICTURE_H   (480)
+#define MAX_SENSOR_FORMAT 20
+#define FORMAT_STRING_LEN 64
+
+
+class UvcDevice : public DeviceAdapter
+{
+public:
+    virtual status_t initParameters(CameraParameters& params, int* supportRecordingFormat, int rfmtLen,
+                        int* supportPictureFormat, int pfmtLen) {return 0;}
+    virtual status_t setParameters(CameraParameters& params) {return 0;}
+
+private:
+    PixelFormat getMatchFormat(int* sfmt, int slen, int* dfmt, int dlen) {return 0;}
+    status_t setSupportedPreviewFormats(int* sfmt, int slen, int* dfmt, int dlen) {return 0;}
+    status_t setPreviewStringFormat(PixelFormat format) {return 0;}
+
+private:
+    char mSupportedFPS[MAX_SENSOR_FORMAT];
+    char mSupportedPictureSizes[CAMER_PARAM_BUFFER_SIZE];
+    char mSupportedPreviewSizes[CAMER_PARAM_BUFFER_SIZE];
+};
+
+#endif
+
diff --git a/mx6/libcamera/V4l2CapDeviceBase.cpp b/mx6/libcamera/V4l2CapDeviceBase.cpp
deleted file mode 100755
index 9d1bcee..0000000
--- a/mx6/libcamera/V4l2CapDeviceBase.cpp
+++ /dev/null
@@ -1,715 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CapDeviceBase.h"
-
-
-
-
-namespace android{
-
-    V4l2CapDeviceBase ::V4l2CapDeviceBase()
-        :mCameraDevice(0),
-        mFmtParamIdx(0),
-        mSizeFPSParamIdx(0),
-        mRequiredFmt(0),
-        mBufQueNum(0),
-        mQueuedBufNum(0)
-
-    {
-        mCaptureDeviceName[0] = '#';
-        memset((void*)&mCapCfg, 0, sizeof(mCapCfg));
-    }
-
-    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
-    {
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::SetDevName(const char * deviceName, const char * devPath){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(mInitalDeviceName, deviceName);
-        if((devPath != NULL) && (strlen(devPath) > 0))
-            strcpy(mCaptureDeviceName, devPath);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(deviceName, mInitalDeviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::DevOpen(int cameraId){
-        CAMERA_LOG_FUNC;
-
-        return V4l2Open(cameraId);
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
-    {
-        CAMERA_LOG_FUNC;
-        if(pType == NULL)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        *pType = mCameraType;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        CAMERA_LOG_FUNC;
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        else
-            return V4l2EnumParam(devParamType,retParam);
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(mCapCfg.fmt != pCapcfg->fmt || mCapCfg.width != pCapcfg->width || mCapCfg.height != pCapcfg->height
-                || mCapCfg.tv.denominator/mCapCfg.tv.numerator != pCapcfg->tv.denominator/pCapcfg->tv.numerator) {
-            mCapCfg.fmt = pCapcfg->fmt;
-            mCapCfg.width = pCapcfg->width;
-            mCapCfg.height = pCapcfg->height;
-            mCapCfg.tv.denominator = pCapcfg->tv.denominator;
-            mCapCfg.tv.numerator = pCapcfg->tv.numerator;
-            CAMERA_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
-            ret = V4l2SetConfig(pCapcfg);
-            if(ret < 0) {
-                return ret;
-            }
-            mCapCfg.rotate = SENSOR_PREVIEW_ROATE_INVALID;
-        }
-
-        if(mCapCfg.rotate != pCapcfg->rotate) {
-            mCapCfg.rotate = pCapcfg->rotate;
-            CAMERA_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
-            if(V4l2SetRot(pCapcfg) < 0)
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        return ret;
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2RegisterBufs(DevBufQue, pBufQueNum);
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
-    }
-
-    CAPTURE_DEVICE_RET  V4l2CapDeviceBase :: DevPrepare(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Prepare();
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStart(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Start();
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
-
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Dequeue(pBufQueIdx);
-        }
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
-
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Queue(BufQueIdx);
-        }
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStop(){
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Stop();
-        }
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDeAllocate(){
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2DeAlloc();
-        }
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevClose(){
-
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Close();
-        }
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Open(int cameraId){
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-        char   dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_capability v4l2_cap;
-        struct v4l2_dbg_chip_ident vid_chip;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
-                        if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                            close(fd);
-                            fd = 0;
-                            CAMERA_LOG_ERR("dev_node %s:cannot get sensor name", dev_node);
-                            continue;
-                        }
-                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
-                                dev_node, vid_chip.match.name);
-                        if(strstr(vid_chip.match.name, mInitalDeviceName)){
-                            is_found = 1;
-                            strcpy(mInitalDeviceName, vid_chip.match.name);
-                            strcpy(mCaptureDeviceName, dev_node);
-                            break;
-                        }
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-            if (fd > 0){
-                mCameraDevice = fd;
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        CAMERA_LOG_FUNC;
-        CAMERA_LOG_RUNTIME("devParamType is %d", devParamType);
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        switch(devParamType){
-            case OUTPU_FMT:
-                ret = V4l2EnumFmt(retParam);
-                break;
-            case FRAME_SIZE_FPS:
-                {
-                    ret = V4l2EnumSizeFps(retParam);
-                    break;
-                }
-            default:
-                {
-                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    break;
-                }
-        }
-        return ret;
-
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        vid_fmtdesc.index = mFmtParamIdx;
-        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }else{
-            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
-            *pParamVal = vid_fmtdesc.pixelformat;
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_frmsizeenum vid_frmsize;
-        struct v4l2_frmivalenum vid_frmval;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
-            vid_frmval.pixel_format = pCapCfg->fmt;
-            vid_frmval.width = vid_frmsize.discrete.width;
-            vid_frmval.height= vid_frmsize.discrete.height;
-            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-                CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
-                mSizeFPSParamIdx = 0;
-                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-            }else{
-                pCapCfg->width	= vid_frmsize.discrete.width;
-                pCapCfg->height = vid_frmsize.discrete.height;
-                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
-                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
-                mSizeFPSParamIdx ++;
-                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-            }
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        *pMode = 0;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        V4l2ConfigInput(pCapcfg);
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("set format failed\n");
-            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-            CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                    parm.parm.capture.timeperframe.denominator);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-
-
-        if(V4l2SetRot(pCapcfg) < 0)
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-        unsigned int i;
-        struct v4l2_buffer buf;
-        enum v4l2_buf_type type;
-        struct v4l2_requestbuffers req;
-        int BufQueNum;
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mBufQueNum = *pBufQueNum;
-
-        memset(&req, 0, sizeof (req));
-        req.count = mBufQueNum;
-        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        req.memory = V4L2_MEMORY_MMAP;
-        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        /*the driver may can't meet the request, and return the buf num it can handle*/
-        *pBufQueNum = mBufQueNum = req.count;
-
-        for (i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (buf));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.index = i;
-            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } else {
-                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-            }
-
-            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
-            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
-            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
-            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-        unsigned int i;
-        struct v4l2_buffer buf;
-        enum v4l2_buf_type type;
-        struct v4l2_requestbuffers req;
-        int BufQueNum;
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mBufQueNum = *pBufQueNum;
-
-        memset(&req, 0, sizeof (req));
-        req.count = mBufQueNum;
-        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        req.memory = V4L2_MEMORY_USERPTR;
-        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        /*the driver may can't meet the request, and return the buf num it can handle*/
-        *pBufQueNum = mBufQueNum = req.count;
-
-        for (i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (buf));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_USERPTR;
-            buf.index = i;
-            buf.m.offset = mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
-            buf.length = mCaptureBuffers[i].length = DevBufQue[i].length;
-            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
-            //memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } else {
-                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-            }
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Prepare(){
-        CAMERA_LOG_FUNC;
-        struct v4l2_buffer buf;
-        mQueuedBufNum = 0;
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (struct v4l2_buffer));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_USERPTR;
-            buf.index = i;
-            buf.m.offset = mCaptureBuffers[i].phy_offset;
-
-            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-                CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            }
-            mQueuedBufNum ++;
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Start(){
-        enum v4l2_buf_type type;
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_STREAMON error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else{
-            CAMERA_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
-        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        *pBufQueIdx = cfilledbuffer.index;
-        mQueuedBufNum --;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        //CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
-        cfilledbuffer.index = BufQueIdx;
-        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        mQueuedBufNum ++;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Stop(){
-        enum v4l2_buf_type type;
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_STREAMOFF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else
-            CAMERA_LOG_INFO("VIDIOC_STREAMOFF ok\n");
-
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
-                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-                mCaptureBuffers[i].length = 0;
-                CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
-            }
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Close(){
-
-        CAMERA_LOG_FUNC;
-
-        if (mCameraDevice <= 0 ){
-            CAMERA_LOG_INFO("the device handle is error");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        CAMERA_LOG_INFO("close the device");
-        close(mCameraDevice);
-        mCameraDevice = -1;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-};
diff --git a/mx6/libcamera/V4l2CapDeviceBase.h b/mx6/libcamera/V4l2CapDeviceBase.h
deleted file mode 100755
index f48ac32..0000000
--- a/mx6/libcamera/V4l2CapDeviceBase.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_CAP_DEVICE_BASE_H
-#define V4L2_CAP_DEVICE_BASE_H
-#include <linux/videodev2.h>
-
-#include "CaptureDeviceInterface.h"
-
-namespace android{
-
-    class V4l2CapDeviceBase : public CaptureDeviceInterface{
-    public:
-
-        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char *devPath = NULL);
-        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType);
-        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId);
-        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET DevPrepare();
-        virtual CAPTURE_DEVICE_RET DevStart();
-        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_RET DevQueue( unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_RET DevStop();
-        virtual CAPTURE_DEVICE_RET DevDeAllocate();
-        virtual CAPTURE_DEVICE_RET DevClose();
-
-    protected:
-
-        V4l2CapDeviceBase();
-        virtual ~V4l2CapDeviceBase();
-        virtual CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-        virtual CAPTURE_DEVICE_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-        virtual CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_RET V4l2Prepare();
-        virtual CAPTURE_DEVICE_RET V4l2Start();
-        virtual CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_RET V4l2Stop();
-        virtual CAPTURE_DEVICE_RET V4l2DeAlloc();
-        virtual CAPTURE_DEVICE_RET V4l2Close();
-        virtual CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode);
-        virtual CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-
-        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
-        char         mInitalDeviceName[CAMERA_SENSOR_LENGTH];
-        int          mCameraDevice;
-        unsigned int mFmtParamIdx;
-        unsigned int mSizeFPSParamIdx;
-        unsigned int mRequiredFmt;
-        unsigned int mBufQueNum;
-        int          mQueuedBufNum;
-        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
-        struct   capture_config_t mCapCfg;
-        CAMERA_TYPE  mCameraType;
-
-    };
-};
-
-#endif
diff --git a/mx6/libcamera/V4l2CsiDevice.cpp b/mx6/libcamera/V4l2CsiDevice.cpp
deleted file mode 100755
index 60fe01b..0000000
--- a/mx6/libcamera/V4l2CsiDevice.cpp
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev.h>
-#include <linux/videodev2.h>
-#include <linux/mxc_v4l2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CsiDevice.h"
-
-namespace android{
-    V4l2CsiDevice :: V4l2CsiDevice(){
-        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
-        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
-        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
-        mCameraType = CAMERA_TYPE_CSI;
-    }
-    V4l2CsiDevice :: ~V4l2CsiDevice()
-    {
-    }
-
-
-#ifdef V4L2_CAMERA_SWITCH
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2Open(int cameraId){
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char	dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_dbg_chip_ident vid_chip;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        ALOGI("%s: mInitalDeviceName %s, cameraId %d, mCaptureDeviceName %s",
-                __func__, mInitalDeviceName, cameraId, mCaptureDeviceName);
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-
-        if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-            ret = V4l2SetSensor(cameraId);
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-
-                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
-                        is_found = 1;
-                        strcpy(mCaptureDeviceName, dev_node);
-                        strcpy(mInitalDeviceName, vid_chip.match.name);
-                        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-                        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-                        break;
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-
-            if (fd > 0){
-                mCameraDevice = fd;
-                ret = V4l2SetSensor(cameraId);
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetSensor(int cameraId)
-    {
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        CAMERA_LOG_INFO("-----set camera sensor %d-----", cameraId);
-        if(cameraId >= 2) {
-            CAMERA_LOG_ERR("Error: camerId %d is too big", cameraId);
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        struct v4l2_control ctrl;
-        ctrl.id = V4L2_CID_MXC_SWITCH_CAM;
-        ctrl.value = cameraId;
-        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_LOG_ERR("set ctrl switch camera failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        return ret;
-    }
-#endif
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
-            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
-            *pParamVal = mSupportedFmt[mFmtParamIdx];
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }else{
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_frmsizeenum vid_frmsize;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            //hardcode here for ov3640
-            if (strstr(mInitalDeviceName, "3640") != NULL){
-                CAMERA_LOG_INFO("the sensor  is  mInitalDeviceName");
-                if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
-                    mSizeFPSParamIdx ++;
-                    vid_frmsize.index = mSizeFPSParamIdx;
-                    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-                        mSizeFPSParamIdx = 0;
-                        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    }
-                }
-            }
-            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            pCapCfg->width  = vid_frmsize.discrete.width;
-            pCapCfg->height = vid_frmsize.discrete.height;
-            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 15;
-            }else{
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 30;
-            }
-            mSizeFPSParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
-    {
-        CAMERA_LOG_FUNC;
-        int input = 1;
-        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
-            CAMERA_LOG_ERR("set input failed");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
-    {
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        memset(&parm, 0, sizeof(struct v4l2_streamparm));
-        memset(&fmt, 0, sizeof(struct v4l2_format));
-        V4l2ConfigInput(pCapcfg);
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        //hard code here to do a walk around.
-        if(pCapcfg->tv.denominator != 30 && pCapcfg->tv.denominator != 15){
-            pCapcfg->tv.numerator = 1;
-            pCapcfg->tv.denominator = 30;
-        }
-
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode),
-                &(parm.parm.capture.timeperframe));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            parm.parm.capture.timeperframe.numerator = 1;
-            parm.parm.capture.timeperframe.denominator = 15;
-            if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
-                CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-                CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                        parm.parm.capture.timeperframe.denominator);
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            }
-        }
-
-        CAMERA_LOG_INFO("Set FPS %d to Capture device",
-                parm.parm.capture.timeperframe.denominator);
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("set format failed\n");
-            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &fmt) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
-            unsigned int *pMode, struct v4l2_fract *pTimeFrame){
-
-        CAMERA_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        unsigned int capturemode = 0;
-        unsigned int capturewidth =  pCapcfg->width;
-        unsigned int captureheight = pCapcfg->height;
-        unsigned int pic_waite_buf_num = 0;
-        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
-                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
-            pic_waite_buf_num = 6;
-            if (capturewidth == 640 && captureheight == 480) {
-                capturemode = 0;	/* VGA mode */
-            }
-            else if (capturewidth == 320 && captureheight == 240) {
-                capturemode = 1;	/* QVGA mode */
-            }
-            else if (capturewidth == 720 && captureheight == 480) {
-                capturemode = 2;	/* PAL mode */
-            }
-            else if (capturewidth == 720 && captureheight == 576) {
-                capturemode = 3;	/* PAL mode */
-            }
-            else if (capturewidth == 1280 && captureheight == 720) {
-                capturemode = 4;	/* 720P mode */
-            }
-            else if (capturewidth == 1920 && captureheight == 1080){
-                pic_waite_buf_num = 3;
-                capturemode = 5;	/* 1080P mode */
-            }
-            else if (capturewidth == 2592 && captureheight == 1944) {
-                pic_waite_buf_num =3;
-                capturemode = 6;	/* 2592x1944 mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 15;
-            }
-            else if (capturewidth == 176 && captureheight == 144) {
-                capturemode = 7;       /* QCIF mode */
-            }
-            else if (capturewidth == 1024 && captureheight == 768) {
-                capturemode = 8;       /* XGA mode */
-            }
-            else{
-                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
-            pic_waite_buf_num = 10;
-            if (capturewidth == 320 && captureheight == 240)
-                capturemode = 1;	/* QVGA mode */
-            else if (capturewidth == 640 && captureheight == 480)
-                capturemode = 0;	/* VGA mode */
-            else if (capturewidth == 720 && captureheight == 480)
-                capturemode = 4;
-            else if (capturewidth == 720 && captureheight == 576)
-                capturemode = 5;
-            else if (capturewidth == 2048 && captureheight == 1536)
-            {
-                pic_waite_buf_num = 10;
-                capturemode = 3;	/* QXGA mode */
-            }
-            else
-            {
-                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else{
-            CAMERA_LOG_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
-            capturemode = 0;
-            pic_waite_buf_num = 0;
-        }
-
-        CAMERA_LOG_INFO("camera mode:%d", capturemode);
-        *pMode = capturemode;
-        pCapcfg->picture_waite_number = pic_waite_buf_num;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_LOG_FUNC;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        struct v4l2_control ctrl;
-
-        // Set rotation
-        ctrl.id = V4L2_CID_MXC_ROT;
-        if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
-            ctrl.value = V4L2_MXC_ROTATE_NONE;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
-            ctrl.value = V4L2_MXC_ROTATE_VERT_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
-            ctrl.value = V4L2_MXC_ROTATE_HORIZ_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
-            ctrl.value = V4L2_MXC_ROTATE_180;
-        else
-            ctrl.value = V4L2_MXC_ROTATE_NONE;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_LOG_ERR("set ctrl failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        return ret;
-    }
-
-    CAPTURE_DEVICE_RET  V4l2CsiDevice :: V4l2DeAlloc() {
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-};
-
diff --git a/mx6/libcamera/V4l2CsiDevice.h b/mx6/libcamera/V4l2CsiDevice.h
deleted file mode 100755
index bdc0632..0000000
--- a/mx6/libcamera/V4l2CsiDevice.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_CSI_DEVICE_H
-#define V4L2_CSI_DEVICE_H
-
-#include <linux/videodev2.h>
-#include "V4l2CapDeviceBase.h"
-#define ENUM_SUPPORTED_FMT     3
-
-#define OV3640_NAME_STR   "ov3640"
-#define OV5640_NAME_STR   "ov5640"
-#define OV5642_NAME_STR   "ov5642"
-namespace android{
-
-class V4l2CsiDevice : public V4l2CapDeviceBase{
-    public:
-
-        V4l2CsiDevice();
-        virtual ~V4l2CsiDevice();
-    protected:
-
-#ifdef V4L2_CAMERA_SWITCH
-        //Only for switch camera with ioctl
-        CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-        CAPTURE_DEVICE_RET V4l2SetSensor(int cameraId);
-#endif
-	CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-	CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-	CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
-                unsigned int *pMode, struct v4l2_fract *pTimeFrame);
-        CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_RET V4l2DeAlloc();
-
-	unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
-   };
-
-};
-#endif
-
-
diff --git a/mx6/libcamera/V4l2UVCDevice.cpp b/mx6/libcamera/V4l2UVCDevice.cpp
deleted file mode 100755
index 5e198de..0000000
--- a/mx6/libcamera/V4l2UVCDevice.cpp
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include <linux/videodev2.h>
-
-
-#include "V4l2UVCDevice.h"
-
-#define MAX_DEV_NAME_LENGTH 10
-
-namespace android {
-
-V4l2UVCDevice::V4l2UVCDevice()
-{
-    mCameraType = CAMERA_TYPE_UVC;
-    memset(mUvcBuffers, 0 , sizeof(mUvcBuffers));
-    mCaptureConfigNum = 0;
-    mCurrentConfig = NULL;
-    memset(mCaptureConfig, 0, sizeof(mCaptureConfig));
-
-    mEnableCSC = false;
-    mSensorFmtCnt = 0;
-    mCscFmtCnt = 0;
-    mActualCscFmtCnt = 0;
-    memset(mSensorSupportFmt, 0, sizeof(mSensorSupportFmt));
-    memset(mActualCscFmt, 0 , sizeof(mActualCscFmt));
-
-    memset(mCscGroup, 0, sizeof(mCscGroup));
-    //related to format support in CSC.
-    mCscGroup[0].srcFormat = v4l2_fourcc('Y','U','Y','V');
-    mCscGroup[0].dstFormat = v4l2_fourcc('N','V','1','2');
-    mCscGroup[0].cscConvert = convertYUYUToNV12;
-    mCscGroup[0].isSensorSupport = false;
-    mCscGroup[0].isOverlapWithSensor = false;
-    mDoCsc = NULL;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Open(int cameraId)
-{
-        CAMERA_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char   dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_capability v4l2_cap;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR | O_NONBLOCK, 0);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5))
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR | O_NONBLOCK, 0)) < 0)
-                        continue;
-                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                        close(fd);
-                        fd = 0;
-                        continue;
-                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
-                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
-                                dev_node, v4l2_cap.driver);
-                        if(strstr((const char*)v4l2_cap.driver, mInitalDeviceName)){
-                            is_found = 1;
-                            CAMERA_LOG_RUNTIME("find the correct sensor %s, len=%d", v4l2_cap.driver, strlen((const char*)v4l2_cap.driver));
-                            strcpy(mInitalDeviceName, (const char*)v4l2_cap.driver);
-                            strcpy(mCaptureDeviceName, dev_node);
-                            break;
-                        }
-                    }
-                    close(fd);
-                    fd = 0;
-                }
-                closedir(v4l_dir);
-            }
-            if (fd > 0){
-                mCameraDevice = fd;
-            }
-            else{
-                CAMERA_LOG_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
-        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
-        return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)
-{
-    unsigned int i;
-    struct v4l2_buffer buf;
-    enum v4l2_buf_type type;
-    struct v4l2_requestbuffers req;
-    int BufQueNum;
-
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    mBufQueNum = *pBufQueNum;
-
-    memset(&req, 0, sizeof (req));
-    req.count = mBufQueNum;
-    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    req.memory = V4L2_MEMORY_MMAP;
-    if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-        CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    /*the driver may can't meet the request, and return the buf num it can handle*/
-    *pBufQueNum = mBufQueNum = req.count;
-
-    for (i = 0; i < mBufQueNum; i++) {
-        memset(&buf, 0, sizeof (buf));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.index = i;
-        if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else {
-            CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-        }
-
-        mCaptureBuffers[i].length = DevBufQue[i].length = mUvcBuffers[i].length = buf.length;
-
-        mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
-        mUvcBuffers[i].phy_offset = (size_t) buf.m.offset;
-
-        mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
-        mUvcBuffers[i].virt_start = (unsigned char *)mmap (NULL, mUvcBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mUvcBuffers[i].phy_offset);
-
-        memset(mUvcBuffers[i].virt_start, 0xFF, mUvcBuffers[i].length);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-        CAMERA_LOG_RUNTIME("user space buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].length = %d\n", i, mUvcBuffers[i].length);
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].phy_offset = 0x%x\n", i, mUvcBuffers[i].phy_offset);
-        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mUvcBuffers[i].virt_start));
-    }
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Prepare()
-{
-    CAMERA_LOG_FUNC;
-    struct v4l2_buffer buf;
-    mQueuedBufNum = 0;
-    for (unsigned int i = 0; i < mBufQueNum; i++) {
-        memset(&buf, 0, sizeof (struct v4l2_buffer));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.memory = V4L2_MEMORY_MMAP;
-        buf.index = i;
-        buf.m.offset = mUvcBuffers[i].phy_offset;
-
-        if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-            CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        mQueuedBufNum ++;
-    }
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Dequeue(unsigned int *pBufQueIdx)
-{
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_buffer cfilledbuffer;
-    int n;
-    fd_set rfds;
-    struct timeval tv;
-    //CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-        return CAPTURE_DEVICE_ERR_OPEN;
-    }
-
-    FD_ZERO(&rfds);
-    FD_SET(mCameraDevice, &rfds);
-    tv.tv_sec = 0;
-    tv.tv_usec = MAX_DEQUEUE_WAIT_TIME*1000;
-    n = select(mCameraDevice+1, &rfds, NULL, NULL, &tv);
-    if(n < 0) {
-        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state error.");
-        ret = CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-    else if(n == 0) {
-        CAMERA_LOG_INFO("Warning!Time out wait for V4L2 capture reading operation!");
-        ret = CAPTURE_DEVICE_ERR_OPT_TIMEOUT;
-    }
-    else if(FD_ISSET(mCameraDevice, &rfds)) {
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-        int rtval;
-        rtval = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
-        if (rtval < 0) {
-            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", rtval);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        *pBufQueIdx = cfilledbuffer.index;
-
-        //should do hardware accelerate.
-        if(mEnableCSC && mDoCsc) {
-            mDoCsc->width = mCurrentConfig->width;
-            mDoCsc->height = mCurrentConfig->height;
-            mDoCsc->srcStride = mDoCsc->width;
-            mDoCsc->dstStride = mDoCsc->width;
-            mDoCsc->srcVirt = mUvcBuffers[*pBufQueIdx].virt_start;
-            mDoCsc->dstVirt = mCaptureBuffers[*pBufQueIdx].virt_start;
-            mDoCsc->srcPhy = mUvcBuffers[*pBufQueIdx].phy_offset;
-            mDoCsc->dstPhy = mCaptureBuffers[*pBufQueIdx].phy_offset;
-            mDoCsc->cscConvert(mDoCsc);
-        }
-        else
-            memcpy(mCaptureBuffers[*pBufQueIdx].virt_start, mUvcBuffers[*pBufQueIdx].virt_start, mCaptureBuffers[*pBufQueIdx].length);
-
-        mQueuedBufNum --;
-
-        ret =  CAPTURE_DEVICE_ERR_NONE;
-    }
-    else {
-        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state, no known error.");
-        ret = CAPTURE_DEVICE_ERR_UNKNOWN;
-    }
-
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Queue(unsigned int BufQueIdx)
-{
-    int ret;
-    struct v4l2_buffer cfilledbuffer;
-    //CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-        return CAPTURE_DEVICE_ERR_OPEN;
-    }
-    memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
-    cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-    cfilledbuffer.index = BufQueIdx;
-    ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
-    if (ret < 0) {
-        CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    mQueuedBufNum ++;
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2DeAlloc()
-{
-
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 ){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    for (unsigned int i = 0; i < mBufQueNum; i++) {
-        if (mUvcBuffers[i].length && (mUvcBuffers[i].virt_start > 0)) {
-            munmap(mUvcBuffers[i].virt_start, mUvcBuffers[i].length);
-            mUvcBuffers[i].length = 0;
-            CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mUvcBuffers[i].virt_start));
-        }
-    }
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-void V4l2UVCDevice::selectCscFunction(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    mDoCsc = NULL;
-    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
-                     mCscGroup[i].dstFormat == format) {
-            mDoCsc = &mCscGroup[i];
-            CAMERA_LOG_RUNTIME("find the match mCscGroup[%d] CSC function", i);
-        }
-    }
-}
-
-unsigned int V4l2UVCDevice::queryCscSourceFormat(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
-                     mCscGroup[i].dstFormat == format) {
-            CAMERA_LOG_RUNTIME("find the CSC source format=0x%x convert to dest format=0x%x",
-                         mCscGroup[i].srcFormat, mCscGroup[i].dstFormat);
-            return mCscGroup[i].srcFormat;
-        }
-    }
-
-    CAMERA_LOG_ERR("invalidate format 0x%x in query", format);
-    return 0;
-}
-
-bool V4l2UVCDevice::needDoCsc(unsigned int format)
-{
-    CAMERA_LOG_FUNC;
-    unsigned int i;
-    for(i=0; i < mActualCscFmtCnt; i++) {
-        if(mActualCscFmt[i] == format)
-            return true;
-    }
-
-    return false;
-}
-
-unsigned int V4l2UVCDevice::countActualCscFmt()
-{
-    CAMERA_LOG_FUNC;
-    if(mSensorFmtCnt <= 0) {
-        return 0;
-    }
-
-    unsigned int i, k;
-    unsigned int n = 0;
-
-    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
-        for(k=0; k < mSensorFmtCnt; k++) {
-            if(mCscGroup[i].srcFormat == mSensorSupportFmt[k]) {
-                mCscGroup[i].isSensorSupport = true;
-                break;
-            }
-        }
-    }
-
-    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
-        for(k=0; k < mSensorFmtCnt; k++) {
-            if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].dstFormat == mSensorSupportFmt[k]) {
-                mCscGroup[i].isOverlapWithSensor = true;
-                break;
-            }
-        }
-        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false) {
-            mActualCscFmt[n++] = mCscGroup[i].dstFormat;
-        }
-    }
-
-    return n;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumFmt(void *retParam)
-{
-    CAMERA_LOG_FUNC;
-
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_fmtdesc vid_fmtdesc;
-    unsigned int *pParamVal = (unsigned int *)retParam;
-
-    vid_fmtdesc.index = mFmtParamIdx;
-    vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
-        if(mSensorFmtCnt > 0) {
-            mCscFmtCnt = countActualCscFmt();
-            mActualCscFmtCnt = mCscFmtCnt;
-            mSensorFmtCnt = 0;
-        }
-        if(mCscFmtCnt > 0) {
-            *pParamVal = mActualCscFmt[mCscFmtCnt-1];
-            mFmtParamIdx ++;
-            mCscFmtCnt --;
-            return CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        mFmtParamIdx = 0;
-        ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-    }else{
-        CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
-        *pParamVal = vid_fmtdesc.pixelformat;
-        if(mFmtParamIdx < MAX_SUPPORTED_FMT) {
-            mSensorSupportFmt[mFmtParamIdx] = vid_fmtdesc.pixelformat;
-            mSensorFmtCnt ++;
-        }
-        mFmtParamIdx ++;
-        ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-    }
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumSizeFps(void *retParam)
-{
-    CAMERA_LOG_FUNC;
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_frmsizeenum vid_frmsize;
-    struct v4l2_frmivalenum vid_frmval;
-
-    struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-    memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-    mCaptureConfigNum = mSizeFPSParamIdx;
-    vid_frmsize.index = mSizeFPSParamIdx;
-    CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-
-    if(needDoCsc(pCapCfg->fmt)) {
-        vid_frmsize.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
-        if(vid_frmsize.pixel_format == 0) {
-            CAMERA_LOG_ERR("EnumSizeFps: queryCscSourceFormat return failed");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-    }
-    else {
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-    }
-    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-        mSizeFPSParamIdx = 0;
-        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-    }else{
-        //uvc handle 1600x1200 may have some problem. so, skip it.
-        if(vid_frmsize.discrete.width == 1600 && vid_frmsize.discrete.height == 1200) {
-            CAMERA_LOG_ERR("EnumSizeFps: now skip %d x %d resolution", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            mSizeFPSParamIdx = 0;
-            return CAPTURE_DEVICE_ERR_SET_PARAM;
-        }
-
-        memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-        CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-        vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
-        if(needDoCsc(pCapCfg->fmt)) {
-            vid_frmval.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
-            if(vid_frmsize.pixel_format == 0) {
-                CAMERA_LOG_ERR("EnumSizeFps2: queryCscSourceFormat return failed");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }
-        else {
-            vid_frmval.pixel_format = pCapCfg->fmt;
-        }
-        vid_frmval.width = vid_frmsize.discrete.width;
-        vid_frmval.height= vid_frmsize.discrete.height;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-            CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            pCapCfg->width	= vid_frmsize.discrete.width;
-            pCapCfg->height = vid_frmsize.discrete.height;
-            pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
-            pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
-            mSizeFPSParamIdx ++;
-
-            //store all configuration here.
-            mCaptureConfig[mCaptureConfigNum].fmt = vid_frmsize.pixel_format;//pCapCfg->fmt;
-            mCaptureConfig[mCaptureConfigNum].width = pCapCfg->width;
-            mCaptureConfig[mCaptureConfigNum].height = pCapCfg->height;
-            mCaptureConfig[mCaptureConfigNum].picture_waite_number = 0;
-            mCaptureConfig[mCaptureConfigNum].tv.numerator = pCapCfg->tv.numerator;
-            mCaptureConfig[mCaptureConfigNum].tv.denominator = pCapCfg->tv.denominator;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-    }
-    return ret;
-}
-
-CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2SetConfig(struct capture_config_t *pCapcfg)
-{
-    CAMERA_LOG_FUNC;
-    if (mCameraDevice <= 0 || pCapcfg == NULL){
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
-    struct v4l2_format fmt;
-    struct v4l2_control ctrl;
-    struct v4l2_streamparm parm;
-    struct capture_config_t *matchConfig = NULL;
-    struct capture_config_t *betterMatchConfig = NULL;
-    struct capture_config_t *bestMatchConfig = NULL;
-
-    //find the best match configuration.
-    for(unsigned int i=0; i < mCaptureConfigNum; i++) {
-        if(/*mCaptureConfig[i].fmt == pCapcfg->fmt &&*/
-                 mCaptureConfig[i].width == pCapcfg->width &&
-                 mCaptureConfig[i].height == pCapcfg->height) {
-            matchConfig = &mCaptureConfig[i];
-            if(mCaptureConfig[i].tv.numerator == pCapcfg->tv.numerator &&
-                    mCaptureConfig[i].tv.denominator == pCapcfg->tv.denominator) {
-                bestMatchConfig = &mCaptureConfig[i];
-            }
-            else if(mCaptureConfig[i].tv.denominator/mCaptureConfig[i].tv.numerator >
-                   pCapcfg->tv.denominator/pCapcfg->tv.numerator){
-                betterMatchConfig = &mCaptureConfig[i];
-            }//else
-        }
-    }//for
-
-    if(bestMatchConfig != NULL) {
-        matchConfig = bestMatchConfig;
-    }
-    else if(betterMatchConfig != NULL) {
-        matchConfig = betterMatchConfig;
-    }
-
-    if(matchConfig == NULL) {
-        CAMERA_LOG_ERR("Error: not support format=0x%x, Width=%d, Height=%d",
-                       pCapcfg->fmt, pCapcfg->width, pCapcfg->height);
-        return CAPTURE_DEVICE_ERR_BAD_PARAM;
-    }
-
-    mCurrentConfig = matchConfig;
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if(needDoCsc(pCapcfg->fmt)) {
-        mEnableCSC = true;
-        //set mDoCsc 
-        selectCscFunction(pCapcfg->fmt);
-        fmt.fmt.pix.pixelformat = queryCscSourceFormat(pCapcfg->fmt);
-        if(fmt.fmt.pix.pixelformat == 0) {
-            CAMERA_LOG_ERR("SetConfig: queryCscSourceFormat return failed");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-    }
-    else {
-        mEnableCSC = false;
-        fmt.fmt.pix.pixelformat = matchConfig->fmt;
-    }
-
-    fmt.fmt.pix.width = matchConfig->width;
-    fmt.fmt.pix.height = matchConfig->height;
-    if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
-        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-    else
-        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-    fmt.fmt.pix.priv = 0;
-    fmt.fmt.pix.sizeimage = 0;
-
-    int err = 0;
-    if ((err = ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt)) < 0) {
-        CAMERA_LOG_ERR("set format failed err=%d\n", err);
-        CAMERA_LOG_ERR("matchConfig->width is %d, matchConfig->height is %d", matchConfig->width, matchConfig->height);
-        CAMERA_LOG_ERR(" Set the Format %x :%c%c%c%c\n", matchConfig->fmt,
-                matchConfig->fmt & 0xFF, (matchConfig->fmt >> 8) & 0xFF,
-                (matchConfig->fmt >> 16) & 0xFF, (matchConfig->fmt >> 24) & 0xFF);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    parm.parm.capture.timeperframe.numerator = matchConfig->tv.numerator;
-    parm.parm.capture.timeperframe.denominator = matchConfig->tv.denominator;
-    CAMERA_LOG_RUNTIME("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                parm.parm.capture.timeperframe.denominator);
-    if ( (err = ioctl(mCameraDevice, VIDIOC_S_PARM, &parm)) < 0) {
-        CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed err=%d\n", __FUNCTION__,__LINE__, err);
-        CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                parm.parm.capture.timeperframe.denominator);
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }
-
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-        CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
-        return CAPTURE_DEVICE_ERR_SYS_CALL;
-    }else{
-
-        CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-        CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-        CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-        CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-    }
-    matchConfig->framesize = fmt.fmt.pix.sizeimage;
-    pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-    //For uvc, the first frame is ok.
-    matchConfig->picture_waite_number = pCapcfg->picture_waite_number = 1;
-
-    return CAPTURE_DEVICE_ERR_NONE;
-}
-
-void V4l2UVCDevice::convertYUYUToNV12(struct CscConversion* param)
-{
-    unsigned char *pSrcBufs = param->srcVirt;
-    unsigned char *pDstBufs = param->dstVirt;
-    unsigned int bufWidth = param->width;
-    unsigned int bufHeight = param->height;
-
-    unsigned char *pSrcY1Offset = pSrcBufs;
-    unsigned char *pSrcY2Offset = pSrcBufs + (bufWidth << 1);
-    unsigned char *pSrcY3Offset = pSrcBufs + (bufWidth << 1) * 2;
-    unsigned char *pSrcY4Offset = pSrcBufs + (bufWidth << 1) * 3;
-    unsigned char *pSrcU1Offset = pSrcY1Offset + 1;
-    unsigned char *pSrcU2Offset = pSrcY2Offset + 1;
-    unsigned char *pSrcU3Offset = pSrcY3Offset + 1;
-    unsigned char *pSrcU4Offset = pSrcY4Offset + 1;
-    unsigned char *pSrcV1Offset = pSrcY1Offset + 3;
-    unsigned char *pSrcV2Offset = pSrcY2Offset + 3;
-    unsigned char *pSrcV3Offset = pSrcY3Offset + 3;
-    unsigned char *pSrcV4Offset = pSrcY4Offset + 3;
-    unsigned int srcYStride = (bufWidth << 1) * 3;
-    unsigned int srcUVStride = srcYStride;
-
-    unsigned char *pDstY1Offset = pDstBufs;
-    unsigned char *pDstY2Offset = pDstBufs + bufWidth;
-    unsigned char *pDstY3Offset = pDstBufs + bufWidth * 2;
-    unsigned char *pDstY4Offset = pDstBufs + bufWidth * 3;
-    unsigned char *pDstU1Offset = pDstBufs + bufWidth * bufHeight;
-    unsigned char *pDstU2Offset = pDstBufs + bufWidth * (bufHeight + 1);
-    unsigned char *pDstV1Offset = pDstU1Offset + 1;
-    unsigned char *pDstV2Offset = pDstU2Offset + 1;
-    unsigned int dstYStride = bufWidth * 3;
-    unsigned int dstUVStride = bufWidth;
-
-    unsigned int nw, nh;
-    for(nh = 0; nh < (bufHeight >> 2); nh++) {
-        for(nw=0; nw < (bufWidth >> 1); nw++) {
-            *pDstY1Offset++ = *pSrcY1Offset;
-            *pDstY2Offset++ = *pSrcY2Offset;
-            *pDstY3Offset++ = *pSrcY3Offset;
-            *pDstY4Offset++ = *pSrcY4Offset;
-
-            pSrcY1Offset += 2;
-            pSrcY2Offset += 2;
-            pSrcY3Offset += 2;
-            pSrcY4Offset += 2;
-
-            *pDstY1Offset++ = *pSrcY1Offset;
-            *pDstY2Offset++ = *pSrcY2Offset;
-            *pDstY3Offset++ = *pSrcY3Offset;
-            *pDstY4Offset++ = *pSrcY4Offset;
-
-            pSrcY1Offset += 2;
-            pSrcY2Offset += 2;
-            pSrcY3Offset += 2;
-            pSrcY4Offset += 2;
-
-            *pDstU1Offset = *pSrcU1Offset;
-            *pDstU2Offset = *pSrcU3Offset;
-            pDstU1Offset += 2;
-            pDstU2Offset += 2;
-            pSrcU1Offset += 4;
-            pSrcU3Offset += 4;
-
-            *pDstV1Offset = *pSrcV1Offset;
-            *pDstV2Offset = *pSrcV3Offset;
-            pDstV1Offset += 2;
-            pDstV2Offset += 2;
-            pSrcV1Offset += 4;
-            pSrcV3Offset += 4;
-        }
-
-        pSrcY1Offset += srcYStride;
-        pSrcY2Offset += srcYStride;
-        pSrcY3Offset += srcYStride;
-        pSrcY4Offset += srcYStride;
-
-        pSrcU1Offset += srcUVStride;
-        pSrcU3Offset += srcUVStride;
-        pSrcV1Offset += srcUVStride;
-        pSrcV3Offset += srcUVStride;
-
-        pDstY1Offset += dstYStride;
-        pDstY2Offset += dstYStride;
-        pDstY3Offset += dstYStride;
-        pDstY4Offset += dstYStride;
-
-        pDstU1Offset += dstUVStride;
-        pDstU2Offset += dstUVStride;
-        pDstV1Offset += dstUVStride;
-        pDstV2Offset += dstUVStride;
-    }
-}
-
-};
-
diff --git a/mx6/libcamera/V4l2UVCDevice.h b/mx6/libcamera/V4l2UVCDevice.h
deleted file mode 100755
index 9aea82a..0000000
--- a/mx6/libcamera/V4l2UVCDevice.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-#ifndef V4L2_UVC_DEVICE_H
-#define V4L2_UVC_DEVICE_H
-
-#include <linux/videodev2.h>
-#include "V4l2CapDeviceBase.h"
-
-#define MAX_DEV_NAME_LENGTH 10
-#define MAX_CAPTURE_CONFIG  20
-#define MAX_SUPPORTED_FMT  10
-#define MAX_CSC_SUPPORT_FMT 1
-
-namespace android{
-
-struct CscConversion {
-    //if the srcFormat is support by sensor.
-    bool isSensorSupport;
-    //if the dstFormat is support by sensor.
-    bool isOverlapWithSensor;
-    int width;
-    int height;
-    int srcStride;
-    int dstStride;
-    unsigned int srcFormat;
-    unsigned int dstFormat;
-    unsigned char* srcVirt;
-    unsigned char* dstVirt;
-    int srcPhy;
-    int dstPhy;
-
-    void(*cscConvert)(struct CscConversion* param);
-};
-
-class V4l2UVCDevice : public V4l2CapDeviceBase{
-public:
-    V4l2UVCDevice();//{mCameraType = CAMERA_TYPE_UVC;}
-    ~V4l2UVCDevice(){}
-
-protected:
-    CAPTURE_DEVICE_RET V4l2Open(int cameraId);
-    CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-    CAPTURE_DEVICE_RET V4l2Prepare();
-    CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-    CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
-    CAPTURE_DEVICE_RET V4l2DeAlloc();
-    CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
-    CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
-    CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-
-private:
-    static void convertYUYUToNV12(struct CscConversion* param);
-    unsigned int countActualCscFmt();
-    bool needDoCsc(unsigned int);
-    void selectCscFunction(unsigned int format);
-    unsigned int queryCscSourceFormat(unsigned int format);
-    //DMA_BUFFER mCameraBuffer[MAX_CAPTURE_BUF_QUE_NUM];
-    //mCaptureBuffers defined in parent class store buffers allocated from user space.
-    //mUvcBuffers store the buffers allocated from uvc driver.
-    DMA_BUFFER mUvcBuffers[MAX_CAPTURE_BUF_QUE_NUM];
-
-    //store sensor configuration here.
-    unsigned int mCaptureConfigNum;
-    struct capture_config_t mCaptureConfig[MAX_CAPTURE_CONFIG];
-    struct capture_config_t* mCurrentConfig;
-
-    //for jpeg encoder support yuyv. this case, should not covert.
-    bool mEnableCSC;
-    //stores nedd csc format. 
-    struct CscConversion mCscGroup[MAX_CSC_SUPPORT_FMT];
-    struct CscConversion* mDoCsc;
-    unsigned int mActualCscFmt[MAX_CSC_SUPPORT_FMT];
-    unsigned int mActualCscFmtCnt;
-    //stores sensor support format.
-    unsigned int mSensorSupportFmt[MAX_SUPPORTED_FMT];
-    unsigned int mSensorFmtCnt;
-    unsigned int mCscFmtCnt;
-};
-
-};
-#endif
-
diff --git a/mx6/libcamera/YuvToJpegEncoder.cpp b/mx6/libcamera/YuvToJpegEncoder.cpp
new file mode 100755
index 0000000..876eb9d
--- /dev/null
+++ b/mx6/libcamera/YuvToJpegEncoder.cpp
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "YuvToJpegEncoder.h"
+#include <ui/PixelFormat.h>
+#include <hardware/hardware.h>
+#include "NV12_resize.h"
+
+YuvToJpegEncoder* YuvToJpegEncoder::create(int format) {
+    // Only ImageFormat.NV21 and ImageFormat.YUY2 are supported
+    // for now.
+    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
+        return new Yuv420SpToJpegEncoder();
+    } else if (format == HAL_PIXEL_FORMAT_YCbCr_422_I) {
+        return new Yuv422IToJpegEncoder();
+    } else {
+        FLOGE("YuvToJpegEncoder:create format:%d not support", format);
+        return NULL;
+    }
+}
+
+int YuvToJpegEncoder::getSupportedPictureFormat(int* pFormat, int len)
+{
+    if(pFormat != NULL && len > 0) {
+        pFormat[0] = v4l2_fourcc('N','V','1','2');
+        if(len > 1) {
+            pFormat[1] = v4l2_fourcc('Y','U','Y','V');
+        }
+
+        return NO_ERROR;
+    }
+    return BAD_VALUE;
+}
+
+YuvToJpegEncoder::YuvToJpegEncoder()
+{
+}
+
+int YuvToJpegEncoder::encode(void* inYuv, int inWidth, int inHeight, int quality,
+                    void* outBuf, int outSize, int outWidth, int outHeight) {
+    jpeg_compress_struct    cinfo;
+    jpegBuilder_error_mgr        sk_err;
+    uint8_t* resize_src = NULL;
+    jpegBuilder_destination_mgr dest_mgr((uint8_t*)outBuf, outSize);
+
+    if(inWidth != outWidth || inHeight != outHeight) {
+        resize_src = (uint8_t*)malloc(outSize);
+        yuvResize((uint8_t*)inYuv, inWidth, inHeight, resize_src, outWidth, outHeight);
+        inYuv = resize_src;
+    }
+
+    cinfo.err = jpeg_std_error(&sk_err);
+    jpeg_create_compress(&cinfo);
+
+    cinfo.dest = &dest_mgr;
+
+    setJpegCompressStruct(&cinfo, outWidth, outHeight, quality);
+
+    jpeg_start_compress(&cinfo, TRUE);
+
+    compress(&cinfo, (uint8_t*) inYuv);
+
+    jpeg_finish_compress(&cinfo);
+
+    if(resize_src != NULL) {
+        free(resize_src);
+    }
+    return dest_mgr.jpegsize;
+}
+
+void YuvToJpegEncoder::setJpegCompressStruct(jpeg_compress_struct* cinfo,
+        int width, int height, int quality) {
+    cinfo->image_width = width;
+    cinfo->image_height = height;
+    cinfo->input_components = 3;
+    cinfo->in_color_space = JCS_YCbCr;
+    jpeg_set_defaults(cinfo);
+
+    jpeg_set_quality(cinfo, quality, TRUE);
+    jpeg_set_colorspace(cinfo, JCS_YCbCr);
+    cinfo->raw_data_in = TRUE;
+    cinfo->dct_method = JDCT_IFAST;
+    configSamplingFactors(cinfo);
+}
+
+///////////////////////////////////////////////////////////////////
+Yuv420SpToJpegEncoder::Yuv420SpToJpegEncoder() :
+        YuvToJpegEncoder() {
+    fNumPlanes = 2;
+}
+
+void Yuv420SpToJpegEncoder::compress(jpeg_compress_struct* cinfo,
+        uint8_t* yuv) {
+    JSAMPROW y[16];
+    JSAMPROW cb[8];
+    JSAMPROW cr[8];
+    JSAMPARRAY planes[3];
+    planes[0] = y;
+    planes[1] = cb;
+    planes[2] = cr;
+
+    int width = cinfo->image_width;
+    int height = cinfo->image_height;
+    uint8_t* yPlanar = yuv;
+    uint8_t* vuPlanar = yuv + width * height;
+    uint8_t* uRows = new uint8_t [8 * (width >> 1)];
+    uint8_t* vRows = new uint8_t [8 * (width >> 1)];
+    // process 16 lines of Y and 8 lines of U/V each time.
+    while (cinfo->next_scanline < cinfo->image_height) {
+        //deitnerleave u and v
+        deinterleave(vuPlanar, uRows, vRows, cinfo->next_scanline, width);
+
+        for (int i = 0; i < 16; i++) {
+            // y row
+            y[i] = yPlanar + (cinfo->next_scanline + i) * width;
+
+            // construct u row and v row
+            if ((i & 1) == 0) {
+                // height and width are both halved because of downsampling
+                int offset = (i >> 1) * (width >> 1);
+                cb[i/2] = uRows + offset;
+                cr[i/2] = vRows + offset;
+            }
+          }
+        jpeg_write_raw_data(cinfo, planes, 16);
+    }
+    delete [] uRows;
+    delete [] vRows;
+
+}
+
+void Yuv420SpToJpegEncoder::deinterleave(uint8_t* vuPlanar, uint8_t* uRows,
+        uint8_t* vRows, int rowIndex, int width) {
+    for (int row = 0; row < 8; ++row) {
+        int offset = ((rowIndex >> 1) + row) * width;
+        uint8_t* vu = vuPlanar + offset;
+        for (int i = 0; i < (width >> 1); ++i) {
+            int index = row * (width >> 1) + i;
+            uRows[index] = vu[0];
+            vRows[index] = vu[1];
+            vu += 2;
+        }
+    }
+}
+
+void Yuv420SpToJpegEncoder::configSamplingFactors(jpeg_compress_struct* cinfo) {
+    // cb and cr are horizontally downsampled and vertically downsampled as well.
+    cinfo->comp_info[0].h_samp_factor = 2;
+    cinfo->comp_info[0].v_samp_factor = 2;
+    cinfo->comp_info[1].h_samp_factor = 1;
+    cinfo->comp_info[1].v_samp_factor = 1;
+    cinfo->comp_info[2].h_samp_factor = 1;
+    cinfo->comp_info[2].v_samp_factor = 1;
+}
+
+int Yuv420SpToJpegEncoder::yuvResize(uint8_t* srcBuf, int srcWidth, int srcHeight,
+                uint8_t* dstBuf, int dstWidth, int dstHeight)
+{
+    if(!srcBuf || !dstBuf) {
+        return -1;
+    }
+
+    structConvImage o_img_ptr, i_img_ptr;
+    //input
+    i_img_ptr.uWidth =  srcWidth;
+    i_img_ptr.uStride =  i_img_ptr.uWidth;
+    i_img_ptr.uHeight =  srcHeight;
+    i_img_ptr.eFormat = IC_FORMAT_YCbCr420_lp;
+    i_img_ptr.imgPtr = srcBuf;
+    i_img_ptr.clrPtr = i_img_ptr.imgPtr + (i_img_ptr.uWidth * i_img_ptr.uHeight);
+
+    //ouput
+    o_img_ptr.uWidth = dstWidth;
+    o_img_ptr.uStride = o_img_ptr.uWidth;
+    o_img_ptr.uHeight = dstHeight;
+    o_img_ptr.eFormat = IC_FORMAT_YCbCr420_lp;
+    o_img_ptr.imgPtr = dstBuf;
+    o_img_ptr.clrPtr = o_img_ptr.imgPtr + (o_img_ptr.uWidth * o_img_ptr.uHeight);
+
+    VT_resizeFrame_Video_opt2_lp(&i_img_ptr, &o_img_ptr, NULL, 0);
+
+    return 0;
+}
+///////////////////////////////////////////////////////////////////////////////
+Yuv422IToJpegEncoder::Yuv422IToJpegEncoder() :
+        YuvToJpegEncoder() {
+    fNumPlanes = 1;
+}
+
+void Yuv422IToJpegEncoder::compress(jpeg_compress_struct* cinfo,
+        uint8_t* yuv) {
+    JSAMPROW y[16];
+    JSAMPROW cb[16];
+    JSAMPROW cr[16];
+    JSAMPARRAY planes[3];
+    planes[0] = y;
+    planes[1] = cb;
+    planes[2] = cr;
+
+    int width = cinfo->image_width;
+    int height = cinfo->image_height;
+    uint8_t* yRows = new uint8_t [16 * width];
+    uint8_t* uRows = new uint8_t [16 * (width >> 1)];
+    uint8_t* vRows = new uint8_t [16 * (width >> 1)];
+
+    uint8_t* yuvOffset = yuv;
+
+    // process 16 lines of Y and 16 lines of U/V each time.
+    while (cinfo->next_scanline < cinfo->image_height) {
+        deinterleave(yuvOffset, yRows, uRows, vRows, cinfo->next_scanline, width, height);
+
+        for (int i = 0; i < 16; i++) {
+            // y row
+            y[i] = yRows + i * width;
+
+            // construct u row and v row
+            // width is halved because of downsampling
+            int offset = i * (width >> 1);
+            cb[i] = uRows + offset;
+            cr[i] = vRows + offset;
+        }
+
+        jpeg_write_raw_data(cinfo, planes, 16);
+    }
+    delete [] yRows;
+    delete [] uRows;
+    delete [] vRows;
+}
+
+
+void Yuv422IToJpegEncoder::deinterleave(uint8_t* yuv, uint8_t* yRows, uint8_t* uRows,
+        uint8_t* vRows, int rowIndex, int width, int height) {
+    for (int row = 0; row < 16; ++row) {
+        uint8_t* yuvSeg = yuv + (rowIndex + row) * width * 2;
+        for (int i = 0; i < (width >> 1); ++i) {
+            int indexY = row * width + (i << 1);
+            int indexU = row * (width >> 1) + i;
+            yRows[indexY] = yuvSeg[0];
+            yRows[indexY + 1] = yuvSeg[2];
+            uRows[indexU] = yuvSeg[1];
+            vRows[indexU] = yuvSeg[3];
+            yuvSeg += 4;
+        }
+    }
+}
+
+void Yuv422IToJpegEncoder::configSamplingFactors(jpeg_compress_struct* cinfo) {
+    // cb and cr are horizontally downsampled and vertically downsampled as well.
+    cinfo->comp_info[0].h_samp_factor = 2;
+    cinfo->comp_info[0].v_samp_factor = 2;
+    cinfo->comp_info[1].h_samp_factor = 1;
+    cinfo->comp_info[1].v_samp_factor = 2;
+    cinfo->comp_info[2].h_samp_factor = 1;
+    cinfo->comp_info[2].v_samp_factor = 2;
+}
+
+int Yuv422IToJpegEncoder::yuvResize(uint8_t* srcBuf, int srcWidth, int srcHeight,
+                uint8_t* dstBuf, int dstWidth, int dstHeight)
+{
+    int i,j,s;
+    int h_offset;
+    int v_offset;
+    unsigned char *ptr,cc;
+    int h_scale_ratio;
+    int v_scale_ratio;
+
+    s = 0;
+
+_resize_begin:
+
+    if(!dstWidth) return -1;
+    if(!dstHeight) return -1;
+
+    h_scale_ratio = srcWidth / dstWidth;
+    if(!h_scale_ratio) return -1;
+
+    v_scale_ratio = srcHeight / dstHeight;
+    if(!v_scale_ratio) return -1;
+
+    h_offset = (srcWidth - dstWidth * h_scale_ratio) / 2;
+    v_offset = (srcHeight - dstHeight * v_scale_ratio) / 2;
+
+    for(i = 0; i < dstHeight * v_scale_ratio; i += v_scale_ratio)
+    {
+        for(j = 0; j < dstWidth * h_scale_ratio; j += h_scale_ratio)
+        {
+            ptr = srcBuf + i * srcWidth + j + v_offset * srcWidth + h_offset;
+            cc = ptr[0];
+
+            ptr = dstBuf + (i / v_scale_ratio) * dstWidth + (j / h_scale_ratio);
+            ptr[0] = cc;
+        }
+    }
+
+    srcBuf += srcWidth*srcHeight;
+    dstBuf += dstWidth*dstHeight;
+
+    if(s < 2)
+    {
+        if(!s++)
+        {
+            srcWidth >>= 1;
+            srcHeight >>= 1;
+
+            dstWidth >>= 1;
+            dstHeight >>= 1;
+        }
+
+        goto _resize_begin;
+    }
+
+    return 0;
+}
+
+
+void jpegBuilder_error_exit(j_common_ptr cinfo)
+{
+    jpegBuilder_error_mgr* error = (jpegBuilder_error_mgr*)cinfo->err;
+
+    (*error->output_message) (cinfo);
+
+    /* Let the memory manager delete any temp files before we die */
+    jpeg_destroy(cinfo);
+
+    longjmp(error->fJmpBuf, -1);
+}
+
+
+static void jpegBuilder_init_destination (j_compress_ptr cinfo) {
+    jpegBuilder_destination_mgr* dest = (jpegBuilder_destination_mgr*)cinfo->dest;
+
+    dest->next_output_byte = dest->buf;
+    dest->free_in_buffer = dest->bufsize;
+    dest->jpegsize = 0;
+}
+
+static boolean jpegBuilder_empty_output_buffer(j_compress_ptr cinfo) {
+    jpegBuilder_destination_mgr* dest = (jpegBuilder_destination_mgr*)cinfo->dest;
+
+    dest->next_output_byte = dest->buf;
+    dest->free_in_buffer = dest->bufsize;
+    return TRUE; // ?
+}
+
+static void jpegBuilder_term_destination (j_compress_ptr cinfo) {
+    jpegBuilder_destination_mgr* dest = (jpegBuilder_destination_mgr*)cinfo->dest;
+    dest->jpegsize = dest->bufsize - dest->free_in_buffer;
+}
+
+jpegBuilder_destination_mgr::jpegBuilder_destination_mgr(uint8_t* input, int size) {
+    this->init_destination = jpegBuilder_init_destination;
+    this->empty_output_buffer = jpegBuilder_empty_output_buffer;
+    this->term_destination = jpegBuilder_term_destination;
+
+    this->buf = input;
+    this->bufsize = size;
+
+    jpegsize = 0;
+}
+
+
diff --git a/mx6/libcamera/YuvToJpegEncoder.h b/mx6/libcamera/YuvToJpegEncoder.h
new file mode 100755
index 0000000..863ef28
--- /dev/null
+++ b/mx6/libcamera/YuvToJpegEncoder.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef YuvToJpegEncoder_DEFINED
+#define YuvToJpegEncoder_DEFINED
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "CameraUtil.h"
+
+extern "C" {
+    #include "jpeglib.h"
+    #include "jerror.h"
+}
+#include <setjmp.h>
+
+class YuvToJpegEncoder {
+public:
+    /** Create an encoder based on the YUV format.
+     */
+    static YuvToJpegEncoder* create(int pixelFormat);
+
+    YuvToJpegEncoder();
+
+    static int getSupportedPictureFormat(int* pFormat, int len);
+    /** Encode YUV data to jpeg,  which is output to a stream.
+     */
+    int encode(void* inYuv, int inWidth, int inHeight, int quality,
+                    void* outBuf, int outSize, int outWidth, int outHeight);
+
+    virtual ~YuvToJpegEncoder() {}
+
+protected:
+    int fNumPlanes;
+
+    void setJpegCompressStruct(jpeg_compress_struct* cinfo, int width,
+            int height, int quality);
+    virtual void configSamplingFactors(jpeg_compress_struct* cinfo) = 0;
+    virtual void compress(jpeg_compress_struct* cinfo, uint8_t* yuv) = 0;
+    virtual int yuvResize(uint8_t* srcBuf, int srcWidth, int srcHeight,
+                uint8_t* dstBuf, int dstWidth, int dstHeight) = 0;
+};
+
+class Yuv420SpToJpegEncoder : public YuvToJpegEncoder {
+public:
+     Yuv420SpToJpegEncoder();
+     virtual ~Yuv420SpToJpegEncoder() {}
+
+private:
+     void configSamplingFactors(jpeg_compress_struct* cinfo);
+     void deinterleaveYuv(uint8_t* yuv, int width, int height,
+            uint8_t*& yPlanar, uint8_t*& uPlanar, uint8_t*& vPlanar);
+     void deinterleave(uint8_t* vuPlanar, uint8_t* uRows, uint8_t* vRows,
+             int rowIndex, int width);
+     void compress(jpeg_compress_struct* cinfo, uint8_t* yuv);
+     virtual int yuvResize(uint8_t* srcBuf, int srcWidth, int srcHeight,
+                uint8_t* dstBuf, int dstWidth, int dstHeight);
+};
+
+class Yuv422IToJpegEncoder : public YuvToJpegEncoder {
+public:
+    Yuv422IToJpegEncoder();
+    virtual ~Yuv422IToJpegEncoder() {}
+
+private:
+    void configSamplingFactors(jpeg_compress_struct* cinfo);
+    void compress(jpeg_compress_struct* cinfo, uint8_t* yuv);
+    void deinterleave(uint8_t* yuv, uint8_t* yRows, uint8_t* uRows,
+            uint8_t* vRows, int rowIndex, int width, int height);
+    virtual int yuvResize(uint8_t* srcBuf, int srcWidth, int srcHeight,
+                uint8_t* dstBuf, int dstWidth, int dstHeight);
+};
+
+struct jpegBuilder_destination_mgr : jpeg_destination_mgr {
+    jpegBuilder_destination_mgr(uint8_t* input, int size);
+
+    uint8_t* buf;
+    int bufsize;
+    size_t jpegsize;
+};
+
+
+struct jpegBuilder_error_mgr : jpeg_error_mgr {
+    jmp_buf fJmpBuf;
+};
+
+void jpegBuilder_error_exit(j_common_ptr cinfo);
+
+#endif
diff --git a/mx6/libcamera/messageQueue.cpp b/mx6/libcamera/messageQueue.cpp
index 29a2087..1dffe07 100755
--- a/mx6/libcamera/messageQueue.cpp
+++ b/mx6/libcamera/messageQueue.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +15,6 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
 
 #include <stdint.h>
 #include <errno.h>
@@ -29,7 +26,6 @@
 #include <binder/IPCThreadState.h>
 
 #include "messageQueue.h"
-#include "Camera_utils.h"
 
 namespace android {
 
@@ -49,44 +45,39 @@ void CMessageList::clear()
 }
 
 CMessageQueue::CMessageQueue()
-    :mQuit(false), mStop(false)
-{
-    mQuitMessage = new CMessage(CMESSAGE_TYPE_QUITE);
-    mStopMessage = new CMessage(CMESSAGE_TYPE_STOP);
-}
-
-CMessageQueue::~CMessageQueue()
 {
     Mutex::Autolock _l(mLock);
     mMessages.clear();
 }
 
-void CMessageQueue::clearMessage()
+CMessageQueue::~CMessageQueue()
 {
-    CAMERA_LOG_ERR("-------CMessageQueue::clearMessage--------");
     Mutex::Autolock _l(mLock);
     mMessages.clear();
-    mStop = false;
 }
 
 sp<CMessage> CMessageQueue::waitMessage(nsecs_t timeout)
 {
     sp<CMessage> result;
+    sp<SyncMessage> syncResult;
     nsecs_t timeoutTime = systemTime() + timeout;
     while(true) {
         Mutex::Autolock _l(mLock);
         nsecs_t now = systemTime();
-        LIST::iterator cur(mMessages.begin());
-
-        if(mQuit) {
-            result = mQuitMessage;
-            return result;
+        //handle sync message firstly.
+        LIST::iterator scur(mSyncMessages.begin());
+        if(scur != mSyncMessages.end()) {
+            syncResult = (SyncMessage*)(*scur).get();
         }
-        if(mStop) {
-            result = mStopMessage;
-            return result;
+
+        if(syncResult != 0) {
+            result = (CMessage*)syncResult.get();
+            mSyncMessages.remove(scur);
+            break;
         }
 
+        //handle sync message secondly.
+        LIST::iterator cur(mMessages.begin());
         if(cur != mMessages.end()) {
             result = *cur;
         }
@@ -107,35 +98,40 @@ sp<CMessage> CMessageQueue::waitMessage(nsecs_t timeout)
             mCondition.wait(mLock);
         }
     }
+
+    if(syncResult != NULL) {
+        syncResult->notify();
+    }
+
     return result;
 }
 
-status_t CMessageQueue::postMessage(const sp<CMessage>& message, int32_t flags) 
+status_t CMessageQueue::postMessage(const sp<CMessage>& message, int32_t flags)
 {
     return queueMessage(message, flags);
 }
 
-status_t CMessageQueue::postQuitMessage()
+status_t CMessageQueue::postSyncMessage(const sp<SyncMessage>& message, int32_t flags)
 {
-    Mutex::Autolock _l(mLock);
-    mQuit = true;
-    mCondition.signal();
-    return NO_ERROR;
+    status_t res = queueSyncMessage(message, flags);
+    if (res == NO_ERROR) {
+        message->wait();
+    }
+    return res;
 }
 
-status_t CMessageQueue::postStopMessage()
+status_t CMessageQueue::queueMessage(const sp<CMessage>& message, int32_t flags)
 {
     Mutex::Autolock _l(mLock);
-    mStop = true;
-    //mMessages.insert(new CMessage(CMESSAGE_TYPE_STOP, 0));
+    mMessages.insert(message);
     mCondition.signal();
     return NO_ERROR;
 }
 
-status_t CMessageQueue::queueMessage(const sp<CMessage>& message, int32_t flags)
+status_t CMessageQueue::queueSyncMessage(const sp<SyncMessage>& message, int32_t flags)
 {
     Mutex::Autolock _l(mLock);
-    mMessages.insert(message);
+    mSyncMessages.insert(message.get());
     mCondition.signal();
     return NO_ERROR;
 }
diff --git a/mx6/libcamera/messageQueue.h b/mx6/libcamera/messageQueue.h
index 243d497..154ff47 100755
--- a/mx6/libcamera/messageQueue.h
+++ b/mx6/libcamera/messageQueue.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +15,6 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- */
-
 
 #ifndef CAMERA_HAL_MESSAGE_QUEUE_H
 #define CAMERA_HAL_MESSAGE_QUEUE_H
@@ -28,17 +25,10 @@
 #include <utils/threads.h>
 #include <utils/Timers.h>
 #include <utils/List.h>
-
-//#include "Barrier.h"
+#include <semaphore.h>
 
 namespace android {
 
-typedef enum{
-    CMESSAGE_TYPE_NORMAL = 0,
-    CMESSAGE_TYPE_STOP = -1,
-    CMESSAGE_TYPE_QUITE = -2,
-}CMESSAGE_TYPE;
-
 class CMessage;
 
 class CMessageList
@@ -59,20 +49,46 @@ public:
 class CMessage : public LightRefBase<CMessage>
 {
 public:
-    CMESSAGE_TYPE what;
+    int32_t what;
     int32_t arg0;
 
-    //CMessage(): what(0), arg0(0) {}
-    CMessage(CMESSAGE_TYPE what, int32_t arg0=0)
+    CMessage(int32_t what, int32_t arg0=0)
         : what(what), arg0(arg0) {}
 
-//protected:
     virtual ~CMessage() {}
 
 private:
     friend class LightRefBase<CMessage>;
 };
 
+class SyncMessage : public CMessage
+{
+public:
+    SyncMessage(int32_t what, int32_t arg0=0)
+        : CMessage(what, arg0)
+    {
+        sem_init(&mSem, 0, 0);
+    }
+
+    void wait()
+    {
+        sem_wait(&mSem);
+    }
+
+    void notify()
+    {
+        sem_post(&mSem);
+    }
+
+    ~SyncMessage()
+    {
+        sem_destroy(&mSem);
+    }
+
+private:
+    sem_t mSem;
+};
+
 class CMessageQueue
 {
     typedef List< sp<CMessage> > LIST;
@@ -82,20 +98,16 @@ public:
 
     sp<CMessage> waitMessage(nsecs_t timeout=-1);
     status_t postMessage(const sp<CMessage>& message, int32_t flags=0);
-    status_t postQuitMessage();
-    status_t postStopMessage();
-    void clearMessage();
+    status_t postSyncMessage(const sp<SyncMessage>& message, int32_t flags=0);
 
 private:
     status_t queueMessage(const sp<CMessage>& message, int32_t flags);
+    status_t queueSyncMessage(const sp<SyncMessage>& message, int32_t flags);
 
     Mutex mLock;
     Condition mCondition;
     CMessageList mMessages;
-    bool mQuit;
-    bool mStop;
-    sp<CMessage> mQuitMessage;
-    sp<CMessage> mStopMessage;
+    CMessageList mSyncMessages;
 };
 
 
-- 
1.8.0

