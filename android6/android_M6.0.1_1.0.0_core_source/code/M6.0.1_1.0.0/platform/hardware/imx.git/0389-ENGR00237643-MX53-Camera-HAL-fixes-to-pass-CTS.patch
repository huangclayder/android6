From 2e19f2a91b1286d0b90bab759f746a65a1521318 Mon Sep 17 00:00:00 2001
From: Lauren Post <lauren.post@freescale.com>
Date: Tue, 18 Dec 2012 14:25:18 -0600
Subject: [PATCH 389/635] ENGR00237643 MX53 Camera HAL fixes to pass CTS

Align with earlier MX6 Camera HAL that passed Camera CTS

Signed-off-by: Lauren Post <lauren.post@freescale.com>
---
 Android.mk                                    |    2 +-
 mx5x/libcamera/Android.mk                     |   18 +-
 mx5x/libcamera/CameraHal.cpp                  | 1591 +++++++++++--------------
 mx5x/libcamera/CameraHal.h                    |  166 +--
 mx5x/libcamera/CameraModule.cpp               |  147 ++-
 mx5x/libcamera/Camera_utils.h                 |   21 +-
 mx5x/libcamera/CaptureDeviceInterface.cpp     |   11 +-
 mx5x/libcamera/CaptureDeviceInterface.h       |   46 +-
 mx5x/libcamera/JpegEncoderInterface.cpp       |    6 +-
 mx5x/libcamera/JpegEncoderInterface.h         |    2 +-
 mx5x/libcamera/JpegEncoderSoftware.cpp        |   63 +-
 mx5x/libcamera/JpegEncoderSoftware.h          |   10 +-
 mx5x/libcamera/PP_ipulib.cpp                  |   20 +-
 mx5x/libcamera/PP_ipulib.h                    |    2 +-
 mx5x/libcamera/PostProcessDeviceInterface.cpp |    2 +-
 mx5x/libcamera/PostProcessDeviceInterface.h   |    2 +-
 mx5x/libcamera/V4l2CapDeviceBase.cpp          |  283 ++---
 mx5x/libcamera/V4l2CapDeviceBase.h            |   72 +-
 mx5x/libcamera/V4l2CsiDevice.cpp              |  176 ++-
 mx5x/libcamera/V4l2CsiDevice.h                |   32 +-
 mx5x/libcamera/V4l2UVCDevice.cpp              |  716 +++++++++++
 mx5x/libcamera/V4l2UVCDevice.h                |   74 +-
 mx5x/libcamera/messageQueue.cpp               |    4 +-
 mx5x/libcamera/messageQueue.h                 |    2 +-
 24 files changed, 1999 insertions(+), 1469 deletions(-)
 create mode 100644 mx5x/libcamera/V4l2UVCDevice.cpp

diff --git a/Android.mk b/Android.mk
index eaac90e..a5311e4 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 common_imx_dirs := libsensors libgps lights wlan
-mx5x_dirs := $(common_imx_dirs) mx5x/audio mx5x/libgralloc mx5x/hwcomposer mx5x/libcamera mx5x/power
+mx5x_dirs := $(common_imx_dirs) mx5x/audio mx5x/libcopybit mx5x/libgralloc  mx5x/hwcomposer mx5x/libcamera
 mx6_dirs := $(common_imx_dirs) alsa mx6/libgralloc_wrapper mx6/hwcomposer mx6/libcamera mx6/power
 
 ifeq ($(TARGET_BOARD_PLATFORM),imx6)
diff --git a/mx5x/libcamera/Android.mk b/mx5x/libcamera/Android.mk
index ccc0a78..13b156b 100755
--- a/mx5x/libcamera/Android.mk
+++ b/mx5x/libcamera/Android.mk
@@ -22,15 +22,13 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES:=    \
 	CameraHal.cpp    \
 	CameraModule.cpp \
-    Camera_pmem.cpp  \
 	CaptureDeviceInterface.cpp \
 	V4l2CsiDevice.cpp \
 	V4l2CapDeviceBase.cpp  \
-	PostProcessDeviceInterface.cpp \
-	PP_ipulib.cpp    \
 	JpegEncoderInterface.cpp \
     JpegEncoderSoftware.cpp \
-    messageQueue.cpp
+    messageQueue.cpp \
+    V4l2UVCDevice.cpp
 
 LOCAL_CPPFLAGS +=
 
@@ -42,22 +40,20 @@ LOCAL_SHARED_LIBRARIES:= \
     libbinder \
     libmedia \
     libhardware_legacy \
+    libion \
     libdl \
-    libc \
-	libipu
+    libc
 
 LOCAL_C_INCLUDES += \
 	frameworks/base/include/binder \
 	frameworks/base/include/ui \
 	frameworks/base/camera/libcameraservice \
-	external/linux-lib/ipu \
 	hardware/imx/mx5x/libgralloc
 
 ifeq ($(HAVE_FSL_IMX_CODEC),true)
     LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
     LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
-    LOCAL_C_INCLUDES +=	\
-         device/fsl-proprietary/codec/ghdr
+    LOCAL_C_INCLUDES += device/fsl-proprietary/codec/ghdr
 endif
 ifeq ($(BOARD_CAMERA_NV12),true)
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
@@ -68,7 +64,9 @@ endif
 #Define this for switch the Camera through V4L2 MXC IOCTL
 #LOCAL_CPPFLAGS += -DV4L2_CAMERA_SWITCH
 
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw	
+LOCAL_CPPFLAGS += -Werror
+
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
 LOCAL_MODULE:= camera.$(TARGET_BOARD_PLATFORM)
 
 LOCAL_CFLAGS += -fno-short-enums
diff --git a/mx5x/libcamera/CameraHal.cpp b/mx5x/libcamera/CameraHal.cpp
index 885e679..111c4ba 100755
--- a/mx5x/libcamera/CameraHal.cpp
+++ b/mx5x/libcamera/CameraHal.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 
@@ -30,16 +30,25 @@
 #include <ui/Rect.h>
 #include "gralloc_priv.h"
 
-namespace android {
+#include <ion/ion.h>
+
+using namespace android;
 
     CameraHal::CameraHal(int cameraid)
-        : mParameters(),
+        :
+        mCaptureRunning(0),
+        mExitCaptureThread(false),
+        mPreviewRunning(0),
+        mExitPreviewThread(false),
+        mExitEncodeThread(false),
+        mTakePictureInProcess(false),
+        mTakePictureAllocBuffer(false),
+        mParameters(),
         mCallbackCookie(NULL),
         mNotifyCb(NULL),
         mDataCb(NULL),
         mDataCbTimestamp(NULL),
         mCaptureFrameThread(NULL),
-        mPostProcessThread(NULL),
         mPreviewShowFrameThread(NULL),
         mEncodeFrameThread(NULL),
         mAutoFocusThread(NULL),
@@ -53,10 +62,8 @@ namespace android {
         mNativeWindow(NULL),
         mMsgEnabled(0),
         mPreviewMemory(NULL),
-        mVideoMemory(NULL),
         mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
-        mPPbufNum(0),
-        mPreviewRunning(0), mCaptureRunning(0),
+        mVideoMemory(NULL),
         mDefaultPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
         mPreviewFrameSize(0),
         mTakePicFlag(false),
@@ -64,8 +71,6 @@ namespace android {
         mCaptureFrameSize(0),
         mCaptureBufNum(0),
         mEnqueuedBufs(0),
-        isCaptureBufsAllocated(0),
-        //isPreviewFinsh(0),
         mRecordRunning(0),
         mCurrentRecordFrame(0),
         nCameraBuffersQueued(0),
@@ -73,22 +78,31 @@ namespace android {
         mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
         mCameraReady(false),
         mCaptureDeviceOpen(false),
-        mPPDeviceNeed(false),
-        bDirectInput(false),
-        mCameraid(cameraid),
-        mPPDeviceNeedForPic(false),
+        mIsCaptureBufsAllocated(0),
         mPowerLock(false),
+        mDirectInput(false),
+        mCameraid(cameraid),
         mPreviewRotate(CAMERA_PREVIEW_BACK_REF),
-        mExitCaptureThread(false), mExitPreviewThread(false), 
-        mExitPostProcessThread(false), mExitEncodeThread(false), mTakePictureInProcess(false)
-    {
-        CAMERA_HAL_LOG_FUNC;
+        mIonFd(-1),
+        mUseIon(true)
+   {
+        CAMERA_LOG_FUNC;
+
+        if(mUseIon) {
+            mIonFd = ion_open();
+            if(mIonFd <= 0) {
+                CAMERA_LOG_INFO("open ion failed.");
+            }
+        }
         preInit();
     }
 
     CameraHal :: ~CameraHal()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
+        if(mUseIon) {
+            ion_close(mIonFd);
+        }
         CameraMiscDeInit();
         CloseCaptureDevice();
         FreeInterBuf();
@@ -99,11 +113,13 @@ namespace android {
         if(mPreviewMemory != NULL) {
             mPreviewMemory->release(mPreviewMemory);
         }
+        status_t err;
+
     }
 
     void CameraHal :: release()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         Mutex::Autolock lock(mLock);
 
         mCameraReady = false;
@@ -114,17 +130,19 @@ namespace android {
 
     void CameraHal :: preInit()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
+        mVpuSupportFmt[0] = v4l2_fourcc('N','V','1','2');
+        mVpuSupportFmt[1] = v4l2_fourcc('Y','U','1','2');
     }
     void CameraHal :: postDestroy()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
+    CAMERA_HAL_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
         if (mCameraReady == false)
             mCaptureDevice = capturedevice;
         else
@@ -132,21 +150,10 @@ namespace android {
         return ret;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice)
+    CAMERA_HAL_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mPPDevice = postprocessdevice;
-        else 
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
         if (mCameraReady == false)
             mJpegEncoder = jpegencoder;
         else
@@ -154,28 +161,17 @@ namespace android {
         return ret;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal::Init()
+    CAMERA_HAL_RET CameraHal::Init()
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
         mCameraReady == true;
+        mCaptureDevice->GetDevType(&mSensorType);
 
-        CAMERA_TYPE cType;
-        mCaptureDevice->GetDevType(&cType);
-        if(cType == CAMERA_TYPE_UVC) {
-            mPPDeviceNeed = true;
-            CAMERA_HAL_LOG_INFO("-----%s: it is uvc device", __FUNCTION__);
-        }else {
-            mPPDeviceNeed = false;
-            CAMERA_HAL_LOG_INFO("-----%s: it is csi device", __FUNCTION__);
-        }
-
-        if ((ret = AolLocForInterBuf())<0)
+        if ((ret = AllocInterBuf())<0)
             return ret;
         if ((ret = InitCameraHalParam()) < 0)
             return ret;
-        if (mPPDeviceNeed == true && mPPDevice == NULL)
-            return CAMERA_HAL_ERR_PP_NULL;
         if ((ret = CameraMiscInit()) < 0)
             return ret;
 
@@ -183,15 +179,15 @@ namespace android {
     }
     void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         mPreviewRotate = previewRotate;
         return ;
     }
 
-    CAMERA_HAL_ERR_RET  CameraHal :: AolLocForInterBuf()
+    CAMERA_HAL_RET  CameraHal :: AllocInterBuf()
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
 
         mSupportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
         mSupportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
@@ -210,7 +206,7 @@ namespace android {
     }
     void  CameraHal :: FreeInterBuf()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mSupportedPictureSizes)
             free(mSupportedPictureSizes);
         if (mSupportedPreviewSizes)
@@ -221,10 +217,10 @@ namespace android {
             free(mSupprotedThumbnailSizes);
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
-    {	
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+    CAMERA_HAL_RET CameraHal :: InitCameraHalParam()
+    {
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
 
         if ((ret = InitCameraBaseParam(&mParameters)) < 0)
             return ret;
@@ -235,20 +231,17 @@ namespace android {
         return ret;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal::CameraMiscInit()
+    CAMERA_HAL_RET CameraHal::CameraMiscInit()
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        pthread_mutex_init(&mPPIOParamMutex, NULL);
-        pthread_mutex_init(&mOverlayMutex, NULL);
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
 
         mPreviewRunning = false;
         mCaptureRunning = false;
         mWaitForTakingPicture = false;
         sem_init(&mCaptureStoppedCondition, 0, 0);
         sem_init(&mPreviewStoppedCondition, 0, 0);
-        sem_init(&mEncodeStoppedCondition, 0, 0);
-        sem_init(&mPostProcessStoppedCondition, 0, 0);
+        //sem_init(&mEncodeStoppedCondition, 0, 0);
         sem_init(&mTakingPicture, 0, 0);
         //mPostProcessRunning = false;
         //mEncodeRunning = false;
@@ -257,67 +250,80 @@ namespace android {
         mEncodeFrameThread = new EncodeFrameThread(this);
         mTakePicThread= new TakePicThread(this);
 
-        if(mPPDeviceNeed){
-            mPostProcessThread = new PostProcessThread(this);
-            if (mPostProcessThread == NULL)
-                 return CAMERA_HAL_ERR_INIT;
-        }
-
         if (mCaptureFrameThread == NULL || mPreviewShowFrameThread == NULL ||
                 mEncodeFrameThread == NULL || mTakePicThread == NULL){
             return CAMERA_HAL_ERR_INIT;
         }
         return ret;
     }
-    CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
+    CAMERA_HAL_RET CameraHal::CameraMiscDeInit()
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAMERA_HAL_RET ret = CAMERA_HAL_ERR_NONE;
         mCaptureThreadQueue.postQuitMessage();
         //Make sure all thread been exit, in case they still
         //access the message queue
-        mCaptureFrameThread->requestExitAndWait();
-        mPreviewShowFrameThread->requestExitAndWait();
-        mEncodeFrameThread->requestExitAndWait();
-        mTakePicThread->requestExitAndWait();
-        pthread_mutex_destroy(&mPPIOParamMutex);
-        pthread_mutex_destroy(&mOverlayMutex);
+        if(mCaptureFrameThread != NULL)
+            mCaptureFrameThread->requestExitAndWait();
+
+        //Post Quite message to make sure the thread can be exited
+        //In case mCaptureFrameThread not been started yet in CTS test
+        mPreviewThreadQueue.postQuitMessage();
+        if(mPreviewShowFrameThread != NULL)
+            mPreviewShowFrameThread->requestExitAndWait();
+        mEncodeThreadQueue.postQuitMessage();
+        if(mEncodeFrameThread != NULL)
+            mEncodeFrameThread->requestExitAndWait();
+        if(mTakePicThread != NULL)
+            mTakePicThread->requestExitAndWait();
         return ret;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
+    CAMERA_HAL_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
     {
-        CAMERA_HAL_LOG_FUNC;
-        int i;
+        CAMERA_LOG_FUNC;
+        int i, n;
+        unsigned int uFormat[MAX_QUERY_FMT_TIMES];
         char fmtStr[40];
 
         memset(fmtStr, 0, 40);
-        convertPreviewFormatToString(fmtStr, 40, mDefaultPreviewFormat);
+        convertPreviewFormatToString(fmtStr, 40, mPreviewCapturedFormat);
         mParameters.setPreviewFormat(fmtStr);
         mParameters.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, fmtStr);
 
+        memset(uFormat, 0, sizeof(uFormat));
+        for(n = 0; n < nFmt; n++) {
+            uFormat[n] = mSensorSupportFmt[n];
+        }
+
         memset(fmtStr, 0, 40);
-        for(i = 0; i < nFmt; i++) {
-            if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','1','2')) {
-                strcat(fmtStr, "yuv420p");
-                strcat(fmtStr, ",");
-            }
-            else if(mCaptureSupportedFormat[i] == v4l2_fourcc('N','V','1','2')) {
-                strcat(fmtStr, "yuv420sp");
-                strcat(fmtStr, ",");
+        for(i = 0; i < n; i++) {
+            for (int j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
+                //should report VPU support format.
+                if(uFormat[i] == mVpuSupportFmt[j]) {
+                    if(uFormat[i] == v4l2_fourcc('Y','U','1','2')) {
+                        strcat(fmtStr, "yuv420p");
+                        strcat(fmtStr, ",");
+                    }
+                    else if(uFormat[i] == v4l2_fourcc('N','V','1','2')) {
+                        strcat(fmtStr, "yuv420sp");
+                        strcat(fmtStr, ",");
+                    }
+                    //else if(mSensorSupportFmt[i] == v4l2_fourcc('Y','U','Y','V')) {
+                    //    strcat(fmtStr, "yuv422i-yuyv");
+                    //    strcat(fmtStr, ",");
+                    //}
+                }
             }
-            //else if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','Y','V')) {
-            //    strcat(fmtStr, "yuv422i-yuyv");
-            //    strcat(fmtStr, ",");
-            //}
         }
+
         mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
         return CAMERA_HAL_ERR_NONE;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
+    CAMERA_HAL_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         char TmpStr[20];
         unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
         struct capture_config_t CaptureSizeFps;
@@ -328,37 +334,42 @@ namespace android {
         if (OpenCaptureDevice() < 0)
             return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
 
-        memset(mCaptureSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+        memset(mSensorSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
 
         for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mCaptureSupportedFormat[i])) < 0)
+            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mSensorSupportFmt[i])) < 0)
                 break;
         }
         if (i == 0)
             return CAMERA_HAL_ERR_GET_PARAM;
 
-        InitCameraPreviewFormatToParam(i);
+        //InitCameraPreviewFormatToParam(i);
 
         if (NegotiateCaptureFmt(false) < 0)
             return CAMERA_HAL_ERR_GET_PARAM;
 
+        //mCaptureDeviceCfg.fmt stores format related to driver.
         CaptureSizeFps.fmt = mCaptureDeviceCfg.fmt;//mPreviewCapturedFormat;
 
-        memset(TmpStr, 0, 20);
-        convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
-        mParameters.setPreviewFormat(TmpStr);
+        //mPreviewCapturedFormat stores format report to app.
+        InitCameraPreviewFormatToParam(i);
+        //memset(TmpStr, 0, 20);
+        //mPreviewCapturedFormat stores format report to app.
+        //convertPreviewFormatToString(TmpStr, 20, mPreviewCapturedFormat);
+        //convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
+        //mParameters.setPreviewFormat(TmpStr);
 
-        CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
+        CAMERA_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
 
         for(;;){
             if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
-                CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
+                CAMERA_LOG_RUNTIME("get the frame size and time interval error");
                 break;
             }
             memset(TmpStr, 0, 20);
             sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
-            CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
-            if (previewCnt == 0)
+            CAMERA_LOG_INFO("Size: %s , Framerate: %d supported", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
+            if (pictureCnt == 0)
                 strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
             else{
                 strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
@@ -366,7 +377,23 @@ namespace android {
             }
             pictureCnt ++;
 
-            if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator >= 15){
+            //Limite the FPS and resolution for preview setting
+            //Typically only max to 1080p for mipi, 720p for csi,
+            //and minum 15 fps need for preview.
+            unsigned int max_preview_w, max_preview_h;
+            char device_name[CAMERA_SENSOR_LENGTH];
+            memset(device_name, 0, CAMERA_SENSOR_LENGTH);
+            mCaptureDevice->GetDevName(device_name);
+            if(strstr(device_name, "mipi")) {
+                max_preview_w = MAX_MIPI_PREVIEW_W;
+                max_preview_h = MAX_MIPI_PREVIEW_H;
+            } else {
+                max_preview_w = MAX_CSI_PREVIEW_W;
+                max_preview_h = MAX_CSI_PREVIEW_H;
+            }
+
+            if ((CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator >= 15)&&
+                (CaptureSizeFps.width <= max_preview_w)&&(CaptureSizeFps.height <= max_preview_h)){
                 if (previewCnt == 0)
                     strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
                 else{
@@ -379,19 +406,19 @@ namespace android {
 
         /*hard code here*/
         strcpy(mSupportedFPS, "15,30");
-        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", mSupportedPictureSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", mSupportedPreviewSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", mSupportedFPS);
+        CAMERA_LOG_INFO("SupportedPictureSizes is %s", mSupportedPictureSizes);
+        CAMERA_LOG_INFO("SupportedPreviewSizes is %s", mSupportedPreviewSizes);
+        CAMERA_LOG_INFO("SupportedFPS is %s", mSupportedFPS);
 
         pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
         pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
         pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,15000),(30000,30000)");
-        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "30000,30000");
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(12000,17000),(25000,33000)");
+        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
 
-        pParam->setPreviewSize(640, 480);
-        pParam->setPictureSize(640, 480);
-        pParam->setPreviewFrameRate(5);
+        pParam->setPreviewSize(DEFAULT_PREVIEW_W, DEFAULT_PREVIEW_H);
+        pParam->setPictureSize(DEFAULT_PICTURE_W, DEFAULT_PICTURE_H);
+        pParam->setPreviewFrameRate(DEFAULT_PREVIEW_FPS);
 
         return CAMERA_HAL_ERR_NONE;
 
@@ -399,10 +426,10 @@ namespace android {
 
     status_t CameraHal :: OpenCaptureDevice()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         if (mCaptureDeviceOpen){
-            CAMERA_HAL_LOG_INFO("The capture device already open");
+            CAMERA_LOG_INFO("The capture device already open");
             return NO_ERROR;
         }
         else if (mCaptureDevice != NULL){
@@ -410,23 +437,23 @@ namespace android {
                 return INVALID_OPERATION;
             mCaptureDeviceOpen = true;
         }else{
-            CAMERA_HAL_ERR("no capture device assigned");
+            CAMERA_LOG_ERR("no capture device assigned");
             return INVALID_OPERATION;
         }
         return ret;
     }
     void CameraHal ::CloseCaptureDevice()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCaptureDeviceOpen && mCaptureDevice != NULL){
             mCaptureDevice->DevClose();
             mCaptureDeviceOpen = false;
         }
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
+    CAMERA_HAL_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
 
         /*hard code here*/
@@ -554,20 +581,19 @@ namespace android {
     void CameraHal::enableMsgType(int32_t msgType)
     {
         Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg enabled is %x###", msgType);
+        CAMERA_LOG_INFO("enableMsgType 0x%x", msgType);
         mMsgEnabled |= msgType;
     }
 
     void CameraHal::disableMsgType(int32_t msgType)
     {
         Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg disabled is %x###", msgType);
+        CAMERA_LOG_INFO("disableMsgType 0x%x", msgType);
         mMsgEnabled &= ~msgType;
     }
     bool CameraHal::msgTypeEnabled(int32_t msgType)
     {
         Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg check is %x###", msgType);
         return (mMsgEnabled & msgType);
     }
 
@@ -578,41 +604,34 @@ namespace android {
 
     char* CameraHal::getParameters() const
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         Mutex::Autolock lock(mLock);
         char* params_string;
         String8 params_str8;
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         CameraParameters mParams = mParameters;
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
 
         params_str8 = mParams.flatten();
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         strcpy(params_string, params_str8.string());
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         return params_string;
     }
 
     status_t  CameraHal:: setParameters(const char* params)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         CameraParameters parameters;
         String8 str_params(params);
 
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         parameters.unflatten(str_params);
-	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
         return setParameters(parameters);
     }
 
-    status_t  CameraHal:: setParameters(const CameraParameters& params)
+    status_t  CameraHal:: setParameters(CameraParameters& params)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int w, h;
-        int framerate;
+        int framerate, local_framerate;
         int max_zoom,zoom, max_fps, min_fps;
         char tmp[128];
         Mutex::Autolock lock(mLock);
@@ -620,58 +639,72 @@ namespace android {
         max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
         zoom = params.getInt(CameraParameters::KEY_ZOOM);
         if(zoom > max_zoom){
-            CAMERA_HAL_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
+            CAMERA_LOG_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
             return BAD_VALUE;
         }
         if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)/* || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)*/
+                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)// || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)
                 )) {
-            CAMERA_HAL_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
-            //CAMERA_HAL_ERR("Only yuv420sp,yuv420p or yuv422i-yuyv is supported, but input format is %s", params.getPreviewFormat());
+            CAMERA_LOG_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
             return BAD_VALUE;
         }
 
         if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
-            CAMERA_HAL_ERR("Only jpeg still pictures are supported");
+            CAMERA_LOG_ERR("Only jpeg still pictures are supported");
             return BAD_VALUE;
         }
 
         params.getPreviewSize(&w, &h);
         sprintf(tmp, "%dx%d", w, h);
-        CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
+        CAMERA_LOG_INFO("Set preview size: %s", tmp);
         if (strstr(mSupportedPreviewSizes, tmp) == NULL){
-            CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
+            CAMERA_LOG_ERR("The preview size w %d, h %d is not corrected", w, h);
             return BAD_VALUE;
         }
 
         params.getPictureSize(&w, &h);
         sprintf(tmp, "%dx%d", w, h);
-        CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
+        CAMERA_LOG_INFO("Set picture size: %s", tmp);
         if (strstr(mSupportedPictureSizes, tmp) == NULL){
-            CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
+            CAMERA_LOG_ERR("The picture size w %d, h %d is not corrected", w, h);
             return BAD_VALUE;
         }
 
-        framerate = params.getPreviewFrameRate();
-        CAMERA_HAL_LOG_INFO("##the set frame rate is %d ##", framerate);
-        if ((framerate > 30) || (framerate < 0) ){
-            CAMERA_HAL_ERR("The framerate is not corrected");
+        params.getPreviewFpsRange(&min_fps, &max_fps);
+        CAMERA_LOG_INFO("FPS range: %d - %d",min_fps, max_fps);
+        if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
+            CAMERA_LOG_ERR("The fps range from %d to %d is error", min_fps, max_fps);
             return BAD_VALUE;
         }
 
-        params.getPreviewFpsRange(&min_fps, &max_fps);
-        CAMERA_HAL_LOG_INFO("###the fps is %d###", max_fps);
-        if (max_fps < 1000 || min_fps < 1000 || max_fps > 30000 || min_fps > 30000){
-            CAMERA_HAL_ERR("The fps range from %d to %d is error", min_fps, max_fps);
+        local_framerate = mParameters.getPreviewFrameRate();
+        CAMERA_LOG_INFO("get local frame rate:%d FPS", local_framerate);
+        if ((local_framerate > 30) || (local_framerate < 0) ){
+            CAMERA_LOG_ERR("The framerate is not corrected");
+            local_framerate = 15;
+        }
+
+        framerate = params.getPreviewFrameRate();
+        CAMERA_LOG_INFO("Set frame rate:%d FPS", framerate);
+        if ((framerate > 30) || (framerate < 0) ){
+            CAMERA_LOG_ERR("The framerate is not corrected");
             return BAD_VALUE;
         }
+        else if(local_framerate != framerate) {
+            if(framerate == 15) {
+                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "12000,17000");
+            }
+            else if (framerate == 30) {
+                params.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "25000,33000");
+            }
+        }
 
         const char *pFlashStr;
         pFlashStr = params.get(CameraParameters::KEY_FLASH_MODE);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0 
+        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0
                 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) != 0
                 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) != 0) {
-            CAMERA_HAL_ERR("The flash mode is not corrected");
+            CAMERA_LOG_ERR("The flash mode is not corrected");
             return BAD_VALUE;
         }
 
@@ -680,34 +713,32 @@ namespace android {
         if(strcmp(pFocusStr, CameraParameters::FOCUS_MODE_AUTO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_INFINITY) != 0
                 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_MACRO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_FIXED) != 0
                 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_EDOF) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) != 0) {
-            CAMERA_HAL_ERR("The focus mode is not corrected");
+            CAMERA_LOG_ERR("The focus mode is not corrected");
             return BAD_VALUE;
         }
         mParameters = params;
-        CAMERA_HAL_LOG_INFO("%s return", __FUNCTION__);
 
         return NO_ERROR;
     }
 
     status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if(window == NULL) {
-            isCaptureBufsAllocated = 0;
-            CAMERA_HAL_ERR("the buf is null!");
+            mIsCaptureBufsAllocated = 0;
+            CAMERA_LOG_INFO("PreviewWindow is null");
         }
         else {
-            CAMERA_HAL_ERR("the buf is not null!");
+            CAMERA_LOG_ERR("PreviewWindow is valid");
         }
         mNativeWindow = window;
-        if((mNativeWindow != NULL) && !isCaptureBufsAllocated && mCaptureBufNum) {
-        //if((mNativeWindow != NULL) && !isCaptureBufsAllocated) {
+        if((mNativeWindow != NULL) && !mIsCaptureBufsAllocated && mCaptureBufNum) {
             if(PrepareCaptureBufs() < 0) {
-                CAMERA_HAL_ERR("PrepareCaptureBufs()-2 error");
+                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
                 return BAD_VALUE;
             }
             if(CameraHALPreviewStart() < 0) {
-                CAMERA_HAL_ERR("CameraHALPreviewStart()-2 error");
+                CAMERA_LOG_ERR("CameraHALPreviewStart() error");
                 return BAD_VALUE;
             }
         }
@@ -717,26 +748,30 @@ namespace android {
 
     status_t CameraHal::freeBuffersToNativeWindow()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
+        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
+            status_t err = freeBufferToIon();
+            if(err == NO_ERROR) {
+                return err;
+            }
+        }
+
 
-        //Mutex::Autolock lock(mLock);
         if (mNativeWindow == NULL){
-            CAMERA_HAL_ERR("the native window is null!");
+            CAMERA_LOG_ERR("the native window is null!");
             return BAD_VALUE;
         }
- 
+
         GraphicBufferMapper &mapper = GraphicBufferMapper::get();
-        android_native_buffer_t *buf;
-        private_handle_t *handle;
+        buffer_handle_t *handle;
         for(unsigned int i = 0; i < mCaptureBufNum; i++) {
             if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_DEQUEUED) {
-                buf = (android_native_buffer_t *)mCaptureBuffers[i].native_buf;
-                if(mCaptureBuffers[i].virt_start != NULL) {
-                    handle = (private_handle_t *)buf->handle;
-                    mapper.unlock(handle);
-                }
-                if(buf != NULL) {
-                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                handle = (buffer_handle_t *)mCaptureBuffers[i].native_buf;
+                if(handle != NULL) {
+                    if(mCaptureBuffers[i].virt_start != NULL) {
+                        mapper.unlock(*handle);
+                    }
+                    mNativeWindow->cancel_buffer(mNativeWindow, handle);
                 }
             }
             else
@@ -753,20 +788,144 @@ namespace android {
         return NO_ERROR;
     }
 
+    status_t CameraHal::freeBufferToIon()
+    {
+        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
+            CAMERA_LOG_ERR("try to free buffer from ion in preview or ion invalid");
+            return BAD_VALUE;
+        }
+
+        CAMERA_LOG_INFO("freeBufferToIon buffer num:%d", mCaptureBufNum);
+        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
+            struct ion_handle * ionHandle = (struct ion_handle *)mCaptureBuffers[i].native_buf;
+            ion_free(mIonFd, ionHandle);
+            munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::allocateBufferFromIon()
+    {
+        if(!mTakePictureAllocBuffer || mIonFd <= 0 || !mUseIon) {
+            CAMERA_LOG_ERR("try to allocate buffer from ion in preview or ion invalid");
+            return BAD_VALUE;
+        }
+
+        int width = 0, height = 0, size = 0;
+        width = mCaptureDeviceCfg.width;
+        height = mCaptureDeviceCfg.height;
+        if(width == 0 || height == 0) {
+            CAMERA_LOG_ERR("allocateBufferFromIon: width or height = 0");
+            return BAD_VALUE;
+        }
+
+        switch(mPreviewCapturedFormat) {
+            case v4l2_fourcc('N','V','1','2'):
+                size = width * height * 3/2;
+                break;
+            case v4l2_fourcc('Y','U','1','2'):
+                size = width * height * 3/2;
+                break;
+            case v4l2_fourcc('Y','U','Y','V'):
+                size = width * height * 2;
+                break;
+            default:
+                CAMERA_LOG_ERR("Error: format not supported int ion alloc");
+                return BAD_VALUE;
+        }
+
+        unsigned char *ptr = NULL;
+        int sharedFd;
+        int phyAddr;
+        struct ion_handle * ionHandle;
+
+        CAMERA_LOG_INFO("allocateBufferFromIon buffer num:%d", mCaptureBufNum);
+        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
+            ionHandle = NULL;
+            size = (size + PAGE_SIZE)&(~(PAGE_SIZE-1));
+            int err = ion_alloc(mIonFd, size, 8, 1, &ionHandle);
+            if(err) {
+                CAMERA_LOG_ERR("ion_alloc failed.");
+                return BAD_VALUE;
+            }
+
+            err = ion_map(mIonFd, ionHandle, size, PROT_READ|PROT_WRITE, MAP_SHARED, 0, &ptr, &sharedFd);
+            if(err) {
+                CAMERA_LOG_ERR("ion_map failed.");
+                return BAD_VALUE;
+            }
+            phyAddr = ion_phys(mIonFd, ionHandle);
+            if(phyAddr == 0) {
+                CAMERA_LOG_ERR("ion_phys failed.");
+                return BAD_VALUE;
+            }
+
+            mCaptureBuffers[i].virt_start = ptr;
+            mCaptureBuffers[i].phy_offset = phyAddr;
+            mCaptureBuffers[i].length =  size;
+            mCaptureBuffers[i].native_buf = (void*)ionHandle;
+            mCaptureBuffers[i].refCount = 0;
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
+            close(sharedFd);
+        }
+        return NO_ERROR;
+    }
+
+    int CameraHal::convertPreviewFormatToPixelFormat(unsigned int format)
+    {
+        int nFormat = 0;
+        switch(format) {
+            case v4l2_fourcc('N','V','1','2'):
+                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP;
+                break;
+            case v4l2_fourcc('Y','U','1','2'):
+                nFormat = HAL_PIXEL_FORMAT_YCbCr_420_P;
+                break;
+            case v4l2_fourcc('Y','U','Y','V'):
+                nFormat = HAL_PIXEL_FORMAT_YCbCr_422_I;
+                break;
+            default:
+                CAMERA_LOG_ERR("Error: format not supported!");
+                break;
+        }
+        CAMERA_LOG_INFO("pixel format: 0x%x", nFormat);
+        return nFormat;
+    }
+
     status_t CameraHal::allocateBuffersFromNativeWindow()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
-        //Mutex::Autolock lock(mLock);
+        if(mTakePictureAllocBuffer && mIonFd > 0 && mUseIon) {
+            status_t err = allocateBufferFromIon();
+            if(err == NO_ERROR) {
+                return err;
+            }
+        }
+
+        status_t err;
         if (mNativeWindow == NULL){
-            CAMERA_HAL_ERR("the native window is null!");
+            CAMERA_LOG_ERR("the native window is null!");
             return NO_ERROR;//BAD_VALUE;
         }
-        status_t err = mNativeWindow->set_buffers_geometry(mNativeWindow,
-                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height, 
-                HAL_PIXEL_FORMAT_YCbCr_420_SP);//mCaptureDeviceCfg.fmt);
+
+        //Make sure the buffer be physical continuous
+        err = mNativeWindow->set_usage(mNativeWindow,
+                GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_FORCE_CONTIGUOUS | GRALLOC_USAGE_HW_TEXTURE);
+        if(err != 0){
+            CAMERA_LOG_ERR("native_window_set_usage failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        //should use mPreviewCapturedFormat here.
+        int uFormat = convertPreviewFormatToPixelFormat(mPreviewCapturedFormat);
+        err = mNativeWindow->set_buffers_geometry(mNativeWindow,
+                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height,
+                uFormat);
         if(err != 0){
-            CAMERA_HAL_ERR("native_window_set_buffers_geometry failed:%s(%d)", 
+            CAMERA_LOG_ERR("native_window_set_buffers_geometry failed:%s(%d)",
                     strerror(-err), -err);
             return err;
         }
@@ -775,19 +934,19 @@ namespace android {
         err = mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow,
                 &minUndequeueBufs);
         if(err != 0) {
-            CAMERA_HAL_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
+            CAMERA_LOG_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
                     strerror(-err), -err);
             return err;
         }
 
         if(mCaptureBufNum > PREVIEW_CAPTURE_BUFFER_NUM) {
-            CAMERA_HAL_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
+            CAMERA_LOG_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
             return BAD_VALUE;
         }
 
         err = mNativeWindow->set_buffer_count(mNativeWindow, mCaptureBufNum);
         if(err != 0) {
-            CAMERA_HAL_ERR("native_window_set_buffer_count failed:%s(%d)",
+            CAMERA_LOG_ERR("native_window_set_buffer_count failed:%s(%d)",
                     strerror(-err), -err);
             return err;
         }
@@ -797,33 +956,30 @@ namespace android {
         void *pVaddr = NULL;
         GraphicBufferMapper &mapper = GraphicBufferMapper::get();
         for(i = 0; i < mCaptureBufNum; i++) {
-            android_native_buffer_t *buf = NULL;
             buffer_handle_t* buf_h = NULL;
             pVaddr = NULL;
             int stride;
             err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
             if((err != 0) || (buf_h == NULL)) {
-                CAMERA_HAL_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
+                CAMERA_LOG_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
                 return BAD_VALUE;
             }
-            buf = container_of(buf_h, ANativeWindowBuffer, handle);
-            private_handle_t *handle = (private_handle_t *)buf->handle;
+            private_handle_t *handle = (private_handle_t *)(*buf_h);
             mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
-
             if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
-                 CAMERA_HAL_ERR("%s: dequeue invalide Buffer, phys=%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
-                 mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                 CAMERA_LOG_ERR("%s: dequeue invalide Buffer, phys=0x%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
+                 mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
                  return BAD_VALUE;
             }
 
             mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
             mCaptureBuffers[i].phy_offset = handle->phys;
             //Calculate the buffer size, for GPU doesn't reply this value.
-            mCaptureBuffers[i].length =  mCaptureDeviceCfg.width * mCaptureDeviceCfg.height * 3 / 2;
-            mCaptureBuffers[i].native_buf = (void *)buf;
+            mCaptureBuffers[i].length =  handle->size;//mCaptureFrameSize
+            mCaptureBuffers[i].native_buf = (void *)buf_h;
             mCaptureBuffers[i].refCount = 0;
             mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
-            CAMERA_HAL_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%x, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+            CAMERA_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%p, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
         }
 
         return NO_ERROR;
@@ -831,7 +987,7 @@ namespace android {
 
     status_t CameraHal::startPreview()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
 
         if(mTakePictureInProcess) {
@@ -840,55 +996,43 @@ namespace android {
             mWaitForTakingPicture = false;
         }
         Mutex::Autolock lock(mLock);
-        //isPreviewFinsh = 0;
         mEnqueuedBufs = 0;
 
         mPreviewLock.lock();
         if (mPreviewRunning) {
             // already running
-            CAMERA_HAL_LOG_RUNTIME("%s : preview thread already running", __func__);
+            CAMERA_LOG_RUNTIME("%s : preview thread already running", __func__);
             mPreviewLock.unlock();
             return NO_ERROR;//INVALID_OPERATION;
-        }        
-            
+        }
+
         if ((ret == CameraHALStartPreview())<0) {
-            CAMERA_HAL_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
+            CAMERA_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
             mPreviewLock.unlock();
-            return ret;            
+            return ret;
         }
 
         mPreviewRunning = true;
         mPreviewLock.unlock();
-        
+
         mCaptureLock.lock();
         if(mCaptureRunning) {
-            CAMERA_HAL_ERR("%s : preview thread already running", __func__);
+            CAMERA_LOG_ERR("%s : preview thread already running", __func__);
             mCaptureLock.unlock();
             return NO_ERROR;
         }
         mCaptureRunning = true;
-        mCaptureLock.unlock();                  
+        mCaptureLock.unlock();
 
-        if(mPPDeviceNeed) {
-            //mPostProcessLock.lock(); 
-            //mPostProcessCondition.signal();
-            //mPostProcessLock.unlock();            
-        }
-    
         LockWakeLock();
         return ret;
     }
 
     void CameraHal::stopPreview()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         struct timeval af_time, be_time;
         Mutex::Autolock lock(mLock);
-        /* Cannot stop preview in recording */
-        //   if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
-        //       return;
-
-        //isPreviewFinsh = 1;
         CameraHALStopPreview();
         UnLockWakeLock();
 
@@ -896,7 +1040,7 @@ namespace android {
 
     bool CameraHal::previewEnabled()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         return mPreviewRunning;
     }
 
@@ -905,25 +1049,15 @@ namespace android {
     {
         unsigned int i;
         if (bDirect == true) {
-            if (!mPPDeviceNeed){
-                if(mCaptureBufNum <= 0)
-                    CAMERA_HAL_LOG_INFO("mCaptureBuf not allocated yet, will register it later");
-                
-                for(i = 0 ; i < mCaptureBufNum; i ++) {
-                    mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
-                    CAMERA_HAL_LOG_INFO("Camera HAL physic address: %x", mCaptureBuffers[i].phy_offset);
-                    mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
-                    memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
+            if(mCaptureBufNum <= 0)
+                CAMERA_LOG_INFO("mCaptureBuf not allocated yet, will register it later");
+
+            for(i = 0 ; i < mCaptureBufNum; i ++) {
+                mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
+                CAMERA_LOG_INFO("Camera HAL physic address: %x", mCaptureBuffers[i].phy_offset);
+                mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
+                memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
                         (void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-                }
-            }else{
-                for(i = 0 ; i < mPPbufNum; i ++) {
-                    mVideoBufferPhy[i].phy_offset = mPPbuf[i].phy_offset;
-                    CAMERA_HAL_LOG_INFO("Camera HAL physic address: %x", mPPbuf[i].phy_offset);
-                    mVideoBufferPhy[i].length = mPPbuf[i].length;
-                    memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
-                    (void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-                }
             }
         }
 
@@ -932,51 +1066,25 @@ namespace android {
 
     status_t CameraHal::storeMetaDataInBuffers(bool enable)
     {
-        CAMERA_HAL_LOG_FUNC;
-        bDirectInput = enable;
-        updateDirectInput(enable);
-        return NO_ERROR;
-    }
-#if 0
-    int32_t CameraHal::getNumberOfVideoBuffers() const
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-	if (!mPPDeviceNeed){
-		return mCaptureBufNum;
-	}else{
-		return  mPPbufNum;
-	}
+        CAMERA_LOG_FUNC;
+        return -1;
     }
 
-    sp<IMemory> CameraHal::getVideoBuffer(int32_t index) const
-    {
-        CAMERA_HAL_LOG_FUNC;
-        //this may be done in cameraHardwareInterface
-        //CameraHardwareInterface::CameraHeapMemory* mem;
-        //mem = (CameraHardwareInterface::CameraHeapMemory*)(mVideoMemory->handle);
-	//return mem->mBuffers[index];
-        return mVideoMemory;
-    }
-#endif
     status_t CameraHal::startRecording()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         unsigned int i;
 
         mEncodeLock.lock();
         if (mRecordRunning == true ) {
-            CAMERA_HAL_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
+            CAMERA_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
             mEncodeLock.unlock();
             return ret;
         }
-        
-           
-        if (bDirectInput == true) {
-            for(i = 0; i < mVideoBufNume; i++) {
-                mVideoBufferUsing[i] = 0;
-            }
+
+        for(i = 0; i < mVideoBufNume; i++) {
+            mVideoBufferUsing[i] = 0;
         }
 
         mRecordRunning = true;
@@ -987,44 +1095,46 @@ namespace android {
 
     void CameraHal::stopRecording()
     {
-        CAMERA_HAL_LOG_FUNC;
-        
-        mEncodeLock.lock();        
+        CAMERA_LOG_FUNC;
+
+        mEncodeLock.lock();
         if(mRecordRunning) {
             mRecordRunning = false;
             mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_STOP, 0));
-            sem_wait(&mEncodeStoppedCondition);
-            CAMERA_HAL_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
+            //stopRecording() will holde mLock in camera service,
+            //when encodeframeThread() is in the call back mDataCbTimestamp.
+            //That call back will make a call of releaseRecordingFrame, which
+            //also try to acquire the lock mLock. It will make a dead lock between the two thread
+            //sem_wait(&mEncodeStoppedCondition);
+            CAMERA_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
         }
         mEncodeLock.unlock();
     }
 
     void CameraHal::releaseRecordingFrame(const void* mem)
     {
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         int index;
 
         index = ((size_t)mem - (size_t)mVideoMemory->data) / mPreviewFrameSize;
         mVideoBufferUsing[index] = 0;
 
-        if (bDirectInput == true) {
-            if(mCaptureBuffers[index].refCount == 0) {
-                CAMERA_HAL_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
-                return;
-            }
-            putBufferCount(&mCaptureBuffers[index]);
+        if(mCaptureBuffers[index].refCount == 0) {
+            CAMERA_LOG_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
+            return;
         }
+        putBufferCount(&mCaptureBuffers[index]);
     }
 
     bool CameraHal::recordingEnabled()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         return (mPreviewRunning && mRecordRunning);
     }
 
     status_t CameraHal::autoFocus()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         Mutex::Autolock lock(mLock);
 
@@ -1039,24 +1149,23 @@ namespace android {
 
     status_t CameraHal::cancelAutoFocus()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         return NO_ERROR;
     }
 
     status_t CameraHal::takePicture()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         Mutex::Autolock lock(mLock);
 
-        //CameraHALStopPreview();
         if(mTakePictureInProcess) {
-            CAMERA_HAL_ERR("%s: takePicture already in process", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: takePicture already in process", __FUNCTION__);
             return INVALID_OPERATION;
         }
 
         if(mTakePicThread->run("takepicThread", PRIORITY_URGENT_DISPLAY) != NO_ERROR) {
-            CAMERA_HAL_ERR("%s: could't run take picture thread", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: could't run take picture thread", __FUNCTION__);
             return INVALID_OPERATION;
         }
         mTakePictureInProcess = true;
@@ -1066,7 +1175,7 @@ namespace android {
 
     status_t CameraHal::cancelPicture()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         mTakePicThread->requestExitAndWait();
 
         return NO_ERROR;
@@ -1075,7 +1184,7 @@ namespace android {
 
     int CameraHal::autoFocusThread()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int FocusFlag = 0;
 
         if (mMsgEnabled & CAMERA_MSG_FOCUS)
@@ -1086,12 +1195,14 @@ namespace android {
 
     int CameraHal::takepicThread()
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_LOG_INFO("Camera is taking picture!");
+        CAMERA_LOG_FUNC;
+        CAMERA_LOG_INFO("Start taking picture!");
 
         /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
         CameraHALStopPreview();
+        mTakePictureAllocBuffer = true;
         cameraHALTakePicture();
+        mTakePictureAllocBuffer = false;
         mTakePictureInProcess = false;
 
         return UNKNOWN_ERROR;
@@ -1099,7 +1210,7 @@ namespace android {
 
     int CameraHal :: cameraHALTakePicture()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int ret = NO_ERROR;
         unsigned int DeQueBufIdx = 0;
         struct jpeg_encoding_conf JpegEncConf;
@@ -1108,51 +1219,59 @@ namespace android {
         camera_memory_t *RawMemBase = NULL;
 
         int  max_fps, min_fps;
+        int actual_fps = 15;
 
         if (mJpegEncoder == NULL){
-            CAMERA_HAL_ERR("the jpeg encoder is NULL");
+            CAMERA_LOG_ERR("the jpeg encoder is NULL");
             return BAD_VALUE;
         }
         mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        //Default setting is 15FPS
         mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDeviceCfg.tv.denominator = 15;
         mCaptureDevice->GetDevName(mCameraSensorName);
         if (strstr(mCameraSensorName, "uvc") == NULL){
             //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
-            if (mParameters.getPreviewFrameRate() >= 15)
-                mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-            else{
+            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
+            if((strstr(mCameraSensorName, "mipi") == NULL)&&
+                (mCaptureDeviceCfg.width == 1920)&&
+                (mCaptureDeviceCfg.height == 1080)) {
+                //Workaround for 1080p setting for csi camera, which only 15fps is valid
+                mCaptureDeviceCfg.tv.denominator = 15;
+            } else {
                 mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-                CAMERA_HAL_LOG_INFO("###start the preview the fps is %d###", max_fps);
-                mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+                if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
+                    if (mParameters.getPreviewFrameRate() >= 15){
+                        mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+                        CAMERA_LOG_INFO("Set Capture Fps %d", mParameters.getPreviewFrameRate());
+                    }
+                }
+                else{
+                    CAMERA_LOG_INFO("Set Capture Fps Range %d - %d",min_fps, max_fps);
+                    actual_fps = min_fps > 15000? 30:15;
+                    mCaptureDeviceCfg.tv.denominator = actual_fps;
+                }
             }
         }else{
                 mCaptureDeviceCfg.tv.denominator = 15;
         }
-        mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
-        mPPbufNum = 1;
+
+        if(mUseIon) {
+            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
+        }
+        else {
+            //surface texture requires larger than 2 buffers to work.
+            mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM + 1;
+        }
         mTakePicFlag = true;
-        mPPDeviceNeedForPic = false;
         if ((ret = GetJpegEncoderParam()) < 0)
             return ret;
         if ((ret = NegotiateCaptureFmt(true)) < 0)
             return ret;
 
-        if (mPPDeviceNeedForPic){
-            if ((ret = PreparePostProssDevice()) < 0){
-                CAMERA_HAL_ERR("PreparePostProssDevice error");
-                return ret;
-            }
-        }
         if ((ret = PrepareCaptureDevices()) < 0)
             return ret;
 
-        if (mPPDeviceNeedForPic){
-            if ((ret = PreparePreviwBuf()) < 0){
-                CAMERA_HAL_ERR("PreparePreviwBuf error");
-                return ret;
-            }
-        }
         if ((ret = PrepareJpegEncoder()) < 0)
             return ret;
 
@@ -1163,7 +1282,7 @@ namespace android {
         }
 
         if (mCaptureDevice->DevStart()<0){
-            CAMERA_HAL_ERR("the capture start up failed !!!!");
+            CAMERA_LOG_ERR("the capture start up failed !!!!");
             return INVALID_OPERATION;
         }
 
@@ -1182,32 +1301,22 @@ namespace android {
             }
         }
 
-        // do the csc if necessary
-        if (mPPDeviceNeedForPic){
-            mPPInputParam.user_def_paddr = mCaptureBuffers[DeQueBufIdx].phy_offset;
-            mPPOutputParam.user_def_paddr = mPPbuf[0].phy_offset;
-            mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
-            mPPDevice->DoPorcess(&(mCaptureBuffers[DeQueBufIdx]), &(mPPbuf[0]));
-            mPPDevice->PPDeviceDeInit();
-            Buf_input = &mPPbuf[0];
-        }else{
-            Buf_input = &mCaptureBuffers[DeQueBufIdx];
-        }
+        Buf_input = &mCaptureBuffers[DeQueBufIdx];
 
         Buf_output.virt_start = (unsigned char *)(JpegMemBase->data);
-        CAMERA_HAL_LOG_INFO("Generated a picture with mMsgEnabled 0x%x", mMsgEnabled);
+        CAMERA_LOG_INFO("Generated a picture with mMsgEnabled 0x%x", mMsgEnabled);
 
         if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
-            CAMERA_HAL_LOG_INFO("CAMERA_MSG_SHUTTER");
+            CAMERA_LOG_INFO("CAMERA_MSG_SHUTTER");
             mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
         }
 
         if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE) {
-            CAMERA_HAL_LOG_INFO("CAMERA_MSG_RAW_IMAGE");
+            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE");
             RawMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
 
             if ( NULL == RawMemBase ) {
-                CAMERA_HAL_LOG_INFO("Raw buffer allocation failed!");
+                CAMERA_LOG_INFO("Raw buffer allocation failed!");
                 ret = UNKNOWN_ERROR;
                 goto Pic_out;
             }
@@ -1217,18 +1326,18 @@ namespace android {
                 void *src = &mCaptureBuffers[DeQueBufIdx];
                 memcpy(dest, src, mCaptureFrameSize);
             }
- 
+
             mDataCb(CAMERA_MSG_RAW_IMAGE, RawMemBase, 0, NULL, mCallbackCookie);
 
             RawMemBase->release(RawMemBase);
         }
 
         if ( mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY ) {
-            CAMERA_HAL_LOG_INFO("CAMERA_MSG_RAW_IMAGE_NOTIFY");
+            CAMERA_LOG_INFO("CAMERA_MSG_RAW_IMAGE_NOTIFY");
             if(mNotifyCb)
                 mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
         }
- 
+
         if (mJpegEncoder->DoEncode(Buf_input,&Buf_output,&JpegEncConf) < 0){
             ret = UNKNOWN_ERROR;
             goto Pic_out;
@@ -1237,11 +1346,15 @@ namespace android {
 Pic_out:
         freeBuffersToNativeWindow();
         if ((JpegMemBase != NULL) &&(JpegMemBase->data != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-            CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
+            CAMERA_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
             mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, 0, NULL, mCallbackCookie);
         }
 
         mCaptureDevice->DevStop();
+        mCaptureDevice->DevDeAllocate();
+        if(mSensorType == CAMERA_TYPE_UVC) {
+            CloseCaptureDevice();
+        }
 
         if(JpegMemBase) {
             JpegMemBase->release(JpegMemBase);
@@ -1255,101 +1368,81 @@ Pic_out:
 
     int CameraHal :: GetJpegEncoderParam()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int ret = NO_ERROR, i = 0;
-        memset(mEncoderSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+        memset(mJpegEncoderSupportFmt, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
 
         for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mEncoderSupportedFormat[i])) < 0)
+            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mJpegEncoderSupportFmt[i])) < 0)
                 break;
         }
         if (i == 0){
-            CAMERA_HAL_ERR("Get the parameters error");
+            CAMERA_LOG_ERR("Get the parameters error");
             return UNKNOWN_ERROR;
         }
         return ret;
     }
     int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int ret = NO_ERROR, i = 0, j = 0;
-
+        unsigned int nPickFormat = 0;
 
         if(TakePicFlag){
-            mPictureEncodeFormat = 0;
+            //when take picture, only the mJpegEncoderSupportFmt impact it.
             for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
                 for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
-                    if (mEncoderSupportedFormat[j] == 0)
+                    if (mJpegEncoderSupportFmt[j] == 0)
                         break;
-                    if (mCaptureSupportedFormat[i] == mEncoderSupportedFormat[j]){
-                        mPictureEncodeFormat= mCaptureSupportedFormat[i];
-
-                        CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
-                                mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
-                                (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
+                    if (mSensorSupportFmt[i] == mJpegEncoderSupportFmt[j]){
+                        nPickFormat = mSensorSupportFmt[i];
+                        CAMERA_LOG_INFO("Get the Picture Encode Format :%c%c%c%c\n",
+                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
+                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
                         break;
                     }
                 }
-                if ((mPictureEncodeFormat != 0) || (mCaptureSupportedFormat[i] == 0))
+                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
                     break;
             }
-            if (mPictureEncodeFormat == 0){
-                mPictureEncodeFormat = mEncoderSupportedFormat[0];
-                mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat; //For uvc now, IPU only can support yuyv.
-                mPPDeviceNeedForPic = true;
-                CAMERA_HAL_LOG_INFO("Need to do the CSC for Jpeg encoder");
-                CAMERA_HAL_LOG_INFO(" Get the captured format is :%c%c%c%c\n",
-                        mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
-                        (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
-                CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
-                        mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
-                        (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
-            }else{
-                mCaptureDeviceCfg.fmt = mPictureEncodeFormat;
-            }
-        }else{
-            CAMERA_HAL_LOG_INFO("mDefaultPreviewFormat :%c%c%c%c\n",
-                    mDefaultPreviewFormat & 0xFF, (mDefaultPreviewFormat >> 8) & 0xFF,
-                    (mDefaultPreviewFormat >> 16) & 0xFF, (mDefaultPreviewFormat >> 24) & 0xFF);
-            CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
-                    mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
-                    (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
-
-            if(mPPDeviceNeed == false) {
-                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                    CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
-                    if (mCaptureSupportedFormat[i] == mDefaultPreviewFormat){
-                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                        //mPPDeviceNeed = false;
-                        //mPreviewCapturedFormat = mPreviewFormat;
-                        mCaptureDeviceCfg.fmt = mDefaultPreviewFormat;
-                        break;
-                    }
-                }
+            if (nPickFormat == 0) {
+                CAMERA_LOG_ERR("NegotiateCaptureFmt failed");
+                return UNKNOWN_ERROR;
             }
             else {
-                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                    //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
-                    if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
-                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                        //mPPDeviceNeed = true;
-                        //mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
-                        mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat;
+                mPictureEncodeFormat = nPickFormat;
+                mCaptureDeviceCfg.fmt = nPickFormat;
+            }
+            //should make mPictureEncodeFormat equal to mPreviewCapturedFormat.
+            //because allocate buffer should use it.
+            mPreviewCapturedFormat = mPictureEncodeFormat;
+        }//endif TakePicFlag
+        else{
+            //when preview or encoder, only mVpuSupportFmt impact it.
+            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                for (j = 0; j < MAX_VPU_SUPPORT_FORMAT; j++) {
+                    if(mVpuSupportFmt[j] == 0)
+                        break;
+                    if(mSensorSupportFmt[i] == mVpuSupportFmt[j]) {
+                        nPickFormat = mSensorSupportFmt[i];
+                        CAMERA_LOG_RUNTIME("get the priview format:%c%c%c%c\n",
+                                nPickFormat&0xFF, (nPickFormat>>8)&0xFF,
+                                (nPickFormat>>16)&0xFF, (nPickFormat>>24)&0xFF);
                         break;
                     }
-                }
+                }//end for
+                if ((nPickFormat != 0) || (mSensorSupportFmt[i] == 0))
+                    break;
             }
-
-            CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt :%c%c%c%c\n",
-                    mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
-                    (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
-
-            if ((i == MAX_QUERY_FMT_TIMES)){
-                CAMERA_HAL_ERR("Negotiate for the preview format error");
-                return BAD_VALUE;
+            if (nPickFormat == 0) {
+                CAMERA_LOG_ERR("NegotiateCaptureFmt2 failed");
+                return UNKNOWN_ERROR;
             }
-        }
-
+            else {
+                mPreviewCapturedFormat = nPickFormat;
+                mCaptureDeviceCfg.fmt = nPickFormat;
+            }
+        }//end else
 
         return ret;
     }
@@ -1379,8 +1472,8 @@ Pic_out:
         mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
         mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
         mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
-        CAMERA_HAL_LOG_INFO("the pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
-        CAMERA_HAL_LOG_INFO("the thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
+        CAMERA_LOG_INFO("pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
+        CAMERA_LOG_INFO("thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
         //set focallength info
         focallength_info.numerator=10001;
         focallength_info.denominator=1000;  // hardcode here for the cts
@@ -1406,7 +1499,7 @@ Pic_out:
         tm = localtime(&clock);
         time_t GpsUtcTime;
         strftime(temp_string, sizeof(temp_string), format, tm);
-        CAMERA_HAL_LOG_INFO("the date time is %s", temp_string);
+        CAMERA_LOG_INFO("date time: %s", temp_string);
         memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
         mJpegEncCfg.pDatetimeInfo = &datetime_info;
 
@@ -1421,10 +1514,10 @@ Pic_out:
             mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
         else
             mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
-        CAMERA_HAL_LOG_INFO("ratate info is %d", rotate_angle);
+        CAMERA_LOG_INFO("rotate: %d", rotate_angle);
 
         pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
-        CAMERA_HAL_LOG_INFO("white balance is %s",pWhiteBalanceStr);
+        CAMERA_LOG_INFO("white balance: %s",pWhiteBalanceStr);
         if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
             whitebalance_info = WHITEBALANCE_AUTO;
         }else{
@@ -1433,7 +1526,7 @@ Pic_out:
         mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
 
         pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
-        CAMERA_HAL_LOG_INFO("flash mode is %s", pFlashStr);
+        CAMERA_LOG_INFO("flash mode: %s", pFlashStr);
         if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
             flash_info = FLASH_NOT_FIRE;
         }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
@@ -1490,11 +1583,11 @@ Pic_out:
                 int intValue;
                 gps_info.altitude[1]=1000;	   // the precision is CM
                 dAltitude= atof(cAltitude);
-                CAMERA_HAL_LOG_RUNTIME("the altitude is %s", cAltitude);
+                CAMERA_LOG_RUNTIME("altitude: %s", cAltitude);
                 intValue = (int)(dAltitude * 1000.0);
                 if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
                 gps_info.altitude[0] = (unsigned long) intValue;
-                CAMERA_HAL_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
+                CAMERA_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
             }
 
             //timestamp: hh/1,mm/1,ss/1
@@ -1504,7 +1597,7 @@ Pic_out:
             if (cTimeStamp != NULL){
 
                 GpsUtcTime = atol(cTimeStamp);
-                CAMERA_HAL_LOG_INFO("the Timestamp is %s", cTimeStamp);
+                CAMERA_LOG_INFO("Timestamp: %s", cTimeStamp);
                 temp_tm = gmtime((const time_t*)&GpsUtcTime);
                 if (temp_tm != NULL)
                     tm = temp_tm;
@@ -1521,18 +1614,17 @@ Pic_out:
             memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
 
 
-            char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
-            if (progressMehod == NULL){
-                CAMERA_HAL_LOG_INFO("The progressMethod is NULL, add a fake");
-                progressMehod = (char *)"fsl_fake_method";
+            char * processMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
+            if (processMehod == NULL){
+                CAMERA_LOG_INFO("processMethod is NULL, add a fake");
+                processMehod = (char *)"fsl_fake_method";
             }
-            CAMERA_HAL_LOG_INFO("the progressMethod is %s", progressMehod);
 
-            memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
+            memcpy(gps_info.processmethod, processMehod, strlen(processMehod));
 
-            gps_info.processmethod_bytes=strlen(progressMehod);
+            gps_info.processmethod_bytes=strlen(processMehod);
 
-            CAMERA_HAL_LOG_INFO("the method is %s", gps_info.processmethod);
+            CAMERA_LOG_INFO("processmethod: %s", gps_info.processmethod);
 
             mJpegEncCfg.pGps_info = &gps_info;
         }else{
@@ -1540,7 +1632,7 @@ Pic_out:
         }
 
         if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
-            CAMERA_HAL_ERR("Jpeg Encoder Init error !!!");
+            CAMERA_LOG_ERR("Jpeg Encoder Init error !!!");
             return UNKNOWN_ERROR;
         }
 
@@ -1549,9 +1641,9 @@ Pic_out:
 
     status_t CameraHal::convertPreviewFormatToString(char *pStr, int length, unsigned int format)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if(pStr == NULL || length < 10) {
-            CAMERA_HAL_ERR("%s: invalide parameters", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: invalide parameters", __FUNCTION__);
             return BAD_VALUE;
         }
         if(format == v4l2_fourcc('Y','U','1','2')) {
@@ -1564,7 +1656,7 @@ Pic_out:
         //    strcpy(pStr, "yuv422i-yuyv");
         //}
         else {
-            CAMERA_HAL_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
             return BAD_VALUE;
         }
         return NO_ERROR;
@@ -1572,7 +1664,7 @@ Pic_out:
 
     status_t CameraHal::convertStringToPreviewFormat(unsigned int *pFormat)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if(!strcmp(mParameters.getPreviewFormat(), "yuv420p")) {
             *pFormat = v4l2_fourcc('Y','U','1','2');
         }
@@ -1583,7 +1675,7 @@ Pic_out:
         //    *pFormat = v4l2_fourcc('Y','U','Y','V');
         //}
         else {
-            CAMERA_HAL_ERR("Only yuv420sp or yuv420p is supported");
+            CAMERA_LOG_ERR("Only yuv420sp or yuv420p is supported");
             return BAD_VALUE;
         }
         return NO_ERROR;
@@ -1591,212 +1683,191 @@ Pic_out:
 
     status_t CameraHal::CameraHALStartPreview()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         int  max_fps, min_fps;
+        int actual_fps = 15;
 
         mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
 
         if ((ret = convertStringToPreviewFormat(&mPreviewCapturedFormat)) != 0) {
-            CAMERA_HAL_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
             return ret;
         }
 
         mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
-        CAMERA_HAL_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
+
+        CAMERA_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
         mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
+        //Default setting is 15FPS
         mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDeviceCfg.tv.denominator = 15;
         mCaptureDevice->GetDevName(mCameraSensorName);
         if (strstr(mCameraSensorName, "uvc") == NULL){
             //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-            // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
-            if (mParameters.getPreviewFrameRate() >= 15)
-                mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+            // so here just a walkaround, if the app set the FpsRange, will follow this FpsRange.
+            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
+            if (max_fps < 1000 || min_fps < 1000 || max_fps > 33000 || min_fps > 33000){
+                if (mParameters.getPreviewFrameRate() >= 15){
+                    mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+                    CAMERA_LOG_INFO("Set Preview Fps %d", mParameters.getPreviewFrameRate());
+                }
+            }
             else{
-                mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-                CAMERA_HAL_LOG_INFO("###start the capture the fps is %d###", max_fps);
-                mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+                CAMERA_LOG_INFO("Set Preview Fps Range %d - %d",min_fps, max_fps);
+                actual_fps = min_fps > 15000? 30:15;
+                mCaptureDeviceCfg.tv.denominator = actual_fps;
             }
         }else{
                 mCaptureDeviceCfg.tv.denominator = 15;
         }
         mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
-        mPPbufNum = POST_PROCESS_BUFFER_NUM;
         mTakePicFlag = false;
 
-        if(mPreviewCapturedFormat)
+        if(mCaptureDeviceCfg.fmt)
                 mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
             else
                 mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
 
         if ((ret = PrepareCaptureDevices()) < 0){
-            CAMERA_HAL_ERR("PrepareCaptureDevices error ");
+            CAMERA_LOG_ERR("PrepareCaptureDevices error ");
             return ret;
         }
-        if (mPPDeviceNeed){
-            if ((ret = PreparePostProssDevice()) < 0){
-                CAMERA_HAL_ERR("PreparePostProssDevice error");
-                return ret;
-            }
-        }
         if ((ret = PreparePreviwBuf()) < 0){
-            CAMERA_HAL_ERR("PreparePreviwBuf error");
+            CAMERA_LOG_ERR("PreparePreviwBuf error");
             return ret;
         }
 
         if ((ret = PreparePreviwMisc()) < 0){
-            CAMERA_HAL_ERR("PreparePreviwMisc error");
+            CAMERA_LOG_ERR("PreparePreviwMisc error");
             return ret;
         }
 
         if(mNativeWindow != NULL) {
             if ((ret = CameraHALPreviewStart()) < 0){
-                CAMERA_HAL_ERR("CameraHALPreviewStart error");
+                CAMERA_LOG_ERR("CameraHALPreviewStart error");
                 return ret;
             }
         }
 
-        //mPreviewRunning = true;
         return ret;
     }
     void CameraHal::CameraHALStopPreview()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mPreviewRunning != 0)	{
             CameraHALStopThreads();
             CameraHALStopMisc();
             mCaptureBufNum = 0;
-            CAMERA_HAL_LOG_INFO("camera hal stop preview done");
+            CAMERA_LOG_INFO("camera hal stop preview done");
         }else{
-            CAMERA_HAL_LOG_INFO("Camera hal already stop preview");
+            CAMERA_LOG_INFO("Camera hal already stop preview");
         }
-        //mCaptureBufNum = 0;
         return ;
     }
 
     void CameraHal :: CameraHALStopThreads()
     {
-        CAMERA_HAL_LOG_FUNC;
-        
+        CAMERA_LOG_FUNC;
+
         mCaptureLock.lock();
         if(mCaptureRunning) {
-            CAMERA_HAL_LOG_INFO("%s :capture run", __FUNCTION__);
+            CAMERA_LOG_INFO("%s :capture run", __FUNCTION__);
             mCaptureThreadQueue.postStopMessage();
             mCaptureRunning = false;
             if(gettid()!= mCaptureFrameThread->mTID)
                 sem_wait(&mCaptureStoppedCondition);
             else
-                CAMERA_HAL_LOG_INFO("Stop CaptureFrameThread in itself");
+                CAMERA_LOG_INFO("Stop CaptureFrameThread in itself");
         }else {
-            CAMERA_HAL_LOG_INFO("%s :capture not run", __FUNCTION__);
+            CAMERA_LOG_INFO("%s :capture not run", __FUNCTION__);
         }
         mCaptureLock.unlock();
-        CAMERA_HAL_LOG_INFO("%s :---------", __FUNCTION__);
-
-        mPostProcessLock.lock(); 
-        if(mPPDeviceNeed && mPreviewRunning) {
-            CAMERA_HAL_LOG_INFO("%s :postprocess run", __FUNCTION__);
-            mPostProcessThreadQueue.postStopMessage();
-            if(gettid()!= mPostProcessThread->mTID)
-                sem_wait(&mPostProcessStoppedCondition);
-            else
-                CAMERA_HAL_LOG_INFO("Stop PostProcessThread in itself");
-        }
-        mPostProcessLock.unlock(); 
+        CAMERA_LOG_INFO("%s :---------", __FUNCTION__);
 
         mPreviewLock.lock();
         if(mPreviewRunning) {
-            CAMERA_HAL_LOG_INFO("%s :preview run", __FUNCTION__);
+            CAMERA_LOG_INFO("%s :preview run", __FUNCTION__);
             mPreviewThreadQueue.postStopMessage();
             mPreviewRunning = false;
             if(gettid()!= mPreviewShowFrameThread->mTID)
                 sem_wait(&mPreviewStoppedCondition);
             else
-                CAMERA_HAL_LOG_INFO("Stop PreviewShowThread in itself");
+                CAMERA_LOG_INFO("Stop PreviewShowThread in itself");
         }else {
-            CAMERA_HAL_LOG_INFO("%s :preview not run", __FUNCTION__);
+            CAMERA_LOG_INFO("%s :preview not run", __FUNCTION__);
         }
         mPreviewLock.unlock();
-        CAMERA_HAL_LOG_INFO("%s :exit", __FUNCTION__);
-        
+        CAMERA_LOG_INFO("%s :exit", __FUNCTION__);
+
         return ;
     }
 
     void CameraHal :: CameraHALStopMisc()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
-        if(mPPDeviceNeed){
-            for (unsigned int i = 0; i < mPPbufNum; i++){
-                mPmemAllocator->deAllocate(&mPPbuf[i]);
-            }
-            mPmemAllocator = NULL;
-        }
         mCaptureDevice->DevStop();
-        //mCaptureDevice->DevDeAllocate();
+        mCaptureDevice->DevDeAllocate();
         freeBuffersToNativeWindow();
-        //CloseCaptureDevice();
-        //mCaptureBufNum = 0;
+        if(mSensorType == CAMERA_TYPE_UVC) {
+            CloseCaptureDevice();
+        }
     }
 
     status_t CameraHal :: PrepareCaptureBufs()
     {
-        CAMERA_HAL_LOG_FUNC;
-        //status_t ret = NO_ERROR;
-        //if(mCaptureBufNum == 0) {
-        //    mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
-        //}
+        CAMERA_LOG_FUNC;
         unsigned int CaptureBufNum = mCaptureBufNum;
-        
+
         if(allocateBuffersFromNativeWindow() < 0) {
-            CAMERA_HAL_ERR("allocateBuffersFromNativeWindow error");
+            CAMERA_LOG_ERR("allocateBuffersFromNativeWindow error");
             return BAD_VALUE;
         }
 
         if (mCaptureDevice->DevRegisterBufs(mCaptureBuffers,&CaptureBufNum)< 0){
-            CAMERA_HAL_ERR("capture device allocat buf error");
+            CAMERA_LOG_ERR("capture device allocat buf error");
             return BAD_VALUE;
         }
         if(mCaptureBufNum != CaptureBufNum){
-            CAMERA_HAL_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
+            CAMERA_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
         }
 
         mCaptureBufNum = CaptureBufNum;
 
         if (mCaptureDevice->DevPrepare()< 0){
-            CAMERA_HAL_ERR("capture device prepare error");
+            CAMERA_LOG_ERR("capture device prepare error");
             return BAD_VALUE;
         }
         nCameraBuffersQueued = mCaptureBufNum;
-        isCaptureBufsAllocated = 1;
+        mIsCaptureBufsAllocated = 1;
 
         if((AllocateRecordVideoBuf())<0) {
-            CAMERA_HAL_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
+            CAMERA_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
             return BAD_VALUE;
         }
- 
+
         return NO_ERROR;
     }
 
     status_t CameraHal :: PrepareCaptureDevices()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         int i =0;
-        //unsigned int CaptureBufNum = mCaptureBufNum;
         struct capture_config_t *pCapcfg;
         if ((ret = OpenCaptureDevice())<0)
             return ret;
 
         if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
-            CAMERA_HAL_ERR("Dev config failed");
+            CAMERA_LOG_ERR("Dev config failed");
             return BAD_VALUE;
         }
         mCaptureFrameSize = mCaptureDeviceCfg.framesize;
 
         if(mNativeWindow != 0) {
             if(PrepareCaptureBufs() < 0) {
-                CAMERA_HAL_ERR("PrepareCaptureBufs() error");
+                CAMERA_LOG_ERR("PrepareCaptureBufs() error");
                 return BAD_VALUE;
             }
         }
@@ -1804,41 +1875,9 @@ Pic_out:
         return ret;
     }
 
-    status_t CameraHal::PreparePostProssDevice()
-    {
-
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int targetFmt;
-        if (mTakePicFlag)
-            targetFmt = mPictureEncodeFormat;
-        else
-            targetFmt = mDefaultPreviewFormat;
-
-        pthread_mutex_lock(&mPPIOParamMutex);
-        mPPInputParam.width = mCaptureDeviceCfg.width;
-        mPPInputParam.height= mCaptureDeviceCfg.height;
-        mPPInputParam.fmt   = mCaptureDeviceCfg.fmt;
-        mPPInputParam.input_crop_win.pos.x = 0;
-        mPPInputParam.input_crop_win.pos.y = 0;
-        mPPInputParam.input_crop_win.win_w = mCaptureDeviceCfg.width;
-        mPPInputParam.input_crop_win.win_h = mCaptureDeviceCfg.height;
-
-        mPPOutputParam.width = mCaptureDeviceCfg.width;
-        mPPOutputParam.height= mCaptureDeviceCfg.height;
-        mPPOutputParam.fmt   = targetFmt;
-        mPPOutputParam.rot   = 0;
-        mPPOutputParam.output_win.pos.x = 0;
-        mPPOutputParam.output_win.pos.y = 0;
-        mPPOutputParam.output_win.win_w = mCaptureDeviceCfg.width;
-        mPPOutputParam.output_win.win_h = mCaptureDeviceCfg.height;
-        pthread_mutex_unlock(&mPPIOParamMutex);
-        return ret;
-    }
-
     status_t CameraHal::PreparePreviwBuf()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         unsigned int i =0;
 
@@ -1850,77 +1889,38 @@ Pic_out:
 
             mPreviewMemory = mRequestMemory(-1, mPreviewFrameSize, mPreviewHeapBufNum, NULL);
             if(mPreviewMemory == NULL) {
-                CAMERA_HAL_ERR("%s, allocate memory failed", __FUNCTION__);
-                return NO_MEMORY;
-            }
-            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
-            //mPreviewHeap.clear();
-            //for (i = 0; i< mPreviewHeapBufNum; i++)
-            //    mPreviewBuffers[i].clear();
-            //mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
-            //if (mPreviewHeap == NULL)
-            //    return NO_MEMORY;
-            //for (i = 0; i < mPreviewHeapBufNum; i++)
-            //    mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
-        }
-        /*allocate the buffer for IPU process*/
-        if (mPPDeviceNeed || mPPDeviceNeedForPic){
-            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
-
-            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
+                CAMERA_LOG_ERR("%s, allocate memory failed", __FUNCTION__);
                 return NO_MEMORY;
             }
-            for (i = 0; i < mPPbufNum; i++){
-                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
-                    return NO_MEMORY;
-                }
-            }
         }
         return ret;
     }
 
     status_t CameraHal ::PreparePreviwMisc()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
-        dequeue_head = 0;
         preview_heap_buf_head = 0;
-        display_head = 0;
-        enc_head     = 0;
-        pp_in_head   = 0;
-        pp_out_head  = 0;
-        error_status = 0;
-        is_first_buffer = 1;
-        last_display_index = 0;
-
-        //for(unsigned int i=0; i < mCaptureBufNum; i++) {
-        //    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
-        //}
-//        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
-//        sem_init(&avab_show_frame, 0, 0);
-//        sem_init(&avab_enc_frame, 0, 0);
-//		sem_init(&avab_enc_frame_finish, 0, 0);
-		if(mPPDeviceNeed){
-            sem_init(&avab_pp_in_frame, 0, 0);
-            sem_init(&avab_pp_out_frame, 0, mPPbufNum);
-        }
-        return ret;
+
+       return ret;
     }
 
     status_t CameraHal ::CameraHALPreviewStart()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         if (mCaptureDevice->DevStart()<0)
             return INVALID_OPERATION;
-        
-        isCaptureBufsAllocated = 1;
+
+        mIsCaptureBufsAllocated = 1;
 
         unsigned int bufIndex = 0;
         //skip 10 frames when doing preview
-        for (int k = 0; k < 10; k++) {
-            mCaptureDevice->DevDequeue(&bufIndex);
-            mCaptureDevice->DevQueue(bufIndex);
+        if(mSensorType != CAMERA_TYPE_UVC) {
+            for (int k = 0; k < 10; k++) {
+                mCaptureDevice->DevDequeue(&bufIndex);
+                mCaptureDevice->DevQueue(bufIndex);
+            }
         }
 
         for(unsigned int i=0; i < mCaptureBufNum; i++) {
@@ -1928,7 +1928,7 @@ Pic_out:
         }
         return ret;
     }
-    
+
     status_t CameraHal::putBufferCount(DMA_BUFFER *pBuf)
     {
         if(pBuf == NULL)
@@ -1945,46 +1945,45 @@ Pic_out:
 
         pBuf->refCount --;
         if(pBuf->refCount == 0) {
-            if(!mPPDeviceNeed && mCaptureRunning) {
+            if(mCaptureRunning) {
                 if(buf_index < mCaptureBufNum) {
                     if(mCaptureDevice->DevQueue(buf_index) <0){
-                        CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
+                        CAMERA_LOG_ERR("The Capture device queue buf %d error !!!!", buf_index);
                         return INVALID_OPERATION;
                     }
+                    //CAMERA_LOG_RUNTIME("Return buffer %d to Capture Device", buf_index);
                     mCaptureBuffers[buf_index].refCount = 0;
                     nCameraBuffersQueued++;
                     mEnqueuedBufs --;
                     mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, buf_index));
                 }else {
                     return INVALID_OPERATION;
-                }                  
-            }else if(mPPDeviceNeed){
-                mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, 0));
-            }//end elseif            
+                }
+            }//end elseif
         }
         return NO_ERROR;
     }
-    
+
     void CameraHal ::getBufferCount(DMA_BUFFER *pBuf)
     {
         if(pBuf == NULL)
             return;
         Mutex::Autolock _l(pBuf->mBufferLock);
-        pBuf->refCount ++;        
+        pBuf->refCount ++;
     }
 
-    int CameraHal ::captureframeThreadWrapper() 
+    int CameraHal ::captureframeThreadWrapper()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         while(1) {
             if(mExitCaptureThread) {
-                CAMERA_HAL_LOG_INFO("%s: exiting normally", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: exiting normally", __FUNCTION__);
                 return 0;
             }
             ret = captureframeThread();
             if(ret < 0) {
-                CAMERA_HAL_ERR("%s: capture thread exit with exception", __FUNCTION__);
+                CAMERA_LOG_ERR("%s: capture thread exit with exception", __FUNCTION__);
                 return ret;
             }
         }
@@ -1993,148 +1992,61 @@ Pic_out:
 
     int CameraHal ::captureframeThread()
     {
-        //CAMERA_HAL_LOG_FUNC;
-        
+        //CAMERA_LOG_FUNC;
+
         unsigned int bufIndex = -1;
         status_t ret = NO_ERROR;
         sp<CMessage> msg = mCaptureThreadQueue.waitMessage();
         if(msg == 0) {
-            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;            
+            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;
         }
-                
+
         switch(msg->what) {
             case CMESSAGE_TYPE_NORMAL:
-
                 ret = mCaptureDevice->DevDequeue(&bufIndex);
                 //handle the error return.
                 if(ret < 0) {
-                    CAMERA_HAL_ERR("%s: get invalide buffer", __FUNCTION__);
-                    mCaptureRunning = false;
+                    CAMERA_LOG_ERR("%s: get invalide buffer", __FUNCTION__);
+                    //mCaptureRunning = false;
                     mCaptureThreadQueue.clearMessage();
                     sem_post(&mCaptureStoppedCondition);
                     return NO_ERROR;
                 }
+                //CAMERA_LOG_RUNTIME("Get buffer %d from Capture Device", bufIndex);
                 //handle the normal return.
-                if(!mPPDeviceNeed) {
-                    getBufferCount(&mCaptureBuffers[bufIndex]);
-                    mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-                    
-                    if(mRecordRunning) {
-                        mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
-                    }
-                }else {
+                getBufferCount(&mCaptureBuffers[bufIndex]);
+                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+
+                if(mRecordRunning) {
                     getBufferCount(&mCaptureBuffers[bufIndex]);
-                    mPostProcessThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
                 }
                 break;
             case CMESSAGE_TYPE_STOP:
-                CAMERA_HAL_LOG_INFO("%s: capture thread stop", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: capture thread stop", __FUNCTION__);
                 mCaptureThreadQueue.clearMessage();
                 sem_post(&mCaptureStoppedCondition);
-                CAMERA_HAL_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
                 break;
             case CMESSAGE_TYPE_QUITE:
                 mExitCaptureThread = 1;
+                CAMERA_LOG_INFO("%s: receive QUITE message", __FUNCTION__);
                 if (mExitPreviewThread == 0)
                     mPreviewThreadQueue.postQuitMessage();
                 if (mExitEncodeThread == 0)
                     mEncodeThreadQueue.postQuitMessage();
-                if (mPPDeviceNeed && (mExitPostProcessThread == 0))
-                    mPostProcessThreadQueue.postQuitMessage();
                 break;
             default:
-                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
                 ret = INVALID_OPERATION;
                 break;
         }//end switch
-        
-        return ret;
-    }
-
-    int CameraHal::postprocessThreadWrapper()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-
-        while(1) {
-            if(mExitPostProcessThread) {
-                CAMERA_HAL_LOG_INFO("%s, postprocessThread exit normally", __FUNCTION__);
-                return ret;
-            }
-            ret = postprocessThread();
-            if(ret < 0) {
-                CAMERA_HAL_ERR("%s, postprocessThread exit with exception", __FUNCTION__);
-                return ret;
-            }
-        }
-        return ret;
-    }
-
-    int CameraHal::postprocessThread()
-    {
-        int PPInIdx = 0, PPoutIdx = 0;
-        DMA_BUFFER *PPInBuf, *PPoutBuf;
-        status_t ret = NO_ERROR;
-        
-        sp<CMessage> msg = mPostProcessThreadQueue.waitMessage();
-        if(msg == 0) {
-            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        switch(msg->what) {
-            case CMESSAGE_TYPE_NORMAL:
-                PPInIdx = msg->arg0;
-                if(PPInIdx < 0 || (unsigned int)PPInIdx >= mCaptureBufNum) {
-                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
-                    return BAD_VALUE;  
-                }
-                PPInBuf = &mCaptureBuffers[PPInIdx];
-                PPoutIdx = pp_out_head;
-                PPoutBuf = &mPPbuf[PPoutIdx];
-                pp_out_head ++;
-                pp_out_head %= mPPbufNum;
-
-                pthread_mutex_lock(&mPPIOParamMutex);
-                mPPInputParam.user_def_paddr = PPInBuf->phy_offset;
-                mPPOutputParam.user_def_paddr = PPoutBuf->phy_offset;
-                mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
-                mPPDevice->DoPorcess(PPInBuf, PPoutBuf);
-                mPPDevice->PPDeviceDeInit();
-                pthread_mutex_unlock(&mPPIOParamMutex);
-
-                getBufferCount(&mPPbuf[PPoutIdx]);
-                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
-                
-                if(mRecordRunning) {
-                    getBufferCount(&mPPbuf[PPoutIdx]);
-                    //CAMERA_HAL_LOG_INFO("%s: post encode message %d", __FUNCTION__, PPoutIdx);
-                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
-                }
 
-                ret = putBufferCount(PPInBuf);                       
-                break;
-            case CMESSAGE_TYPE_STOP:
-                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop", __FUNCTION__);
-                mPostProcessThreadQueue.clearMessage();
-                sem_post(&mPostProcessStoppedCondition);
-                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop finish", __FUNCTION__);
-                break;
-            case CMESSAGE_TYPE_QUITE:
-                mExitPostProcessThread = 1;
-                mPreviewThreadQueue.postQuitMessage();
-                if(mRecordRunning)
-                    mEncodeThreadQueue.postQuitMessage();
-                break;
-            default:
-                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
-                ret = INVALID_OPERATION;
-                break;
-        }
         return ret;
     }
 
-    void CameraHal::SearchBuffer(void *pNativeBuf, unsigned int *pIndex)
+    void CameraHal::SearchBuffer(void *pNativeBuf, int *pIndex)
     {
         //int index;
         for(unsigned int i=0; i < mCaptureBufNum; i++){
@@ -2147,22 +2059,22 @@ Pic_out:
         *pIndex = -1;
         return;
     }
-    
+
     int CameraHal ::previewshowFrameThreadWrapper()
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         while(1) {
             if(mExitPreviewThread) {
-                CAMERA_HAL_LOG_INFO("%s: exiting", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: exiting", __FUNCTION__);
                 return 0;
             }
             ret = previewshowFrameThread();
             if(ret < 0) {
-                CAMERA_HAL_ERR("%s: preview thread exit with exception", __FUNCTION__);
+                CAMERA_LOG_ERR("%s: preview thread exit with exception", __FUNCTION__);
                 mExitPreviewThread = 1;
                 return ret;
-            }            
+            }
         }
         return ret;
     }
@@ -2180,7 +2092,7 @@ Pic_out:
                 FILE *pf = NULL;
                 pf = fopen("/sdcard/camera_tst.data", "wb");
                 if(pf == NULL) {
-                    CAMERA_HAL_ERR("open /sdcard/camera_tst.data failed");
+                    CAMERA_LOG_ERR("open /sdcard/camera_tst.data failed");
                 }
                 else {
                     fwrite(pInBuf->virt_start, pInBuf->length, 1, pf);
@@ -2188,55 +2100,50 @@ Pic_out:
                 }
                 vflg = 0;
             }
-#endif                    
+#endif
     }
-   
+
     int CameraHal ::previewshowFrameThread()
     {
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         int display_index = -1;
         DMA_BUFFER *pInBuf = NULL;
-        android_native_buffer_t *buf = NULL;
         buffer_handle_t *buf_h = NULL;
-        unsigned int buf_index = -1;
+        int buf_index = -1;
         int stride = 0, err = 0;
 
         sp<CMessage> msg = mPreviewThreadQueue.waitMessage();
         if(msg == 0) {
-            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
             mPreviewRunning = false;
-            return BAD_VALUE;            
+            return BAD_VALUE;
         }
 
         switch(msg->what) {
             case CMESSAGE_TYPE_NORMAL:
                 display_index = msg->arg0;
                 if(display_index < 0 || (unsigned int)display_index >= mCaptureBufNum) {
-                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
                     mPreviewRunning = false;
                     mPreviewThreadQueue.clearMessage();
                     sem_post(&mPreviewStoppedCondition);
-                    return BAD_VALUE;  
-                }
-                if(!mPPDeviceNeed) {
-                    pInBuf = &mCaptureBuffers[display_index];
-                }else {
-                    pInBuf = &mPPbuf[display_index];
+                    return BAD_VALUE;
                 }
-                
+                pInBuf = &mCaptureBuffers[display_index];
+
                 if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-                    //CAMERA_HAL_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
+                    //CAMERA_LOG_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
                     convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
                             (uint8_t*)((unsigned char*)mPreviewMemory->data + preview_heap_buf_head*mPreviewFrameSize),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
                     mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, preview_heap_buf_head, NULL, mCallbackCookie);
                     preview_heap_buf_head ++;
                     preview_heap_buf_head %= mPreviewHeapBufNum;
-                }                
+                }
 
                 if (mNativeWindow != 0) {
-                    if (mNativeWindow->enqueue_buffer(mNativeWindow, &((android_native_buffer_t * )pInBuf->native_buf)->handle) < 0){
-                        CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
+                    if (mNativeWindow->enqueue_buffer(mNativeWindow, (buffer_handle_t * )pInBuf->native_buf) < 0){
+                        CAMERA_LOG_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
                         mPreviewRunning = false;
                         mPreviewThreadQueue.clearMessage();
                         sem_post(&mPreviewStoppedCondition);
@@ -2258,19 +2165,18 @@ Pic_out:
 
                 err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
                 if((err != 0) || buf_h == NULL) {
-                    CAMERA_HAL_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
+                    CAMERA_LOG_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
                     mPreviewRunning = false;
                     mPreviewThreadQueue.clearMessage();
                     sem_post(&mPreviewStoppedCondition);
                     return INVALID_OPERATION;
                 }
-                buf = container_of(buf_h, ANativeWindowBuffer, handle);
 
-                SearchBuffer((void *)buf, &buf_index);
+                SearchBuffer((void *)buf_h, &buf_index);
 
-                if(buf_index >= mCaptureBufNum || (buf_index < 0)) {
-                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
-                    CAMERA_HAL_ERR("dequeue invalide buffer!!!!");
+                if(buf_index >= (int)mCaptureBufNum || (buf_index < 0)) {
+                    mNativeWindow->cancel_buffer(mNativeWindow, buf_h);
+                    CAMERA_LOG_ERR("dequeue invalide buffer!!!!");
                     mPreviewRunning = false;
                     mPreviewThreadQueue.clearMessage();
                     sem_post(&mPreviewStoppedCondition);
@@ -2281,26 +2187,27 @@ Pic_out:
                 ret = putBufferCount(&mCaptureBuffers[buf_index]);
                 break;
             case CMESSAGE_TYPE_STOP:
-                CAMERA_HAL_LOG_INFO("%s: preview thread stop", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: preview thread stop", __FUNCTION__);
                 mPreviewThreadQueue.clearMessage();
                 sem_post(&mPreviewStoppedCondition);
-                CAMERA_HAL_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
                 break;
             case CMESSAGE_TYPE_QUITE:
                 mExitPreviewThread = 1;
+                CAMERA_LOG_INFO("%s: receive QUIT message", __FUNCTION__);
                 break;
             default:
-                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
                 ret = INVALID_OPERATION;
-                break;   
+                break;
         }
-        
+
         return ret;
     }
-    
+
     int CameraHal::encodeframeThreadWrapper()
     {
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         while(1) {
             if(mExitEncodeThread) {
@@ -2308,57 +2215,51 @@ Pic_out:
             }
             ret = encodeframeThread();
             if(ret < 0) {
-                CAMERA_HAL_ERR("%s: encode thread exit with exception", __FUNCTION__);
+                CAMERA_LOG_ERR("%s: encode thread exit with exception", __FUNCTION__);
                 mExitEncodeThread = 1;
                 return ret;
             }
         }
         return ret;
     }
-    
+
     int CameraHal::encodeframeThread()
     {
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         status_t ret = NO_ERROR;
         int enc_index;
         sp<CMessage> msg = mEncodeThreadQueue.waitMessage();
         if(msg == 0) {
-            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
-            return BAD_VALUE;            
+            CAMERA_LOG_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;
         }
-            
+
         switch(msg->what) {
             case CMESSAGE_TYPE_NORMAL:
                 enc_index = msg->arg0;
                 unsigned int i;
                 if(enc_index < 0 || (unsigned int)enc_index >= mCaptureBufNum) {
-                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    CAMERA_LOG_ERR("%s: get invalide buffer index", __FUNCTION__);
                     mRecordRunning = false;
                     mEncodeThreadQueue.clearMessage();
-                    sem_post(&mEncodeStoppedCondition);
-                    return BAD_VALUE;  
+                    //sem_post(&mEncodeStoppedCondition);
+                    return BAD_VALUE;
                 }
-                
+
                 struct timespec ts;
                 DMA_BUFFER *EncBuf;
-                if (!mPPDeviceNeed){
-                    EncBuf = &mCaptureBuffers[enc_index];
-                }else{
-                    EncBuf = &mPPbuf[enc_index];
-                }
+                EncBuf = &mCaptureBuffers[enc_index];
 
                 if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
                     nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-                    if (bDirectInput == true) {
+                    if (mDirectInput == true) {
 	                    memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
                             (void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
                     } else {
                         memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
                                 (void*)EncBuf->virt_start, mPreviewFrameSize);
-                        ret = putBufferCount(EncBuf);
                     }
 
-                    getBufferCount(&mCaptureBuffers[enc_index]);
                     mVideoBufferUsing[enc_index] = 1;
                     mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, enc_index, mCallbackCookie);
                     break;
@@ -2366,20 +2267,20 @@ Pic_out:
                 break;
 
             case CMESSAGE_TYPE_STOP:
-                CAMERA_HAL_LOG_INFO("%s: encode thread stop", __FUNCTION__);
+                CAMERA_LOG_INFO("%s: encode thread stop", __FUNCTION__);
                 mEncodeThreadQueue.clearMessage();
-                sem_post(&mEncodeStoppedCondition);
+                //sem_post(&mEncodeStoppedCondition);
                 break;
             case CMESSAGE_TYPE_QUITE:
                 mExitEncodeThread = 1;
-                break;                
+                break;
 
             default:
-                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                CAMERA_LOG_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
                 ret = INVALID_OPERATION;
-                break;                   
+                break;
         }
-        
+
         return ret;
     }
 
@@ -2387,31 +2288,19 @@ Pic_out:
     {
         status_t ret = NO_ERROR;
         unsigned int i = 0;
-        //mVideoHeap.clear();
         if(mVideoMemory != NULL) {
             mVideoMemory->release(mVideoMemory);
         }
-        //for(i = 0; i < mVideoBufNume; i++) {
-        //    mVideoBuffers[i].clear();
-        //    mVideoBufferUsing[i] = 0;
-        //}
 
-        CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
-        //mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
+        CAMERA_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
         mVideoMemory = mRequestMemory(-1, mPreviewFrameSize, mVideoBufNume, NULL);
-        //if (mVideoHeap == NULL)
         if(mVideoMemory == NULL) {
-            CAMERA_HAL_ERR("%s, request video buffer failed", __FUNCTION__);
+            CAMERA_LOG_ERR("%s, request video buffer failed", __FUNCTION__);
             return NO_MEMORY;
         }
-        //for(i = 0; i < mVideoBufNume; i++) {
-        //    CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
-        //    mVideoBuffers[i] = new MemoryBase(mVideoHeap,
-        //            mPreviewFrameSize * i, mPreviewFrameSize);
-        //}
-        
+
         //Make sure the buffer been updated for direct input
-        updateDirectInput(bDirectInput);
+        updateDirectInput(mDirectInput);
         return ret;
     }
 
@@ -2472,11 +2361,11 @@ Pic_out:
             return -1;
         }
 
-        CAMERA_HAL_LOG_RUNTIME("the attribute is %s", cAttribute);
+        CAMERA_LOG_RUNTIME("the attribute is %s", cAttribute);
 
         dAttribtute = atof(cAttribute);
 
-        CAMERA_HAL_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
+        CAMERA_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
         intAttribute  = (long)(dAttribtute*(double)3600.0);
         if (intAttribute < 0){
             ret = 1;
@@ -2494,128 +2383,12 @@ Pic_out:
         degree = (unsigned int)(intAttribute/3600);
         second = (unsigned int)eAttr + second * 1000;
 
-        CAMERA_HAL_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
+        CAMERA_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
 
         return ret;
 
     }
 
-#if 0
-#define FACE_BACK_CAMERA_NAME "back_camera_name"
-#define FACE_FRONT_CAMERA_NAME "front_camera_name"
-#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
-#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
-#define DEFAULT_ERROR_NAME '#'
-#define DEFAULT_ERROR_NAME_str "#"
-#define UVC_NAME "uvc"
-    static CameraInfo sCameraInfo[2];
-    static char Camera_name[2][MAX_SENSOR_NAME];
-
-    static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
-    {
-        char orientStr[10];
-
-        property_get (FACE_BACK_CAMERA_NAME,
-                pFaceBackCameraName,
-                DEFAULT_ERROR_NAME_str );
-        property_get (FACE_BACK_CAMERA_ORIENT,
-                orientStr,
-                DEFAULT_ERROR_NAME_str );
-
-        if (orientStr[0] == DEFAULT_ERROR_NAME )
-            *pFaceBackOrient = 0;
-        else 
-            *pFaceBackOrient = atoi(orientStr);
-
-        ALOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
-
-        property_get (FACE_FRONT_CAMERA_NAME,
-                pFaceFrontCameraName,
-                DEFAULT_ERROR_NAME_str );
-
-        property_get (FACE_FRONT_CAMERA_ORIENT,
-                orientStr,
-                DEFAULT_ERROR_NAME_str );
-
-
-        if (orientStr[0] == DEFAULT_ERROR_NAME )
-            *pFaceFrontOrient = 0;
-        else 
-            *pFaceFrontOrient = atoi(orientStr);
-
-        ALOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
-
-    }
-
-    int HAL_getNumberOfCameras()
-    {
-        int back_orient =0,  front_orient = 0;
-        int back_camera_num = 0, front_camera_num = 0;
-        GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
-        if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
-            sCameraInfo[0].facing = CAMERA_FACING_BACK;
-            sCameraInfo[0].orientation = back_orient;
-            back_camera_num++;
-        }
-        if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
-            if(back_camera_num > 0){
-                sCameraInfo[1].facing = CAMERA_FACING_FRONT;
-                sCameraInfo[1].orientation = front_orient;
-            }else{
-                sCameraInfo[0].facing = CAMERA_FACING_FRONT;
-                sCameraInfo[0].orientation = front_orient;
-            }
-            front_camera_num ++;
-        }
-        return (back_camera_num + front_camera_num);					
-
-    }
-
-    void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
-    {
-        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));					
-    }
-
-    sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
-    {
-        char *SelectedCameraName;
-        int back_camera_num = 0, front_camera_num = 0;
-        sp<CaptureDeviceInterface> pCaptureDevice = NULL;
-        sp<PostProcessDeviceInterface> pPPDevice = NULL;
-        sp<JpegEncoderInterface>pJpegEncoder = NULL;
-
-        if (HAL_getNumberOfCameras() ==0 ){
-            CAMERA_HAL_ERR("There is no configure for Cameras");
-            return NULL;
-        }
-
-        SelectedCameraName = Camera_name[sCameraInfo[cameraId].facing];
-
-        pCaptureDevice = createCaptureDevice(SelectedCameraName);
-        pPPDevice = createPPDevice();
-        pJpegEncoder = createJpegEncoder(SOFTWARE_JPEG_ENC);
-
-        CameraHal *pCameraHal = new CameraHal();
-        if (pCameraHal->setCaptureDevice(pCaptureDevice) < 0 ||
-                pCameraHal->setPostProcessDevice(pPPDevice) < 0 ||
-                pCameraHal->setJpegEncoder(pJpegEncoder) < 0)
-            return NULL;
-
-        if (pCameraHal->Init() < 0)
-            return NULL;
-
-        //now the board has only one csi camera sensor, so just do mirror for it
-        if(strstr(SelectedCameraName, "ov") != NULL){
-            pCameraHal->setPreviewRotate(CAMERA_PREVIEW_BACK_REF);
-        }
-
-        sp<CameraHardwareInterface> hardware(pCameraHal);
-        CAMERA_HAL_LOG_INFO("created the fsl Camera hal");
-
-        return hardware;
-    }
-
-#endif
-};
+//};
 
 
diff --git a/mx5x/libcamera/CameraHal.h b/mx5x/libcamera/CameraHal.h
index 1f7e22b..03bbda5 100755
--- a/mx5x/libcamera/CameraHal.h
+++ b/mx5x/libcamera/CameraHal.h
@@ -15,6 +15,10 @@
  * limitations under the License.
  */
 
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ */
+
 #ifndef CAMERA_HAL_BASE_H
 #define CAMERA_HAL_BASE_H
 
@@ -36,9 +40,7 @@
 #include <hardware/camera.h>
 #include <semaphore.h>
 
-#include "Camera_pmem.h"
 #include "CaptureDeviceInterface.h"
-#include "PostProcessDeviceInterface.h"
 #include "JpegEncoderInterface.h"
 #include "messageQueue.h"
 
@@ -50,17 +52,28 @@
 #define MAX_QUERY_FMT_TIMES 20
 #define PARAMS_DELIMITER ","
 #define V4LSTREAM_WAKE_LOCK "V4LCapture"
-#define MAX_SENSOR_NAME 32
 
-#define PREVIEW_HEAP_BUF_NUM    5
-#define VIDEO_OUTPUT_BUFFER_NUM 5
-#define POST_PROCESS_BUFFER_NUM 5
-#define TAKE_PIC_QUE_BUF_NUM 5
+#define PREVIEW_HEAP_BUF_NUM    6
+#define VIDEO_OUTPUT_BUFFER_NUM 6
+#define POST_PROCESS_BUFFER_NUM 6
+#define TAKE_PIC_QUE_BUF_NUM 6
 
-#define PREVIEW_CAPTURE_BUFFER_NUM 5
-#define PICTURE_CAPTURE_BUFFER_NUM 3
+#define PREVIEW_CAPTURE_BUFFER_NUM 6
+#define PICTURE_CAPTURE_BUFFER_NUM 2
 
-namespace android {
+#define DEFAULT_PREVIEW_FPS (15)
+#define DEFAULT_PREVIEW_W   (640)
+#define DEFAULT_PREVIEW_H   (480)
+#define MAX_MIPI_PREVIEW_W       (1920)
+#define MAX_MIPI_PREVIEW_H       (1080)
+#define MAX_CSI_PREVIEW_W       (1280)
+#define MAX_CSI_PREVIEW_H       (720)
+#define DEFAULT_PICTURE_W   (640)
+#define DEFAULT_PICTURE_H   (480)
+
+#define MAX_VPU_SUPPORT_FORMAT 2
+using namespace android;
+//namespace android {
 
     typedef enum{
         CAMERA_HAL_ERR_NONE = 0,
@@ -71,7 +84,7 @@ namespace android {
         CAMERA_HAL_ERR_INIT = -5,
         CAMERA_HAL_ERR_ALLOC_BUF =-6,
         CAMERA_HAL_ERR_PP_NULL = -7
-    }CAMERA_HAL_ERR_RET;
+    }CAMERA_HAL_RET;
 
 	typedef enum{
         CAMERA_PREVIEW_BACK_REF = 0,
@@ -89,7 +102,6 @@ namespace android {
 
     class CameraHal {
     public:
-        //virtual sp<IMemoryHeap> getPreviewHeap() const;
         virtual sp<IMemoryHeap> getRawHeap() const;
 
         virtual status_t setPreviewWindow(struct preview_stream_ops *window);
@@ -103,13 +115,13 @@ namespace android {
         virtual void        disableMsgType(int32_t msgType);
         virtual bool        msgTypeEnabled(int32_t msgType);
 
+        status_t freeBufferToIon();
+        status_t allocateBufferFromIon();
         virtual status_t    startPreview();
         virtual void        stopPreview();
         virtual bool        previewEnabled();
 
 		virtual status_t  storeMetaDataInBuffers(bool enable);
-		//virtual int32_t getNumberOfVideoBuffers() const;
-		//virtual sp<IMemory> getVideoBuffer(int32_t index) const;
 
         virtual status_t    startRecording();
         virtual void        stopRecording();
@@ -121,7 +133,7 @@ namespace android {
         virtual status_t    takePicture();
         virtual status_t    cancelPicture();
         virtual status_t    dump(int fd) const;
-        virtual status_t    setParameters(const CameraParameters& params);
+        virtual status_t    setParameters(CameraParameters& params);
         virtual status_t    setParameters(const char* params);
         virtual char*  getParameters() const;
         void putParameters(char *);
@@ -129,10 +141,9 @@ namespace android {
                 int32_t arg2);
         virtual void release();
 
-        CAMERA_HAL_ERR_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
-        CAMERA_HAL_ERR_RET setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice);
-        CAMERA_HAL_ERR_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
-        CAMERA_HAL_ERR_RET  Init();
+        CAMERA_HAL_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
+        CAMERA_HAL_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
+        CAMERA_HAL_RET Init();
         void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
 
         CameraHal(int cameraid);
@@ -156,23 +167,6 @@ namespace android {
             int mTID;
         };
 
-        class PostProcessThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            PostProcessThread(CameraHal* hw)
-                : Thread(false), mHardware(hw), mTID(0)  { }
-            virtual void onFirstRef() {
-                run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mTID = gettid();
-                mHardware->postprocessThreadWrapper();
-                return false;
-            }
-            int mTID;
-        };
-
-
         class PreviewShowFrameThread : public Thread {
             CameraHal* mHardware;
         public:
@@ -233,7 +227,7 @@ namespace android {
             virtual void onFirstRef() {
                 run("TakePicThread", PRIORITY_URGENT_DISPLAY);
             }
-#endif  
+#endif
             virtual bool threadLoop() {
                 mTID = gettid();
                 mHardware->takepicThread();
@@ -248,20 +242,18 @@ namespace android {
         status_t OpenCaptureDevice();
         void CloseCaptureDevice();
 
-        CAMERA_HAL_ERR_RET AolLocForInterBuf();
+        CAMERA_HAL_RET AllocInterBuf();
         void  FreeInterBuf();
-        CAMERA_HAL_ERR_RET InitCameraHalParam();
-        CAMERA_HAL_ERR_RET InitCameraBaseParam(CameraParameters *pParam);
-        CAMERA_HAL_ERR_RET InitPictureExifParam(CameraParameters *pParam);
-        CAMERA_HAL_ERR_RET CameraMiscInit();
-        CAMERA_HAL_ERR_RET CameraMiscDeInit();
+        CAMERA_HAL_RET InitCameraHalParam();
+        CAMERA_HAL_RET InitCameraBaseParam(CameraParameters *pParam);
+        CAMERA_HAL_RET InitPictureExifParam(CameraParameters *pParam);
+        CAMERA_HAL_RET CameraMiscInit();
+        CAMERA_HAL_RET CameraMiscDeInit();
         status_t CameraHALPreviewStart();
         int captureframeThread();
-        int postprocessThread();
         int previewshowFrameThread();
         int encodeframeThread();
         int captureframeThreadWrapper();
-        int postprocessThreadWrapper();
         int previewshowFrameThreadWrapper();
         int encodeframeThreadWrapper();
         status_t AllocateRecordVideoBuf();
@@ -271,12 +263,10 @@ namespace android {
 
         status_t PreparePreviwBuf();
         status_t PrepareCaptureDevices();
-        status_t PreparePostProssDevice();
         status_t PreparePreviwMisc();
 
         void CameraHALStopThreads();
         void LockWakeLock();
-
         void UnLockWakeLock();
 
         int autoFocusThread();
@@ -292,51 +282,45 @@ namespace android {
         int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
 
         status_t allocateBuffersFromNativeWindow();
-        void SearchBuffer(void *pNativeBuf, unsigned int *pIndex);
+        void SearchBuffer(void *pNativeBuf, int *pIndex);
         status_t freeBuffersToNativeWindow();
         status_t PrepareCaptureBufs();
         status_t updateDirectInput(bool bDirect);
 
-        volatile bool isCaptureBufsAllocated;
-        //volatile bool isPreviewFinsh;
         status_t convertStringToPreviewFormat(unsigned int *pFormat);
         status_t convertPreviewFormatToString(char *pStr, int length, unsigned int format);
+        int convertPreviewFormatToPixelFormat(unsigned int format);
         status_t putBufferCount(DMA_BUFFER *pBuf);
         void getBufferCount(DMA_BUFFER *pBuf);
-        CAMERA_HAL_ERR_RET InitCameraPreviewFormatToParam(int nFmt);
+        CAMERA_HAL_RET InitCameraPreviewFormatToParam(int nFmt);
 
         CMessageQueue mCaptureThreadQueue;
         CMessageQueue mPreviewThreadQueue;
-        CMessageQueue mPostProcessThreadQueue;
         CMessageQueue mEncodeThreadQueue;
 
+        //For capture thread(queue/dequeue with v4l2 driver)
         mutable Mutex mCaptureLock;
-        mutable Condition mCaptureCondition;
-        //mutable Condition mCaptureStoppedCondition;
         mutable sem_t mCaptureStoppedCondition;
         bool mCaptureRunning;
         bool mExitCaptureThread;
+
+        //For preview thread(queue/dequeue with NativeWindow)
         mutable Mutex mPreviewLock;
-        mutable Condition mPreviewCondition;
-        //mutable Condition mPreviewStoppedCondition;
         mutable sem_t mPreviewStoppedCondition;
         bool mPreviewRunning;
         bool mExitPreviewThread;
-        mutable Mutex mPostProcessLock;
-        //mutable Condition mPostProcessCondition;
-        mutable sem_t mPostProcessStoppedCondition;
-        //bool mPostProcessRunning;
-        bool mExitPostProcessThread;
+
+        //For video recording thread
         mutable Mutex mEncodeLock;
-        mutable Condition mEncodeCondition;
-        //mutable Condition mEncodeStoppedCondition;
         mutable sem_t mEncodeStoppedCondition;
-        //bool mEncodeRunning;
         bool mExitEncodeThread;
+
+        //For picture taking thread
         mutable sem_t mTakingPicture;
         bool mWaitForTakingPicture;
         bool mTakePictureInProcess;
 
+        bool mTakePictureAllocBuffer;
         CameraParameters    mParameters;
         void               *mCallbackCookie;
         camera_notify_callback    mNotifyCb;
@@ -345,12 +329,10 @@ namespace android {
         camera_request_memory mRequestMemory;
 
         sp<CaptureDeviceInterface> mCaptureDevice;
-        sp<PostProcessDeviceInterface> mPPDevice;
         sp<JpegEncoderInterface> mJpegEncoder;
 
 
         sp<CaptureFrameThread> mCaptureFrameThread;
-        sp<PostProcessThread>  mPostProcessThread;
         sp<PreviewShowFrameThread> mPreviewShowFrameThread;
         sp<EncodeFrameThread> mEncodeFrameThread;
         sp<AutoFocusThread>mAutoFocusThread;
@@ -370,39 +352,27 @@ namespace android {
         struct capture_config_t mCaptureDeviceCfg;
         DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
 
-        //sp<MemoryHeapBase>  mPreviewHeap;
         camera_memory_t* mPreviewMemory;
-        //sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
 
         /* the buffer for recorder */
         unsigned int        mVideoBufNume;
         camera_memory_t* mVideoMemory;
-        //sp<MemoryHeapBase>  mVideoHeap;
-        //sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
-        volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
+        int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
 		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
 
-        sp<PmemAllocator>   mPmemAllocator;
-        DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
-        unsigned int        mPPbufNum;
-        pp_input_param_t    mPPInputParam;
-        pp_output_param_t   mPPOutputParam;
-
-        //volatile bool       mPreviewRunning;
         unsigned int        mDefaultPreviewFormat;
         unsigned int 		mPreviewFrameSize;
         unsigned int        mPreviewCapturedFormat;
 
         bool                mTakePicFlag;
-        unsigned int        mEncoderSupportedFormat[MAX_QUERY_FMT_TIMES];
+        unsigned int        mJpegEncoderSupportFmt[MAX_QUERY_FMT_TIMES];
         enc_cfg_param       mJpegEncCfg;
 
         unsigned int        mUvcSpecialCaptureFormat;
-        unsigned int        mCaptureSupportedFormat[MAX_QUERY_FMT_TIMES];
+        unsigned int        mSensorSupportFmt[MAX_QUERY_FMT_TIMES];
         unsigned int        mPictureEncodeFormat;
         unsigned int        mCaptureFrameSize;
         unsigned int        mCaptureBufNum;
-        //unsigned int        mCaptureBufsActual;
         unsigned int        mEnqueuedBufs;
 
         bool                mRecordRunning;
@@ -412,43 +382,27 @@ namespace android {
         unsigned int        mPreviewHeapBufNum;
         unsigned int        mTakePicBufQueNum;
 
-        char                mCameraSensorName[MAX_SENSOR_NAME];
+        char                mCameraSensorName[CAMERA_SENSOR_LENGTH];
         bool mCameraReady;
         bool mCaptureDeviceOpen;
-        bool mPPDeviceNeed;
-        bool mPPDeviceNeedForPic;
+        bool mIsCaptureBufsAllocated;
         bool mPreviewStopped;
         bool mRecordStopped;
         bool mPowerLock;
-        bool bDirectInput;
+        bool mDirectInput;
         int mCameraid;
 
-        int error_status;
         unsigned int preview_heap_buf_head;
-        unsigned int display_head;
-        unsigned int enc_head;
-        unsigned int dequeue_head;
-        unsigned int is_first_buffer;
-        unsigned int last_display_index;
-        unsigned int pp_in_head;
-        unsigned int pp_out_head;
-        unsigned int buffer_index_maps[PREVIEW_CAPTURE_BUFFER_NUM];
-
-        sem_t avab_show_frame;
-        sem_t avab_dequeue_frame;
-        sem_t avab_enc_frame;
-        sem_t avab_enc_frame_finish;
-        sem_t avab_pp_in_frame;
-        sem_t avab_pp_out_frame;
-
-        pthread_mutex_t mOverlayMutex;
-        pthread_mutex_t mMsgMutex;
-        pthread_mutex_t mPPIOParamMutex;
+
         CAMERA_PREVIEW_ROTATE mPreviewRotate;
 
+        unsigned int mVpuSupportFmt[MAX_VPU_SUPPORT_FORMAT];
+        CAMERA_TYPE mSensorType;
+        int mIonFd;
+        bool mUseIon;
     };
 
-}; // namespace android
+//}; // namespace android
 
 #endif
 
diff --git a/mx5x/libcamera/CameraModule.cpp b/mx5x/libcamera/CameraModule.cpp
index f683150..d28a3d3 100644
--- a/mx5x/libcamera/CameraModule.cpp
+++ b/mx5x/libcamera/CameraModule.cpp
@@ -14,19 +14,18 @@
  * limitations under the License.
  */
 
-/**
-* @file CameraHal.cpp
-*
-* This file maps the Camera Hardware Interface to V4L2.
-*
-*/
-
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #define LOG_TAG "CameraHAL"
-
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <dirent.h>
 #include <utils/threads.h>
 #include <cutils/properties.h>
 #include "CameraHal.h"
@@ -34,7 +33,7 @@
 
 #define MAX_CAMERAS_SUPPORTED 2
 //static android::CameraProperties gCameraProperties;
-static android::CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
+static CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
 static unsigned int gCamerasOpen = 0;
 static android::Mutex gCameraHalDeviceLock;
 
@@ -66,7 +65,6 @@ camera_module_t HAL_MODULE_INFO_SYM = {
 
 typedef struct fsl_camera_device {
     camera_device_t base;
-    /* TI specific "private" data can go here (base.priv) */
     int cameraid;
 } fsl_camera_device_t;
 
@@ -477,11 +475,16 @@ done:
 #define FACE_FRONT_CAMERA_NAME "front_camera_name"
 #define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
 #define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
-#define DEFAULT_ERROR_NAME '#'
-#define DEFAULT_ERROR_NAME_str "#"
+#define DEFAULT_ERROR_NAME '0'
+#define DEFAULT_ERROR_NAME_str "0"
 #define UVC_NAME "uvc"
 static struct camera_info sCameraInfo[2];
-static char Camera_name[2][MAX_SENSOR_NAME];
+//gCameraName[0]  for back camera name
+//gCameraName[1]  for front camera name
+static char gCameraName[2][CAMERA_SENSOR_LENGTH];
+static char gCameraDevPath[2][CAMAERA_FILENAME_LENGTH];
+static int gCameraNum = 0;
+
 /*******************************************************************
  * implementation of camera_module functions
  *******************************************************************/
@@ -500,16 +503,15 @@ int camera_device_open(const hw_module_t* module, const char* name,
     int cameraid;
     fsl_camera_device_t* camera_device = NULL;
     camera_device_ops_t* camera_ops = NULL;
-    android::CameraHal* camera = NULL;
+    CameraHal* camera = NULL;
     char *SelectedCameraName;
     android::sp<android::CaptureDeviceInterface> pCaptureDevice = NULL;
-    android::sp<android::PostProcessDeviceInterface> pPPDevice = NULL;
     android::sp<android::JpegEncoderInterface>pJpegEncoder = NULL;
     //android::CameraProperties::Properties* properties = NULL;
 
     android::Mutex::Autolock lock(gCameraHalDeviceLock);
 
-    ALOGI("camera_device open");
+    ALOGI("camera_device open: %s", name);
 
     if (name != NULL) {
         cameraid = atoi(name);
@@ -583,13 +585,13 @@ int camera_device_open(const hw_module_t* module, const char* name,
         *device = &camera_device->base.common;
 
         camera_device->cameraid = cameraid;
-        SelectedCameraName = Camera_name[sCameraInfo[cameraid].facing];
+        SelectedCameraName = gCameraName[sCameraInfo[cameraid].facing];
 
-        pCaptureDevice = android::createCaptureDevice(SelectedCameraName);
-        pPPDevice = android::createPPDevice();
+        pCaptureDevice = android::createCaptureDevice(SelectedCameraName,
+                gCameraDevPath[sCameraInfo[cameraid].facing]);
         pJpegEncoder = android::createJpegEncoder(android::SOFTWARE_JPEG_ENC);
 
-        camera = new android::CameraHal(cameraid);
+        camera = new CameraHal(cameraid);
 
         if(!camera)
         {
@@ -599,16 +601,14 @@ int camera_device_open(const hw_module_t* module, const char* name,
         }
 
         if (camera->setCaptureDevice(pCaptureDevice) < 0 ||
-                camera->setPostProcessDevice(pPPDevice) < 0 ||
-                camera->setJpegEncoder(pJpegEncoder) < 0)
-            return NULL;
-
-        if (camera->Init() < 0)
-            return NULL;
+                camera->setJpegEncoder(pJpegEncoder) < 0) {
+            rv = -EINVAL;
+            goto fail;
+        }
 
-        //now the board has only one csi camera sensor, so just do mirror for it
-        if(strstr(SelectedCameraName, "ov") != NULL){
-            camera->setPreviewRotate(android::CAMERA_PREVIEW_HORIZ_FLIP);
+        if (camera->Init() < 0) {
+            rv = -EINVAL;
+            goto fail;
         }
 
         gCameraHals[cameraid] = camera;
@@ -634,6 +634,56 @@ fail:
     return rv;
 }
 
+static int GetDevPath(const char *pCameraName, char *pCameraDevPath, unsigned int pathLen)
+{
+    int retCode = -1;
+    int fd = 0;
+    char   dev_node[CAMAERA_FILENAME_LENGTH];
+    DIR *v4l_dir = NULL;
+    struct dirent *dir_entry;
+    struct v4l2_capability v4l2_cap;
+    struct v4l2_dbg_chip_ident vid_chip;
+
+    v4l_dir = opendir("/sys/class/video4linux");
+    if (v4l_dir){
+        while((dir_entry = readdir(v4l_dir))) {
+            memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+            if(strncmp(dir_entry->d_name, "video", 5))
+                continue;
+            sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+            if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                continue;
+            if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
+                close(fd);
+                fd = 0;
+                continue;
+            } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
+                if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
+                    close(fd);
+                    fd = 0;
+                    continue;
+                }
+                if(strstr(vid_chip.match.name, pCameraName)){
+                    //fsl csi/mipi camera name and path match
+                    if(pathLen > strlen(dev_node)) {
+                        strcpy(pCameraDevPath, dev_node);
+                        ALOGI("Get sensor %s's dev path %s", pCameraName, pCameraDevPath);
+                        retCode = 0;
+                    }
+                    close(fd);
+                    fd = 0;
+                    break;
+                }
+            }
+            close(fd);
+            fd = 0;
+        }
+        closedir(v4l_dir);
+    }
+
+    return retCode;
+}
+
 static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
 {
     char orientStr[10];
@@ -643,7 +693,7 @@ static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraN
 
     if (orientStr[0] == DEFAULT_ERROR_NAME )
         *pFaceBackOrient = 0;
-    else 
+    else
         *pFaceBackOrient = atoi(orientStr);
 
     ALOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
@@ -655,34 +705,33 @@ static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraN
 
     if (orientStr[0] == DEFAULT_ERROR_NAME )
         *pFaceFrontOrient = 0;
-    else 
+    else
         *pFaceFrontOrient = atoi(orientStr);
 
     ALOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
-
 }
 
 int camera_get_number_of_cameras()
 {
     int back_orient =0,  front_orient = 0;
-    int back_camera_num = 0, front_camera_num = 0;
-    GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
-    if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
-        sCameraInfo[0].facing = CAMERA_FACING_BACK;
-        sCameraInfo[0].orientation = back_orient;
-        back_camera_num++;
-    }
-    if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
-        if(back_camera_num > 0){
-            sCameraInfo[1].facing = CAMERA_FACING_FRONT;
-            sCameraInfo[1].orientation = front_orient;
-        }else{
-	    sCameraInfo[0].facing = CAMERA_FACING_FRONT;
-	    sCameraInfo[0].orientation = front_orient;
+    if(gCameraNum == 0) {
+        GetCameraPropery(gCameraName[0], gCameraName[1], &back_orient, &front_orient);
+        if (gCameraName[0][0] != DEFAULT_ERROR_NAME){
+            sCameraInfo[gCameraNum].facing = CAMERA_FACING_BACK;
+            sCameraInfo[gCameraNum].orientation = back_orient;
+            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
+            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
+            gCameraNum++;
+        }
+        if (gCameraName[1][0] != DEFAULT_ERROR_NAME){
+            sCameraInfo[gCameraNum].facing = CAMERA_FACING_FRONT;
+            sCameraInfo[gCameraNum].orientation = front_orient;
+            memset(gCameraDevPath[gCameraNum], 0, CAMAERA_FILENAME_LENGTH);
+            GetDevPath(gCameraName[gCameraNum], gCameraDevPath[gCameraNum], CAMAERA_FILENAME_LENGTH);
+            gCameraNum++;
         }
-        front_camera_num ++;
     }
-    return (back_camera_num + front_camera_num);					
+    return gCameraNum;
 
 }
 
diff --git a/mx5x/libcamera/Camera_utils.h b/mx5x/libcamera/Camera_utils.h
index 70630c3..c1d1c45 100755
--- a/mx5x/libcamera/Camera_utils.h
+++ b/mx5x/libcamera/Camera_utils.h
@@ -16,7 +16,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef CAMERA_UTILS_H
@@ -28,20 +28,19 @@
 #include <utils/threads.h>
 
 //#define CAMERA_HAL_DEBUG_LOG
-
 #ifdef CAMERA_HAL_DEBUG_LOG
-#define CAMERA_HAL_LOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
-#define CAMERA_HAL_LOG_FUNC ALOGI("%s is excuting...",  __FUNCTION__)
-#define CAMERA_HAL_LOG_TRACE   ALOGI("%s : %d", __FUNCTION__,__LINE__)
-#define CAMERA_HAL_LOG_INFO(format, ...) ALOGI((format), ## __VA_ARGS__)
+#define CAMERA_LOG_RUNTIME(format, ...) ALOGI((format), ## __VA_ARGS__)
+#define CAMERA_LOG_FUNC ALOGI("%s is excuting...",  __FUNCTION__)
+#define CAMERA_LOG_TRACE   ALOGI("%s : %d", __FUNCTION__,__LINE__)
 #else
-#define CAMERA_HAL_LOG_RUNTIME(format, ...) 
-#define CAMERA_HAL_LOG_FUNC
-#define CAMERA_HAL_LOG_TRACE
-#define CAMERA_HAL_LOG_INFO(format, ...)
+#define CAMERA_LOG_RUNTIME(format, ...)
+#define CAMERA_LOG_FUNC
+#define CAMERA_LOG_TRACE
 #endif
 
-#define CAMERA_HAL_ERR(format, ...) ALOGE((format), ##__VA_ARGS__)
+#define CAMERA_LOG_INFO(format, ...) ALOGI((format), ## __VA_ARGS__)
+#define CAMERA_LOG_WARN(format, ...) ALOGW((format), ## __VA_ARGS__)
+#define CAMERA_LOG_ERR(format, ...) ALOGE((format), ##__VA_ARGS__)
 
 namespace android {
 
diff --git a/mx5x/libcamera/CaptureDeviceInterface.cpp b/mx5x/libcamera/CaptureDeviceInterface.cpp
index 791308c..6f8c90a 100755
--- a/mx5x/libcamera/CaptureDeviceInterface.cpp
+++ b/mx5x/libcamera/CaptureDeviceInterface.cpp
@@ -15,23 +15,20 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include "V4l2UVCDevice.h"
 #include "V4l2CsiDevice.h"
 namespace android{
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath)
     {
         if(strstr(deviceName, UVC_NAME_STRING)){
-            CAMERA_HAL_LOG_INFO("It is the UVC device, name:%s", deviceName);
-
             sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
-            device->SetDevName(deviceName);
+            device->SetDevName(deviceName, devPath);
             return device;
         }else{
-            CAMERA_HAL_LOG_INFO("It is the CSI device");
             sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
-            device->SetDevName(deviceName);
+            device->SetDevName(deviceName, devPath);
             return device;
         }
     }
diff --git a/mx5x/libcamera/CaptureDeviceInterface.h b/mx5x/libcamera/CaptureDeviceInterface.h
index 293476a..dddb38f 100755
--- a/mx5x/libcamera/CaptureDeviceInterface.h
+++ b/mx5x/libcamera/CaptureDeviceInterface.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef CAPTURE_DEVICE_INTERFACE_H
@@ -25,6 +25,11 @@
 #include "Camera_utils.h"
 
 
+#define CAMAERA_FILENAME_LENGTH     256
+#define MAX_CAPTURE_BUF_QUE_NUM     6
+#define CAMERA_SENSOR_LENGTH       32
+#define MAX_DEQUEUE_WAIT_TIME  (5000)  //5000ms for uvc camera
+
 namespace android {
 #define UVC_NAME_STRING "uvc"
 
@@ -39,14 +44,15 @@ namespace android {
         CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
         CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
         CAPTURE_DEVICE_ERR_SYS_CALL=-6,
+        CAPTURE_DEVICE_ERR_OPT_TIMEOUT=-7,
         CAPTURE_DEVICE_ERR_UNKNOWN = -100
-    }CAPTURE_DEVICE_ERR_RET;
+    }CAPTURE_DEVICE_RET;
 
     typedef enum{
         MOTION_MODE = 0,
         HIGH_QUALITY_MODE = 1
     }CAPTURE_MODE;
-    
+
     typedef enum{
         CAMERA_TYPE_CSI = 0,
         CAMERA_TYPE_UVC = 1,
@@ -78,32 +84,32 @@ namespace android {
         unsigned int framesize;   //out
         unsigned int picture_waite_number;//out
         struct timeval_fract tv;
-		SENSOR_PREVIEW_ROTATE rotate;
+	SENSOR_PREVIEW_ROTATE rotate;
     };
 
 
     class CaptureDeviceInterface : public virtual RefBase{
     public:
 
-        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevOpen(int cameraId)=0;
-        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevPrepare()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevStart()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevQueue(unsigned int BufQueIdx)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
-        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType)=0;
+        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char * devPath = NULL)=0;
+        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId)=0;
+        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
+        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
+        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_RET DevPrepare()=0;
+        virtual CAPTURE_DEVICE_RET DevStart()=0;
+        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx)=0;
+        virtual CAPTURE_DEVICE_RET DevQueue(unsigned int BufQueIdx)=0;
+        virtual CAPTURE_DEVICE_RET DevStop()=0;
+        virtual CAPTURE_DEVICE_RET DevDeAllocate()=0;
+        virtual CAPTURE_DEVICE_RET DevClose()=0;
+        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType)=0;
 
         virtual ~ CaptureDeviceInterface(){}
     };
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName);
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(const char *deviceName, const char *devPath);
 
 };
 #endif
diff --git a/mx5x/libcamera/JpegEncoderInterface.cpp b/mx5x/libcamera/JpegEncoderInterface.cpp
index 30b9d96..65ac721 100755
--- a/mx5x/libcamera/JpegEncoderInterface.cpp
+++ b/mx5x/libcamera/JpegEncoderInterface.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. 
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include "JpegEncoderSoftware.h"
 namespace android{
@@ -23,11 +23,11 @@ namespace android{
     extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
     {
         if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
-            CAMERA_HAL_LOG_INFO("Create the software encoder");
+            CAMERA_LOG_INFO("Create the software encoder");
             return JpegEncoderSoftware::createInstance();
         }
         else{
-            CAMERA_HAL_ERR("the hardware encoder is not supported");
+            CAMERA_LOG_ERR("the hardware encoder is not supported");
             return NULL;
         }
     }
diff --git a/mx5x/libcamera/JpegEncoderInterface.h b/mx5x/libcamera/JpegEncoderInterface.h
index b515757..3f1a857 100755
--- a/mx5x/libcamera/JpegEncoderInterface.h
+++ b/mx5x/libcamera/JpegEncoderInterface.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef JPEG_ENCODER_INTERFACE_H
diff --git a/mx5x/libcamera/JpegEncoderSoftware.cpp b/mx5x/libcamera/JpegEncoderSoftware.cpp
index 14adb6a..49868d7 100755
--- a/mx5x/libcamera/JpegEncoderSoftware.cpp
+++ b/mx5x/libcamera/JpegEncoderSoftware.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include <string.h>
 #include <unistd.h>
@@ -47,6 +47,7 @@ namespace android{
         pEncObj(NULL)
     {
         mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
+        mSupportedType[1] = v4l2_fourcc('Y','U','Y','V');
     }
 
     JpegEncoderSoftware :: ~JpegEncoderSoftware()
@@ -58,7 +59,7 @@ namespace android{
     {
 
         int * pSupportedType = (int *)pQueryRet;
-        switch(QueryType){	
+        switch(QueryType){
             case SUPPORTED_FMT:
                 if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
                     *pSupportedType = mSupportedType[mSupportedTypeIdx];
@@ -77,7 +78,7 @@ namespace android{
 
     JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
         struct jpeg_enc_focallength_t * pFoclLength = NULL;
@@ -94,7 +95,7 @@ namespace android{
         pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
 
         if (pEncCfgLocal == NULL){
-            CAMERA_HAL_ERR("Allocat buffer for EncCfg failed");
+            CAMERA_LOG_ERR("Allocat buffer for EncCfg failed");
             return JPEG_ENC_ERROR_ALOC_BUF;
         }
 
@@ -110,7 +111,7 @@ namespace android{
             pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
 
             if (pFoclLength == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pFoclLength failed");
+                CAMERA_LOG_ERR("Allocat buffer for pFoclLength failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -124,7 +125,7 @@ namespace android{
             pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
 
             if (pMakeInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pMakeInfo failed");
+                CAMERA_LOG_ERR("Allocat buffer for pMakeInfo failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -137,7 +138,7 @@ namespace android{
             pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
 
             if (pMakeNote == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pMakeNote failed");
+                CAMERA_LOG_ERR("Allocat buffer for pMakeNote failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -150,7 +151,7 @@ namespace android{
             pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
 
             if (pModelInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pModelInfo failed");
+                CAMERA_LOG_ERR("Allocat buffer for pModelInfo failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -163,7 +164,7 @@ namespace android{
             pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
 
             if (pDatetimeInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pDatetimeInfo failed");
+                CAMERA_LOG_ERR("Allocat buffer for pDatetimeInfo failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -176,7 +177,7 @@ namespace android{
             pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
 
             if (pGpsInfoLocal == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pGpsInfoLocal failed");
+                CAMERA_LOG_ERR("Allocat buffer for pGpsInfoLocal failed");
                 ret = JPEG_ENC_ERROR_ALOC_BUF;
                 goto INT_ERR_RET;
             }
@@ -215,7 +216,7 @@ INT_ERR_RET:
     }
 
     JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
 
         if (pEncCfgLocal != NULL ){
@@ -240,20 +241,20 @@ INT_ERR_RET:
 
     JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int i = 0;
 
         JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
 
         if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
-            CAMERA_HAL_ERR("The input widht and height is wrong");
+            CAMERA_LOG_ERR("The input widht and height is wrong");
             return JPEG_ENC_ERROR_BAD_PARAM;
         }
 
-        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)|| 
+        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)||
                 (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
                 (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
-            CAMERA_HAL_ERR("The input widht and height is wrong");
+            CAMERA_LOG_ERR("The input widht and height is wrong");
             return JPEG_ENC_ERROR_BAD_PARAM;
         }
 
@@ -270,7 +271,7 @@ INT_ERR_RET:
 
     JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
         int width, height, size,index;
@@ -424,7 +425,7 @@ encodeframe:
             v_buff = NULL;
             i_buff = (JPEG_ENC_UINT8 *)buffer;
         }
-        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
 
         /* --------------------------------------------
          * QUERY MEMORY REQUIREMENTS
@@ -433,11 +434,11 @@ encodeframe:
 
         if(return_val != JPEG_ENC_ERR_NO_ERROR)
         {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
+            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
             goto done;
         }
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_query_mem_req success");
+        CAMERA_LOG_RUNTIME("jpeg_enc_query_mem_req success");
         /* --------------------------------------------
          * ALLOCATE MEMORY REQUESTED BY CODEC
          * -------------------------------------------*/
@@ -450,7 +451,7 @@ encodeframe:
             mem_info = &(obj_ptr->mem_infos.mem_info[index]);
             mem_info->memptr = (void *) malloc(mem_info->size);
             if(mem_info->memptr==NULL) {
-                CAMERA_HAL_LOG_RUNTIME("Malloc error after query\n");
+                CAMERA_LOG_RUNTIME("Malloc error after query\n");
                 goto done;
             }
         }
@@ -458,12 +459,12 @@ encodeframe:
         return_val = jpeg_enc_init(obj_ptr);
         if(return_val != JPEG_ENC_ERR_NO_ERROR)
         {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            CAMERA_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
+            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
             goto done;
         }
 
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_init success");
+        CAMERA_LOG_RUNTIME("jpeg_enc_init success");
         if(params->mode == JPEG_ENC_THUMB)
             createJpegExifTags(obj_ptr);
 
@@ -472,8 +473,8 @@ encodeframe:
 
         if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
         {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            CAMERA_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
+            CAMERA_LOG_RUNTIME("Return Val %d\n",return_val);
             goto done;
         }
 
@@ -516,7 +517,7 @@ encodeframe:
 
             goto encodeframe;
         }
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_encodeframe success");
+        CAMERA_LOG_RUNTIME("jpeg_enc_encodeframe success");
         // Make an IMemory for each frame
         //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
         *pEncSize = g_JpegDataLen;
@@ -556,14 +557,14 @@ done:
         {
             /* Flush the buffer*/
             g_JpegDataLen += *out_buf_len_ptr;
-            CAMERA_HAL_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
+            CAMERA_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
 
             *out_buf_ptrptr = NULL;
-            *out_buf_len_ptr = NULL;
+            *out_buf_len_ptr = 0;
         }
         else
         {
-            CAMERA_HAL_LOG_RUNTIME("Not enough buffer for encoding");
+            CAMERA_LOG_RUNTIME("Not enough buffer for encoding");
             return 0;
         }
 
@@ -572,7 +573,7 @@ done:
 
     void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
     {
-        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+        CAMERA_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
 
         jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
         jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
diff --git a/mx5x/libcamera/JpegEncoderSoftware.h b/mx5x/libcamera/JpegEncoderSoftware.h
index 2bcd2d1..7e22dff 100755
--- a/mx5x/libcamera/JpegEncoderSoftware.h
+++ b/mx5x/libcamera/JpegEncoderSoftware.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef JPEG_ENCODER_SOFTWARE_H
@@ -40,7 +40,7 @@
 
 
 namespace android{
-#define MAX_ENC_SUPPORTED_YUV_TYPE  1
+#define MAX_ENC_SUPPORTED_YUV_TYPE  2
 
     class JpegEncoderSoftware : public JpegEncoderInterface{
     public:
@@ -61,8 +61,8 @@ namespace android{
 
         static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
                 JPEG_ENC_UINT32 *out_buf_len_ptr,
-                JPEG_ENC_UINT8 flush, 
-                void * context, 
+                JPEG_ENC_UINT8 flush,
+                void * context,
                 JPEG_ENC_MODE enc_mode);
         void createJpegExifTags(jpeg_enc_object * obj_ptr);
         int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
@@ -78,7 +78,7 @@ namespace android{
         static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
         static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
 
-    }; 
+    };
 };
 
 #endif
diff --git a/mx5x/libcamera/PP_ipulib.cpp b/mx5x/libcamera/PP_ipulib.cpp
index 69d91ee..07e72a4 100755
--- a/mx5x/libcamera/PP_ipulib.cpp
+++ b/mx5x/libcamera/PP_ipulib.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include "PP_ipulib.h"
 #include <stdlib.h>
@@ -34,7 +34,7 @@ namespace android{
         singleton.clear();
     }
     PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
 
         int mIPURet;
@@ -63,7 +63,7 @@ namespace android{
         mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
         mIPUOutputParam.rot = pp_output->rot;
         mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
-        CAMERA_HAL_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+        CAMERA_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
                 mIPUOutputParam.width,
                 mIPUOutputParam.height,
                 mIPUOutputParam.output_win.pos.x,
@@ -72,7 +72,7 @@ namespace android{
                 mIPUOutputParam.output_win.win_h,
                 mIPUOutputParam.rot);
 
-        CAMERA_HAL_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+        CAMERA_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
                 mIPUInputParam.width,
                 mIPUInputParam.height,
                 mIPUInputParam.fmt,
@@ -83,7 +83,7 @@ namespace android{
 
         mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
         if (mIPURet < 0) {
-            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
+            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
             return PPDEVICE_ERROR_INIT;
         }  
 
@@ -91,7 +91,7 @@ namespace android{
     }
 
     PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
 
         int mIPURet;
@@ -99,9 +99,9 @@ namespace android{
 
         mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
 
-        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset,NULL,NULL,NULL);
+        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset, 0,NULL,NULL);
         if (mIPURet < 0) {
-            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
+            CAMERA_LOG_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
             mxc_ipu_lib_task_uninit(&mIPUHandle);
             memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
             return PPDEVICE_ERROR_PROCESS;
@@ -112,7 +112,7 @@ namespace android{
     }
 
     PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
 
         mxc_ipu_lib_task_uninit(&mIPUHandle);
@@ -122,7 +122,7 @@ namespace android{
     }
 
     sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (singleton != 0) {
             sp<PostProcessDeviceInterface> device = singleton.promote();
             if (device != 0) {
diff --git a/mx5x/libcamera/PP_ipulib.h b/mx5x/libcamera/PP_ipulib.h
index 39b0d4c..ee5fe03 100755
--- a/mx5x/libcamera/PP_ipulib.h
+++ b/mx5x/libcamera/PP_ipulib.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef PP_IPU_LIB_H
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.cpp b/mx5x/libcamera/PostProcessDeviceInterface.cpp
index 3d7e752..0b33c6d 100755
--- a/mx5x/libcamera/PostProcessDeviceInterface.cpp
+++ b/mx5x/libcamera/PostProcessDeviceInterface.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include "PP_ipulib.h" 
 namespace android{
diff --git a/mx5x/libcamera/PostProcessDeviceInterface.h b/mx5x/libcamera/PostProcessDeviceInterface.h
index 9d730b6..d7cf58a 100755
--- a/mx5x/libcamera/PostProcessDeviceInterface.h
+++ b/mx5x/libcamera/PostProcessDeviceInterface.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 #ifndef POSTPROCESS_DEVICE_INTERFACE_H
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.cpp b/mx5x/libcamera/V4l2CapDeviceBase.cpp
index 74abc55..9d1bcee 100755
--- a/mx5x/libcamera/V4l2CapDeviceBase.cpp
+++ b/mx5x/libcamera/V4l2CapDeviceBase.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include <string.h>
 #include <unistd.h>
@@ -57,42 +57,44 @@ namespace android{
     {
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::SetDevName(char * deviceName){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase::SetDevName(const char * deviceName, const char * devPath){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if(NULL == deviceName)
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         strcpy(mInitalDeviceName, deviceName);
+        if((devPath != NULL) && (strlen(devPath) > 0))
+            strcpy(mCaptureDeviceName, devPath);
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if(NULL == deviceName)
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         strcpy(deviceName, mInitalDeviceName);
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::DevOpen(int cameraId){
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase::DevOpen(int cameraId){
+        CAMERA_LOG_FUNC;
 
-        return V4l2Open(cameraId); 
-    } 
+        return V4l2Open(cameraId);
+    }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if(pType == NULL)
             return CAPTURE_DEVICE_ERR_OPEN;
         *pType = mCameraType;
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAMERA_LOG_FUNC;
 
         if(mCameraDevice <= 0)
             return CAPTURE_DEVICE_ERR_OPEN;
@@ -101,14 +103,14 @@ namespace android{
 
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
 
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if(mCapCfg.fmt != pCapcfg->fmt || mCapCfg.width != pCapcfg->width || mCapCfg.height != pCapcfg->height
                 || mCapCfg.tv.denominator/mCapCfg.tv.numerator != pCapcfg->tv.denominator/pCapcfg->tv.numerator) {
             mCapCfg.fmt = pCapcfg->fmt;
@@ -116,7 +118,7 @@ namespace android{
             mCapCfg.height = pCapcfg->height;
             mCapCfg.tv.denominator = pCapcfg->tv.denominator;
             mCapCfg.tv.numerator = pCapcfg->tv.numerator;
-            CAMERA_HAL_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
+            CAMERA_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
             ret = V4l2SetConfig(pCapcfg);
             if(ret < 0) {
                 return ret;
@@ -126,7 +128,7 @@ namespace android{
 
         if(mCapCfg.rotate != pCapcfg->rotate) {
             mCapCfg.rotate = pCapcfg->rotate;
-            CAMERA_HAL_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
+            CAMERA_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
             if(V4l2SetRot(pCapcfg) < 0)
                 return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
@@ -135,44 +137,44 @@ namespace android{
 
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else
             return V4l2RegisterBufs(DevBufQue, pBufQueNum);
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else
             return V4l2AllocateBuf(DevBufQue, pBufQueNum);
     }
 
-    CAPTURE_DEVICE_ERR_RET  V4l2CapDeviceBase :: DevPrepare(){
+    CAPTURE_DEVICE_RET  V4l2CapDeviceBase :: DevPrepare(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else
             return V4l2Prepare();
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStart(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStart(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else
             return V4l2Start();
     }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
 
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else{
@@ -181,9 +183,9 @@ namespace android{
 
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
 
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else{
@@ -191,8 +193,8 @@ namespace android{
         }
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStop(){
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevStop(){
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
         }else{
@@ -201,8 +203,8 @@ namespace android{
 
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDeAllocate(){
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevDeAllocate(){
+        CAMERA_LOG_FUNC;
 
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
@@ -210,9 +212,9 @@ namespace android{
             return V4l2DeAlloc();
         }
     }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevClose(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: DevClose(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         if (mCameraDevice <= 0){
             return CAPTURE_DEVICE_ERR_OPEN;
@@ -221,53 +223,61 @@ namespace android{
         }
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Open(int cameraId){
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Open(int cameraId){
+        CAMERA_LOG_FUNC;
         int fd = 0, i, j, is_found = 0;
         const char *flags[] = {"uncompressed", "compressed"};
-
         char   dev_node[CAMAERA_FILENAME_LENGTH];
         DIR *v4l_dir = NULL;
         struct dirent *dir_entry;
         struct v4l2_capability v4l2_cap;
+        struct v4l2_dbg_chip_ident vid_chip;
         struct v4l2_fmtdesc vid_fmtdesc;
         struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
 
         if(mCameraDevice > 0)
             return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
         else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
             mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
             if (mCameraDevice < 0)
                 return CAPTURE_DEVICE_ERR_OPEN;
         }
         else{
-            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
             v4l_dir = opendir("/sys/class/video4linux");
             if (v4l_dir){
                 while((dir_entry = readdir(v4l_dir))) {
                     memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                    if(strncmp(dir_entry->d_name, "video", 5))
                         continue;
                     sprintf(dev_node, "/dev/%s", dir_entry->d_name);
                     if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
                         continue;
-                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
                     if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
                         close(fd);
                         fd = 0;
                         continue;
-                    } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
-                            (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
-                        is_found = 1;
-                        strcpy(mCaptureDeviceName, dev_node);
-                        CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
-                        break;
-                    } else {
-                        close(fd);
-                        fd = 0;
+                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
+                        if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
+                            close(fd);
+                            fd = 0;
+                            CAMERA_LOG_ERR("dev_node %s:cannot get sensor name", dev_node);
+                            continue;
+                        }
+                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
+                                dev_node, vid_chip.match.name);
+                        if(strstr(vid_chip.match.name, mInitalDeviceName)){
+                            is_found = 1;
+                            strcpy(mInitalDeviceName, vid_chip.match.name);
+                            strcpy(mCaptureDeviceName, dev_node);
+                            break;
+                        }
                     }
+                    close(fd);
+                    fd = 0;
                 }
                 closedir(v4l_dir);
             }
@@ -275,23 +285,25 @@ namespace android{
                 mCameraDevice = fd;
             }
             else{
-                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                CAMERA_LOG_ERR("The device name is not correct or the device is error");
                 return CAPTURE_DEVICE_ERR_OPEN;
             }
         }
-        return ret; 
+        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
+        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
+        return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
 
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_LOG_RUNTIME("devParamType is %d", devParamType);
+        CAMERA_LOG_FUNC;
+        CAMERA_LOG_RUNTIME("devParamType is %d", devParamType);
 
         if(mCameraDevice <= 0)
             return CAPTURE_DEVICE_ERR_OPEN;
         switch(devParamType){
-            case OUTPU_FMT: 
+            case OUTPU_FMT:
                 ret = V4l2EnumFmt(retParam);
                 break;
             case FRAME_SIZE_FPS:
@@ -309,9 +321,9 @@ namespace android{
 
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         struct v4l2_fmtdesc vid_fmtdesc;
         unsigned int *pParamVal = (unsigned int *)retParam;
 
@@ -321,7 +333,7 @@ namespace android{
             mFmtParamIdx = 0;
             ret = CAPTURE_DEVICE_ERR_GET_PARAM;
         }else{
-            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
+            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
             *pParamVal = vid_fmtdesc.pixelformat;
             mFmtParamIdx ++;
             ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
@@ -329,29 +341,29 @@ namespace android{
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         struct v4l2_frmsizeenum vid_frmsize;
         struct v4l2_frmivalenum vid_frmval;
 
         struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
         memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
         vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
         vid_frmsize.pixel_format = pCapCfg->fmt;
         if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
             mSizeFPSParamIdx = 0;
             ret = CAPTURE_DEVICE_ERR_SET_PARAM;
         }else{
             memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
             vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
             vid_frmval.pixel_format = pCapCfg->fmt;
             vid_frmval.width = vid_frmsize.discrete.width;
             vid_frmval.height= vid_frmsize.discrete.height;
             if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-                CAMERA_HAL_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
+                CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
                 mSizeFPSParamIdx = 0;
                 ret = CAPTURE_DEVICE_ERR_SET_PARAM;
             }else{
@@ -366,10 +378,10 @@ namespace android{
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
 
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -379,9 +391,9 @@ namespace android{
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -389,10 +401,10 @@ namespace android{
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
 
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -403,14 +415,14 @@ namespace android{
     }
 
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
 
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         struct v4l2_format fmt;
         struct v4l2_control ctrl;
         struct v4l2_streamparm parm;
@@ -430,9 +442,9 @@ namespace android{
         fmt.fmt.pix.sizeimage = 0;
 
         if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_HAL_ERR("set format failed\n");
-            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+            CAMERA_LOG_ERR("set format failed\n");
+            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
                     pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
                     (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
             return CAPTURE_DEVICE_ERR_SYS_CALL;
@@ -446,8 +458,8 @@ namespace android{
             return ret;
 
         if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-            CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
+            CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+            CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
                     parm.parm.capture.timeperframe.denominator);
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
@@ -459,14 +471,14 @@ namespace android{
 
         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }else{
 
-            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
         }
         pCapcfg->framesize = fmt.fmt.pix.sizeimage;
         pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
@@ -474,14 +486,14 @@ namespace android{
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
         unsigned int i;
         struct v4l2_buffer buf;
         enum v4l2_buf_type type;
         struct v4l2_requestbuffers req;
         int BufQueNum;
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -493,7 +505,7 @@ namespace android{
         req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         req.memory = V4L2_MEMORY_MMAP;
         if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
 
@@ -505,10 +517,10 @@ namespace android{
             buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
             buf.index = i;
             if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
                 return CAPTURE_DEVICE_ERR_SYS_CALL;
             } else {
-                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
             }
 
             mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
@@ -516,22 +528,22 @@ namespace android{
             mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
                     PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
             memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
         }
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
         unsigned int i;
         struct v4l2_buffer buf;
         enum v4l2_buf_type type;
         struct v4l2_requestbuffers req;
         int BufQueNum;
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -543,7 +555,7 @@ namespace android{
         req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         req.memory = V4L2_MEMORY_USERPTR;
         if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
 
@@ -559,22 +571,22 @@ namespace android{
             buf.length = mCaptureBuffers[i].length = DevBufQue[i].length;
             mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
             //memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+            CAMERA_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
             if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
                 return CAPTURE_DEVICE_ERR_SYS_CALL;
             } else {
-                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+                CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
             }
         }
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Prepare(){
-        CAMERA_HAL_LOG_FUNC;
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Prepare(){
+        CAMERA_LOG_FUNC;
         struct v4l2_buffer buf;
         mQueuedBufNum = 0;
         for (unsigned int i = 0; i < mBufQueNum; i++) {
@@ -585,36 +597,36 @@ namespace android{
             buf.m.offset = mCaptureBuffers[i].phy_offset;
 
             if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-                CAMERA_HAL_ERR("VIDIOC_QBUF error\n");
+                CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
                 return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } 
+            }
             mQueuedBufNum ++;
         }
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Start(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Start(){
         enum v4l2_buf_type type;
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 ){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
         type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            CAMERA_LOG_ERR("VIDIOC_STREAMON error\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         } else{
-            CAMERA_HAL_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
+            CAMERA_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
         }
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
         int ret;
         struct v4l2_buffer cfilledbuffer;
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
             return CAPTURE_DEVICE_ERR_OPEN;
         }
@@ -623,7 +635,7 @@ namespace android{
         cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
         ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
         if (ret < 0) {
-            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
         *pBufQueIdx = cfilledbuffer.index;
@@ -632,10 +644,10 @@ namespace android{
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
         int ret;
         struct v4l2_buffer cfilledbuffer;
-        //CAMERA_HAL_LOG_FUNC;
+        //CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
             return CAPTURE_DEVICE_ERR_OPEN;
         }
@@ -645,7 +657,7 @@ namespace android{
         cfilledbuffer.index = BufQueIdx;
         ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
         if (ret < 0) {
-            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
         mQueuedBufNum ++;
@@ -653,26 +665,26 @@ namespace android{
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Stop(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Stop(){
         enum v4l2_buf_type type;
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 ){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
         type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            CAMERA_LOG_ERR("VIDIOC_STREAMOFF error\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         } else
-            CAMERA_HAL_LOG_INFO("VIDIOC_STREAMOFF ok\n");
+            CAMERA_LOG_INFO("VIDIOC_STREAMOFF ok\n");
 
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 ){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -681,24 +693,23 @@ namespace android{
             if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
                 munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
                 mCaptureBuffers[i].length = 0;
-                CAMERA_HAL_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
+                CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
             }
         }
         return CAPTURE_DEVICE_ERR_NONE;
     }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Close(){
+    CAPTURE_DEVICE_RET V4l2CapDeviceBase :: V4l2Close(){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
 
         if (mCameraDevice <= 0 ){
-            CAMERA_HAL_LOG_INFO("the device handle is error");
+            CAMERA_LOG_INFO("the device handle is error");
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
-        CAMERA_HAL_LOG_INFO("close the device");
+        CAMERA_LOG_INFO("close the device");
         close(mCameraDevice);
         mCameraDevice = -1;
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-
 };
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.h b/mx5x/libcamera/V4l2CapDeviceBase.h
index f1ad23f..f48ac32 100755
--- a/mx5x/libcamera/V4l2CapDeviceBase.h
+++ b/mx5x/libcamera/V4l2CapDeviceBase.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #ifndef V4L2_CAP_DEVICE_BASE_H
 #define V4L2_CAP_DEVICE_BASE_H
@@ -23,55 +23,51 @@
 
 #include "CaptureDeviceInterface.h"
 
-#define CAMAERA_FILENAME_LENGTH     256
-#define MAX_CAPTURE_BUF_QUE_NUM     6
-#define CAMAERA_SENSOR_LENGTH       32
-
 namespace android{
 
     class V4l2CapDeviceBase : public CaptureDeviceInterface{
     public:
 
-        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType);
-        virtual CAPTURE_DEVICE_ERR_RET DevOpen(int cameraId);
-        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET DevPrepare();
-        virtual CAPTURE_DEVICE_ERR_RET DevStart();
-        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET DevQueue( unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET DevStop();
-        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate();
-        virtual CAPTURE_DEVICE_ERR_RET DevClose();
+        virtual CAPTURE_DEVICE_RET SetDevName(const char * deviceName, const char *devPath = NULL);
+        virtual CAPTURE_DEVICE_RET GetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_RET GetDevType(CAMERA_TYPE *pType);
+        virtual CAPTURE_DEVICE_RET DevOpen(int cameraId);
+        virtual CAPTURE_DEVICE_RET EnumDevParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_RET DevSetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_RET DevPrepare();
+        virtual CAPTURE_DEVICE_RET DevStart();
+        virtual CAPTURE_DEVICE_RET DevDequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_RET DevQueue( unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_RET DevStop();
+        virtual CAPTURE_DEVICE_RET DevDeAllocate();
+        virtual CAPTURE_DEVICE_RET DevClose();
 
     protected:
 
         V4l2CapDeviceBase();
         virtual ~V4l2CapDeviceBase();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Open(int cameraId);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Prepare();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Start();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Queue(unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Stop();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2DeAlloc();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Close();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
-        virtual CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_RET V4l2Open(int cameraId);
+        virtual CAPTURE_DEVICE_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
+        virtual CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
+        virtual CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_RET V4l2Prepare();
+        virtual CAPTURE_DEVICE_RET V4l2Start();
+        virtual CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_RET V4l2Stop();
+        virtual CAPTURE_DEVICE_RET V4l2DeAlloc();
+        virtual CAPTURE_DEVICE_RET V4l2Close();
+        virtual CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode);
+        virtual CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
 
         char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
-        char         mInitalDeviceName[CAMAERA_SENSOR_LENGTH];
+        char         mInitalDeviceName[CAMERA_SENSOR_LENGTH];
         int          mCameraDevice;
         unsigned int mFmtParamIdx;
         unsigned int mSizeFPSParamIdx;
diff --git a/mx5x/libcamera/V4l2CsiDevice.cpp b/mx5x/libcamera/V4l2CsiDevice.cpp
index 0f8da8a..60fe01b 100755
--- a/mx5x/libcamera/V4l2CsiDevice.cpp
+++ b/mx5x/libcamera/V4l2CsiDevice.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #include <string.h>
 #include <unistd.h>
@@ -49,8 +49,9 @@ namespace android{
     }
 
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2Open(int cameraId){
-        CAMERA_HAL_LOG_FUNC;
+#ifdef V4L2_CAMERA_SWITCH
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2Open(int cameraId){
+        CAMERA_LOG_FUNC;
         int fd = 0, i, j, is_found = 0;
         const char *flags[] = {"uncompressed", "compressed"};
 
@@ -60,40 +61,33 @@ namespace android{
         struct v4l2_dbg_chip_ident vid_chip;
         struct v4l2_fmtdesc vid_fmtdesc;
         struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        ALOGI("%s: mInitalDeviceName %s, cameraId %d, mCaptureDeviceName %s",
+                __func__, mInitalDeviceName, cameraId, mCaptureDeviceName);
 
         if(mCameraDevice > 0)
             return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
 
-#ifdef V4L2_CAMERA_SWITCH
         if (mCaptureDeviceName[0] != '#'){
-            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            CAMERA_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
             mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
             if (mCameraDevice < 0)
                 return CAPTURE_DEVICE_ERR_OPEN;
             ret = V4l2SetSensor(cameraId);
         }
         else{
-            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
             v4l_dir = opendir("/sys/class/video4linux");
             if (v4l_dir){
                 while((dir_entry = readdir(v4l_dir))) {
                     memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                    if(strncmp(dir_entry->d_name, "video", 5))
                         continue;
                     sprintf(dev_node, "/dev/%s", dir_entry->d_name);
                     if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
                         continue;
-                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
-
-                    if (fd > 0){
-                        mCameraDevice = fd;
-                        ret = V4l2SetSensor(cameraId);
-                    }
-                    else{
-                        CAMERA_HAL_ERR("The device name is not correct or the device is error");
-                        return CAPTURE_DEVICE_ERR_OPEN;
-                    }
+                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
 
                     if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
                         close(fd);
@@ -103,55 +97,35 @@ namespace android{
                         is_found = 1;
                         strcpy(mCaptureDeviceName, dev_node);
                         strcpy(mInitalDeviceName, vid_chip.match.name);
-                        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
-                        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
+                        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
+                        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
                         break;
-                    } else{
-                        close(fd);
-                        fd = 0;
                     }
+                    close(fd);
+                    fd = 0;
                 }
                 closedir(v4l_dir);
             }
+
             if (fd > 0){
                 mCameraDevice = fd;
                 ret = V4l2SetSensor(cameraId);
             }
             else{
-                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                CAMERA_LOG_ERR("The device name is not correct or the device is error");
                 return CAPTURE_DEVICE_ERR_OPEN;
             }
         }
-#else
-        memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-        sprintf(dev_node, "/dev/video%d", cameraId);
-        if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0) {
-            CAMERA_HAL_ERR("dev_node %s:cannot be opened", dev_node);
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-
-        if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-            close(fd);
-            CAMERA_HAL_ERR("dev_node %s:cannot get sensor name", dev_node);
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        strcpy(mCaptureDeviceName, dev_node);
-        strcpy(mInitalDeviceName, vid_chip.match.name);
-        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
-        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
-        mCameraDevice = fd;
-#endif
-        return ret; 
+        return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetSensor(int cameraId)
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetSensor(int cameraId)
     {
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        CAMERA_HAL_LOG_INFO("-----set camera sensor %d-----", cameraId);
-#ifdef V4L2_CAMERA_SWITCH
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAMERA_LOG_INFO("-----set camera sensor %d-----", cameraId);
         if(cameraId >= 2) {
-            CAMERA_HAL_ERR("Error: camerId %d is too big", cameraId);
+            CAMERA_LOG_ERR("Error: camerId %d is too big", cameraId);
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
 
@@ -159,20 +133,20 @@ namespace android{
         ctrl.id = V4L2_CID_MXC_SWITCH_CAM;
         ctrl.value = cameraId;
         if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_HAL_ERR("set ctrl switch camera failed\n");
+            CAMERA_LOG_ERR("set ctrl switch camera failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
-#endif
         return ret;
     }
+#endif
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         unsigned int *pParamVal = (unsigned int *)retParam;
 
         if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
-            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
+            CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
             *pParamVal = mSupportedFmt[mFmtParamIdx];
             mFmtParamIdx ++;
             ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
@@ -183,15 +157,15 @@ namespace android{
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         struct v4l2_frmsizeenum vid_frmsize;
 
         struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
         memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
         vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
         vid_frmsize.pixel_format = pCapCfg->fmt;
         if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
             mSizeFPSParamIdx = 0;
@@ -199,7 +173,7 @@ namespace android{
         }else{
             //hardcode here for ov3640
             if (strstr(mInitalDeviceName, "3640") != NULL){
-                CAMERA_HAL_LOG_INFO("the sensor  is  mInitalDeviceName");
+                CAMERA_LOG_INFO("the sensor  is  mInitalDeviceName");
                 if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
                     mSizeFPSParamIdx ++;
                     vid_frmsize.index = mSizeFPSParamIdx;
@@ -209,7 +183,7 @@ namespace android{
                     }
                 }
             }
-            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
             pCapCfg->width  = vid_frmsize.discrete.width;
             pCapCfg->height = vid_frmsize.discrete.height;
             if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
@@ -225,27 +199,27 @@ namespace android{
         return ret;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
     {
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         int input = 1;
         if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
-            CAMERA_HAL_ERR("set input failed");
+            CAMERA_LOG_ERR("set input failed");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
     {
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
 
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         struct v4l2_format fmt;
         struct v4l2_control ctrl;
         struct v4l2_streamparm parm;
@@ -260,11 +234,10 @@ namespace android{
             pCapcfg->tv.numerator = 1;
             pCapcfg->tv.denominator = 30;
         }
-        CAMERA_HAL_LOG_RUNTIME("the fps is %d", pCapcfg->tv.denominator);
 
         parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
         parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode), 
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode),
                 &(parm.parm.capture.timeperframe));
         if (ret != CAPTURE_DEVICE_ERR_NONE)
             return ret;
@@ -273,13 +246,15 @@ namespace android{
             parm.parm.capture.timeperframe.numerator = 1;
             parm.parm.capture.timeperframe.denominator = 15;
             if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
-                CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-                CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator, 
+                CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+                CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
                         parm.parm.capture.timeperframe.denominator);
                 return CAPTURE_DEVICE_ERR_SYS_CALL;
             }
         }
 
+        CAMERA_LOG_INFO("Set FPS %d to Capture device",
+                parm.parm.capture.timeperframe.denominator);
 
         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         fmt.fmt.pix.pixelformat = pCapcfg->fmt;
@@ -294,9 +269,9 @@ namespace android{
         fmt.fmt.pix.sizeimage = 0;
 
         if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_HAL_ERR("set format failed\n");
-            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+            CAMERA_LOG_ERR("set format failed\n");
+            CAMERA_LOG_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_LOG_ERR(" Set the Format :%c%c%c%c\n",
                     pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
                     (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
             return CAPTURE_DEVICE_ERR_SYS_CALL;
@@ -304,24 +279,24 @@ namespace android{
 
         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         if (ioctl(mCameraDevice, VIDIOC_G_FMT, &fmt) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }else{
 
-            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+            CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
         }
         pCapcfg->framesize = fmt.fmt.pix.sizeimage;
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
             unsigned int *pMode, struct v4l2_fract *pTimeFrame){
 
-        CAMERA_HAL_LOG_FUNC;
+        CAMERA_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -335,34 +310,22 @@ namespace android{
             pic_waite_buf_num = 6;
             if (capturewidth == 640 && captureheight == 480) {
                 capturemode = 0;	/* VGA mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 30;
             }
             else if (capturewidth == 320 && captureheight == 240) {
                 capturemode = 1;	/* QVGA mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 30;
             }
             else if (capturewidth == 720 && captureheight == 480) {
                 capturemode = 2;	/* PAL mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 30;
             }
             else if (capturewidth == 720 && captureheight == 576) {
                 capturemode = 3;	/* PAL mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 30;
             }
             else if (capturewidth == 1280 && captureheight == 720) {
                 capturemode = 4;	/* 720P mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 30;
             }
             else if (capturewidth == 1920 && captureheight == 1080){
                 pic_waite_buf_num = 3;
                 capturemode = 5;	/* 1080P mode */
-                pTimeFrame->numerator = 1;
-                pTimeFrame->denominator = 15;
             }
             else if (capturewidth == 2592 && captureheight == 1944) {
                 pic_waite_buf_num =3;
@@ -372,11 +335,12 @@ namespace android{
             }
             else if (capturewidth == 176 && captureheight == 144) {
                 capturemode = 7;       /* QCIF mode */
-                //pTimeFrame->numerator = 1;
-                //pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 1024 && captureheight == 768) {
+                capturemode = 8;       /* XGA mode */
             }
             else{
-                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
                 return CAPTURE_DEVICE_ERR_BAD_PARAM;
             }
         }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
@@ -396,26 +360,26 @@ namespace android{
             }
             else
             {
-                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                CAMERA_LOG_ERR("The camera mode is not supported!!!!");
                 return CAPTURE_DEVICE_ERR_BAD_PARAM;
             }
         }else{
-            CAMERA_HAL_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
+            CAMERA_LOG_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
             capturemode = 0;
             pic_waite_buf_num = 0;
         }
 
-        CAMERA_HAL_LOG_INFO("the mode is %d", capturemode);
+        CAMERA_LOG_INFO("camera mode:%d", capturemode);
         *pMode = capturemode;
         pCapcfg->picture_waite_number = pic_waite_buf_num;
 
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
+    CAPTURE_DEVICE_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
 
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        CAMERA_LOG_FUNC;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
@@ -436,11 +400,15 @@ namespace android{
             ctrl.value = V4L2_MXC_ROTATE_NONE;
 
         if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_HAL_ERR("set ctrl failed\n");
+            CAMERA_LOG_ERR("set ctrl failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
 
         return ret;
     }
+
+    CAPTURE_DEVICE_RET  V4l2CsiDevice :: V4l2DeAlloc() {
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
 };
 
diff --git a/mx5x/libcamera/V4l2CsiDevice.h b/mx5x/libcamera/V4l2CsiDevice.h
index 4305ed9..bdc0632 100755
--- a/mx5x/libcamera/V4l2CsiDevice.h
+++ b/mx5x/libcamera/V4l2CsiDevice.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #ifndef V4L2_CSI_DEVICE_H
 #define V4L2_CSI_DEVICE_H
@@ -31,22 +31,26 @@ namespace android{
 
 class V4l2CsiDevice : public V4l2CapDeviceBase{
     public:
-        
+
         V4l2CsiDevice();
         virtual ~V4l2CsiDevice();
     protected:
-		
-		CAPTURE_DEVICE_ERR_RET V4l2Open(int cameraId);
-        CAPTURE_DEVICE_ERR_RET V4l2SetSensor(int cameraId);
-		CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
-		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
-		CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
-                unsigned int *pMode, struct v4l2_fract *pTimeFrame); 
-        CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-
-		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
+
+#ifdef V4L2_CAMERA_SWITCH
+        //Only for switch camera with ioctl
+        CAPTURE_DEVICE_RET V4l2Open(int cameraId);
+        CAPTURE_DEVICE_RET V4l2SetSensor(int cameraId);
+#endif
+	CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
+	CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
+	CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg,
+                unsigned int *pMode, struct v4l2_fract *pTimeFrame);
+        CAPTURE_DEVICE_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_RET V4l2DeAlloc();
+
+	unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
    };
 
 };
diff --git a/mx5x/libcamera/V4l2UVCDevice.cpp b/mx5x/libcamera/V4l2UVCDevice.cpp
new file mode 100644
index 0000000..5e198de
--- /dev/null
+++ b/mx5x/libcamera/V4l2UVCDevice.cpp
@@ -0,0 +1,716 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include <linux/videodev2.h>
+
+
+#include "V4l2UVCDevice.h"
+
+#define MAX_DEV_NAME_LENGTH 10
+
+namespace android {
+
+V4l2UVCDevice::V4l2UVCDevice()
+{
+    mCameraType = CAMERA_TYPE_UVC;
+    memset(mUvcBuffers, 0 , sizeof(mUvcBuffers));
+    mCaptureConfigNum = 0;
+    mCurrentConfig = NULL;
+    memset(mCaptureConfig, 0, sizeof(mCaptureConfig));
+
+    mEnableCSC = false;
+    mSensorFmtCnt = 0;
+    mCscFmtCnt = 0;
+    mActualCscFmtCnt = 0;
+    memset(mSensorSupportFmt, 0, sizeof(mSensorSupportFmt));
+    memset(mActualCscFmt, 0 , sizeof(mActualCscFmt));
+
+    memset(mCscGroup, 0, sizeof(mCscGroup));
+    //related to format support in CSC.
+    mCscGroup[0].srcFormat = v4l2_fourcc('Y','U','Y','V');
+    mCscGroup[0].dstFormat = v4l2_fourcc('N','V','1','2');
+    mCscGroup[0].cscConvert = convertYUYUToNV12;
+    mCscGroup[0].isSensorSupport = false;
+    mCscGroup[0].isOverlapWithSensor = false;
+    mDoCsc = NULL;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Open(int cameraId)
+{
+        CAMERA_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char   dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_capability v4l2_cap;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_LOG_INFO("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR | O_NONBLOCK, 0);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5))
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR | O_NONBLOCK, 0)) < 0)
+                        continue;
+                    CAMERA_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
+                        close(fd);
+                        fd = 0;
+                        continue;
+                    } else if (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) {
+                        CAMERA_LOG_RUNTIME("dev_node: %s, sensor name: %s",
+                                dev_node, v4l2_cap.driver);
+                        if(strstr((const char*)v4l2_cap.driver, mInitalDeviceName)){
+                            is_found = 1;
+                            CAMERA_LOG_RUNTIME("find the correct sensor %s, len=%d", v4l2_cap.driver, strlen((const char*)v4l2_cap.driver));
+                            strcpy(mInitalDeviceName, (const char*)v4l2_cap.driver);
+                            strcpy(mCaptureDeviceName, dev_node);
+                            break;
+                        }
+                    }
+                    close(fd);
+                    fd = 0;
+                }
+                closedir(v4l_dir);
+            }
+            if (fd > 0){
+                mCameraDevice = fd;
+            }
+            else{
+                CAMERA_LOG_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        CAMERA_LOG_INFO("device name is %s", mCaptureDeviceName);
+        CAMERA_LOG_INFO("sensor name is %s", mInitalDeviceName);
+        return ret;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)
+{
+    unsigned int i;
+    struct v4l2_buffer buf;
+    enum v4l2_buf_type type;
+    struct v4l2_requestbuffers req;
+    int BufQueNum;
+
+    CAMERA_LOG_FUNC;
+    if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+        return CAPTURE_DEVICE_ERR_BAD_PARAM;
+    }
+
+    mBufQueNum = *pBufQueNum;
+
+    memset(&req, 0, sizeof (req));
+    req.count = mBufQueNum;
+    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    req.memory = V4L2_MEMORY_MMAP;
+    if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+        CAMERA_LOG_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+        return CAPTURE_DEVICE_ERR_SYS_CALL;
+    }
+
+    /*the driver may can't meet the request, and return the buf num it can handle*/
+    *pBufQueNum = mBufQueNum = req.count;
+
+    for (i = 0; i < mBufQueNum; i++) {
+        memset(&buf, 0, sizeof (buf));
+        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        buf.index = i;
+        if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+            CAMERA_LOG_ERR("VIDIOC_QUERYBUF error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else {
+            CAMERA_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+        }
+
+        mCaptureBuffers[i].length = DevBufQue[i].length = mUvcBuffers[i].length = buf.length;
+
+        mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
+        mUvcBuffers[i].phy_offset = (size_t) buf.m.offset;
+
+        mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
+        mUvcBuffers[i].virt_start = (unsigned char *)mmap (NULL, mUvcBuffers[i].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mUvcBuffers[i].phy_offset);
+
+        memset(mUvcBuffers[i].virt_start, 0xFF, mUvcBuffers[i].length);
+        CAMERA_LOG_RUNTIME("user space buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+        CAMERA_LOG_RUNTIME("user space buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+        CAMERA_LOG_RUNTIME("user space buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].length = %d\n", i, mUvcBuffers[i].length);
+        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].phy_offset = 0x%x\n", i, mUvcBuffers[i].phy_offset);
+        CAMERA_LOG_RUNTIME("uvc driver buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mUvcBuffers[i].virt_start));
+    }
+
+    return CAPTURE_DEVICE_ERR_NONE;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Prepare()
+{
+    CAMERA_LOG_FUNC;
+    struct v4l2_buffer buf;
+    mQueuedBufNum = 0;
+    for (unsigned int i = 0; i < mBufQueNum; i++) {
+        memset(&buf, 0, sizeof (struct v4l2_buffer));
+        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        buf.memory = V4L2_MEMORY_MMAP;
+        buf.index = i;
+        buf.m.offset = mUvcBuffers[i].phy_offset;
+
+        if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
+            CAMERA_LOG_ERR("VIDIOC_QBUF error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        mQueuedBufNum ++;
+    }
+
+    return CAPTURE_DEVICE_ERR_NONE;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Dequeue(unsigned int *pBufQueIdx)
+{
+    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+    struct v4l2_buffer cfilledbuffer;
+    int n;
+    fd_set rfds;
+    struct timeval tv;
+    //CAMERA_LOG_FUNC;
+    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+        return CAPTURE_DEVICE_ERR_OPEN;
+    }
+
+    FD_ZERO(&rfds);
+    FD_SET(mCameraDevice, &rfds);
+    tv.tv_sec = 0;
+    tv.tv_usec = MAX_DEQUEUE_WAIT_TIME*1000;
+    n = select(mCameraDevice+1, &rfds, NULL, NULL, &tv);
+    if(n < 0) {
+        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state error.");
+        ret = CAPTURE_DEVICE_ERR_SYS_CALL;
+    }
+    else if(n == 0) {
+        CAMERA_LOG_INFO("Warning!Time out wait for V4L2 capture reading operation!");
+        ret = CAPTURE_DEVICE_ERR_OPT_TIMEOUT;
+    }
+    else if(FD_ISSET(mCameraDevice, &rfds)) {
+        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
+        int rtval;
+        rtval = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
+        if (rtval < 0) {
+            CAMERA_LOG_ERR("Camera VIDIOC_DQBUF failure, ret=%d", rtval);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        *pBufQueIdx = cfilledbuffer.index;
+
+        //should do hardware accelerate.
+        if(mEnableCSC && mDoCsc) {
+            mDoCsc->width = mCurrentConfig->width;
+            mDoCsc->height = mCurrentConfig->height;
+            mDoCsc->srcStride = mDoCsc->width;
+            mDoCsc->dstStride = mDoCsc->width;
+            mDoCsc->srcVirt = mUvcBuffers[*pBufQueIdx].virt_start;
+            mDoCsc->dstVirt = mCaptureBuffers[*pBufQueIdx].virt_start;
+            mDoCsc->srcPhy = mUvcBuffers[*pBufQueIdx].phy_offset;
+            mDoCsc->dstPhy = mCaptureBuffers[*pBufQueIdx].phy_offset;
+            mDoCsc->cscConvert(mDoCsc);
+        }
+        else
+            memcpy(mCaptureBuffers[*pBufQueIdx].virt_start, mUvcBuffers[*pBufQueIdx].virt_start, mCaptureBuffers[*pBufQueIdx].length);
+
+        mQueuedBufNum --;
+
+        ret =  CAPTURE_DEVICE_ERR_NONE;
+    }
+    else {
+        CAMERA_LOG_ERR("Error!Query the V4L2 Handler state, no known error.");
+        ret = CAPTURE_DEVICE_ERR_UNKNOWN;
+    }
+
+    return ret;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2Queue(unsigned int BufQueIdx)
+{
+    int ret;
+    struct v4l2_buffer cfilledbuffer;
+    //CAMERA_LOG_FUNC;
+    if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+        return CAPTURE_DEVICE_ERR_OPEN;
+    }
+    memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
+    cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    cfilledbuffer.memory = V4L2_MEMORY_MMAP;
+    cfilledbuffer.index = BufQueIdx;
+    ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
+    if (ret < 0) {
+        CAMERA_LOG_ERR("Camera VIDIOC_QBUF failure, ret=%d", ret);
+        return CAPTURE_DEVICE_ERR_SYS_CALL;
+    }
+
+    mQueuedBufNum ++;
+
+    return CAPTURE_DEVICE_ERR_NONE;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2DeAlloc()
+{
+
+    CAMERA_LOG_FUNC;
+    if (mCameraDevice <= 0 ){
+        return CAPTURE_DEVICE_ERR_BAD_PARAM;
+    }
+
+    for (unsigned int i = 0; i < mBufQueNum; i++) {
+        if (mUvcBuffers[i].length && (mUvcBuffers[i].virt_start > 0)) {
+            munmap(mUvcBuffers[i].virt_start, mUvcBuffers[i].length);
+            mUvcBuffers[i].length = 0;
+            CAMERA_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mUvcBuffers[i].virt_start));
+        }
+    }
+    return CAPTURE_DEVICE_ERR_NONE;
+}
+
+void V4l2UVCDevice::selectCscFunction(unsigned int format)
+{
+    CAMERA_LOG_FUNC;
+    mDoCsc = NULL;
+    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
+        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
+                     mCscGroup[i].dstFormat == format) {
+            mDoCsc = &mCscGroup[i];
+            CAMERA_LOG_RUNTIME("find the match mCscGroup[%d] CSC function", i);
+        }
+    }
+}
+
+unsigned int V4l2UVCDevice::queryCscSourceFormat(unsigned int format)
+{
+    CAMERA_LOG_FUNC;
+    for(int i=0; i<MAX_CSC_SUPPORT_FMT; i++) {
+        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false &&
+                     mCscGroup[i].dstFormat == format) {
+            CAMERA_LOG_RUNTIME("find the CSC source format=0x%x convert to dest format=0x%x",
+                         mCscGroup[i].srcFormat, mCscGroup[i].dstFormat);
+            return mCscGroup[i].srcFormat;
+        }
+    }
+
+    CAMERA_LOG_ERR("invalidate format 0x%x in query", format);
+    return 0;
+}
+
+bool V4l2UVCDevice::needDoCsc(unsigned int format)
+{
+    CAMERA_LOG_FUNC;
+    unsigned int i;
+    for(i=0; i < mActualCscFmtCnt; i++) {
+        if(mActualCscFmt[i] == format)
+            return true;
+    }
+
+    return false;
+}
+
+unsigned int V4l2UVCDevice::countActualCscFmt()
+{
+    CAMERA_LOG_FUNC;
+    if(mSensorFmtCnt <= 0) {
+        return 0;
+    }
+
+    unsigned int i, k;
+    unsigned int n = 0;
+
+    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
+        for(k=0; k < mSensorFmtCnt; k++) {
+            if(mCscGroup[i].srcFormat == mSensorSupportFmt[k]) {
+                mCscGroup[i].isSensorSupport = true;
+                break;
+            }
+        }
+    }
+
+    for(i=0; i < MAX_CSC_SUPPORT_FMT; i++) {
+        for(k=0; k < mSensorFmtCnt; k++) {
+            if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].dstFormat == mSensorSupportFmt[k]) {
+                mCscGroup[i].isOverlapWithSensor = true;
+                break;
+            }
+        }
+        if(mCscGroup[i].isSensorSupport == true && mCscGroup[i].isOverlapWithSensor == false) {
+            mActualCscFmt[n++] = mCscGroup[i].dstFormat;
+        }
+    }
+
+    return n;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumFmt(void *retParam)
+{
+    CAMERA_LOG_FUNC;
+
+    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+    struct v4l2_fmtdesc vid_fmtdesc;
+    unsigned int *pParamVal = (unsigned int *)retParam;
+
+    vid_fmtdesc.index = mFmtParamIdx;
+    vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
+        if(mSensorFmtCnt > 0) {
+            mCscFmtCnt = countActualCscFmt();
+            mActualCscFmtCnt = mCscFmtCnt;
+            mSensorFmtCnt = 0;
+        }
+        if(mCscFmtCnt > 0) {
+            *pParamVal = mActualCscFmt[mCscFmtCnt-1];
+            mFmtParamIdx ++;
+            mCscFmtCnt --;
+            return CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        mFmtParamIdx = 0;
+        ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+    }else{
+        CAMERA_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
+        *pParamVal = vid_fmtdesc.pixelformat;
+        if(mFmtParamIdx < MAX_SUPPORTED_FMT) {
+            mSensorSupportFmt[mFmtParamIdx] = vid_fmtdesc.pixelformat;
+            mSensorFmtCnt ++;
+        }
+        mFmtParamIdx ++;
+        ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+    }
+    return ret;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2EnumSizeFps(void *retParam)
+{
+    CAMERA_LOG_FUNC;
+    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+    struct v4l2_frmsizeenum vid_frmsize;
+    struct v4l2_frmivalenum vid_frmval;
+
+    struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+    memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+    mCaptureConfigNum = mSizeFPSParamIdx;
+    vid_frmsize.index = mSizeFPSParamIdx;
+    CAMERA_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+
+    if(needDoCsc(pCapCfg->fmt)) {
+        vid_frmsize.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
+        if(vid_frmsize.pixel_format == 0) {
+            CAMERA_LOG_ERR("EnumSizeFps: queryCscSourceFormat return failed");
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+    }
+    else {
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+    }
+    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+        mSizeFPSParamIdx = 0;
+        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+    }else{
+        //uvc handle 1600x1200 may have some problem. so, skip it.
+        if(vid_frmsize.discrete.width == 1600 && vid_frmsize.discrete.height == 1200) {
+            CAMERA_LOG_ERR("EnumSizeFps: now skip %d x %d resolution", vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            mSizeFPSParamIdx = 0;
+            return CAPTURE_DEVICE_ERR_SET_PARAM;
+        }
+
+        memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
+        CAMERA_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+        vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
+        if(needDoCsc(pCapCfg->fmt)) {
+            vid_frmval.pixel_format = queryCscSourceFormat(pCapCfg->fmt);
+            if(vid_frmsize.pixel_format == 0) {
+                CAMERA_LOG_ERR("EnumSizeFps2: queryCscSourceFormat return failed");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }
+        else {
+            vid_frmval.pixel_format = pCapCfg->fmt;
+        }
+        vid_frmval.width = vid_frmsize.discrete.width;
+        vid_frmval.height= vid_frmsize.discrete.height;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
+            CAMERA_LOG_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            pCapCfg->width	= vid_frmsize.discrete.width;
+            pCapCfg->height = vid_frmsize.discrete.height;
+            pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
+            pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
+            mSizeFPSParamIdx ++;
+
+            //store all configuration here.
+            mCaptureConfig[mCaptureConfigNum].fmt = vid_frmsize.pixel_format;//pCapCfg->fmt;
+            mCaptureConfig[mCaptureConfigNum].width = pCapCfg->width;
+            mCaptureConfig[mCaptureConfigNum].height = pCapCfg->height;
+            mCaptureConfig[mCaptureConfigNum].picture_waite_number = 0;
+            mCaptureConfig[mCaptureConfigNum].tv.numerator = pCapCfg->tv.numerator;
+            mCaptureConfig[mCaptureConfigNum].tv.denominator = pCapCfg->tv.denominator;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+    }
+    return ret;
+}
+
+CAPTURE_DEVICE_RET V4l2UVCDevice::V4l2SetConfig(struct capture_config_t *pCapcfg)
+{
+    CAMERA_LOG_FUNC;
+    if (mCameraDevice <= 0 || pCapcfg == NULL){
+        return CAPTURE_DEVICE_ERR_BAD_PARAM;
+    }
+
+    CAPTURE_DEVICE_RET ret = CAPTURE_DEVICE_ERR_NONE;
+    struct v4l2_format fmt;
+    struct v4l2_control ctrl;
+    struct v4l2_streamparm parm;
+    struct capture_config_t *matchConfig = NULL;
+    struct capture_config_t *betterMatchConfig = NULL;
+    struct capture_config_t *bestMatchConfig = NULL;
+
+    //find the best match configuration.
+    for(unsigned int i=0; i < mCaptureConfigNum; i++) {
+        if(/*mCaptureConfig[i].fmt == pCapcfg->fmt &&*/
+                 mCaptureConfig[i].width == pCapcfg->width &&
+                 mCaptureConfig[i].height == pCapcfg->height) {
+            matchConfig = &mCaptureConfig[i];
+            if(mCaptureConfig[i].tv.numerator == pCapcfg->tv.numerator &&
+                    mCaptureConfig[i].tv.denominator == pCapcfg->tv.denominator) {
+                bestMatchConfig = &mCaptureConfig[i];
+            }
+            else if(mCaptureConfig[i].tv.denominator/mCaptureConfig[i].tv.numerator >
+                   pCapcfg->tv.denominator/pCapcfg->tv.numerator){
+                betterMatchConfig = &mCaptureConfig[i];
+            }//else
+        }
+    }//for
+
+    if(bestMatchConfig != NULL) {
+        matchConfig = bestMatchConfig;
+    }
+    else if(betterMatchConfig != NULL) {
+        matchConfig = betterMatchConfig;
+    }
+
+    if(matchConfig == NULL) {
+        CAMERA_LOG_ERR("Error: not support format=0x%x, Width=%d, Height=%d",
+                       pCapcfg->fmt, pCapcfg->width, pCapcfg->height);
+        return CAPTURE_DEVICE_ERR_BAD_PARAM;
+    }
+
+    mCurrentConfig = matchConfig;
+
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    if(needDoCsc(pCapcfg->fmt)) {
+        mEnableCSC = true;
+        //set mDoCsc 
+        selectCscFunction(pCapcfg->fmt);
+        fmt.fmt.pix.pixelformat = queryCscSourceFormat(pCapcfg->fmt);
+        if(fmt.fmt.pix.pixelformat == 0) {
+            CAMERA_LOG_ERR("SetConfig: queryCscSourceFormat return failed");
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+    }
+    else {
+        mEnableCSC = false;
+        fmt.fmt.pix.pixelformat = matchConfig->fmt;
+    }
+
+    fmt.fmt.pix.width = matchConfig->width;
+    fmt.fmt.pix.height = matchConfig->height;
+    if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
+        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+    else
+        fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+    fmt.fmt.pix.priv = 0;
+    fmt.fmt.pix.sizeimage = 0;
+
+    int err = 0;
+    if ((err = ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt)) < 0) {
+        CAMERA_LOG_ERR("set format failed err=%d\n", err);
+        CAMERA_LOG_ERR("matchConfig->width is %d, matchConfig->height is %d", matchConfig->width, matchConfig->height);
+        CAMERA_LOG_ERR(" Set the Format %x :%c%c%c%c\n", matchConfig->fmt,
+                matchConfig->fmt & 0xFF, (matchConfig->fmt >> 8) & 0xFF,
+                (matchConfig->fmt >> 16) & 0xFF, (matchConfig->fmt >> 24) & 0xFF);
+        return CAPTURE_DEVICE_ERR_SYS_CALL;
+    }
+
+    parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    parm.parm.capture.timeperframe.numerator = matchConfig->tv.numerator;
+    parm.parm.capture.timeperframe.denominator = matchConfig->tv.denominator;
+    CAMERA_LOG_RUNTIME("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
+                parm.parm.capture.timeperframe.denominator);
+    if ( (err = ioctl(mCameraDevice, VIDIOC_S_PARM, &parm)) < 0) {
+        CAMERA_LOG_ERR("%s:%d  VIDIOC_S_PARM failed err=%d\n", __FUNCTION__,__LINE__, err);
+        CAMERA_LOG_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
+                parm.parm.capture.timeperframe.denominator);
+        return CAPTURE_DEVICE_ERR_SYS_CALL;
+    }
+
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+        CAMERA_LOG_ERR("VIDIOC_S_PARM failed\n");
+        return CAPTURE_DEVICE_ERR_SYS_CALL;
+    }else{
+
+        CAMERA_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+        CAMERA_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+        CAMERA_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+        CAMERA_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+    }
+    matchConfig->framesize = fmt.fmt.pix.sizeimage;
+    pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+    //For uvc, the first frame is ok.
+    matchConfig->picture_waite_number = pCapcfg->picture_waite_number = 1;
+
+    return CAPTURE_DEVICE_ERR_NONE;
+}
+
+void V4l2UVCDevice::convertYUYUToNV12(struct CscConversion* param)
+{
+    unsigned char *pSrcBufs = param->srcVirt;
+    unsigned char *pDstBufs = param->dstVirt;
+    unsigned int bufWidth = param->width;
+    unsigned int bufHeight = param->height;
+
+    unsigned char *pSrcY1Offset = pSrcBufs;
+    unsigned char *pSrcY2Offset = pSrcBufs + (bufWidth << 1);
+    unsigned char *pSrcY3Offset = pSrcBufs + (bufWidth << 1) * 2;
+    unsigned char *pSrcY4Offset = pSrcBufs + (bufWidth << 1) * 3;
+    unsigned char *pSrcU1Offset = pSrcY1Offset + 1;
+    unsigned char *pSrcU2Offset = pSrcY2Offset + 1;
+    unsigned char *pSrcU3Offset = pSrcY3Offset + 1;
+    unsigned char *pSrcU4Offset = pSrcY4Offset + 1;
+    unsigned char *pSrcV1Offset = pSrcY1Offset + 3;
+    unsigned char *pSrcV2Offset = pSrcY2Offset + 3;
+    unsigned char *pSrcV3Offset = pSrcY3Offset + 3;
+    unsigned char *pSrcV4Offset = pSrcY4Offset + 3;
+    unsigned int srcYStride = (bufWidth << 1) * 3;
+    unsigned int srcUVStride = srcYStride;
+
+    unsigned char *pDstY1Offset = pDstBufs;
+    unsigned char *pDstY2Offset = pDstBufs + bufWidth;
+    unsigned char *pDstY3Offset = pDstBufs + bufWidth * 2;
+    unsigned char *pDstY4Offset = pDstBufs + bufWidth * 3;
+    unsigned char *pDstU1Offset = pDstBufs + bufWidth * bufHeight;
+    unsigned char *pDstU2Offset = pDstBufs + bufWidth * (bufHeight + 1);
+    unsigned char *pDstV1Offset = pDstU1Offset + 1;
+    unsigned char *pDstV2Offset = pDstU2Offset + 1;
+    unsigned int dstYStride = bufWidth * 3;
+    unsigned int dstUVStride = bufWidth;
+
+    unsigned int nw, nh;
+    for(nh = 0; nh < (bufHeight >> 2); nh++) {
+        for(nw=0; nw < (bufWidth >> 1); nw++) {
+            *pDstY1Offset++ = *pSrcY1Offset;
+            *pDstY2Offset++ = *pSrcY2Offset;
+            *pDstY3Offset++ = *pSrcY3Offset;
+            *pDstY4Offset++ = *pSrcY4Offset;
+
+            pSrcY1Offset += 2;
+            pSrcY2Offset += 2;
+            pSrcY3Offset += 2;
+            pSrcY4Offset += 2;
+
+            *pDstY1Offset++ = *pSrcY1Offset;
+            *pDstY2Offset++ = *pSrcY2Offset;
+            *pDstY3Offset++ = *pSrcY3Offset;
+            *pDstY4Offset++ = *pSrcY4Offset;
+
+            pSrcY1Offset += 2;
+            pSrcY2Offset += 2;
+            pSrcY3Offset += 2;
+            pSrcY4Offset += 2;
+
+            *pDstU1Offset = *pSrcU1Offset;
+            *pDstU2Offset = *pSrcU3Offset;
+            pDstU1Offset += 2;
+            pDstU2Offset += 2;
+            pSrcU1Offset += 4;
+            pSrcU3Offset += 4;
+
+            *pDstV1Offset = *pSrcV1Offset;
+            *pDstV2Offset = *pSrcV3Offset;
+            pDstV1Offset += 2;
+            pDstV2Offset += 2;
+            pSrcV1Offset += 4;
+            pSrcV3Offset += 4;
+        }
+
+        pSrcY1Offset += srcYStride;
+        pSrcY2Offset += srcYStride;
+        pSrcY3Offset += srcYStride;
+        pSrcY4Offset += srcYStride;
+
+        pSrcU1Offset += srcUVStride;
+        pSrcU3Offset += srcUVStride;
+        pSrcV1Offset += srcUVStride;
+        pSrcV3Offset += srcUVStride;
+
+        pDstY1Offset += dstYStride;
+        pDstY2Offset += dstYStride;
+        pDstY3Offset += dstYStride;
+        pDstY4Offset += dstYStride;
+
+        pDstU1Offset += dstUVStride;
+        pDstU2Offset += dstUVStride;
+        pDstV1Offset += dstUVStride;
+        pDstV2Offset += dstUVStride;
+    }
+}
+
+};
+
diff --git a/mx5x/libcamera/V4l2UVCDevice.h b/mx5x/libcamera/V4l2UVCDevice.h
index 47e0c20..9aea82a 100755
--- a/mx5x/libcamera/V4l2UVCDevice.h
+++ b/mx5x/libcamera/V4l2UVCDevice.h
@@ -15,26 +15,84 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 #ifndef V4L2_UVC_DEVICE_H
 #define V4L2_UVC_DEVICE_H
 
 #include <linux/videodev2.h>
-
-
 #include "V4l2CapDeviceBase.h"
 
 #define MAX_DEV_NAME_LENGTH 10
+#define MAX_CAPTURE_CONFIG  20
+#define MAX_SUPPORTED_FMT  10
+#define MAX_CSC_SUPPORT_FMT 1
 
 namespace android{
 
-    class V4l2UVCDevice : public V4l2CapDeviceBase{
-    public:
-        V4l2UVCDevice(){mCameraType = CAMERA_TYPE_UVC;}
-        ~V4l2UVCDevice(){}
+struct CscConversion {
+    //if the srcFormat is support by sensor.
+    bool isSensorSupport;
+    //if the dstFormat is support by sensor.
+    bool isOverlapWithSensor;
+    int width;
+    int height;
+    int srcStride;
+    int dstStride;
+    unsigned int srcFormat;
+    unsigned int dstFormat;
+    unsigned char* srcVirt;
+    unsigned char* dstVirt;
+    int srcPhy;
+    int dstPhy;
+
+    void(*cscConvert)(struct CscConversion* param);
+};
+
+class V4l2UVCDevice : public V4l2CapDeviceBase{
+public:
+    V4l2UVCDevice();//{mCameraType = CAMERA_TYPE_UVC;}
+    ~V4l2UVCDevice(){}
 
-    };
+protected:
+    CAPTURE_DEVICE_RET V4l2Open(int cameraId);
+    CAPTURE_DEVICE_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+    CAPTURE_DEVICE_RET V4l2Prepare();
+    CAPTURE_DEVICE_RET V4l2Dequeue(unsigned int *pBufQueIdx);
+    CAPTURE_DEVICE_RET V4l2Queue(unsigned int BufQueIdx);
+    CAPTURE_DEVICE_RET V4l2DeAlloc();
+    CAPTURE_DEVICE_RET V4l2EnumFmt(void *retParam);
+    CAPTURE_DEVICE_RET V4l2EnumSizeFps(void *retParam);
+    CAPTURE_DEVICE_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+
+private:
+    static void convertYUYUToNV12(struct CscConversion* param);
+    unsigned int countActualCscFmt();
+    bool needDoCsc(unsigned int);
+    void selectCscFunction(unsigned int format);
+    unsigned int queryCscSourceFormat(unsigned int format);
+    //DMA_BUFFER mCameraBuffer[MAX_CAPTURE_BUF_QUE_NUM];
+    //mCaptureBuffers defined in parent class store buffers allocated from user space.
+    //mUvcBuffers store the buffers allocated from uvc driver.
+    DMA_BUFFER mUvcBuffers[MAX_CAPTURE_BUF_QUE_NUM];
+
+    //store sensor configuration here.
+    unsigned int mCaptureConfigNum;
+    struct capture_config_t mCaptureConfig[MAX_CAPTURE_CONFIG];
+    struct capture_config_t* mCurrentConfig;
+
+    //for jpeg encoder support yuyv. this case, should not covert.
+    bool mEnableCSC;
+    //stores nedd csc format. 
+    struct CscConversion mCscGroup[MAX_CSC_SUPPORT_FMT];
+    struct CscConversion* mDoCsc;
+    unsigned int mActualCscFmt[MAX_CSC_SUPPORT_FMT];
+    unsigned int mActualCscFmtCnt;
+    //stores sensor support format.
+    unsigned int mSensorSupportFmt[MAX_SUPPORTED_FMT];
+    unsigned int mSensorFmtCnt;
+    unsigned int mCscFmtCnt;
+};
 
 };
 #endif
diff --git a/mx5x/libcamera/messageQueue.cpp b/mx5x/libcamera/messageQueue.cpp
index 547816a..29a2087 100644
--- a/mx5x/libcamera/messageQueue.cpp
+++ b/mx5x/libcamera/messageQueue.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 
@@ -63,7 +63,7 @@ CMessageQueue::~CMessageQueue()
 
 void CMessageQueue::clearMessage()
 {
-    CAMERA_HAL_ERR("-------CMessageQueue::clearMessage--------");
+    CAMERA_LOG_ERR("-------CMessageQueue::clearMessage--------");
     Mutex::Autolock _l(mLock);
     mMessages.clear();
     mStop = false;
diff --git a/mx5x/libcamera/messageQueue.h b/mx5x/libcamera/messageQueue.h
index 8054cfe..243d497 100644
--- a/mx5x/libcamera/messageQueue.h
+++ b/mx5x/libcamera/messageQueue.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  */
 
 
-- 
1.8.0

