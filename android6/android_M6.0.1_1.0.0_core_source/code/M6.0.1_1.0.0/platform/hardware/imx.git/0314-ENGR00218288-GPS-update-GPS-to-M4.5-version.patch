From 49d8f63ce22653dc8d03f0867ed61b0c6c43e01b Mon Sep 17 00:00:00 2001
From: Jianzheng Zhou <B38613@freescale.com>
Date: Wed, 25 Jul 2012 15:28:34 +0800
Subject: [PATCH 314/635] ENGR00218288 GPS:update GPS to M4.5 version

update GPS HAL to new version, which tested to be much better than
before version in signal and navigating speed.

Signed-off-by: Jianzheng Zhou <B38613@freescale.com>
---
 libgps/athr_gps.c | 1095 +++++++++++++++++++++++++----------------------------
 libgps/gps.c      |   33 +-
 2 files changed, 544 insertions(+), 584 deletions(-)

diff --git a/libgps/athr_gps.c b/libgps/athr_gps.c
index b46a006..943ad75 100755
--- a/libgps/athr_gps.c
+++ b/libgps/athr_gps.c
@@ -1,21 +1,20 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
- * Copyright (C) 2008 - 2011 Atheros Corporation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
+* Copyright (C) 2011 The Android Open Source Project
+* Copyright (C) 2011 Atheros Communications, Inc.
+* Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 #include <errno.h>
 #include <pthread.h>
 #include <termios.h>
@@ -27,6 +26,9 @@
 #include <signal.h>
 #include <unistd.h>
 #include <stdio.h>
+#include <time.h>
+#include <sys/inotify.h>
+#include <poll.h>
 
 #define  LOG_TAG  "athr_gps"
 
@@ -35,7 +37,7 @@
 #include <cutils/properties.h>
 #include <hardware/gps.h>
 
-/* for Atheros GPS devices, jeanson */
+/* for Atheros GPS devices*/
 #define ATHR_GPS
 #define ATHR_GPSXtra
 #define ATHR_GPSNi
@@ -43,14 +45,14 @@
 //#define  GPS_DEBUG
 #undef	 GPS_DEBUG_TOKEN	/* print out NMEA tokens */
 
+#define  DFR(...)   LOGD(__VA_ARGS__)
+
 #ifdef GPS_DEBUG
 #  define  D(...)   LOGD(__VA_ARGS__)
 #else
 #  define  D(...)   ((void)0)
 #endif
 
-#define  DFR(...)   D(__VA_ARGS__)
-
 #define GPS_STATUS_CB(_cb, _s)    \
   if ((_cb).status_cb) {          \
     GpsStatus gps_status;         \
@@ -90,31 +92,12 @@ typedef struct {
     AthTimemap_t timemap;
 } NmeaReader;
 
-/* Since NMEA parser requires locks */
-/*
-TODO: 1. Change to function call
-      2. Add processing of EINVAL, ENOSYS, EDEADLK, EINTR (debug output at least)
-*/
-#define GPS_STATE_LOCK_FIX(_s)         \
-{                                      \
-  int ret;                             \
-  do {                                 \
-    ret = sem_wait(&(_s)->fix_sem);    \
-  } while (ret < 0 && errno == EINTR);   \
-}
-
-/*
-TODO: 1. Change to function call
-      2. Add processing of EINVAL, ENOSYS (debug output at least)
-*/
-#define GPS_STATE_UNLOCK_FIX(_s)       \
-  sem_post(&(_s)->fix_sem)
-
 typedef struct {
     int                     init;
     int                     fd;
     GpsCallbacks            callbacks;
     pthread_t               thread;
+    pthread_t		    nmea_thread;
     pthread_t               tmr_thread;
     int                     control[2];
     int                     fix_freq;
@@ -132,26 +115,51 @@ typedef struct {
 #endif
 } GpsState;
 
+
+GpsCallbacks* g_gpscallback = 0;
+
+void gps_state_lock_fix(GpsState *state) {
+    int ret;
+    do {
+        ret=sem_wait(&state->fix_sem);
+    } while (ret < 0 && errno == EINTR);
+    if (ret < 0) {
+        D("Error in GPS state lock:%s\n", strerror(errno));
+    }
+}
+
+void gps_state_unlock_fix(GpsState *state) {
+    if (sem_post(&state->fix_sem) == -1)
+	{
+		if(errno == EAGAIN)
+			if(sem_post(&state->fix_sem)== -1)
+				D("Error in GPS state unlock:%s\n", strerror(errno));
+	}
+}
+
+int 	gps_opentty(GpsState *state);
+void 	gps_closetty(GpsState *state);
+void 	gps_wakeup(GpsState *state);
+void 	gps_sleep(GpsState *state);
+int 	gps_checkstate(GpsState *state);
+
 static GpsState  _gps_state[1];
 static GpsState *gps_state = _gps_state;
+static int sleep_lock = 0;
+static int lastcmd = 0;
+static int bGetFormalNMEA = 1;
+static int started    = 0;
+static int continue_thread = 1;
+static int bOrionShutdown = 0;
 
 #define GPS_DEV_SLOW_UPDATE_RATE (10)
 #define GPS_DEV_HIGH_UPDATE_RATE (1)
 
-#ifdef ATHR_GPS
 #define GPS_DEV_LOW_BAUD  (B9600)
 #define GPS_DEV_HIGH_BAUD (B115200)
-#else
-#define GPS_DEV_LOW_BAUD  (B9600)
-#define GPS_DEV_HIGH_BAUD (B19200)
-#endif
 
-static void gps_dev_init(int fd);
-static void gps_dev_deinit(int fd);
-static void gps_dev_start(int fd);
-static void gps_dev_stop(int fd);
+static void gps_nmea_thread( void*  arg );
 static void gps_timer_thread( void*  arg );
-static int athr_gps_start();
 
 /*****************************************************************/
 /*****************************************************************/
@@ -164,7 +172,7 @@ static int athr_gps_start();
 #ifdef ATHR_GPSNi
 static void ath_send_ni_notification(NmeaReader* r)
 {
-    D("ath_send_ni_notification is called");
+    //D("ath_send_ni_notification is called");
     if (gps_state->ni_init && gps_state->ni_callbacks.notify_cb)
     {
         memset(&gps_state->ni_notification, 0, sizeof(sizeof(gps_state->ni_notification)));
@@ -180,18 +188,13 @@ static void ath_send_ni_notification(NmeaReader* r)
         gps_state->ni_notification.text_encoding            = GPS_ENC_NONE;
         if (r->timemap.valid && r->timemap.timestamp == r->fix.timestamp)
         {
-            sprintf(gps_state->ni_notification.extras, "systime=%10.10lf", r->timemap.systime);
-            D("ath_send_ni_notification systime is set: %s (%lf)", gps_state->ni_notification.extras, r->timemap.systime);
+            sprintf(gps_state->ni_notification.extras, "pps=%10.10lf", r->timemap.systime);
             r->timemap.valid = 0;
         }
         else
         {
             gps_state->ni_notification.extras[0] = 0;
-            D("ath_send_ni_notification systime is NOT set");
         }
-        D("ath_send_ni_notification systime valid = %d", r->timemap.valid);
-        D("ath_send_ni_notification systime 1: %lf", (double)r->timemap.timestamp);
-        D("ath_send_ni_notification systime 2: %lf", (double)r->fix.timestamp);
 
         gps_state->ni_callbacks.notify_cb(&gps_state->ni_notification);
     }
@@ -359,8 +362,6 @@ static void nmea_reader_update_utc_diff( NmeaReader*  r )
                365*tm_utc.tm_year)));
 
 	r->utc_diff = time_utc - time_local;
-
-    // D("r->utc_diff:%d", r->utc_diff);
 }
 
 
@@ -388,7 +389,6 @@ static int nmea_reader_get_timestamp(NmeaReader*  r, Token  tok, time_t *timesta
         return -1;
 
     if (r->utc_year < 0) {
-        D("no date yet, quit... ");
         return -1;
     }
 
@@ -398,22 +398,19 @@ static int nmea_reader_get_timestamp(NmeaReader*  r, Token  tok, time_t *timesta
 
     tm.tm_hour = hour;
     tm.tm_min  = minute;
-    tm.tm_sec  = (int) seconds;
+    tm.tm_sec   = (int) seconds;
     tm.tm_year = r->utc_year - 1900;
     tm.tm_mon  = r->utc_mon - 1;
     tm.tm_mday = r->utc_day;
     tm.tm_isdst = -1;
 
-    // D("h: %d, m: %d, s: %f", tm.tm_hour, tm.tm_min, tm.tm_sec);
+    // D("h: %d, m: %d, s: %d", tm.tm_hour, tm.tm_min, tm.tm_sec);
     // D("Y: %d, M: %d, D: %d", tm.tm_year, tm.tm_mon, tm.tm_mday);
 
-    // FIXME: RGE: call to next function should be moved to proper location to be called
-	//             in the beginning and if timezone value changes
 	nmea_reader_update_utc_diff(r);
 
 	ttime = mktime( &tm );
 	*timestamp = ttime - r->utc_diff;
-	D("nmea_reader_get_timestamp: %d, %d", (int)ttime, (int)*timestamp);
 
     return 0;
 }
@@ -425,7 +422,6 @@ nmea_reader_update_time( NmeaReader*  r, Token  tok )
     int ret = nmea_reader_get_timestamp( r, tok, &timestamp);
     if (0 == ret)
         r->fix.timestamp = (long long)timestamp * 1000;
-    D("nmea_reader_update_time: %lf %lf", (double) timestamp, (double) r->fix.timestamp);
     return ret;
 }
 
@@ -452,11 +448,9 @@ nmea_reader_update_date( NmeaReader*  r, Token  date, Token  mtime )
     int    day, mon, year;
 
     if (tok.p + 6 != tok.end) {
-        D("no date info, use host time as default: '%.*s'", tok.end-tok.p, tok.p);
+
         /* no date info, will use host time in _update_time function
-           jhung 2010/05/12
          */
-        // return -1;
     }
     /* normal case */
     day  = str2int(tok.p, tok.p+2);
@@ -464,7 +458,6 @@ nmea_reader_update_date( NmeaReader*  r, Token  date, Token  mtime )
     year = str2int(tok.p+4, tok.p+6) + 2000;
 
     if ((day|mon|year) < 0) {
-        D("date not properly formatted: '%.*s'", tok.end-tok.p, tok.p);
         return -1;
     }
 
@@ -499,7 +492,6 @@ nmea_reader_update_latlong( NmeaReader*  r,
 
     tok = latitude;
     if (tok.p + 6 > tok.end) {
-        D("latitude is too short: '%.*s'", tok.end-tok.p, tok.p);
         return -1;
     }
     lat = convert_from_hhmm(tok);
@@ -508,7 +500,6 @@ nmea_reader_update_latlong( NmeaReader*  r,
 
     tok = longitude;
     if (tok.p + 6 > tok.end) {
-        D("longitude is too short: '%.*s'", tok.end-tok.p, tok.p);
         return -1;
     }
     lon = convert_from_hhmm(tok);
@@ -587,6 +578,7 @@ nmea_reader_update_speed( NmeaReader*  r,
 
     r->fix.flags   |= GPS_LOCATION_HAS_SPEED;
     r->fix.speed    = str2float(tok.p, tok.end);
+    r->fix.speed   *= 0.514444;    // fix for Speed Unit form Knots to Meters per Second
     return 0;
 }
 
@@ -628,29 +620,17 @@ nmea_reader_parse( NmeaReader*  r )
     NmeaTokenizer  tzer[1];
     Token          tok;
 
-    // D("Received: '%.*s'", r->pos, r->in);
-
-    if (r->pos < 9)
-	{
-        D("Too short. discarded.");
-        return;
+    if (r->pos < 9) {
+         return;
     }
 
-#if 1 /* for NMEAListener callback */
-    if (gps_state->callbacks.nmea_cb)
-	{
-        D("NMEAListener callback... ");
+    if (gps_state->callbacks.nmea_cb) {
         struct timeval tv;
         unsigned long long mytimems;
-
         gettimeofday(&tv,NULL);
-        mytimems = tv.tv_sec * 1000LL + tv.tv_usec / 1000;
-
+        mytimems = tv.tv_sec * 1000 + tv.tv_usec / 1000;
         gps_state->callbacks.nmea_cb(mytimems, r->in, r->pos);
-
-        D("NMEAListener callback ended... ");
     }
-#endif
 
     nmea_tokenizer_init(tzer, r->in, r->in + r->pos);
 #ifdef GPS_DEBUG_TOKEN
@@ -667,14 +647,11 @@ nmea_reader_parse( NmeaReader*  r )
     tok = nmea_tokenizer_get(tzer, 0);
 
     if (tok.p + 5 > tok.end) {
-        /* for $PUNV sentences, jhung */
-        if ( !memcmp(tok.p, "PUNV", 4) )
-		{
-            // D("$PUNV sentences found!");
+        /* for $PUNV sentences */
+        if ( !memcmp(tok.p, "PUNV", 4) ) {
             Token tok_cfg = nmea_tokenizer_get(tzer,1);
 
             if (!memcmp(tok_cfg.p, "CFG_R", 5)) {
-                D("$PUNV,CFG_R found! ");
             } else if ( !memcmp(tok_cfg.p, "QUAL", 4) ) {
                 Token  tok_sigma_x   = nmea_tokenizer_get(tzer, 3);
 
@@ -686,16 +663,15 @@ nmea_reader_parse( NmeaReader*  r )
             {
                 Token systime = nmea_tokenizer_get(tzer, 8); // system time token
                 Token timestamp = nmea_tokenizer_get(tzer, 2); // UTC time token
-                D("TIMEMAP systime='%.*s'", systime.end - systime.p, systime.p);
-                D("TIMEMAP timestamp='%.*s'", timestamp.end - timestamp.p, timestamp.p);
                 nmea_reader_update_timemap(r, systime, timestamp);
             }
         }else{
-            D("sentence id '%.*s' too short, ignored.", tok.end-tok.p, tok.p);
         }
         return;
     }
 
+	if ( !memcmp(tok.p, "GPG", 3) ) //GPGSA,GPGGA,GPGSV
+		bGetFormalNMEA = 1;
     // ignore first two characters.
     tok.p += 2;
 
@@ -746,10 +722,6 @@ nmea_reader_parse( NmeaReader*  r )
 
         if (tok_fixStatus.p[0] != '\0' && tok_fixStatus.p[0] != '1') {
 
-//          Token  tok_accuracy      = nmea_tokenizer_get(tzer, 15);
-
-//          nmea_reader_update_accuracy(r, tok_accuracy);
-
           r->sv_status.used_in_fix_mask = 0ul;
 
           for (i = 3; i <= 14; ++i){
@@ -759,20 +731,15 @@ nmea_reader_parse( NmeaReader*  r )
 
             /* only available for PRN 1-32 */
             if ((prn > 0) && (prn < 33)){
-              // bug, prn 1 should be put on bit 0
-              // r->sv_status.used_in_fix_mask |= (1ul << (32 - prn));
               r->sv_status.used_in_fix_mask |= (1ul << (prn-1));
               r->sv_status_changed = 1;
               /* mark this parameter to identify the GSA is in fixed state */
               r->gsa_fixed = 1;
-              // D("%s: fix mask is %ld (PRN: %d)", __FUNCTION__, r->sv_status.used_in_fix_mask, prn);
             }
-
           }
 
         }else {
           if (r->gsa_fixed == 1) {
-            D("%s: GPGSA fixed -> unfixed", __FUNCTION__);
             r->sv_status.used_in_fix_mask = 0ul;
             r->sv_status_changed = 1;
             r->gsa_fixed = 0;
@@ -792,6 +759,7 @@ nmea_reader_parse( NmeaReader*  r )
           int totalSentences = str2int(tok_noSentences.p, tok_noSentences.end);
           int curr;
           int i;
+
           if (sentence == 1) {
               r->sv_status_changed = 0;
               r->sv_status.num_svs = 0;
@@ -823,18 +791,12 @@ nmea_reader_parse( NmeaReader*  r )
           if (sentence == totalSentences) {
               r->sv_status_changed = 1;
           }
-
-          // D("%s: GSV message with total satellites %d", __FUNCTION__, noSatellites);
-
         }
 
     } else if ( !memcmp(tok.p, "RMC", 3) ) {
 
         Token  tok_fixStatus     = nmea_tokenizer_get(tzer,2);
 
-        /* always write back location and time information
-           jhung, 20100512
-        */
         if (tok_fixStatus.p[0] == 'A')
         {
           Token  tok_time          = nmea_tokenizer_get(tzer,1);
@@ -895,7 +857,6 @@ nmea_reader_parse( NmeaReader*  r )
 
     } else {
         tok.p -= 2;
-        DFR("unknown sentence '%.*s", tok.end-tok.p, tok.p);
     }
 
     if (!gps_state->first_fix &&
@@ -911,47 +872,8 @@ nmea_reader_parse( NmeaReader*  r )
 
         gps_state->first_fix = 1;
     }
-
-#if 0
-    if (r->fix.flags != 0) {
-#ifdef GPS_DEBUG
-        char   temp[256];
-        char*  p   = temp;
-        char*  end = p + sizeof(temp);
-        struct tm   utc;
-
-        p += snprintf( p, end-p, "sending fix" );
-        if (r->fix.flags & GPS_LOCATION_HAS_LAT_LONG) {
-            p += snprintf(p, end-p, " lat=%g lon=%g", r->fix.latitude, r->fix.longitude);
-        }
-        if (r->fix.flags & GPS_LOCATION_HAS_ALTITUDE) {
-            p += snprintf(p, end-p, " altitude=%g", r->fix.altitude);
-        }
-        if (r->fix.flags & GPS_LOCATION_HAS_SPEED) {
-            p += snprintf(p, end-p, " speed=%g", r->fix.speed);
-        }
-        if (r->fix.flags & GPS_LOCATION_HAS_BEARING) {
-            p += snprintf(p, end-p, " bearing=%g", r->fix.bearing);
-        }
-        if (r->fix.flags & GPS_LOCATION_HAS_ACCURACY) {
-            p += snprintf(p,end-p, " accuracy=%g", r->fix.accuracy);
-        }
-        gmtime_r( (time_t*) &r->fix.timestamp, &utc );
-        p += snprintf(p, end-p, " time=%s", asctime( &utc ) );
-        D(temp);
-#endif
-        if (r->callback) {
-            r->callback( &r->fix );
-            r->fix.flags = 0;
-        }
-        else {
-            D("no callback, keeping data until needed !");
-        }
-    }
-#endif
 }
 
-
 /* parse the OAP200 commands for ATHR chipsets */
 static void
 athr_reader_parse( char* buf, int length)
@@ -965,8 +887,7 @@ athr_reader_parse( char* buf, int length)
     }
 
     /* for NMEAListener callback */
-    if (gps_state->callbacks.nmea_cb)
-	{
+    if (gps_state->callbacks.nmea_cb) {
         D("NMEAListener callback for ATHR... ");
         struct timeval tv;
         unsigned long long mytimems;
@@ -999,12 +920,10 @@ nmea_reader_addc( NmeaReader*  r, int  c )
     r->in[r->pos] = (char)c;
     r->pos       += 1;
 
-    if (c == '\n')
-	{
-        GPS_STATE_LOCK_FIX(gps_state);
-        // D("Parsing NMEA commands");
+    if (c == '\n') {
+        gps_state_lock_fix(gps_state);
         nmea_reader_parse( r );
-        GPS_STATE_UNLOCK_FIX(gps_state);
+        gps_state_unlock_fix(gps_state);
         r->pos = 0;
     }
 }
@@ -1042,12 +961,11 @@ gps_state_done( GpsState*  s )
     void*  dummy;
     int ret;
 
-    DFR("gps send quit command");
-
     do { ret=write( s->control[0], &cmd, 1 ); }
     while (ret < 0 && errno == EINTR);
 
     DFR("gps waiting for command thread to stop");
+	gps_sleep(s);
 
     pthread_join(s->thread, &dummy);
 
@@ -1059,34 +977,119 @@ gps_state_done( GpsState*  s )
     close( s->control[0] ); s->control[0] = -1;
     close( s->control[1] ); s->control[1] = -1;
 
-    // close connection to the QEMU GPS daemon
-    close( s->fd ); s->fd = -1;
-
     sem_destroy(&s->fix_sem);
+	g_gpscallback = 0;
 
     memset(s, 0, sizeof(*s));
 
-    DFR("gps deinit complete");
+}
 
+static int athr_run_hook(char* name)
+{
+    char   prop[PROPERTY_VALUE_MAX];
+    char   buf[PROPERTY_VALUE_MAX + 20];
+    if (property_get("athr.gps.hookspath",prop,"") == 0)
+	{
+        LOGE("%s: athr.gps.hookspath property is not set", __FUNCTION__);
+		return 0;
+    }
+    sprintf(buf,"%s/%s" , prop, name);
+    LOGI("%s: going to execute hook  \"%s\"", __FUNCTION__, buf);
+    return !system(buf);
 }
 
+static int athr_run_hook_start()
+{
+    return athr_run_hook("start");
+}
+
+static int athr_run_hook_stop()
+{
+    return athr_run_hook("stop");
+}
+
+
+void gps_wakeup(GpsState *state)
+{
+	if( sleep_lock == 0) // it reset by athr_gps_start
+	{
+		gps_state_lock_fix(state);
+
+		gps_opentty(state);
+
+		if (athr_run_hook_start())
+		{
+			D("%s: Hook says: quit now", __FUNCTION__);
+		}
+		else
+		{
+			D("Send WAKEUP command to GPS");
+			sleep_lock = time((time_t*)NULL);
+			/* send $PUNV,WAKEUP command*/
+			if (write(state->fd, "$PUNV,WAKEUP*2C\r\n", 17) < 0)
+			{
+				D("Send WAKEUP command ERROR!");
+				bOrionShutdown = 1;
+			}
+			else
+				bOrionShutdown = 0;
+		}
+		bGetFormalNMEA = 0;
+		gps_state_unlock_fix(state);
+	}
+}
+
+void gps_sleep(GpsState *state)
+{
+	if (athr_run_hook_stop()) {
+		D("%s: Hook says: quit now", __FUNCTION__);
+		gps_state_lock_fix(state);
+		started = 0;
+		sleep_lock = 0; // allow next wakeup command
+		gps_state_unlock_fix(state);
+	}
+	else
+	{
+		gps_state_lock_fix(state);
+
+		if(state->fd == -1)
+			gps_opentty(state);
+
+		if (write(state->fd, "$PUNV,SLEEP*7E\r\n", 16) < 0)
+		{
+			D("Send SLEEP command ERROR!");
+			bOrionShutdown = 1;
+		}
+		else
+			bOrionShutdown = 0;
+
+		started = 0;
+		sleep_lock = 0; // allow next wakeup command
+
+		gps_state_unlock_fix(state);
+	}
+	gps_state_lock_fix(state);
+	gps_closetty(state);
+	gps_state_unlock_fix(state);
+}
 
 static void
 gps_state_start( GpsState*  s )
 {
     char  cmd = CMD_START;
     int   ret;
+	DFR("%s", __FUNCTION__);
 
-    do
-	{
-		ret=write( s->control[0], &cmd, 1 );
-	}while (ret < 0 && errno == EINTR);
+	gps_state_lock_fix(s);
+	lastcmd = CMD_START;
+	gps_state_unlock_fix(s);
 
 
+    do { ret=write( s->control[0], &cmd, 1 ); }
+    while (ret < 0 && errno == EINTR);
 
     if (ret != 1)
-        D("%s: could not send CMD_START command: ret=%d: %s",
-          __FUNCTION__, ret, strerror(errno));
+        D("%s: could not send CMD_START command: ret=%d: %s", __FUNCTION__, ret, strerror(errno));
 }
 
 
@@ -1096,7 +1099,22 @@ gps_state_stop( GpsState*  s )
     char  cmd = CMD_STOP;
     int   ret;
 
-    do { ret=write( s->control[0], &cmd, 1 ); }
+	DFR("%s", __FUNCTION__);
+
+	gps_state_lock_fix(s);
+	lastcmd = CMD_STOP;
+	gps_state_unlock_fix(s);
+
+    do
+	{
+		DFR("try %s", __FUNCTION__);
+		ret=write( s->control[0], &cmd, 1 );
+		if(ret < 0)
+		{
+			LOGE("write control socket error %s", strerror(errno));
+			sleep(1);
+		}
+	}
     while (ret < 0 && errno == EINTR);
 
     if (ret != 1)
@@ -1119,7 +1137,7 @@ epoll_register( int  epoll_fd, int  fd )
     ev.data.fd = fd;
     do {
         ret = epoll_ctl( epoll_fd, EPOLL_CTL_ADD, fd, &ev );
-    } while (ret < 0);
+    } while (ret < 0 && errno == EINTR);
     return ret;
 }
 
@@ -1130,7 +1148,7 @@ epoll_deregister( int  epoll_fd, int  fd )
     int  ret;
     do {
         ret = epoll_ctl( epoll_fd, EPOLL_CTL_DEL, fd, NULL );
-    } while (ret < 0);
+    } while (ret < 0 && errno == EINTR);
     return ret;
 }
 
@@ -1138,51 +1156,64 @@ epoll_deregister( int  epoll_fd, int  fd )
  * when started, messages from the QEMU GPS daemon. these are simple NMEA sentences
  * that must be parsed to be converted into GPS fixes sent to the framework
  */
-static void gps_state_thread( void*  arg )
+
+static int         epoll_ctrlfd ;
+static int         epoll_nmeafd ;
+
+
+static void
+gps_state_thread( void*  arg )
 {
     GpsState*   state = (GpsState*) arg;
-    NmeaReader  *reader;
-    int         epoll_fd   = epoll_create(2);
-    int         started    = 0;
     int         gps_fd     = state->fd;
     int         control_fd = state->control[1];
-
-    reader = &state->reader;
-
-    nmea_reader_init( reader );
+	epoll_ctrlfd   = epoll_create(1);
+	epoll_nmeafd   = epoll_create(1);
 
     // register control file descriptors for polling
-    epoll_register( epoll_fd, control_fd );
-    epoll_register( epoll_fd, gps_fd );
+    epoll_register( epoll_ctrlfd, control_fd );
 
     D("gps thread running");
 
+	state->tmr_thread = state->callbacks.create_thread_cb("athr_gps_tmr", gps_timer_thread, state);
+	if (!state->tmr_thread)
+	{
+		LOGE("could not create gps timer thread: %s", strerror(errno));
+		started = 0;
+		state->init = STATE_INIT;
+		goto Exit;
+	}
 
-    gps_dev_init(gps_fd);
+	state->nmea_thread = state->callbacks.create_thread_cb("athr_nmea_thread", gps_nmea_thread, state);
+	if (!state->nmea_thread)
+	{
+		LOGE("could not create gps nmea thread: %s", strerror(errno));
+		started = 0;
+		state->init = STATE_INIT;
+		goto Exit;
+	}
+
+	started = 0;
+	state->init = STATE_INIT;
 
     // now loop
-    for (;;)
-	{
-        struct epoll_event   events[2];
+    for (;;) {
+        struct epoll_event   events[1];
         int                  ne, nevents;
 
-        nevents = epoll_wait( epoll_fd, events, 2, -1 );
-        if (nevents < 0)
-	{
+        nevents = epoll_wait( epoll_ctrlfd, events, 1, -1 );
+        if (nevents < 0) {
             if (errno != EINTR)
                 LOGE("epoll_wait() unexpected error: %s", strerror(errno));
             continue;
         }
         // D("gps thread received %d events", nevents);
-        for (ne = 0; ne < nevents; ne++)
-		{
-            if ((events[ne].events & (EPOLLERR|EPOLLHUP)) != 0)
-			{
+        for (ne = 0; ne < nevents; ne++) {
+            if ((events[ne].events & (EPOLLERR|EPOLLHUP)) != 0) {
                 LOGE("EPOLLERR or EPOLLHUP after epoll_wait() !?");
                 goto Exit;
             }
-            if ((events[ne].events & EPOLLIN) != 0)
-			{
+            if ((events[ne].events & EPOLLIN) != 0) {
                 int  fd = events[ne].data.fd;
 
                 if (fd == control_fd)
@@ -1190,13 +1221,11 @@ static void gps_state_thread( void*  arg )
                     char  cmd = 255;
                     int   ret;
                     D("gps control fd event");
-                    do
-					{
+                    do {
                         ret = read( fd, &cmd, 1 );
-                    } while (ret < 0 && ((errno == EIO) || (errno == EINTR)));
+                    } while (ret < 0 && errno == EINTR);
 
-                    if (cmd == CMD_QUIT)
-					{
+                    if (cmd == CMD_QUIT) {
                         D("gps thread quitting on demand");
                         goto Exit;
                     }
@@ -1204,107 +1233,150 @@ static void gps_state_thread( void*  arg )
 					{
                         if (!started)
 						{
+							NmeaReader  *reader;
+							reader = &state->reader;
+							nmea_reader_init( reader );
                             D("gps thread starting  location_cb=%p", state->callbacks.location_cb);
                             started = 1;
-
-                            gps_dev_start(gps_fd);
-
-                            GPS_STATUS_CB(state->callbacks, GPS_STATUS_SESSION_BEGIN);
-
                             state->init = STATE_START;
-
-			    state->tmr_thread = state->callbacks.create_thread_cb("athr_gps_tmr", gps_timer_thread, state);
-			    if (!state->tmr_thread)
-			{
-                                LOGE("could not create gps timer thread: %s", strerror(errno));
-                                started = 0;
-                                state->init = STATE_INIT;
-                                goto Exit;
-                            }
-
+							/* handle wakeup routine*/
+							gps_wakeup(state);
                         }
+						else
+							D("LM already start");
+
                     }
                     else if (cmd == CMD_STOP) {
                         if (started) {
-                            void *dummy;
-                            D("gps thread stopping");
-                            started = 0;
-
-                            gps_dev_stop(gps_fd);
-
                             state->init = STATE_INIT;
-
-                            pthread_join(state->tmr_thread, &dummy);
-
-                            GPS_STATUS_CB(state->callbacks, GPS_STATUS_SESSION_END);
-
-                        }
-                    }
-                }
-                else if (fd == gps_fd)
-                {
-                    char buf[512];
-                    int  nn, ret;
-
-		    // D("gps fd event start");
-                    do {
-							fd_set readfds;
-							FD_ZERO(&readfds);
-							FD_SET(fd, &readfds);
-
-							ret = select(FD_SETSIZE, &readfds, NULL, NULL, NULL);
-							if (ret < 0)
-								continue;
-							if (FD_ISSET(fd, &readfds))
-								ret = read( fd, buf, sizeof(buf) );
-                        // D("read buffer size: %d", ret);
-                    } while (ret < 0 && ((errno == EIO) || (errno == EINTR)));
-
-		    if (state->init != STATE_START)
-			continue;
-
-                    if (ret > 0)
-                        for (nn = 0; nn < ret; nn++)
-                            nmea_reader_addc( reader, buf[nn] );
-                    /* ATHR in/out sentences, jhung */
-                    if ((buf[0] == 'O') && (buf[1] == 'A') && (buf[2] == 'P'))
-					{
-                        D("OAP200 sentences found");
-                        athr_reader_parse(buf, ret);
-                        /*
-                        for (nn = 0; nn < ret; nn++)
-                            D("%.2x ", buf[nn]);
-                        */
-                    }else if ((buf[0] == '#') && (buf[1] == '!') && \
-                              (buf[2] == 'G') && (buf[3] == 'S') && \
-                              (buf[4] == 'M') && (buf[5] == 'A'))
-					{
-
-                        D("GSMA sentences found");
-                        athr_reader_parse(buf, ret);
+                       }
                     }
-                    /* end ATHR in/out sentences */
-                    // D("gps fd event end");
                 }
                 else
                 {
                     LOGE("epoll_wait() returned unkown fd %d ?", fd);
+					gps_fd = _gps_state->fd; //resign fd to gps_fd
                 }
             }
         }
     }
 Exit:
+	{
+		void *dummy;
+		continue_thread = 0;
+		close(epoll_ctrlfd);
+		close(epoll_nmeafd);
+		pthread_join(state->tmr_thread, &dummy);
+		pthread_join(state->nmea_thread, &dummy);
+		DFR("gps control thread destroyed");
+	}
+    return;
+}
+
+static void
+gps_nmea_thread( void*  arg )
+{
+	GpsState *state = (GpsState *)arg;
+	NmeaReader  *reader;
+    reader = &state->reader;
 
-    gps_dev_deinit(gps_fd);
+	DFR("gps entered nmea thread");
+	int versioncnt = 0;
 
-    return;
+   // now loop
+    while (continue_thread)
+	{
+		char buf[512];
+		int  nn, ret;
+		struct timeval tv;
+
+		while(sleep_lock == 0 && continue_thread) //don't read while sleep
+			sleep(1);
+
+		if(state->fd == -1)
+		{
+			GPS_STATUS_CB(state->callbacks, GPS_STATUS_SESSION_END);
+			gps_opentty(state);
+			sleep(1);
+			continue;
+		}
+
+		if(bOrionShutdown && started) // Orion be shutdown but LM is started, try to wake it up.
+		{
+			LOGI("Try to wake orion up after 5 secs");
+			sleep_lock = 0;
+			sleep(5);
+			GPS_STATUS_CB(state->callbacks, GPS_STATUS_SESSION_BEGIN);
+			gps_wakeup(state);
+			nmea_reader_init( reader );
+			bOrionShutdown = 0;
+		}
+
+		if(!continue_thread)
+			break;
+
+		fd_set readfds;
+		FD_ZERO(&readfds);
+		FD_SET(state->fd, &readfds);
+		/* Wait up to 100 ms. */
+		tv.tv_sec = 0;
+		tv.tv_usec = 100;
+
+		ret = select(state->fd + 1, &readfds, NULL, NULL, &tv);
+
+		if (FD_ISSET(state->fd, &readfds))
+		{
+			memset(buf,0,sizeof(buf));
+			ret = read( state->fd, buf, sizeof(buf) );
+			if (ret > 0)
+			{
+				if (strstr(buf, "CFG_R"))
+				{
+					LOGI("ver %s",buf);
+				}
+
+				for (nn = 0; nn < ret; nn++)
+					nmea_reader_addc( reader, buf[nn] );
+
+				/* ATHR in/out sentences*/
+				if ((buf[0] == 'O') && (buf[1] == 'A') && (buf[2] == 'P')) {
+					D("OAP200 sentences found");
+					athr_reader_parse(buf, ret);
+					/*
+					for (nn = 0; nn < ret; nn++)
+						D("%.2x ", buf[nn]);
+					*/
+				}else if ((buf[0] == '#') && (buf[1] == '!') && \
+						  (buf[2] == 'G') && (buf[3] == 'S') && \
+						  (buf[4] == 'M') && (buf[5] == 'A')) {
+					D("GSMA sentences found");
+					athr_reader_parse(buf, ret);
+				}
+			}
+			else
+			{
+				DFR("Error on NMEA read :%s",strerror(errno));
+				gps_closetty(state);
+				GPS_STATUS_CB(state->callbacks, GPS_STATUS_SESSION_END);
+				sleep(3); //wait Orion shutdown.
+				bOrionShutdown = 1;
+				continue;
+			}
+		}
+
+		if(!continue_thread)
+			break;
+	}
+Exit:
+	DFR("gps nmea thread destroyed");
+	return;
 }
 
-static void gps_timer_thread( void*  arg )
+static void
+gps_timer_thread( void*  arg )
 {
-	int need_sleep = 0;
-	int sleep_val = 0;
-	int continue_thread = 0;
+    int need_sleep = 0;
+    int sleep_val = 0;
 
   GpsState *state = (GpsState *)arg;
 
@@ -1312,76 +1384,163 @@ static void gps_timer_thread( void*  arg )
 
   do {
 
-    DFR ("gps timer exp");
+	while(started != 1 && continue_thread) //
+	{
+		usleep(500*1000);
+	}
 
-    GPS_STATE_LOCK_FIX(state);
+    gps_state_lock_fix(state);
 
-    //if (state->reader.fix.flags != 0) {
-	// RGE 2011-02-08
-	if ((state->reader.fix.flags & GPS_LOCATION_HAS_LAT_LONG) != 0)
-	{
-      D("gps fix cb: 0x%x", state->reader.fix.flags);
+    if ((state->reader.fix.flags & GPS_LOCATION_HAS_LAT_LONG) != 0) {
+
+      //D("gps fix cb: 0x%x", state->reader.fix.flags);
 
       ath_send_ni_notification(&state->reader);
 
-      if (state->callbacks.location_cb)
-	  {
+      if (state->callbacks.location_cb) {
           state->callbacks.location_cb( &state->reader.fix );
           state->reader.fix.flags = 0;
           state->first_fix = 1;
       }
 
-      if (state->fix_freq == 0)
-	  {
+      if (state->fix_freq == 0) {
         state->fix_freq = -1;
       }
 
     }
 
-    if (state->reader.sv_status_changed != 0)
-	{
+    if (state->reader.sv_status_changed != 0) {
 
       // D("gps sv status callback");
 
-      if (state->callbacks.sv_status_cb)
-	  {
+      if (state->callbacks.sv_status_cb) {
           state->callbacks.sv_status_cb( &state->reader.sv_status );
           state->reader.sv_status_changed = 0;
       }
 
     }
 
-	// RGE 2011-02-08
-	need_sleep = (state->fix_freq != -1 && state->init == STATE_START ? 1 : 0);
-	sleep_val = state->fix_freq;
+    need_sleep = (state->fix_freq != -1 && state->init == STATE_START ? 1 : 0);
+    sleep_val = state->fix_freq;
+
+    gps_state_unlock_fix(state);
 
-	GPS_STATE_UNLOCK_FIX(state);
+    if (need_sleep) {
+        sleep(sleep_val);
+    }
 
-	// RGE 2011-02-08
-    if (need_sleep)
+	if( state->init == STATE_INIT && lastcmd == CMD_STOP && started == 1)
 	{
-		sleep(sleep_val);
-	}
+		int gap = 0;
+		D("Wait for NMEA coming,%d,%d,%d", state->init , lastcmd, started);
 
-    GPS_STATE_LOCK_FIX(state);
-	continue_thread = state->init == STATE_START ? 1 : 0;
-	GPS_STATE_UNLOCK_FIX(state);
+		while (state->init != STATE_START && bGetFormalNMEA == 0 && continue_thread && !bOrionShutdown)
+		{
+			usleep(300*1000);
+			if (++gap > 100)
+				break;
+		} ;
+
+		D("Get NMEA %d and state %d",bGetFormalNMEA,state->init);
+		// even we don't get nmea after 30 second, still force close it
+		bGetFormalNMEA |= (gap >= 100);
+
+		if( state->init == STATE_INIT && lastcmd == CMD_STOP && started == 1)
+		{
+			gps_sleep(state);
+		}
+		else
+		{
+			D("User enter LM before sending sleep, so drop it");
+		}
+	}
 
   } while(continue_thread);
 
+
   DFR("gps timer thread destroyed");
 
   return;
 
 }
 
+static char   prop[PROPERTY_VALUE_MAX];
+
+int gps_opentty(GpsState *state)
+{
+
+	DFR("%s", __FUNCTION__);
+
+	if(strlen(prop) <= 0)
+	{
+		state->fd  = -1;
+		return state->fd;
+	}
+
+	if(state->fd != -1)
+		gps_closetty(state);
+
+    do {
+        state->fd = open( prop, O_RDWR | O_NOCTTY | O_NONBLOCK);
+    } while (state->fd < 0 && errno == EINTR);
+
+    if (state->fd < 0) {
+        char device[256];
+
+        // let's try add /dev/ to the property name as a last resort
+        if ( snprintf(device, sizeof(device), "/dev/%s0", prop) >= (int)sizeof(device) ) {
+            DFR("gps serial device name too long: '%s'", prop);
+            return -1;
+        }
+
+        do {
+            state->fd = open( device, O_RDWR | O_NOCTTY | O_NONBLOCK);
+        } while (state->fd < 0 && errno == EINTR);
+
+        if (state->fd < 0)
+        {
+            LOGE("could not open gps serial device %s: %s", prop, strerror(errno) );
+            return -1;
+        }
+    }
+
+    D("gps will read from %s", prop);
+
+    // disable echo on serial lines
+    if ( isatty( state->fd ) ) {
+        struct termios  ios;
+        tcgetattr( state->fd, &ios );
+        bzero(&ios, sizeof(ios));
+        ios.c_cflag = B115200 | CS8 | CLOCAL | CREAD;
+        ios.c_iflag = IGNPAR;
+        ios.c_oflag = 0;
+        ios.c_lflag = 0;  /* disable ECHO, ICANON, etc... */
+        tcsetattr( state->fd, TCSANOW, &ios );
+		tcflush(state->fd,TCIOFLUSH);
+    }
+
+	epoll_register( epoll_nmeafd, state->fd );
+
+	return 0;
+}
+
+void gps_closetty(GpsState *s)
+{
+	if(s->fd != -1)
+	{
+		DFR("%s", __FUNCTION__);
+		// close connection to the QEMU GPS daemon
+		epoll_deregister( epoll_nmeafd, s->fd );
+		close( s->fd );
+		s->fd = -1;
+	}
+}
+
 static void
 gps_state_init( GpsState*  state )
 {
-    char   prop[PROPERTY_VALUE_MAX];
-    char   device[256];
     int    ret;
-    int    retry_count = 0;
+    int    done = 0;
 
     struct sigevent tmr_event;
 
@@ -1391,6 +1550,7 @@ gps_state_init( GpsState*  state )
     state->fd         = -1;
     state->fix_freq   = -1;
     state->first_fix  = 0;
+	continue_thread = 1;
 
     if (sem_init(&state->fix_sem, 0, 1) != 0) {
       D("gps semaphore initialization failed! errno = %d", errno);
@@ -1398,7 +1558,6 @@ gps_state_init( GpsState*  state )
     }
 
     // look for a kernel-provided device name
-#ifdef ATHR_GPS
     if (property_get("athr.gps.mode",prop,"hosted") == 0)
     {
       DFR("Running ATHR GPS driver in hosted mode!");
@@ -1421,56 +1580,9 @@ gps_state_init( GpsState*  state )
         return;
       }
     }
-#else	 /* original code */
-    if (property_get("ro.kernel.android.gps",prop,"") == 0) {
-        DFR("no kernel-provided gps device name (old code)");
-        return;
-    }
-#endif	/* ATHR_GPS */
-    /* open virtual serial port 0 as the master input node */
-    if ( snprintf(device, sizeof(device), "/dev/%s0", prop) >= (int)sizeof(device) ) {
-        LOGE("gps serial device name too long: '%s'", prop);
-        return;
-    }
-
-    do
-     {
-        retry_count++;
-        state->fd = open( device, O_RDWR | O_NOCTTY | O_NONBLOCK);
-	usleep (500000);
-     } while ((retry_count < 100) && state->fd < 0 && ((errno == EIO) || (errno == EINTR)));
-
-    if (state->fd < 0)
-	{
-        LOGE("could not open gps serial device %s: %s", device, strerror(errno) );
-        return;
-    }
 
-	D("gps will read from %s", device);
 
-    // disable echo on serial lines
-    if ( isatty( state->fd ) )
-	{
-        struct termios  ios;
-        tcgetattr( state->fd, &ios );
-#ifdef ATHR_GPS
-        D("set to 115200bps, 8-N-1");
-        bzero(&ios, sizeof(ios));
-        ios.c_cflag = B115200 | CS8 | CLOCAL | CREAD;
-        ios.c_iflag = IGNPAR;
-        ios.c_oflag = 0;
-        ios.c_lflag = 0;  /* disable ECHO, ICANON, etc... */
-#else
-        ios.c_lflag = 0;  /* disable ECHO, ICANON, etc... */
-        ios.c_oflag &= (~ONLCR); /* Stop \n -> \r\n translation on output */
-        ios.c_iflag &= (~(ICRNL | INLCR)); /* Stop \r -> \n & \n -> \r translation on input */
-        ios.c_iflag |= (IGNCR | IXOFF);  /* Ignore \r & XON/XOFF on input */
-#endif
-        tcsetattr( state->fd, TCSANOW, &ios );
-    }
-
-    if ( socketpair( AF_LOCAL, SOCK_STREAM, 0, state->control ) < 0 )
-	{
+    if ( socketpair( AF_LOCAL, SOCK_STREAM, 0, state->control ) < 0 ) {
         LOGE("could not create thread control socket pair: %s", strerror(errno));
         goto Fail;
     }
@@ -1499,38 +1611,19 @@ Fail:
 /*****************************************************************/
 /*****************************************************************/
 
+
 static int athr_gps_init(GpsCallbacks* callbacks)
 {
     GpsState*  s = _gps_state;
-    int    retry_count = 200;
-    const char *desired_status = "running";
-    char value[PROPERTY_VALUE_MAX] = {'\0'};
-
-    s->callbacks = *callbacks;
-    if (property_set("ctl.start", "ing") < 0) {
-        LOGE("Failed to start ing");
-        return -1;
-    }
 
-    while (retry_count-- > 0) {
-        usleep(200000);
-        if (property_get("init.svc.ing", value, NULL)) {
-            if (strcmp(value, desired_status) == 0) {
-                LOGE("ing service is running\r\n");
-                break;
-            }
-            else
-                LOGE("ing service is not running\r\n");
-        }
-    }
+	D("gps state initializing %d",s->init);
 
-    gps_state_init(s);
+    s->callbacks = *callbacks;
+    if (!s->init)
+        gps_state_init(s);
 
-    if (s->fd < 0)
-      {
-	LOGE("athr_init error\r\n");
-        return -1;
-      }
+	if(!g_gpscallback)
+		g_gpscallback = callbacks;
 
     return 0;
 }
@@ -1540,64 +1633,26 @@ athr_gps_cleanup(void)
 {
     GpsState*  s = _gps_state;
 
+	D("%s: called", __FUNCTION__);
+
     if (s->init)
         gps_state_done(s);
-    if (property_set("ctl.stop", "ing") < 0) {
-      LOGE("Failed to stop ing");
-      return;
-    }
-}
-
-static int athr_run_hook(char* name)
-{
-    char   prop[PROPERTY_VALUE_MAX];
-    char   buf[PROPERTY_VALUE_MAX + 20];
-    if (property_get("athr.gps.hookspath",prop,"") == 0)
-	{
-        DFR("%s: athr.gps.hookspath property is not set", __FUNCTION__);
-		return 0;
-    }
-    sprintf(buf,"%s/%s" , prop, name);
-	DFR("%s: going to execute hook  \"%s\"", __FUNCTION__, buf);
-    return !system(buf);
-}
-
-static int athr_run_hook_start()
-{
-	return athr_run_hook("start");
-}
-
-static int athr_run_hook_stop()
-{
-	return athr_run_hook("stop");
 }
 
 static int athr_gps_start()
 {
     GpsState*  s = _gps_state;
+	D("%s: called", __FUNCTION__ );
 
-    if (!s->init)
+	if(gps_checkstate(s) == -1)
 	{
-        DFR("%s: called with uninitialized state !!", __FUNCTION__);
-        return -1;
-    }
+		DFR("%s: called with uninitialized state !!", __FUNCTION__);
+		return -1;
+	}
+	gps_state_start(s);
 
-    D("%s: called", __FUNCTION__);
+	GPS_STATUS_CB(s->callbacks, GPS_STATUS_SESSION_BEGIN);
 
-    if (athr_run_hook_start())
-	{
-        DFR("%s: Hook says: quit now", __FUNCTION__);
-    }
-	else
-	{
-        /* send $PUNV,WAKEUP*2C command, jhung */
-		D("Send WAKEUP command to GPS");
-        if (write(s->fd, "$PUNV,WAKEUP*2C\r\n", 17) < 0)
-        {
-            D("Send WAKEUP command ERROR!");
-        }
-    }
-    gps_state_start(s);
     return 0;
 }
 
@@ -1607,24 +1662,20 @@ athr_gps_stop()
 {
     GpsState*  s = _gps_state;
 
-    if (!s->init) {
-        DFR("%s: called with uninitialized state !!", __FUNCTION__);
-        return -1;
-    }
+	D("%s: called", __FUNCTION__ );
 
-	D("%s: called", __FUNCTION__);
+	if(gps_checkstate(s) == -1)
+	{
+		DFR("%s: called with uninitialized state !!", __FUNCTION__);
+		return -1;
+	}
+
+	//close LM first
+	gps_state_stop(s);
+	D("Try to change state to init");
+	//change state to INIT
+	GPS_STATUS_CB(s->callbacks, GPS_STATUS_SESSION_END);
 
-    if (athr_run_hook_stop()) {
-        DFR("%s: Hook says: quit now", __FUNCTION__);
-    } else {
-        /* send $PUNV,SLEEP*7E command, jhung */
-        D("Send SLEEP command to GPS");
-        if (write(s->fd, "$PUNV,SLEEP*7E\r\n", 16) < 0)
-        {
-            D("Send SLEEP command ERROR!");
-        }
-    }
-    gps_state_stop(s);
     return 0;
 }
 
@@ -1634,12 +1685,11 @@ athr_gps_set_fix_frequency(int freq)
 {
     GpsState*  s = _gps_state;
 
-    if (!s->init) {
-        DFR("%s: called with uninitialized state !!", __FUNCTION__);
-        return;
-    }
-
-    D("%s: called", __FUNCTION__);
+	if(gps_checkstate(s) == -1)
+	{
+		DFR("%s: called with uninitialized state !!", __FUNCTION__);
+		return;
+	}
 
     s->fix_freq = (freq <= 0) ? 1 : freq;
 
@@ -1681,7 +1731,7 @@ static int athr_gps_set_position_mode(GpsPositionMode mode, GpsPositionRecurrenc
 
 	if (!s->init) {
 		D("%s: called with uninitialized state !!", __FUNCTION__);
-		//return -1;
+		return -1;
 	}
 
 	s->fix_freq = min_interval/1000;
@@ -1692,8 +1742,25 @@ static int athr_gps_set_position_mode(GpsPositionMode mode, GpsPositionRecurrenc
 
 	D("gps fix frquency set to %d milli-secs", min_interval);
 
-	return 0;
+    return 0;
+}
+
 
+int gps_checkstate(GpsState *s)
+{
+    if (!s->init) {
+
+        if(g_gpscallback)
+			athr_gps_init(g_gpscallback);
+
+		if(!s->init)
+		{
+			LOGE("%s: still called with uninitialized state !!", __FUNCTION__);
+			return -1;
+		}
+    }
+
+	return 0;
 }
 
 #ifdef ATHR_GPSXtra
@@ -1716,18 +1783,21 @@ static int athr_gps_xtra_inject_data(char *data, int length)
     int cnt;
 
     D("%s: entered, data: %.2x (len: %d)", __FUNCTION__, *data, length);
+
     if (write(s->fd, data, length) < 0)
     {
       D("Send $PUNV command ERROR!");
       return -1;
     }
 
+#ifdef GPS_DEBUG
     /* debug */
     D("inject cmds: ");
     for (cnt=0; cnt<length; cnt++)
       D("%.2x (%d) ", data[cnt], data[cnt]);
     /* end debug */
     D("%s: closed", __FUNCTION__);
+#endif
     return 0;
 }
 
@@ -1761,8 +1831,6 @@ static void athr_gps_ni_init(GpsNiCallbacks* callbacks)
 static void athr_gps_ni_respond(int notif_id, GpsUserResponseType user_response)
 {
     // D("%s: entered", __FUNCTION__);
-
-    return;
 }
 
 static const GpsNiInterface athrGpsNiInterface = {
@@ -1792,7 +1860,6 @@ static const void* athr_gps_get_extension(const char* name)
     return NULL;
 }
 
-// RGE 2011-02-08
 static const GpsInterface  athrGpsInterface = {
     .size =sizeof(GpsInterface),
     .init = athr_gps_init,
@@ -1857,117 +1924,3 @@ static unsigned char gps_dev_calc_nmea_csum(char *msg)
 
   return csum;
 }
-
-static void gps_dev_set_nmea_message_rate(int fd, char *msg, int rate)
-{
-  char buff[50];
-  int i;
-
-  DFR("gps set to baud rate %d bps", rate);
-#ifdef ATHR_GPS
-  sprintf(buff, "$PUNV,SET,00,0000,00,1000,%d,1D*", rate);
-#else
-  sprintf(buff, "$PUBX,40,%s,%d,%d,%d,0*", msg, rate, rate, rate);
-#endif
-  i = strlen(buff);
-
-  sprintf((buff + i), "%02x\r\n", gps_dev_calc_nmea_csum(buff));
-
-  gps_dev_send(fd, buff);
-
-  DFR("gps sent to device: %s", buff);
-
-  return;
-
-}
-
-static void gps_dev_set_baud_rate(int fd, int baud)
-{
-
-  char buff[50];
-  int i, u;
-#ifdef ATHR_GPS
-
-  sprintf(buff, "$PUNV,SET,00,0000,00,1000,%d,1D*", baud);
-  i = strlen(buff);
-  sprintf((buff + i), "%02x\r\n", gps_dev_calc_nmea_csum(buff));
-
-  gps_dev_send(fd, buff);
-  DFR("gps sent to device: %s (ATHR)", buff);
-
-#else	/* original Freerunner code */
-  for (u = 0; u < 3; ++u) {
-
-    sprintf(buff, "$PUBX,41,%d,0003,0003,%d,0*", u, baud);
-    i = strlen(buff);
-
-    sprintf((buff + i), "%02x\r\n", gps_dev_calc_nmea_csum(buff));
-
-    gps_dev_send(fd, buff);
-
-    D("gps sent to device: %s", buff);
-
-  }
-#endif
-  return;
-
-}
-
-static void gps_dev_set_message_rate(int fd, int rate)
-{
-
-  unsigned int i;
-
-  char *msg[] = {
-                 "GGA", "GLL", "ZDA",
-                 "VTG", "GSA", "GSV",
-                 "RMC", "QUAL"
-                };
-
-  for (i = 0; i < sizeof(msg)/sizeof(msg[0]); ++i) {
-    gps_dev_set_nmea_message_rate(fd, msg[i], rate);
-  }
-
-  return;
-
-}
-
-static void gps_dev_init(int fd)
-{
-
-  usleep(1000*1000);
-
-  // To set to STOP state
-  gps_dev_stop(fd);
-
-  return;
-
-}
-
-static void gps_dev_deinit(int fd)
-{
-  // null
-}
-
-static void gps_dev_start(int fd)
-{
-#ifndef ATHR_GPS
-  // Set full message rate
-  gps_dev_set_message_rate(fd, GPS_DEV_HIGH_UPDATE_RATE);
-#endif
-
-
-  D("gps dev start initiated");
-
-}
-
-static void gps_dev_stop(int fd)
-{
-#ifndef ATHR_GPS
-  // Set slow message rate
-  gps_dev_set_message_rate(fd, GPS_DEV_SLOW_UPDATE_RATE);
-#endif
-
-  D("gps dev stop initiated");
-
-}
diff --git a/libgps/gps.c b/libgps/gps.c
index c4eb6e5..1c7585d 100644
--- a/libgps/gps.c
+++ b/libgps/gps.c
@@ -1,20 +1,27 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
- */
-
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Copyright (C) 2009, QUALCOMM USA, INC.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided with the distribution.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.*
  */
 
  /*
-- 
1.8.0

