From ab22e0cc421b4f41e1bbb4ca7737b284eb095de3 Mon Sep 17 00:00:00 2001
From: Xinyu Chen <b03824@freescale.com>
Date: Tue, 30 Aug 2011 13:24:47 +0800
Subject: [PATCH 169/635] ENGR00000000 Merge maddev_honeycomb_mx6 to
 maddev_honeycomb

Conflicts:
	alsa/alsa_imx.cpp
---
 Android.mk                        |   11 +
 alsa/Android.mk                   |   45 +
 alsa/alsa_imx.cpp                 |  637 +++++++++++
 libcopybit/Android.mk             |   44 -
 libcopybit/c2d_api.h              |  541 ----------
 libcopybit/copybit.cpp            |  510 ---------
 libgralloc/Android.mk             |   53 -
 libgralloc/allocator.cpp          |  170 ---
 libgralloc/allocator.h            |  129 ---
 libgralloc/framebuffer.cpp        | 1698 -----------------------------
 libgralloc/gr.h                   |   63 --
 libgralloc/gralloc.cpp            |  506 ---------
 libgralloc/gralloc_priv.h         |  144 ---
 libgralloc/mapper.cpp             |  282 -----
 liboverlay/overlay.cpp            | 2123 -------------------------------------
 liboverlay/overlay_pmem.cpp       |  166 ---
 liboverlay/overlay_pmem.h         |   42 -
 liboverlay/overlay_thread.h       |  724 -------------
 liboverlay/overlay_utils.h        |   78 --
 liboverlay/overlays_test.cpp      |  685 ------------
 modules/alsa/Android.mk           |   45 -
 modules/alsa/alsa_imx5x.cpp       |  647 -----------
 mx5x/hwcomposer/Android.mk        |   30 +
 mx5x/hwcomposer/BG_device.cpp     |  159 +++
 mx5x/hwcomposer/FG_device.cpp     |  307 ++++++
 mx5x/hwcomposer/README.android    |    3 +
 mx5x/hwcomposer/blit_gpu.cpp      |   43 +
 mx5x/hwcomposer/blit_gpu.h        |   42 +
 mx5x/hwcomposer/blit_ipu.cpp      |  171 +++
 mx5x/hwcomposer/blit_ipu.h        |   52 +
 mx5x/hwcomposer/hwc_common.cpp    |  216 ++++
 mx5x/hwcomposer/hwc_common.h      |  214 ++++
 mx5x/hwcomposer/hwcomposer.cpp    |  556 ++++++++++
 mx5x/hwcomposer/output_device.cpp |  140 +++
 mx5x/libcopybit/Android.mk        |   44 +
 mx5x/libcopybit/c2d_api.h         |  541 ++++++++++
 mx5x/libcopybit/copybit.cpp       |  510 +++++++++
 mx5x/libgralloc/Android.mk        |   51 +
 mx5x/libgralloc/allocator.cpp     |  170 +++
 mx5x/libgralloc/allocator.h       |  129 +++
 mx5x/libgralloc/framebuffer.cpp   | 1698 +++++++++++++++++++++++++++++
 mx5x/libgralloc/gr.h              |   63 ++
 mx5x/libgralloc/gralloc.cpp       |  506 +++++++++
 mx5x/libgralloc/gralloc_priv.h    |  144 +++
 mx5x/libgralloc/mapper.cpp        |  282 +++++
 mx6/hwcomposer/Android.mk         |   30 +
 mx6/hwcomposer/BG_device.cpp      |  159 +++
 mx6/hwcomposer/FG_device.cpp      |  307 ++++++
 mx6/hwcomposer/README.android     |    3 +
 mx6/hwcomposer/blit_gpu.cpp       |   43 +
 mx6/hwcomposer/blit_gpu.h         |   42 +
 mx6/hwcomposer/blit_ipu.cpp       |  171 +++
 mx6/hwcomposer/blit_ipu.h         |   52 +
 mx6/hwcomposer/hwc_common.cpp     |  216 ++++
 mx6/hwcomposer/hwc_common.h       |  214 ++++
 mx6/hwcomposer/hwcomposer.cpp     |  554 ++++++++++
 mx6/hwcomposer/output_device.cpp  |  140 +++
 mx6/libgralloc/allocator.cpp      |  170 +++
 mx6/libgralloc/allocator.h        |  129 +++
 mx6/libgralloc/framebuffer.cpp    | 1697 +++++++++++++++++++++++++++++
 mx6/libgralloc/gr.h               |   63 ++
 mx6/libgralloc/gralloc.cpp        |  506 +++++++++
 mx6/libgralloc/gralloc_priv.h     |  195 ++++
 mx6/libgralloc/mapper.cpp         |  282 +++++
 64 files changed, 11737 insertions(+), 8650 deletions(-)
 create mode 100644 Android.mk
 create mode 100755 alsa/Android.mk
 create mode 100755 alsa/alsa_imx.cpp
 delete mode 100755 libcopybit/Android.mk
 delete mode 100755 libcopybit/c2d_api.h
 delete mode 100755 libcopybit/copybit.cpp
 delete mode 100755 libgralloc/Android.mk
 delete mode 100755 libgralloc/allocator.cpp
 delete mode 100755 libgralloc/allocator.h
 delete mode 100755 libgralloc/framebuffer.cpp
 delete mode 100755 libgralloc/gr.h
 delete mode 100755 libgralloc/gralloc.cpp
 delete mode 100755 libgralloc/gralloc_priv.h
 delete mode 100755 libgralloc/mapper.cpp
 delete mode 100755 liboverlay/overlay.cpp
 delete mode 100755 liboverlay/overlay_pmem.cpp
 delete mode 100755 liboverlay/overlay_pmem.h
 delete mode 100755 liboverlay/overlay_thread.h
 delete mode 100755 liboverlay/overlay_utils.h
 delete mode 100755 liboverlay/overlays_test.cpp
 delete mode 100755 modules/alsa/Android.mk
 delete mode 100755 modules/alsa/alsa_imx5x.cpp
 create mode 100755 mx5x/hwcomposer/Android.mk
 create mode 100755 mx5x/hwcomposer/BG_device.cpp
 create mode 100755 mx5x/hwcomposer/FG_device.cpp
 create mode 100755 mx5x/hwcomposer/README.android
 create mode 100755 mx5x/hwcomposer/blit_gpu.cpp
 create mode 100755 mx5x/hwcomposer/blit_gpu.h
 create mode 100755 mx5x/hwcomposer/blit_ipu.cpp
 create mode 100755 mx5x/hwcomposer/blit_ipu.h
 create mode 100755 mx5x/hwcomposer/hwc_common.cpp
 create mode 100755 mx5x/hwcomposer/hwc_common.h
 create mode 100755 mx5x/hwcomposer/hwcomposer.cpp
 create mode 100755 mx5x/hwcomposer/output_device.cpp
 create mode 100755 mx5x/libcopybit/Android.mk
 create mode 100755 mx5x/libcopybit/c2d_api.h
 create mode 100755 mx5x/libcopybit/copybit.cpp
 create mode 100755 mx5x/libgralloc/Android.mk
 create mode 100755 mx5x/libgralloc/allocator.cpp
 create mode 100755 mx5x/libgralloc/allocator.h
 create mode 100755 mx5x/libgralloc/framebuffer.cpp
 create mode 100755 mx5x/libgralloc/gr.h
 create mode 100755 mx5x/libgralloc/gralloc.cpp
 create mode 100755 mx5x/libgralloc/gralloc_priv.h
 create mode 100755 mx5x/libgralloc/mapper.cpp
 create mode 100755 mx6/hwcomposer/Android.mk
 create mode 100755 mx6/hwcomposer/BG_device.cpp
 create mode 100755 mx6/hwcomposer/FG_device.cpp
 create mode 100755 mx6/hwcomposer/README.android
 create mode 100755 mx6/hwcomposer/blit_gpu.cpp
 create mode 100755 mx6/hwcomposer/blit_gpu.h
 create mode 100755 mx6/hwcomposer/blit_ipu.cpp
 create mode 100755 mx6/hwcomposer/blit_ipu.h
 create mode 100755 mx6/hwcomposer/hwc_common.cpp
 create mode 100755 mx6/hwcomposer/hwc_common.h
 create mode 100755 mx6/hwcomposer/hwcomposer.cpp
 create mode 100755 mx6/hwcomposer/output_device.cpp
 create mode 100755 mx6/libgralloc/allocator.cpp
 create mode 100755 mx6/libgralloc/allocator.h
 create mode 100755 mx6/libgralloc/framebuffer.cpp
 create mode 100755 mx6/libgralloc/gr.h
 create mode 100755 mx6/libgralloc/gralloc.cpp
 create mode 100755 mx6/libgralloc/gralloc_priv.h
 create mode 100755 mx6/libgralloc/mapper.cpp

diff --git a/Android.mk b/Android.mk
new file mode 100644
index 0000000..2c989ae
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,11 @@
+common_imx_dirs := libsensor alsa libcamera
+mx5x_dirs := $(common_imx_dirs) libgps mx5x/libcopybit mx5x/libgralloc
+mx6_dirs := $(common_imx_dirs) mx6/libgralloc
+
+ifeq ($(TARGET_BOARD_PLATFORM),imx6)
+  include $(call all-named-subdir-makefiles,$(mx6_dirs))
+else
+  ifeq ($(TARGET_BOARD_PLATFORM),imx5x)
+    include $(call all-named-subdir-makefiles,$(mx5x_dirs))
+  endif
+endif
diff --git a/alsa/Android.mk b/alsa/Android.mk
new file mode 100755
index 0000000..1cbc739
--- /dev/null
+++ b/alsa/Android.mk
@@ -0,0 +1,45 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# This is the Freescale ALSA module for i.MX
+
+ifeq ($(strip $(BOARD_USES_ALSA_AUDIO)),true)
+
+  LOCAL_PATH := $(call my-dir)
+
+  include $(CLEAR_VARS)
+
+  LOCAL_PRELINK_MODULE := false
+
+  LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+
+  LOCAL_CFLAGS := -D_POSIX_SOURCE -Wno-multichar
+
+  LOCAL_C_INCLUDES += hardware/alsa_sound external/alsa-lib/include
+
+  LOCAL_SRC_FILES:= alsa_imx.cpp
+
+  LOCAL_SHARED_LIBRARIES := \
+	libaudio \
+  	libasound \
+  	liblog   \
+    libcutils
+
+  LOCAL_MODULE:= alsa.$(TARGET_BOARD_PLATFORM)
+
+  LOCAL_MODULE_TAGS := eng
+
+  include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/alsa/alsa_imx.cpp b/alsa/alsa_imx.cpp
new file mode 100755
index 0000000..99ac647
--- /dev/null
+++ b/alsa/alsa_imx.cpp
@@ -0,0 +1,637 @@
+/* alsa_imx.cpp
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/* Copyright 2010-2011 Freescale Semiconductor Inc. */
+
+#define LOG_TAG "iMXALSA"
+#include <utils/Log.h>
+
+#include "AudioHardwareALSA.h"
+#include <media/AudioRecord.h>
+
+#include <cutils/properties.h>
+//#define BLUETOOTH_SCO_DEVICE "hw:0,1"
+//#define FM_TRANSMIT_DEVICE "hw:0,2"
+
+#ifndef ALSA_DEFAULT_SAMPLE_RATE
+#define ALSA_DEFAULT_SAMPLE_RATE 44100 // in Hz
+#endif
+
+#define DEVICE_DEFAULT    0
+#define DEVICE_SPDIF      1
+#define DEVICE_SGTL5000   2
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
+
+namespace android
+{
+
+static int s_device_open(const hw_module_t*, const char*, hw_device_t**);
+static int s_device_close(hw_device_t*);
+static status_t s_init(alsa_device_t *, ALSAHandleList &);
+static status_t s_open(alsa_handle_t *, uint32_t, int);
+static status_t s_close(alsa_handle_t *);
+static status_t s_route(alsa_handle_t *, uint32_t, int);
+
+char spdifcardname[32];
+char sgtlcardname[32];
+int  selecteddevice ;    
+    
+static hw_module_methods_t s_module_methods = {
+    open            : s_device_open
+};
+
+extern "C" const hw_module_t HAL_MODULE_INFO_SYM = {
+    tag             : HARDWARE_MODULE_TAG,
+    version_major   : 1,
+    version_minor   : 0,
+    id              : ALSA_HARDWARE_MODULE_ID,
+    name            : "i.MX ALSA module",
+    author          : "Freescale Semiconductor",
+    methods         : &s_module_methods,
+    dso             : 0,
+    reserved        : {0,},
+};
+
+static int s_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device)
+{
+    alsa_device_t *dev;
+    dev = (alsa_device_t *) malloc(sizeof(*dev));
+    if (!dev) return -ENOMEM;
+
+    memset(dev, 0, sizeof(*dev));
+
+    /* initialize the procs */
+    dev->common.tag = HARDWARE_DEVICE_TAG;
+    dev->common.version = 0;
+    dev->common.module = (hw_module_t *) module;
+    dev->common.close = s_device_close;
+    dev->init = s_init;
+    dev->open = s_open;
+    dev->close = s_close;
+    dev->route = s_route;
+
+    *device = &dev->common;
+
+    LOGD("i.MX ALSA module opened");
+
+    return 0;
+}
+
+static int s_device_close(hw_device_t* device)
+{
+    free(device);
+    return 0;
+}
+
+// ----------------------------------------------------------------------------
+
+static const int DEFAULT_SAMPLE_RATE = ALSA_DEFAULT_SAMPLE_RATE;
+
+static void setDefaultControls(uint32_t devices, int mode, const char *cardname);
+
+typedef void (*AlsaControlSet)(uint32_t devices, int mode, const char *cardname);
+
+#define IMX_OUT_DEFAULT   (\
+        AudioSystem::DEVICE_OUT_EARPIECE | \
+        AudioSystem::DEVICE_OUT_SPEAKER | \
+        AudioSystem::DEVICE_OUT_WIRED_HEADSET | \
+        AudioSystem::DEVICE_OUT_WIRED_HEADPHONE | \
+        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP | \
+        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES | \
+        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | \
+        AudioSystem::DEVICE_OUT_AUX_DIGITAL | \
+        AudioSystem::DEVICE_OUT_DEFAULT \
+	)
+
+#define IMX_IN_DEFAULT    (\
+        AudioSystem::DEVICE_IN_ALL &\
+	~AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET \
+	)
+
+static alsa_handle_t _defaults[] = {
+    {
+        module      : 0,
+        devices     : IMX_OUT_DEFAULT,
+        curDev      : 0,
+        curMode     : 0,
+        handle      : 0,
+        format      : SND_PCM_FORMAT_S16_LE, // AudioSystem::PCM_16_BIT
+        channels    : 2,
+        sampleRate  : DEFAULT_SAMPLE_RATE,
+        latency     : 200000, // Desired Delay in usec
+        bufferSize  : 6144, // Desired Number of samples
+        modPrivate  : (void *)&setDefaultControls,
+    },
+    {
+        module      : 0,
+        devices     : IMX_IN_DEFAULT,
+        curDev      : 0,
+        curMode     : 0,
+        handle      : 0,
+        format      : SND_PCM_FORMAT_S16_LE, // AudioSystem::PCM_16_BIT
+        channels    : 2,
+        sampleRate  : DEFAULT_SAMPLE_RATE,
+        latency     : 250000, // Desired Delay in usec
+        bufferSize  : 6144, // Desired Number of samples
+        modPrivate  : (void *)&setDefaultControls,
+    },
+};
+
+// ----------------------------------------------------------------------------
+
+snd_pcm_stream_t direction(alsa_handle_t *handle)
+{
+    return (handle->devices & AudioSystem::DEVICE_OUT_ALL) ? SND_PCM_STREAM_PLAYBACK
+            : SND_PCM_STREAM_CAPTURE;
+}
+
+//card_device =0, return the card name, card_device=1, return the card device name
+const char *deviceName(alsa_handle_t *alsa_handle, uint32_t device, int mode, int card_device)
+{
+
+	snd_ctl_t *handle;
+	int card, err, dev, idx;
+	snd_ctl_card_info_t *info;
+	snd_pcm_info_t *pcminfo;
+	snd_ctl_card_info_alloca(&info);
+	snd_pcm_info_alloca(&pcminfo);
+    int  cardnum = 0;
+    char value[PROPERTY_VALUE_MAX];
+    snd_pcm_stream_t stream = direction(alsa_handle);
+    bool havespdifdevice = false;
+    bool havesgtldevice = false;
+    
+	card = -1;
+	if (snd_card_next(&card) < 0 || card < 0) {
+		LOGD("no soundcards found...");
+		return "default";
+	}
+	LOGD("**** List of %s Hardware Devices ****\n",
+	       snd_pcm_stream_name(stream));
+	while (card >= 0) {
+		char name[32];
+		sprintf(name, "hw:%d", card);
+		if ((err = snd_ctl_open(&handle, name, 0)) < 0) {
+			LOGD("control open (%i): %s", card, snd_strerror(err));
+			goto next_card;
+		}
+		if ((err = snd_ctl_card_info(handle, info)) < 0) {
+			LOGD("control hardware info (%i): %s", card, snd_strerror(err));
+			snd_ctl_close(handle);
+			goto next_card;
+		}
+		dev = -1;
+		while (1) {
+			unsigned int count;
+			if (snd_ctl_pcm_next_device(handle, &dev)<0)
+				LOGD("snd_ctl_pcm_next_device");
+			if (dev < 0)
+				break;
+			snd_pcm_info_set_device(pcminfo, dev);
+			snd_pcm_info_set_subdevice(pcminfo, 0);
+			snd_pcm_info_set_stream(pcminfo, stream);
+			if ((err = snd_ctl_pcm_info(handle, pcminfo)) < 0) {
+				if (err != -ENOENT)
+					LOGD("control digital audio info (%i): %s", card, snd_strerror(err));
+				continue;
+			}
+			
+			LOGD("card %i: %s [%s], device %i: %s [%s]\n",
+				card, snd_ctl_card_info_get_id(info), snd_ctl_card_info_get_name(info),
+				dev,
+				snd_pcm_info_get_id(pcminfo),
+				snd_pcm_info_get_name(pcminfo));
+                			
+			if(strcmp(snd_pcm_info_get_id(pcminfo),"IMX SPDIF mxc spdif-0")==0) {
+			     if(card_device==0)  sprintf(spdifcardname, "hw:0%d", card);
+			     else         		 sprintf(spdifcardname, "hw:%d,%d", card, dev);
+			     havespdifdevice =  true;
+			}
+            
+			if(strcmp(snd_pcm_info_get_id(pcminfo),"SGTL5000 SGTL5000-0")==0) {
+			     if(card_device==0) sprintf(sgtlcardname, "hw:0%d", card);
+			     else               sprintf(sgtlcardname, "hw:%d,%d", card, dev);
+			     havesgtldevice =  true;                
+			}
+			cardnum++;
+		}
+		snd_ctl_close(handle);
+	next_card:
+
+		if (snd_card_next(&card) < 0) {
+			LOGD("snd_card_next");
+			break;
+		}
+	}
+        
+    property_get("ro.HDMI_AUDIO_OUTPUT", value, "");
+    if((device & AudioSystem::DEVICE_OUT_AUX_DIGITAL) && havespdifdevice && (strcmp(value, "1") == 0))
+    {
+        selecteddevice = DEVICE_SPDIF;
+        return spdifcardname;
+
+    }else if(havesgtldevice)
+    {
+        selecteddevice = DEVICE_SGTL5000;
+        return sgtlcardname;
+    }
+    selecteddevice = DEVICE_DEFAULT; 
+    return "default";
+}
+
+
+
+const char *streamName(alsa_handle_t *handle)
+{
+    return snd_pcm_stream_name(direction(handle));
+}
+
+status_t setHardwareParams(alsa_handle_t *handle)
+{
+    snd_pcm_hw_params_t *hardwareParams;
+    status_t err;
+    snd_pcm_access_mask_t *mask;
+
+    snd_pcm_uframes_t bufferSize = handle->bufferSize;
+    unsigned int requestedRate = handle->sampleRate;
+    unsigned int latency = handle->latency;
+
+    // snd_pcm_format_description() and snd_pcm_format_name() do not perform
+    // proper bounds checking.
+    bool validFormat = (static_cast<int> (handle->format)
+            > SND_PCM_FORMAT_UNKNOWN) && (static_cast<int> (handle->format)
+            <= SND_PCM_FORMAT_LAST);
+    const char *formatDesc = validFormat ? snd_pcm_format_description(
+            handle->format) : "Invalid Format";
+    const char *formatName = validFormat ? snd_pcm_format_name(handle->format)
+            : "UNKNOWN";
+
+    if (snd_pcm_hw_params_malloc(&hardwareParams) < 0) {
+        LOG_ALWAYS_FATAL("Failed to allocate ALSA hardware parameters!");
+        return NO_INIT;
+    }
+
+    err = snd_pcm_hw_params_any(handle->handle, hardwareParams);
+    if (err < 0) {
+        LOGE("Unable to configure hardware: %s", snd_strerror(err));
+        goto done;
+    }
+
+    // Set the interleaved read and write format.
+    mask = (snd_pcm_access_mask_t *)malloc(snd_pcm_access_mask_sizeof());
+    snd_pcm_access_mask_none(mask);
+    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_INTERLEAVED);
+    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_NONINTERLEAVED);
+    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_COMPLEX);
+    err = snd_pcm_hw_params_set_access_mask(handle->handle, hardwareParams, mask);
+
+    if (err < 0) {
+        LOGW("Unable to enable MMAP access for PCM: %s", snd_strerror(err));
+        err = snd_pcm_hw_params_set_access(handle->handle, hardwareParams,
+                SND_PCM_ACCESS_RW_INTERLEAVED);
+        if (err < 0) {
+            LOGE("Unable to configure PCM read/write format: %s",
+                    snd_strerror(err));
+            free(mask);
+            goto done;
+        }
+        handle->mmap = 0;
+    } else {
+        handle->mmap = 1;
+        LOGW("enable MMAP access for PCM");
+    }
+    free(mask);
+
+    err = snd_pcm_hw_params_set_format(handle->handle, hardwareParams,
+            handle->format);
+    if (err < 0) {
+        LOGE("Unable to configure PCM format %s (%s): %s",
+                formatName, formatDesc, snd_strerror(err));
+        goto done;
+    }
+
+    LOGV("Set %s PCM format to %s (%s)", streamName(), formatName, formatDesc);
+
+    err = snd_pcm_hw_params_set_channels(handle->handle, hardwareParams,
+            handle->channels);
+    if (err < 0) {
+        LOGE("Unable to set channel count to %i: %s",
+                handle->channels, snd_strerror(err));
+        goto done;
+    }
+
+    LOGV("Using %i %s .", handle->channels,
+            handle->channels == 1 ? "channel" : "channels");
+
+    err = snd_pcm_hw_params_set_rate_near(handle->handle, hardwareParams,
+            &requestedRate, 0);
+
+    if (err < 0)
+        LOGE("Unable to set %s sample rate to %u: %s",
+                streamName(handle), handle->sampleRate, snd_strerror(err));
+    else if (requestedRate != handle->sampleRate)
+        // Some devices have a fixed sample rate, and can not be changed.
+        // This may cause resampling problems; i.e. PCM playback will be too
+        // slow or fast.
+        LOGW("Requested rate (%u HZ) does not match actual rate (%u HZ)",
+                handle->sampleRate, requestedRate);
+    else
+        LOGV("Set sample rate to %u HZ", requestedRate);
+
+    // get the max buffer size we can set
+    err = snd_pcm_hw_params_get_buffer_size_max(hardwareParams, &bufferSize);
+    if (err < 0) {
+        LOGE("Unable to get max buffer size:  %s", snd_strerror(err));
+        goto done;
+    }
+
+    // Make sure we have at least the size we originally wanted
+    err = snd_pcm_hw_params_set_buffer_size(handle->handle, hardwareParams,
+            bufferSize);
+    if (err < 0) {
+        LOGE("Unable to set buffer size to %d:  %s",
+                (int)bufferSize, snd_strerror(err));
+        goto done;
+    }
+
+    // Setup buffers for latency
+    err = snd_pcm_hw_params_set_buffer_time_near(handle->handle,
+            hardwareParams, &latency, NULL);
+    if (err < 0) {
+        /* That didn't work, set the period instead */
+        unsigned int periodTime = latency / 4;
+        err = snd_pcm_hw_params_set_period_time_near(handle->handle,
+                hardwareParams, &periodTime, NULL);
+        if (err < 0) {
+            LOGE("Unable to set the period time for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        snd_pcm_uframes_t periodSize;
+        err = snd_pcm_hw_params_get_period_size(hardwareParams, &periodSize,
+                NULL);
+        if (err < 0) {
+            LOGE("Unable to get the period size for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        bufferSize = periodSize * 4;
+        if (bufferSize < handle->bufferSize) bufferSize = handle->bufferSize;
+        err = snd_pcm_hw_params_set_buffer_size_near(handle->handle,
+                hardwareParams, &bufferSize);
+        if (err < 0) {
+            LOGE("Unable to set the buffer size for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        LOGV("Setup buffers time near for latency failed %d", latency);
+    } else {
+        // OK, we got buffer time near what we expect. See what that did for bufferSize.
+        err = snd_pcm_hw_params_get_buffer_size(hardwareParams, &bufferSize);
+        if (err < 0) {
+            LOGE("Unable to get the buffer size for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        // Does set_buffer_time_near change the passed value? It should.
+        err = snd_pcm_hw_params_get_buffer_time(hardwareParams, &latency, NULL);
+        if (err < 0) {
+            LOGE("Unable to get the buffer time for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        unsigned int periodTime = latency / 4;
+        err = snd_pcm_hw_params_set_period_time_near(handle->handle,
+                hardwareParams, &periodTime, NULL);
+        if (err < 0) {
+            LOGE("Unable to set the period time for latency: %s", snd_strerror(err));
+            goto done;
+        }
+        LOGV("Setup buffers time near for latency ok %d", latency);
+    }
+
+    LOGI("Buffer size: %d", (int)bufferSize);
+    LOGI("Latency: %d", (int)latency);
+
+    handle->bufferSize = bufferSize;
+    handle->latency = latency;
+
+    // Commit the hardware parameters back to the device.
+    err = snd_pcm_hw_params(handle->handle, hardwareParams);
+    if (err < 0) LOGE("Unable to set hardware parameters: %s", snd_strerror(err));
+
+    done:
+    snd_pcm_hw_params_free(hardwareParams);
+
+    return err;
+}
+
+status_t setSoftwareParams(alsa_handle_t *handle)
+{
+    snd_pcm_sw_params_t * softwareParams;
+    int err;
+
+    snd_pcm_uframes_t bufferSize = 0;
+    snd_pcm_uframes_t periodSize = 0;
+    snd_pcm_uframes_t startThreshold, stopThreshold;
+
+    if (snd_pcm_sw_params_malloc(&softwareParams) < 0) {
+        LOG_ALWAYS_FATAL("Failed to allocate ALSA software parameters!");
+        return NO_INIT;
+    }
+
+    // Get the current software parameters
+    err = snd_pcm_sw_params_current(handle->handle, softwareParams);
+    if (err < 0) {
+        LOGE("Unable to get software parameters: %s", snd_strerror(err));
+        goto done;
+    }
+
+    // Configure ALSA to start the transfer when the buffer is almost full.
+    snd_pcm_get_params(handle->handle, &bufferSize, &periodSize);
+
+    if (handle->devices & AudioSystem::DEVICE_OUT_ALL) {
+        // For playback, configure ALSA to start the transfer when the
+        // buffer is full.
+        startThreshold = bufferSize - 1;
+        stopThreshold = bufferSize;
+    } else {
+        // For recording, configure ALSA to start the transfer on the
+        // first frame.
+        startThreshold = 1;
+        stopThreshold = bufferSize;
+    }
+
+    err = snd_pcm_sw_params_set_start_threshold(handle->handle, softwareParams,
+            startThreshold);
+    if (err < 0) {
+        LOGE("Unable to set start threshold to %lu frames: %s",
+                startThreshold, snd_strerror(err));
+        goto done;
+    }
+
+    err = snd_pcm_sw_params_set_stop_threshold(handle->handle, softwareParams,
+            stopThreshold);
+    if (err < 0) {
+        LOGE("Unable to set stop threshold to %lu frames: %s",
+                stopThreshold, snd_strerror(err));
+        goto done;
+    }
+
+    // Allow the transfer to start when at least periodSize samples can be
+    // processed.
+    err = snd_pcm_sw_params_set_avail_min(handle->handle, softwareParams,
+            periodSize);
+    if (err < 0) {
+        LOGE("Unable to configure available minimum to %lu: %s",
+                periodSize, snd_strerror(err));
+        goto done;
+    }
+
+    // Commit the software parameters back to the device.
+    err = snd_pcm_sw_params(handle->handle, softwareParams);
+    if (err < 0) LOGE("Unable to configure software parameters: %s",
+            snd_strerror(err));
+
+    done:
+    snd_pcm_sw_params_free(softwareParams);
+
+    return err;
+}
+
+void setDefaultControls(uint32_t devices, int mode, const char *cardname)
+{
+
+    ALSAControl *ctl = new ALSAControl(cardname);
+    LOGD (" setDefaultControls set card :%s",cardname);
+    if(devices & IMX_OUT_DEFAULT)
+    {
+        if(selecteddevice == DEVICE_SGTL5000)
+        {
+            if (devices & AudioSystem::DEVICE_OUT_SPEAKER ||
+               devices & AudioSystem::DEVICE_OUT_EARPIECE) {
+               ctl->set("Speaker Function", "on"); // on
+             } else {
+               ctl->set("Speaker Function", "off"); // off
+             }
+        }
+     }
+
+#if 0
+    if (devices & AudioSystem::DEVICE_OUT_WIRED_HEADSET ||
+        devices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) {
+        control.set("Speader Function", 0); // on
+    } else {
+        control.set("Speader Function", 1); // on
+    }
+#endif
+}
+
+void setAlsaControls(alsa_handle_t *handle, uint32_t devices, int mode)
+{
+    AlsaControlSet set = (AlsaControlSet) handle->modPrivate;
+    const char *card = deviceName(handle, devices, mode, 0);
+    set(devices, mode, card);
+}
+
+// ----------------------------------------------------------------------------
+
+static status_t s_init(alsa_device_t *module, ALSAHandleList &list)
+{
+    LOGD("Initializing devices for IMX ALSA module");
+
+    list.clear();
+
+    for (size_t i = 0; i < ARRAY_SIZE(_defaults); i++) {
+
+        _defaults[i].module = module;
+        list.push_back(_defaults[i]);
+    }
+
+    return NO_ERROR;
+}
+
+static status_t s_open(alsa_handle_t *handle, uint32_t devices, int mode)
+{
+    // Close off previously opened device.
+    // It would be nice to determine if the underlying device actually
+    // changes, but we might be recovering from an error or manipulating
+    // mixer settings (see asound.conf).
+    //
+    s_close(handle);
+
+    LOGD("open called for devices %08x in mode %d...", devices, mode);
+
+    const char *stream = streamName(handle);
+    const char *devName = deviceName(handle, devices, mode, 1);
+
+    // The PCM stream is opened in blocking mode, per ALSA defaults.  The
+    // AudioFlinger seems to assume blocking mode too, so asynchronous mode
+    // should not be used.
+    int err = snd_pcm_open(&handle->handle, devName, direction(handle), 0);
+
+    if (err < 0) {
+        LOGE("Failed to Initialize any ALSA %s device: %s", stream, strerror(err));
+        return NO_INIT;
+    }
+
+    err = setHardwareParams(handle);
+
+    if (err == NO_ERROR) err = setSoftwareParams(handle);
+
+    setAlsaControls(handle, devices, mode);
+    LOGI("Initialized ALSA %s device %s", stream, devName);
+
+    handle->curDev = devices;
+    handle->curMode = mode;
+
+    return err;
+}
+
+static status_t s_close(alsa_handle_t *handle)
+{
+    LOGW("s_close--");
+    status_t err = NO_ERROR;
+    snd_pcm_t *h = handle->handle;
+    handle->handle = 0;
+    handle->curDev = 0;
+    handle->curMode = 0;
+    if (h) {
+        snd_pcm_drain(h);
+        err = snd_pcm_close(h);
+    }
+
+    return err;
+}
+
+static status_t s_route(alsa_handle_t *handle, uint32_t devices, int mode)
+{
+    status_t status = NO_ERROR;
+
+    LOGD("route called for devices %08x in mode %d...", devices, mode);
+    // below Always noting to do, so we open device every time.
+    if (handle->handle && handle->curDev == devices && handle->curMode == mode)
+        ; // Nothing to do
+    else if (handle->handle && (handle->devices & devices))
+    {
+        setAlsaControls(handle, devices, mode);
+        handle->curDev  = devices;
+        handle->curMode = mode;
+    }
+    else {
+        //LOGE("Why are we routing to a device that isn't supported by this object?!?!?!?!");
+        status = s_open(handle, devices, mode);
+    }
+    return status;
+}
+
+}
diff --git a/libcopybit/Android.mk b/libcopybit/Android.mk
deleted file mode 100755
index 1ab57f2..0000000
--- a/libcopybit/Android.mk
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-ifeq ($(HAVE_FSL_IMX_GPU),true)
-ifeq ($(BOARD_SOC_CLASS),IMX5X)
-
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_C_INCLUDES += hardware/mx5x/libgralloc
-LOCAL_SHARED_LIBRARIES := liblog
-ifeq ($(BOARD_SOC_TYPE),IMX50)
-LOCAL_SHARED_LIBRARIES += libc2d_z160
-else
-LOCAL_SHARED_LIBRARIES += libc2d_z430
-endif
-
-LOCAL_SRC_FILES := 	\
-	copybit.cpp
-	
-LOCAL_MODULE := copybit.$(TARGET_BOARD_PLATFORM)
-LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).copybit\" -D_LINUX
-
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif
-endif
diff --git a/libcopybit/c2d_api.h b/libcopybit/c2d_api.h
deleted file mode 100755
index 91e19e0..0000000
--- a/libcopybit/c2d_api.h
+++ /dev/null
@@ -1,541 +0,0 @@
-/* -------------------------------------------------------------------------
- *
- *  Copyright (C) 2010  QUALCOMM Incorporated.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * $Id:
- * $DateTime:
- * $Author:
- *
- *//*!
- * \file    c2d_api.h
- * \brief   C2D API
- *//*----------------------------------------------------------------------*/
- 
-
-#ifndef __c2d_api_h_
-#define __c2d_api_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-/* -------------------------------------------------------------------------
- * C2D Defines
- *//*----------------------------------------------------------------------*/
-
-#ifndef _LINUX
-#define C2D_API __declspec (dllexport)     /*!< DLL exports */
-#ifndef C2D_API
-#ifdef WIN32
-#define C2D_API __declspec (dllexport)     /*!< DLL exports */
-#else
-#define C2D_API
-#endif
-#endif
-#else //_LINUX
-#define C2D_API
-#endif //_LINUX
-
-typedef void*                   C2D_CONTEXT; /*!< C2D Context type */
-typedef void*                   C2D_SURFACE; /*!< C2D Surface type */
-
-typedef enum __C2D_STATUS {         /*!< Status codes, returned by any c2d function */
-    C2D_STATUS_OK              = 0, /*!<   operation was successful     */ 
-    C2D_STATUS_FAILURE         = 1, /*!<   unspecified failure          */
-    C2D_STATUS_NOT_SUPPORTED   = 2, /*!<   not supported functionality  */ 
-    C2D_STATUS_OUT_OF_MEMORY   = 3, /*!<   memory allocation failed     */        
-    C2D_STATUS_INVALID_PARAM   = 4, /*!<   invalid parameter or combination of parameters */       
-} C2D_STATUS;
-
-
-typedef enum _C2D_COLORFORMAT {             /*!< Color formats */
-    /* 1bit formats (alpha mask) */
-    C2D_COLOR_A1                            = 0,    /*!< 1bit per pixel (alpha mask)    */
-    /* 4bit formats (alpha mask) */
-    C2D_COLOR_A4                            = 1,    /*!< 4bit per pixel (alpha mask)    */
-    /* 8bit formats */
-    C2D_COLOR_A8                            = 2,    /*!< 8bit per pixel (alpha mask)    */
-    C2D_COLOR_8                             = 3,    /*!< 8bit per pixel                 */  
-    /* 16bit formats */
-    C2D_COLOR_4444                          = 4,    /*!< 16bit per pixel 4444 ARGB      */
-    C2D_COLOR_4444_RGBA                     = 5,    /*!< 16bit per pixel 4444 RGBA      */
-    C2D_COLOR_1555                          = 6,    /*!< 16bit per pixel 1555 ARGB      */
-    C2D_COLOR_5551_RGBA                     = 7,    /*!< 16bit per pixel 5551 RGBA      */
-    C2D_COLOR_0565                          = 8,    /*!< 16bit per pixel 0565 RGB       */
-    /* 32bit formats */
-    C2D_COLOR_8888                          = 9,    /*!< 32bit per pixel 8888 ARGB      */
-    C2D_COLOR_8888_RGBA                     = 10,   /*!< 32bit per pixel 8888 RGBA      */
-    C2D_COLOR_8888_ABGR                     = 11,   /*!< 32bit per pixel 8888 ABGR      */
-    /* 24bit formats */
-    C2D_COLOR_888                           = 12,   /*!< 24bit per pixel 888 BGR        */
-    /* YUV Formats etc.   */
-    C2D_NUMBER_OF_COLORFORMATS              = 13,    /*!< number of color formats; keep this the last */
-    C2D_COLOR_DUMMY                         = (1<<30) /*!< dummy enum. C2D_COLORFORMAT is used in C2D_SURFACE_DEF struct,
-                                                           this makes sure that C2D_COLORFORMAT size is aligned to 32bit  */
-} C2D_COLORFORMAT;
-
-
-typedef struct _C2D_RECT /*!< c2d rectangle              */
-{
-    int x;         /*!<   upper-left x */
-    int y;         /*!<   upper-left y */
-    int width;     /*!<   width */
-    int height;    /*!<   height */
-} C2D_RECT;
-
-typedef struct _C2D_POINT
-{
-    int x;
-    int y;
-} C2D_POINT;
-
-
-typedef struct _C2D_SURFACE_DEF { /*!< Structure for creating a c2d surface                  */
-    C2D_COLORFORMAT format;     /*!< RGBA color format                                       */
-    unsigned int    width;      /*!< defines width in pixels                                 */
-    unsigned int    height;     /*!< defines height in pixels                                */
-    unsigned int    stride;     /*!< set by c2dSurfAlloc, defines stride in bytes            */
-    void           *buffer;     /*!< set by c2dSurfAlloc, physical address to surface buffer */ 
-    void           *host;       /*!< set by c2dSurfAlloc, virtual address to surface buffer  */ 
-    unsigned int    flags;      /*!< different flags to control the surface behavior         */
-} C2D_SURFACE_DEF;
-
-#define C2D_SURFACE_NO_BUFFER_ALLOC   1
-#define C2D_SURFACE_CLIPRECT_OVERRIDE 2
-
-
-typedef enum _C2D_GRADIENT_DIRECTION {  /*!< Direction of linear color fill */    
-    C2D_GD_LEFTTOP_RIGHTBOTTOM,  /*!< Left to Right, Top to Bottom */
-    C2D_GD_RIGHTTOP_LEFTBOTTOM,  /*!< Right to Left, Top to Bottom */
-    C2D_GD_LEFTBOTTOM_RIGHTTOP,  /*!< Left to Right, Bottom to Top */
-    C2D_GD_RIGHTBOTTOM_LEFTTOP,  /*!< Right to Left, Bottom to Top */
-    C2D_GD_TOP_BOTTOM,           /*!< Top to bottom */
-    C2D_GD_LEFT_RIGHT,           /*!< Left to right */
-    C2D_GD_BOTTOM_TOP,           /*!< Bottom up */
-    C2D_GD_RIGHT_LEFT            /*!< Right to left */
-} C2D_GRADIENT_DIRECTION;
-
-typedef enum __C2D_STRETCH_MODE {    /*!< Stretching modes */
-    C2D_STRETCH_POINT_SAMPLING,      /*!< Simple point sampling */
-    C2D_STRETCH_BILINEAR_SAMPLING    /*!< Linear interpolation in x- and y-direction */
-} C2D_STRETCH_MODE;
-
-typedef enum __C2D_ALPHA_BLEND_MODE {    /*!< Blending modes enumeration */
-    C2D_ALPHA_BLEND_NONE        = 0,     /*!< disables alpha blending */
-    C2D_ALPHA_BLEND_SRCOVER     = 1,     /*!< Source Over Destination */
-    C2D_ALPHA_BLEND_DIRECT      = 2,
-} C2D_ALPHA_BLEND_MODE;
-
-typedef enum __C2D_PARAMETERS {               /*!< Draw parameters                */
-    C2D_PARAM_FILL_BIT        = (1<<0),       /*!< fill rect or arc               */
-    C2D_PARAM_GRADIENT_BIT    = (1<<1),       /*!< fill with fg color to bg color */
-    C2D_PARAM_PATTERN_BIT     = (1<<2),       /*!< fill with brush                */
-    C2D_PARAM_TILING_BIT      = (1<<3),       /*!< tiling(repeat), no scaling for brush */
-    C2D_PARAM_MIRROR_BIT      = (1<<4),       /*!< horizontal mirroring           */
-    C2D_PARAM_LINE_LAST_PIXEL = (1<<5),       /*!< draw the last pixel of a line segment */
-} C2D_PARAMETERS;
-    
-
- typedef enum _C2D_DISPLAY {               /*!< Display enumeration */
-    C2D_DISPLAY_MAIN        = (1 << 0),    /*!< main display */
-    C2D_DISPLAY_SECONDARY   = (1 << 1),    /*!< secondary display */
-    C2D_DISPLAY_TV_OUT      = (1 << 2),    /*!< tv-out etc. */
-    C2D_DISPLAY_OVERLAY     = (1 << 3),    /*!< overlay window bit for display surface if overlay surfaces are supported */
-    C2D_DISPLAY_BG          = (1 << 4),    /*!< background window bit */
-} C2D_DISPLAY;
-
-
-/* -------------------------------------------------------------------------
- *                          C2D API
- *//*----------------------------------------------------------------------*/
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Create C2D context, 
- *          allocates and returns new handle to the draw state
- *  
- * \param   a_c2dContext is pointer to C2D_CONTEXT where context id is stored
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dCreateContext(C2D_CONTEXT *a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Destroy C2D context,
- *          free the given draw state
- *
- * \param   a_c2dContext is the C2D_CONTEXT where context was created
- *                       with c2dCreateContext function
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDestroyContext(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Alloc C2D surface, 
- *          allocates surface and returns handle to it
- *  
- * \param   a_c2dSurface is the pointer to C2D_SURFACE where surface id is stored
- * \param   a_surfaceDef is the pointer to C2D_SURFACE_DEF
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfAlloc(C2D_CONTEXT a_c2dContext, C2D_SURFACE *a_c2dSurface, C2D_SURFACE_DEF *a_surfaceDef);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Free C2D surface,
- *          free the given surface
- *
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfFree(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Lock C2D surface,
- *          Lock surface and return virtual address to surface buffer.
- *
- * \param   a_c2dContext is the context handle
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfLock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, void** a_ptr);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Unlock C2D surface,
- *          Give surface back for HW access
- *
- * \param   a_c2dContext is the context handle
- * \param   a_c2dSurface is the C2D_SURFACE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSurfUnlock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination surface
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_type is the C2D_SURFACE_TYPE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source surface
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_type is the C2D_SURFACE_TYPE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set ROP mode
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rop is the 32bit rop mode
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetRop(C2D_CONTEXT a_c2dContext, unsigned int a_rop);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set foreground color
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_fgColor is the 32bit value for the fgcolor
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetFgColor(C2D_CONTEXT a_c2dContext, unsigned int a_fgColor);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set background color
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_bgColoris the 32bit value for the bgcolor
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBgColor(C2D_CONTEXT a_c2dContext, unsigned int a_bgColor);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set gradient direction
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_direction is the C2D_GRADIENT_DIRECTION
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetGradientDirection(C2D_CONTEXT a_c2dContext, C2D_GRADIENT_DIRECTION a_direction);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set stretching mode
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_mode, C2D_STRETCH_MODE, how to perform stretching
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetStretchMode(C2D_CONTEXT a_c2dContext, C2D_STRETCH_MODE a_mode);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rect is the C2D_RECT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_rect is the C2D_RECT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Sets the region of the destination surface that is clipped
- *          during rendering. Works similar to destination rectangle except
- *          clipping rectangle can be used to clip a stretched blt.
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_clipRect, *C2D_RECT, pass NULL to disable
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstClipRect(C2D_CONTEXT a_c2dContext, C2D_RECT *a_clipRect);
-
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source rotation
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_degree is the 32bit value for rotation
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination rotation
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_degree is the 32bit value for rotation
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set alpha blend mode
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_mode is the C2D_ALPHA_BLEND_MODE
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBlendMode(C2D_CONTEXT a_c2dContext, C2D_ALPHA_BLEND_MODE a_mode);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set global alpha
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_value is the 32bit value for global alpha, (8bit used -> 0-255)
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetGlobalAlpha(C2D_CONTEXT a_c2dContext, unsigned int a_value);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set source colorkey
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_color is the 32bit RGB value for source colorkey, alpha channel ignored
- * \param   a_bEnable, int, enable or disable the use of color key
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetSrcColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set destination colorkey
- *
- * \param   a_c2dContext, C2D_CONTEXT
- * \param   a_color, unsigned int, RGB, alpha channel ignored
- * \param   a_bEnable, int, enable or disable the use of color key
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDstColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set surface as the current brush
- *
- * \param   a_c2dContext is C2D_CONTEXT
- * \param   a_c2dSurface is C2D_SURFACE
- * \param   a_tilingOffset, C2D_POINT*, offset added to upper left corner of the destination rectangle
- *          for brush aligment. Passing NULL equals to zero offset.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetBrushSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_tilingOffset);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set mask surface, if a_c2dSurface is NULL the mask usage is disabled
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_c2dSurface is the C2D_SURFACE
- * \param   a_offset, C2D_POINT*, mask offset to use, NULL means no offset
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetMaskSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_offset);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Blits the source surface to the destination surface with current state
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawBlit(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a rectangle,
- *          The dest regtangle is used to set draw coordinates
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawRect(C2D_CONTEXT a_c2dContext, C2D_PARAMETERS a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a line
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS. 
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawLine(C2D_CONTEXT a_c2dContext,
-                               C2D_POINT *a_start, C2D_POINT *a_end,
-                               unsigned int a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Draws a circular or elliptical arc with coordinates from
- *          the destination rectangle
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dDrawArc(C2D_CONTEXT a_c2dContext, int a_startAngle, int a_arcAngle, unsigned int a_drawConfig);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Flush all the context draws to HW
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dFlush(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Flush all the context draws to HW and waits them to be executed
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dFinish(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Waits for the end-of-pipeline timestamp of the last submitted command buffer
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dWaitForTimestamp(C2D_CONTEXT a_c2dContext);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Get display info, a_displayInfo will be filled with information
- *
- * \param   a_display, C2D_DISPLAY
- * \param   a_displayInfo is the pointer to the C2D_SURFACE_DEF
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dGetDisplayInfo(C2D_DISPLAY a_display, C2D_SURFACE_DEF *a_displayInfo);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set display surface
- *
- * \param   a_display is the C2D_DISPLAY
- * \param   a_c2dSurface is the C2D_SURFACE
- * \param   a_displayConfig is the colorkey enable etc. if supported by diplay controller
- * \param   a_configParam is the colorkey value if supported by display controller
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE a_c2dSurface, unsigned int a_displayConfig, unsigned int a_configParam);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Get current display surface
- *
- * \param   a_display is the C2D_DISPLAY
- * \param   a_c2dSurface is the pointer to the C2D_SURFACE where surface id is stored
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dGetCurrentDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE *a_c2dSurface);
-
-/*-------------------------------------------------------------------*//*!
- * \external
- * \brief   Set dither
- *
- * \param   a_c2dContext is the C2D_CONTEXT
- * \param   a_bEnable int, enable or disable the effect of dither
- * \return  C2D_STATUS
- *//*-------------------------------------------------------------------*/ 
-C2D_API C2D_STATUS c2dSetDither(C2D_CONTEXT a_c2dContext, int a_bEnable);
-
-C2D_API C2D_STATUS c2dWaitIrq(C2D_CONTEXT a_c2dContext, unsigned int *Count, unsigned int timeout);
-C2D_API C2D_STATUS c2dLibOpen(void);
-C2D_API C2D_STATUS c2dLibClose(void);
-
-C2D_API C2D_STATUS c2dTranslatePhysaddr(void* virtAddr, unsigned int* physAddr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __c2d_api_h_ */
diff --git a/libcopybit/copybit.cpp b/libcopybit/copybit.cpp
deleted file mode 100755
index 1f2a630..0000000
--- a/libcopybit/copybit.cpp
+++ /dev/null
@@ -1,510 +0,0 @@
- /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#define LOG_TAG "copybit"
-
-#include <cutils/log.h>
- 
-#include <c2d_api.h>
-
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-
-#include <hardware/copybit.h>
-
-#include "gralloc_priv.h"
-
-
-/******************************************************************************/
-#define MAX_SCALE_FACTOR    (8)
-#define MDP_ALPHA_NOP 0xff
-/******************************************************************************/
-
-/* mFlags bit define */
-enum {
-    /* flip source image horizontally */
-    C2D_FLIP_H    = HAL_TRANSFORM_FLIP_H,
-    /* flip source image vertically */
-    C2D_FLIP_V    = HAL_TRANSFORM_FLIP_V,
-    /* enable or disable dithering */
-    C2D_DITHER = 0x4,
-    /* enable or disable alpha blend */
-    C2D_ALPHA_BLEND = 0x8,
-};
-
-/** State information for each device instance */
-struct copybit_context_t {
-    struct copybit_device_t device;
-    C2D_CONTEXT c2dctx;
-    int     mCache;
-    uint32_t mAlpha;
-    uint32_t mRotate;    
-    uint32_t mFlags;
-};
-
-
-/**
- * Common hardware methods
- */
-
-static int open_copybit(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device);
-
-static struct hw_module_methods_t copybit_module_methods = {
-    open:  open_copybit
-};
-
-/*
- * The COPYBIT Module
- */
-struct copybit_module_t HAL_MODULE_INFO_SYM = {
-    common: {
-        tag: HARDWARE_MODULE_TAG,
-        version_major: 1,
-        version_minor: 0,
-        id: COPYBIT_HARDWARE_MODULE_ID,
-        name: "C2D Z160 COPYBIT Module",
-        author: "Freescale, Inc.",
-        methods: &copybit_module_methods
-    }
-};
-
-/*****************************************************************************/
-/** check pixel alpha */
-static bool hasAlpha(int format) {
-    switch (format) {
-    case COPYBIT_FORMAT_RGBA_8888:
-    case COPYBIT_FORMAT_BGRA_8888:
-    case COPYBIT_FORMAT_RGBA_5551:
-    case COPYBIT_FORMAT_RGBA_4444:
-        return true;
-    default:
-        return false;
-    }
-}
-
-/** min of int a, b */
-static inline int min(int a, int b) {
-    return (a<b) ? a : b;
-}
-
-/** max of int a, b */
-static inline int max(int a, int b) {
-    return (a>b) ? a : b;
-}
-
-/** scale each parameter by mul/div. Assume div isn't 0 */
-static inline void MULDIV(int *a, int *b, int mul, int div) {
-    if (mul != div) {
-        *a = (mul * *a) / div;
-        *b = (mul * *b) / div;
-    }
-}
-
-/** Determine the intersection of lhs & rhs store in out */
-static void intersect(struct copybit_rect_t *out,
-                      const struct copybit_rect_t *lhs,
-                      const struct copybit_rect_t *rhs) {
-    out->l = max(lhs->l, rhs->l);
-    out->t = max(lhs->t, rhs->t);
-    out->r = min(lhs->r, rhs->r);
-    out->b = min(lhs->b, rhs->b);
-}
-
-/** Set a parameter to value */
-static int set_parameter_copybit(
-        struct copybit_device_t *dev,
-        int name,
-        int value) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    int status = 0;
-    if (ctx) {
-        switch(name) {
-        case COPYBIT_ROTATION_DEG:
-            switch (value) {
-            case 0:
-            case 90:
-            case 180:
-            case 270:
-                ctx->mRotate = value;
-                break;
-            default:
-                LOGE("Invalid value for COPYBIT_ROTATION");
-                status = -EINVAL;
-                break;
-            }
-            break;
-        case COPYBIT_PLANE_ALPHA:
-            if (value < 0)      value = 0;
-            if (value >= 256)   value = 255;
-                ctx->mAlpha = value;
-            break;
-        case COPYBIT_DITHER:
-            if (value == COPYBIT_ENABLE) {
-                ctx->mFlags |= C2D_DITHER;
-            } else if (value == COPYBIT_DISABLE) {
-                ctx->mFlags &= ~C2D_DITHER;
-            }
-            break;
-        case COPYBIT_TRANSFORM:
-            switch (value) {
-            case 0:
-                ctx->mRotate = 0;
-                break;            
-            case COPYBIT_TRANSFORM_ROT_90:
-                ctx->mRotate = 90;
-                break;
-            case COPYBIT_TRANSFORM_ROT_180:
-                ctx->mRotate = 180;
-                break;
-            case COPYBIT_TRANSFORM_ROT_270:
-                ctx->mRotate = 270;
-                break;
-            case COPYBIT_TRANSFORM_FLIP_H:
-                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
-                ctx->mFlags |= C2D_FLIP_H;
-                break;
-            case COPYBIT_TRANSFORM_FLIP_V:
-                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
-                ctx->mFlags |= C2D_FLIP_V;
-                break;
-            default:
-                LOGE("Invalid value for COPYBIT_ROTATION");
-                status = -EINVAL;
-                break;
-            }
-            break;        
-        case COPYBIT_BLUR:
-            LOGE("Not support for COPYBIT_BLUR");
-            status = -EINVAL;
-            break;
-        default:
-            status = -EINVAL;
-            break;
-        }
-    } else {
-        status = -EINVAL;
-    }
-    return status;
-}
-
-/** Get a static info value */
-static int get(struct copybit_device_t *dev, int name) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    int value;
-    if (ctx) {
-        switch(name) {
-        case COPYBIT_MINIFICATION_LIMIT:
-            value = MAX_SCALE_FACTOR;
-            break;
-        case COPYBIT_MAGNIFICATION_LIMIT:
-            value = MAX_SCALE_FACTOR;
-            break;
-        case COPYBIT_SCALING_FRAC_BITS:
-            value = 32;
-            break;
-        case COPYBIT_ROTATION_STEP_DEG:
-            value = 90;
-            break;
-        default:
-            value = -EINVAL;
-        }
-    } else {
-        value = -EINVAL;
-    }
-    return value;
-}
-
-/** convert COPYBIT_FORMAT to C2D format */
-static C2D_COLORFORMAT get_format(int format) {
-    switch (format) {
-	case COPYBIT_FORMAT_RGBA_8888:     return C2D_COLOR_8888_ABGR;    
-    case COPYBIT_FORMAT_RGB_565:       return C2D_COLOR_0565;
-    case COPYBIT_FORMAT_RGBA_5551:     return C2D_COLOR_5551_RGBA;
-    case COPYBIT_FORMAT_RGBA_4444:     return C2D_COLOR_4444_RGBA;
-    case COPYBIT_FORMAT_RGBX_8888:	   return C2D_COLOR_8888_ABGR; //work-around, C2D does not support RGBX
-    case COPYBIT_FORMAT_RGB_888:
-	   return C2D_COLOR_888; //work-around, C2D supports BGR not RGB in this case
-    case COPYBIT_FORMAT_BGRA_8888:	   return C2D_COLOR_8888;//work-around, C2D supports ARGB not BGRA in this case
-    case COPYBIT_FORMAT_YCbCr_422_SP:  
-    case COPYBIT_FORMAT_YCbCr_420_SP:
- 
-    default:                           return C2D_COLOR_0565;//work-around, C2D does not support YCbCr   
-    }
-}
-
-/** get  pixelbit from COPYBIT_FORMAT format */
-static int get_pixelbit(int format) {
-    switch (format) {
-    case COPYBIT_FORMAT_RGBA_8888:
-    case COPYBIT_FORMAT_RGBX_8888:
-    case COPYBIT_FORMAT_BGRA_8888:     return 32;
-    case COPYBIT_FORMAT_RGB_888:       return 24;
-    case COPYBIT_FORMAT_RGB_565:
-    case COPYBIT_FORMAT_RGBA_5551:
-    case COPYBIT_FORMAT_RGBA_4444:     return 16;
-    case COPYBIT_FORMAT_YCbCr_422_SP:
-    case COPYBIT_FORMAT_YCbCr_420_SP:
-    default:                           return 8;
-    }
-}
-
-/** do convert of image to c2d surface **/
-static void image_to_surface(copybit_image_t const *img, C2D_SURFACE_DEF *surfaceDef) 
-{
-    private_handle_t* hnd = (private_handle_t*)img->handle;
-    surfaceDef->format = get_format(img->format);
-    surfaceDef->width =  img->w;
-    surfaceDef->height = img->h;
-
-	//make sure stride is 32 pixel aligned
-    surfaceDef->stride = ((img->w + 31) & ~31)*get_pixelbit(img->format)>>3;
-
-    surfaceDef->buffer = (void *)hnd->phys;
-    surfaceDef->host = (void *)hnd->base;
-    surfaceDef->flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-}
-
-/** setup rectangles */
-static void set_rects(struct copybit_context_t *dev,
-                      C2D_RECT *srcRect,
-                      C2D_RECT *dstRect,
-                      const struct copybit_rect_t *dst,
-                      const struct copybit_rect_t *src,
-                      const struct copybit_rect_t *scissor,
-                      copybit_image_t const *img) {
-    struct copybit_rect_t clip;
-    intersect(&clip, scissor, dst);
-
-    dstRect->x  = clip.l;
-    dstRect->y  = clip.t;
-    dstRect->width  = clip.r - clip.l;
-    dstRect->height  = clip.b - clip.t;
-
-    uint32_t W, H;
-    if ((dev->mRotate == 90) || ((dev->mRotate == 270))) {
-        srcRect->x = (clip.t - dst->t) + src->t;
-        srcRect->y = (dst->r - clip.r) + src->l;
-        srcRect->width = (clip.b - clip.t);
-        srcRect->height = (clip.r - clip.l);
-        W = dst->b - dst->t;
-        H = dst->r - dst->l;
-    } else {
-        srcRect->x  = (clip.l - dst->l) + src->l;
-        srcRect->y  = (clip.t - dst->t) + src->t;
-        srcRect->width  = (clip.r - clip.l);
-        srcRect->height  = (clip.b - clip.t);
-        W = dst->r - dst->l;
-        H = dst->b - dst->t;
-    }
-    MULDIV(&srcRect->x, &srcRect->width, src->r - src->l, W);
-    MULDIV(&srcRect->y, &srcRect->height, src->b - src->t, H);
-
-    if ((dev->mRotate == 180) || ((dev->mRotate == 270))) {
-        srcRect->y = src->b - src->t - (srcRect->y + srcRect->height);
-        srcRect->x = src->r - src->l - (srcRect->x + srcRect->width);
-    }
-}
-
-/** do a stretch blit type operation */
-static int stretch_copybit(
-        struct copybit_device_t *dev,
-        struct copybit_image_t const *dst,
-        struct copybit_image_t const *src,
-        struct copybit_rect_t const *dst_rect,
-        struct copybit_rect_t const *src_rect,
-        struct copybit_region_t const *region) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    C2D_SURFACE_DEF srcSurfaceDef;
-    C2D_SURFACE_DEF dstSurfaceDef;
-    C2D_SURFACE srcSurface;
-    C2D_SURFACE dstSurface;    
-    C2D_RECT srcRect;
-    C2D_RECT dstRect;
-    int status = 0;
-
-    if (ctx) {
-        if (ctx->mAlpha < 255) {
-            switch (src->format) {
-                // we don't support plane alpha with below formats
-                case COPYBIT_FORMAT_RGBX_8888:
-                case COPYBIT_FORMAT_RGB_888:
-                case COPYBIT_FORMAT_BGRA_8888:
-                case COPYBIT_FORMAT_YCbCr_422_SP:
-                case COPYBIT_FORMAT_YCbCr_420_SP:
-                    return -EINVAL;
-            }
-        }
-
-        if (src_rect->l < 0 || src_rect->r > src->w ||
-            src_rect->t < 0 || src_rect->b > src->h) {
-            // this is always invalid
-            LOGE("src_rect invalid");
-            return -EINVAL;
-        }
-
-        const struct copybit_rect_t bounds = { 0, 0, dst->w, dst->h };
-        struct copybit_rect_t clip;
-        status = 0;
-
-
-        image_to_surface(src, &srcSurfaceDef);
-        if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
-        {
-            LOGE("srcSurface c2dSurfAlloc fail");
-            return -EINVAL;
-        }
-                
-        image_to_surface(dst, &dstSurfaceDef);
-        if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
-        {
-            LOGE("dstSurface c2dSurfAlloc fail");
-            c2dSurfFree(ctx->c2dctx, srcSurface);
-            return -EINVAL;
-        }
-
-
-        c2dSetSrcSurface(ctx->c2dctx, srcSurface);
-        c2dSetDstSurface(ctx->c2dctx, dstSurface); 
-        c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
-        
-
-        //if (hasAlpha(src->format) || hasAlpha(dst->format))
-        if (hasAlpha(src->format) && (ctx->mFlags & C2D_ALPHA_BLEND))
-                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_SRCOVER);
-        else
-                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);
-                   
-        c2dSetGlobalAlpha(ctx->c2dctx, ctx->mAlpha);  
-        c2dSetDither(ctx->c2dctx, (ctx->mFlags & C2D_DITHER) > 0 ? 1:0); 
-
-        while ((status == 0) && region->next(region, &clip)) {          
-                intersect(&clip, &bounds, &clip);
-                set_rects(ctx, &srcRect, &dstRect, dst_rect, src_rect, &clip, src);
-                if (srcRect.width<=0 || srcRect.height<=0)
-                {
-                        LOGE("srcRect invalid");
-                        continue;
-                }
-                if (dstRect.width<=0 || dstRect.height<=0)
-                {
-                        LOGE("dstRect invalid");
-                        continue;
-                }
-
-                c2dSetSrcRectangle(ctx->c2dctx, &srcRect);
-                c2dSetDstRectangle(ctx->c2dctx, &dstRect);      
-                c2dDrawBlit(ctx->c2dctx); 
-        }
-
-		c2dFinish(ctx->c2dctx);
-		c2dSurfFree(ctx->c2dctx, srcSurface);
-		c2dSurfFree(ctx->c2dctx, dstSurface);
-
-    } 
-    else {
-        status = -EINVAL;
-    }
-
-
-    return status;
-}
-
-/** Perform a blit type operation */
-/* Pay attention, from now on blit_copybit will only work on C2D_ALPHA_BLEND_NONE mode,
- if need C2D_ALPHA_BLEND_SRCOVER mode pls use stretch_copybit */
-static int blit_copybit(
-        struct copybit_device_t *dev,
-        struct copybit_image_t const *dst,
-        struct copybit_image_t const *src,
-        struct copybit_region_t const *region) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    struct copybit_rect_t dr = { 0, 0, dst->w, dst->h };
-    struct copybit_rect_t sr = { 0, 0, src->w, src->h };
-    if (ctx->mFlags & C2D_ALPHA_BLEND)
-    {
-        int status = 0;
-        ctx->mFlags &= ~C2D_ALPHA_BLEND;
-        status = stretch_copybit(dev, dst, src, &dr, &sr, region);
-        ctx->mFlags |= C2D_ALPHA_BLEND;
-        return status;
-    }
-    else
-        return stretch_copybit(dev, dst, src, &dr, &sr, region);
-}
-
-/*****************************************************************************/
-
-/** Close the copybit device */
-static int close_copybit(struct hw_device_t *dev) 
-{
-    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
-    if (ctx) {
-        C2D_STATUS c2dstatus;
-        if (ctx->c2dctx != NULL)
-        	c2dstatus = c2dDestroyContext(ctx->c2dctx);
-        free(ctx);
-    }
-    return 0;
-}
-
-/** Open a new instance of a copybit device using name */
-static int open_copybit(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device)
-{
-    int status = -EINVAL;
-       
-    copybit_context_t *ctx;
-    ctx = (copybit_context_t *)malloc(sizeof(copybit_context_t));
-    memset(ctx, 0, sizeof(*ctx));
-
-    ctx->device.common.tag = HARDWARE_DEVICE_TAG;
-    ctx->device.common.version = 1;
-    ctx->device.common.module = const_cast<hw_module_t*>(module);
-    ctx->device.common.close = close_copybit;
-    ctx->device.set_parameter = set_parameter_copybit;
-    ctx->device.get = get;
-    ctx->device.blit = blit_copybit;
-    ctx->device.stretch = stretch_copybit;
-    ctx->mAlpha = MDP_ALPHA_NOP;
-    ctx->mFlags |= C2D_ALPHA_BLEND;
-     
-    C2D_STATUS c2dstatus;
-    c2dstatus = c2dCreateContext(&ctx->c2dctx);
-    if (c2dstatus != C2D_STATUS_OK)
-        close_copybit(&ctx->device.common);
-    else
-    {
-        *device = &ctx->device.common;
-        status = 0;
-    }
-
-    return status;
-}
diff --git a/libgralloc/Android.mk b/libgralloc/Android.mk
deleted file mode 100755
index 0f1fb2d..0000000
--- a/libgralloc/Android.mk
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-ifeq ($(BOARD_SOC_CLASS),IMX5X)
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libcutils libGLESv1_CM libipu
-ifeq ($(BOARD_SOC_TYPE),IMX50)
-LOCAL_SHARED_LIBRARIES += libc2d_z160
-else
-LOCAL_SHARED_LIBRARIES += libc2d_z430
-endif
-LOCAL_C_INCLUDES += external/linux-lib/ipu
-LOCAL_C_INCLUDES += hardware/mx5x/libcopybit
-
-LOCAL_SRC_FILES := 	\
-	allocator.cpp 	\
-	gralloc.cpp 	\
-	framebuffer.cpp \
-	mapper.cpp
-	
-LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
-LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).gralloc\" -D_LINUX
-
-
-ifeq ($(HAVE_FSL_EPDC_FB),true)
-LOCAL_CFLAGS += -DFSL_EPDC_FB
-endif
-
-ifeq ($(HAVE_FSL_IMX_IPU),true)
-LOCAL_CFLAGS += -DSECOND_DISPLAY_SUPPORT
-endif
-
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-endif
diff --git a/libgralloc/allocator.cpp b/libgralloc/allocator.cpp
deleted file mode 100755
index 4dad6a1..0000000
--- a/libgralloc/allocator.cpp
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cutils/log.h>
-
-#include "allocator.h"
-
-
-// align all the memory blocks on a cache-line boundary
-const int SimpleBestFitAllocator::kMemoryAlign = 32;
-
-SimpleBestFitAllocator::SimpleBestFitAllocator()
-    : mHeapSize(0)
-{
-}
-
-SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
-    : mHeapSize(0)
-{
-    setSize(size);
-}
-
-SimpleBestFitAllocator::~SimpleBestFitAllocator()
-{
-    while(!mList.isEmpty()) {
-        delete mList.remove(mList.head());
-    }
-}
-
-ssize_t SimpleBestFitAllocator::setSize(size_t size)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize != 0) return -EINVAL;
-    size_t pagesize = getpagesize();
-    mHeapSize = ((size + pagesize-1) & ~(pagesize-1));
-    chunk_t* node = new chunk_t(0, mHeapSize / kMemoryAlign);
-    mList.insertHead(node);
-    return size;
-}
-    
-    
-size_t SimpleBestFitAllocator::size() const
-{
-    return mHeapSize;
-}
-
-ssize_t SimpleBestFitAllocator::allocate(size_t size, uint32_t flags)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize == 0) return -EINVAL;
-    ssize_t offset = alloc(size, flags);
-    return offset;
-}
-
-ssize_t SimpleBestFitAllocator::deallocate(size_t offset)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize == 0) return -EINVAL;
-    chunk_t const * const freed = dealloc(offset);
-    if (freed) {
-        return 0;
-    }
-    return -ENOENT;
-}
-
-ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
-{
-    if (size == 0) {
-        return 0;
-    }
-    size = (size + kMemoryAlign-1) / kMemoryAlign;
-    chunk_t* free_chunk = 0;
-    chunk_t* cur = mList.head();
-
-    size_t pagesize = getpagesize();
-    while (cur) {
-        int extra = ( -cur->start & ((pagesize/kMemoryAlign)-1) ) ;
-
-        // best fit
-        if (cur->free && (cur->size >= (size+extra))) {
-            if ((!free_chunk) || (cur->size < free_chunk->size)) {
-                free_chunk = cur;
-            }
-            if (cur->size == size) {
-                break;
-            }
-        }
-        cur = cur->next;
-    }
-
-    if (free_chunk) {
-        const size_t free_size = free_chunk->size;
-        free_chunk->free = 0;
-        free_chunk->size = size;
-        if (free_size > size) {
-            int extra = ( -free_chunk->start & ((pagesize/kMemoryAlign)-1) ) ;
-            if (extra) {
-                chunk_t* split = new chunk_t(free_chunk->start, extra);
-                free_chunk->start += extra;
-                mList.insertBefore(free_chunk, split);
-            }
-
-            LOGE_IF(((free_chunk->start*kMemoryAlign)&(pagesize-1)),
-                    "page is not aligned!!!");
-
-            const ssize_t tail_free = free_size - (size+extra);
-            if (tail_free > 0) {
-                chunk_t* split = new chunk_t(
-                        free_chunk->start + free_chunk->size, tail_free);
-                mList.insertAfter(free_chunk, split);
-            }
-        }
-        return (free_chunk->start)*kMemoryAlign;
-    }
-    return -ENOMEM;
-}
-
-SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
-{
-    start = start / kMemoryAlign;
-    chunk_t* cur = mList.head();
-    while (cur) {
-        if (cur->start == start) {
-            LOG_FATAL_IF(cur->free,
-                "block at offset 0x%08lX of size 0x%08lX already freed",
-                cur->start*kMemoryAlign, cur->size*kMemoryAlign);
-
-            // merge freed blocks together
-            chunk_t* freed = cur;
-            cur->free = 1;
-            do {
-                chunk_t* const p = cur->prev;
-                chunk_t* const n = cur->next;
-                if (p && (p->free || !cur->size)) {
-                    freed = p;
-                    p->size += cur->size;
-                    mList.remove(cur);
-                    delete cur;
-                }
-                cur = n;
-            } while (cur && cur->free);
-
-            #ifndef NDEBUG
-                if (!freed->free) {
-                    dump_l("dealloc (!freed->free)");
-                }
-            #endif
-            LOG_FATAL_IF(!freed->free,
-                "freed block at offset 0x%08lX of size 0x%08lX is not free!",
-                freed->start * kMemoryAlign, freed->size * kMemoryAlign);
-
-            return freed;
-        }
-        cur = cur->next;
-    }
-    return 0;
-}
diff --git a/libgralloc/allocator.h b/libgralloc/allocator.h
deleted file mode 100755
index b0d89e9..0000000
--- a/libgralloc/allocator.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#ifndef GRALLOC_ALLOCATOR_H_
-#define GRALLOC_ALLOCATOR_H_
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "gr.h"
-
-// ----------------------------------------------------------------------------
-
-/*
- * A simple templatized doubly linked-list implementation
- */
-
-template <typename NODE>
-class LinkedList
-{
-    NODE*  mFirst;
-    NODE*  mLast;
-
-public:
-                LinkedList() : mFirst(0), mLast(0) { }
-    bool        isEmpty() const { return mFirst == 0; }
-    NODE const* head() const { return mFirst; }
-    NODE*       head() { return mFirst; }
-    NODE const* tail() const { return mLast; }
-    NODE*       tail() { return mLast; }
-
-    void insertAfter(NODE* node, NODE* newNode) {
-        newNode->prev = node;
-        newNode->next = node->next;
-        if (node->next == 0) mLast = newNode;
-        else                 node->next->prev = newNode;
-        node->next = newNode;
-    }
-
-    void insertBefore(NODE* node, NODE* newNode) {
-         newNode->prev = node->prev;
-         newNode->next = node;
-         if (node->prev == 0)   mFirst = newNode;
-         else                   node->prev->next = newNode;
-         node->prev = newNode;
-    }
-
-    void insertHead(NODE* newNode) {
-        if (mFirst == 0) {
-            mFirst = mLast = newNode;
-            newNode->prev = newNode->next = 0;
-        } else {
-            newNode->prev = 0;
-            newNode->next = mFirst;
-            mFirst->prev = newNode;
-            mFirst = newNode;
-        }
-    }
-    
-    void insertTail(NODE* newNode) {
-        if (mLast == 0) {
-            insertHead(newNode);
-        } else {
-            newNode->prev = mLast;
-            newNode->next = 0;
-            mLast->next = newNode;
-            mLast = newNode;
-        }
-    }
-
-    NODE* remove(NODE* node) {
-        if (node->prev == 0)    mFirst = node->next;
-        else                    node->prev->next = node->next;
-        if (node->next == 0)    mLast = node->prev;
-        else                    node->next->prev = node->prev;
-        return node;
-    }
-};
-
-class SimpleBestFitAllocator
-{
-public:
-
-    SimpleBestFitAllocator();
-    SimpleBestFitAllocator(size_t size);
-    ~SimpleBestFitAllocator();
-
-    ssize_t     setSize(size_t size);
-
-    ssize_t     allocate(size_t size, uint32_t flags = 0);
-    ssize_t     deallocate(size_t offset);
-    size_t      size() const;
-
-private:
-    struct chunk_t {
-        chunk_t(size_t start, size_t size) 
-            : start(start), size(size), free(1), prev(0), next(0) {
-        }
-        size_t              start;
-        size_t              size : 28;
-        int                 free : 4;
-        mutable chunk_t*    prev;
-        mutable chunk_t*    next;
-    };
-
-    ssize_t  alloc(size_t size, uint32_t flags);
-    chunk_t* dealloc(size_t start);
-
-    static const int    kMemoryAlign;
-    mutable Locker      mLock;
-    LinkedList<chunk_t> mList;
-    size_t              mHeapSize;
-};
-
-#endif /* GRALLOC_ALLOCATOR_H_ */
diff --git a/libgralloc/framebuffer.cpp b/libgralloc/framebuffer.cpp
deleted file mode 100755
index 4e3441b..0000000
--- a/libgralloc/framebuffer.cpp
+++ /dev/null
@@ -1,1698 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2010-2011 Freescale Semiconductor Inc. */
-
-#include <sys/mman.h>
-
-#include <dlfcn.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/ioctl.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-
-#if HAVE_ANDROID_OS
-#include <linux/fb.h>
-#include <linux/mxcfb.h>
-#include <linux/videodev.h>
-#include <sys/mman.h>
-
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-#endif
-#include <GLES/gl.h>
-#include <c2d_api.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-#include "gralloc_priv.h"
-#include "gr.h"
-#define  MAX_RECT_NUM   20
-/*****************************************************************************/
-
-// numbers of buffers for page flipping
-#define NUM_BUFFERS 3
-
-enum {
-    PAGE_FLIP = 0x00000001,
-    LOCKED = 0x00000002
-};
-
-struct fb_context_t {
-    framebuffer_device_t  device;
-#ifdef FSL_EPDC_FB
-    //Partial udate feature
-    bool rect_update;
-    int count;      //count need less than MAX_RECT_NUM ;
-    int updatemode[20];
-    int partial_left[20];
-    int partial_top[20];
-    int partial_width[20];
-    int partial_height[20];
-#endif
-#ifdef SECOND_DISPLAY_SUPPORT
-    bool sec_display_inited;
-    int sec_fp;
-    int sec_disp_w;
-    int sec_disp_h;
-    int sec_disp_base;
-    int sec_disp_phys;
-    int sec_frame_size;
-    int sec_disp_next_buf;
-    struct fb_var_screeninfo sec_info;
-    struct fb_fix_screeninfo sec_finfo;
-    struct framebuffer_device_t* dev;
-    buffer_handle_t buffer;
-    sem_t sec_display_begin;
-    sem_t sec_display_end;
-    pthread_t thread_id;
-    C2D_CONTEXT c2dctx;
-    int sec_rotation;
-    int cleancount;
-    int mRotate;
-#endif
-};
-
-static int nr_framebuffers;
-static int no_ipu = 0;
-
-#ifdef SECOND_DISPLAY_SUPPORT
-#define MAX_SEC_DISP_WIDTH (1024)
-#define MAX_SEC_DISP_HEIGHT (1024)
-static int mapSecFrameBuffer(fb_context_t* ctx);
-static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx);
-static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx);
-void * secDispShowFrames(void * arg);
-#endif
-
-#ifdef FSL_EPDC_FB
-#define WAVEFORM_MODE_INIT                      0x0   // Screen goes to white (clears)
-#define WAVEFORM_MODE_DU                        0x1   // Grey->white/grey->black
-#define WAVEFORM_MODE_GC16                      0x2   // High fidelity (flashing)
-#define WAVEFORM_MODE_GC4                       0x3   //
-//#define WAVEFORM_MODE_AUTO                    257  // defined in mxcfb.h
-
-
-#define EINK_WAVEFORM_MODE_INIT      0x00000000
-#define EINK_WAVEFORM_MODE_DU        0x00000001
-#define EINK_WAVEFORM_MODE_GC16      0x00000002
-#define EINK_WAVEFORM_MODE_GC4       0x00000003
-#define EINK_WAVEFORM_MODE_AUTO      0x00000004
-#define EINK_WAVEFORM_MODE_MASK      0x0000000F
-#define EINK_AUTO_MODE_REGIONAL      0x00000000
-#define EINK_AUTO_MODE_AUTOMATIC     0x00000010
-#define EINK_AUTO_MODE_MASK          0x00000010
-#define EINK_UPDATE_MODE_PARTIAL     0x00000000
-#define EINK_UPDATE_MODE_FULL        0x00000020
-#define EINK_UPDATE_MODE_MASK        0x00000020
-#define EINK_WAIT_MODE_NOWAIT        0x00000000
-#define EINK_WAIT_MODE_WAIT          0x00000040
-#define EINK_WAIT_MODE_MASK          0x00000040
-#define EINK_COMBINE_MODE_NOCOMBINE  0x00000000
-#define EINK_COMBINE_MODE_COMBINE    0x00000080
-#define EINK_COMBINE_MODE_MASK       0x00000080
-#define EINK_DITHER_MODE_NODITHER    0x00000000
-#define EINK_DITHER_MODE_DITHER      0x00000100
-#define EINK_DITHER_MODE_MASK        0x00000100
-#define EINK_INVERT_MODE_NOINVERT    0x00000000
-#define EINK_INVERT_MODE_INVERT      0x00000200
-#define EINK_INVERT_MODE_MASK        0x00000200
-#define EINK_CONVERT_MODE_NOCONVERT  0x00000000
-#define EINK_CONVERT_MODE_CONVERT    0x00000400
-#define EINK_CONVERT_MODE_MASK       0x00000400
-
-#define EINK_DEFAULT_MODE            0x00000004
-
-__u32 marker_val = 1;
-static void update_to_display(int left, int top, int width, int height, int updatemode, int fb_dev)
-{
-	struct mxcfb_update_data upd_data;
-	int retval;
-	bool wait_for_complete;
-	int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-	memset(&upd_data, 0, sizeof(mxcfb_update_data));
-
-    LOGI("update_to_display:left=%d, top=%d, width=%d, height=%d updatemode=%d\n", left, top, width, height,updatemode);
-
-
-    if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_DU)
-	   upd_data.waveform_mode = WAVEFORM_MODE_DU;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC4)
-	   upd_data.waveform_mode = WAVEFORM_MODE_GC4;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC16)
-	   upd_data.waveform_mode = WAVEFORM_MODE_GC16;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_AUTO)
-	   upd_data.waveform_mode = WAVEFORM_MODE_AUTO;
-	else 
-        LOGI("waveform_mode  wrong\n");
-	   
-    if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_REGIONAL)
-        auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-    else if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_AUTOMATIC)
-        auto_update_mode = AUTO_UPDATE_MODE_AUTOMATIC_MODE;
-    else 
-        LOGI("wait_for_complete  wrong\n");
-        
-    if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_PARTIAL)
-        upd_data.update_mode = UPDATE_MODE_PARTIAL;
-    else if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_FULL)
-        upd_data.update_mode = UPDATE_MODE_FULL;
-    else
-        LOGI("update_mode  wrong\n");
-
-    if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_NOWAIT)
-        wait_for_complete = false;
-    else if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_WAIT)
-        wait_for_complete = true;
-    else 
-        LOGI("wait_for_complete  wrong\n");
-
-    if((updatemode & EINK_INVERT_MODE_MASK) == EINK_INVERT_MODE_INVERT)
-	{
-	   upd_data.flags |= EPDC_FLAG_ENABLE_INVERSION;
-       LOGI("invert mode \n");
-    }
-
-	retval = ioctl(fb_dev, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
-	if (retval < 0) {
-		LOGI("set auto update mode failed.  Error = 0x%x", retval);
-	}    
-    
-    upd_data.temp = 24; //the temperature is get from linux team
-	upd_data.update_region.left = left;
-	upd_data.update_region.width = width;
-	upd_data.update_region.top = top;
-	upd_data.update_region.height = height;
-
-	if (wait_for_complete) {
-		/* Get unique marker value */
-		upd_data.update_marker = marker_val++;
-	} else {
-		upd_data.update_marker = 0;
-	}
-
-	retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
-	while (retval < 0) {
-		/* We have limited memory available for updates, so wait and
-		 * then try again after some updates have completed */
-		usleep(300000);
-		retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
-        LOGI("MXCFB_SEND_UPDATE  retval = 0x%x try again maybe", retval);
-	}
-
-	if (wait_for_complete) {
-		/* Wait for update to complete */
-		retval = ioctl(fb_dev, MXCFB_WAIT_FOR_UPDATE_COMPLETE, &upd_data.update_marker);
-		if (retval < 0) {
-			LOGI("Wait for update complete failed.  Error = 0x%x", retval);
-		}
-	}
-
-
-}
-#endif
-
-
-sem_t * fslwatermark_sem_open()
-{
-    int fd;
-    int ret;
-    sem_t *pSem = NULL;
-    char *shm_path, shm_file[256];
-
-    shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */ 
-
-    if (shm_path == NULL)
-        strcpy(shm_file, "/dev/shm");   /* default path */
-    else
-        strcpy(shm_file, shm_path);
-
-    strcat(shm_file, "/"); 
-    strcat(shm_file, "codec.shm");
-
-    fd = open(shm_file, O_RDWR, 0666);
-    if (fd < 0) { 
-        /* first thread/process need codec protection come here */
-        fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0666);
-       if(fd < 0)
-       {
-           return NULL;
-       }
-       ftruncate(fd, sizeof(sem_t));
-
-       /* map the semaphore variant in the file */ 
-       pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-       if((void *)(-1) == pSem)
-       {
-           return NULL;
-       }
-       /* do the semaphore initialization */
-       ret = sem_init(pSem, 0, 1);
-       if(-1 == ret)
-       {
-           return NULL;
-       }
-    }
-    else
-      pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-
-    close(fd);
-
-    return pSem;
-}
-
-
-/*****************************************************************************/
-
-static int fb_setSwapInterval(struct framebuffer_device_t* dev,
-            int interval)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
-        return -EINVAL;
-    // FIXME: implement fb_setSwapInterval
-    return 0;
-}
-
-#ifdef FSL_EPDC_FB
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int* left, int* top, int* width, int* height, int* updatemode, int count)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if(count > MAX_RECT_NUM)
-    {
-        LOGE("count > MAX_RECT_NUM in fb_setUpdateRect\n");
-        return -EINVAL;
-    }
-
-    ctx->rect_update      = true;
-    ctx->count            = 0;
-    for(int i=0; i < count; i++)
-    {
-        if (((width[i]|height[i]) <= 0) || ((left[i]|top[i])<0))  return -EINVAL;
-        ctx->updatemode[i]       = updatemode[i];
-        ctx->partial_left[i]     = left[i];
-        ctx->partial_top[i]      = top[i];
-        ctx->partial_width[i]    = width[i];
-        ctx->partial_height[i]   = height[i];
-    }
-    ctx->count            = count;
-    return 0;
-}
-#else
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int l, int t, int w, int h)
-{
-    if (((w|h) <= 0) || ((l|t)<0))
-        return -EINVAL;
-    return 0;
-}
-
-#ifdef SECOND_DISPLAY_SUPPORT
-static int fb_setSecRotation(struct framebuffer_device_t* dev,int secRotation)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    //LOGI("fb_setSecRotation %d",secRotation);
-    if((ctx->sec_rotation != secRotation)&&(ctx->sec_disp_base != 0))      
-       memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-    ctx->sec_rotation = secRotation;
-    switch(secRotation)
-    {
-    case 4:
-       ctx->mRotate = 90;
-       break;
-    case 3:
-       ctx->mRotate = 180;
-       break;
-    case 7:
-       ctx->mRotate = 270;
-       break;
-    case 0:
-    default:
-       ctx->mRotate = 0;
-       break;
-    }
-    return 0;
-}
-#endif
-#endif
-
-
-
-static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
-{
-    if (private_handle_t::validate(buffer) < 0)
-        return -EINVAL;
-
-    fb_context_t* ctx = (fb_context_t*)dev;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    if (m->currentBuffer) {
-        m->base.unlock(&m->base, m->currentBuffer);
-        m->currentBuffer = 0;
-    }
-
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-
-        m->base.lock(&m->base, buffer, 
-                private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), NULL);
-
-        const size_t offset = hnd->base - m->framebuffer->base;
-        m->info.activate = FB_ACTIVATE_VBL;
-        m->info.yoffset = offset / m->finfo.line_length;
-
-        #ifdef SECOND_DISPLAY_SUPPORT
-        //Check the prop rw.SECOND_DISPLAY_CONNECTED
-        char value[PROPERTY_VALUE_MAX];
-     
-        property_get("rw.SECOND_DISPLAY_CONNECTED", value, "");
-        if (strcmp(value, "1") == 0) {
-            if(!ctx->sec_display_inited) {
-                //Init the second display
-                if(mapSecFrameBuffer(ctx)== 0)
-                {    
-                    ctx->sec_display_inited = true;
-                    c2dCreateContext(&ctx->c2dctx); 
-
-                    sem_init(&ctx->sec_display_begin, 0, 0);
-                    sem_init(&ctx->sec_display_end, 0, 0);
-                     
-                    pthread_create(&ctx->thread_id, NULL, &secDispShowFrames, (void *)ctx);
-                                        
-                    //Set the prop rw.SECOND_DISPLAY_ENABLED to 1
-                    LOGI("sys.SECOND_DISPLAY_ENABLED Set to 1");
-                    property_set("sys.SECOND_DISPLAY_ENABLED", "1");
-                }
-            }
-
-            if(ctx->sec_display_inited) {
-                //Resize the primary display to the second display
-                ctx->dev = dev;
-                ctx->buffer = buffer;
-                sem_post(&ctx->sec_display_begin);
-            }
-        }
-        else{
-            if(ctx->sec_display_inited) {
-                
-                ctx->sec_display_inited = false;
-                
-                sem_post(&ctx->sec_display_begin);
-                sem_wait(&ctx->sec_display_end);
-                
-                sem_destroy(&ctx->sec_display_begin);
-                sem_destroy(&ctx->sec_display_end);
-                
-                if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
-                
-                //Set the prop rw.SECOND_DISPLAY_ENABLED to 0
-                LOGI("Switch back to display 0");
-                LOGI("sys.SECOND_DISPLAY_ENABLED Set to 0");
-                property_set("sys.SECOND_DISPLAY_ENABLED", "0");
-                memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-                //unmap the sec_disp_base
-                munmap((void *)ctx->sec_disp_base, ctx->sec_frame_size*nr_framebuffers);
-                ctx->sec_disp_base = 0;
-                //DeInit the second display
-                if(ctx->sec_fp) {
-                    int fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0); 
-                    if(fp_property >= 0) {
-                        char overlayStr[32];
-                        int blank;
-                        int fb2_fp;
-			struct fb_var_screeninfo fb0_var;
-
-                        blank = 1;
-
-                        fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
-                        if (fb2_fp < 0){
-                            LOGE("Error!Cannot open the /dev/graphics/fb2");
-                        }
-                        else{
-                            if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
-                        		LOGI("Error!BLANK FB2 failed!\n");
-                        	}
-                            close(fb2_fp);
-                        }
-
-                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!BLANK FB1 failed!\n");
-                    	}
-                    
-                        if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!BLANK FB0 failed!\n");
-                    	}
-
-                        memset(overlayStr, 0 ,32);
-                        strcpy(overlayStr, "1-layer-fb\n");
-                        LOGI("WRITE 1-layer-fb to fb1/fsl_disp_property");
-                        write(fp_property, overlayStr, strlen(overlayStr)+1);
-                        close(fp_property);
-
-                        blank = FB_BLANK_POWERDOWN;
-                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!BLANK FB1 failed!\n");
-                    	}
-                        blank = FB_BLANK_UNBLANK;
-                    	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!UNBLANK FB0 failed!\n");
-                    	}
-
-			if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO,
-				  &fb0_var) < 0) {
-                            LOGE("Error!Cannot get var info for fb0");
-			}
-
-			if (fb0_var.bits_per_pixel == 32) {
-				struct mxcfb_loc_alpha l_alpha;
-
-				l_alpha.enable = true;
-				l_alpha.alpha_in_pixel = true;
-				if (ioctl(m->framebuffer->fd, MXCFB_SET_LOC_ALPHA,
-				            &l_alpha) < 0) {
-				    LOGE("Error!MXCFB_SET_LOC_ALPHA failed!");
-				}
-			} else {
-				struct mxcfb_gbl_alpha gbl_alpha;
-	                        struct mxcfb_color_key key;
-
-				gbl_alpha.alpha = 255;
-				gbl_alpha.enable = 1;
-				if (ioctl(m->framebuffer->fd, MXCFB_SET_GBL_ALPHA,
-					  &gbl_alpha) < 0) {
-				    LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
-				}
-
-	                        key.enable = 1;
-	                        key.color_key = 0x00000000; // Black
-	                        LOGI("MXCFB_SET_CLR_KEY");
-	                        if( ioctl(m->framebuffer->fd, MXCFB_SET_CLR_KEY,
-					  &key) < 0)
-	                        {
-	                            LOGE("Error!MXCFB_SET_CLR_KEY for fb0");
-	                        }
-			}
-                    }
-                    close(ctx->sec_fp);
-                    ctx->sec_fp = 0;
-                }
-            }
-        }
-
-        #endif
-
-        if (ioctl(m->framebuffer->fd, FBIOPAN_DISPLAY, &m->info) == -1) {
-            LOGE("FBIOPAN_DISPLAY failed");
-            m->base.unlock(&m->base, buffer); 
-            return -errno;
-        }
-
-    #ifdef SECOND_DISPLAY_SUPPORT
-        if(ctx->sec_display_inited) sem_wait(&ctx->sec_display_end);
-    #endif
-
-#ifdef FSL_EPDC_FB
-        if(ctx->rect_update) {
-            for(int i=0; i < ctx->count; i++)
-            {
-                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
-                              ctx->partial_width[i],ctx->partial_height[i],
-                              ctx->updatemode[i],m->framebuffer->fd);
-            }
-
-            ctx->rect_update = false;
-        }
-        else{
-            update_to_display(0,0,m->info.xres,m->info.yres,EINK_DEFAULT_MODE,m->framebuffer->fd);
-        }
-#endif
-
-        m->currentBuffer = buffer;
-        
-    } else {
-        // If we can't do the page_flip, just copy the buffer to the front 
-        // FIXME: use copybit HAL instead of memcpy
-        
-        void* fb_vaddr;
-        void* buffer_vaddr;
-        
-        m->base.lock(&m->base, m->framebuffer, 
-                GRALLOC_USAGE_SW_WRITE_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &fb_vaddr);
-
-        m->base.lock(&m->base, buffer, 
-                GRALLOC_USAGE_SW_READ_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &buffer_vaddr);
-
-        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres));
-
-#ifdef FSL_EPDC_FB
-        if(ctx->rect_update) {
-            for(int i=0; i < ctx->count; i++)
-            {
-                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
-                              ctx->partial_width[i],ctx->partial_height[i],
-                              ctx->updatemode[i],m->framebuffer->fd);
-            }
-
-            ctx->rect_update = false;
-        }
-        else{
-            update_to_display(0,0,m->info.xres,m->info.yres, EINK_DEFAULT_MODE ,m->framebuffer->fd);
-        }
-#endif
-
-        m->base.unlock(&m->base, buffer); 
-        m->base.unlock(&m->base, m->framebuffer); 
-    }
-    
-    return 0;
-}
-
-static int fb_compositionComplete(struct framebuffer_device_t* dev)
-{
-    glFinish();
-    return 0;
-}
-
-/*****************************************************************************/
-#define SINGLE_DISPLAY_CAPABILITY  (1920 * 1080 * 60)
-#define DUAL_DISPLAY_CAPABILITY    (1920 * 1080 * 30)
-
-typedef struct
-{
-	char* start;
-	char* end;
-	int width;
-	int height;
-	int freq;
-}
-disp_mode;
-
-static int str2int(char *p)
-{
-	int val = 0;
-	if(!p) return -1;
-
-	while(p[0] >= '0' && p[0] <= '9')
-	{
-		val = val * 10 + p[0] - '0';
-		p++;
-	}
-
-	return val;
-}
-
-typedef enum {
-    CHECK_NEXT_STATE,
-    FIND_WIDTH_STATE,
-    FIND_JOINT_STATE,
-    FIND_HEIGHT_STATE,
-    PREFIX_FREQ_STATE,
-    FREQUENCY_STATE,
-    FIND_NEWLINE_STATE
-}
-read_state;
-
-static disp_mode disp_mode_list[128];
-static int disp_mode_compare( const void *arg1, const void *arg2)
-{
-	disp_mode *dm1 = (disp_mode *)arg1;
-	disp_mode *dm2 = (disp_mode *)arg2;
-
-	if(dm1->width * dm1->height > dm2->width * dm2->height) return -1;
-	if(dm1->width * dm1->height == dm2->width * dm2->height)
-	{
-		return dm1->freq > dm2->freq ? -1 : 1;
-	}
-
-	return 1;
-}
-static char* find_available_mode(const char *mode_list, int dual_disp)
-{
-	int disp_threshold = 0;
-	int i,disp_mode_count = 0;
-	read_state state = CHECK_NEXT_STATE;
-	char *p = (char *)mode_list;
-
-    if(!p) return NULL;
-
-	while(p[0])
-	{
-		switch(state)
-		{
-		case CHECK_NEXT_STATE:
-			if(!strncmp(p, "D:", 2)
-				|| !strncmp(p, "S:", 2)
-				|| !strncmp(p, "U:", 2)
-				|| !strncmp(p, "V:", 2))
-			{
-				disp_mode_list[disp_mode_count].start = p;
-				state = FIND_WIDTH_STATE;
-				p+=2;
-			}
-			else p++;
-			break;
-		case FIND_WIDTH_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].width = str2int(p);
-				state = FIND_JOINT_STATE;
-			}
-			p++;
-			break;
-		case FIND_JOINT_STATE:
-			if(p[0] == 'x' || p[0] == 'X')
-			{
-				state = FIND_HEIGHT_STATE;
-			}
-			p++;
-			break;
-		case FIND_HEIGHT_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].height = str2int(p);
-				state = PREFIX_FREQ_STATE;
-			}
-			p++;
-			break;
-		case PREFIX_FREQ_STATE:
-			if(!strncmp(p, "p-", 2) || !strncmp(p, "i-", 2))
-			{
-				state = FREQUENCY_STATE;
-				p+=2;
-			}
-			else p++;
-			break;
-		case  FREQUENCY_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].freq = str2int(p);
-				state = FIND_NEWLINE_STATE;
-			}
-			p++;
-			break;
-		case FIND_NEWLINE_STATE:
-			if(p[0] == '\n')
-			{
-				disp_mode_list[disp_mode_count++].end = p+1;
-				state = CHECK_NEXT_STATE;
-                if(disp_mode_count >= sizeof(disp_mode_list)/sizeof(disp_mode_list[0])) goto check_mode_end;
-			}
-			p++;
-			break;
-		default:
-			p++;
-			break;
-		}
-	}
-
-check_mode_end:
-
-	qsort(&disp_mode_list[0], disp_mode_count, sizeof(disp_mode), disp_mode_compare);
-
-	disp_threshold = dual_disp ? DUAL_DISPLAY_CAPABILITY : SINGLE_DISPLAY_CAPABILITY;
-
-	for(i=0; i<disp_mode_count; i++)
-	{
-		if(disp_mode_list[i].width * disp_mode_list[i].height * disp_mode_list[i].freq <= disp_threshold)
-			break;
-	}
-
-	if(disp_mode_list[i].end) disp_mode_list[i].end[0] = 0;
-
-    return disp_mode_list[i].start;
-}
-
-static int set_graphics_fb_mode(int fb, int dual_disp)
-{
-    int size=0;
-    int fp_cmd=0;
-    int fp_mode=0;
-    int fp_modes=0;
-    char fb_mode[256];
-    char fb_modes[1024];
-    char cmd_line[1024];
-    char temp_name[256];
-    char *disp_mode=NULL;
-
-    char value[PROPERTY_VALUE_MAX];
-    property_get("ro.AUTO_CONFIG_DISPLAY", value, "0");
-    if (strcmp(value, "1") != 0)  return 0;
-
-    fp_cmd = open("/proc/cmdline",O_RDONLY, 0);
-    if(fp_cmd < 0) {
-        LOGI("Error! Cannot open /proc/cmdline");
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(cmd_line, 0, sizeof(cmd_line));
-    size = read(fp_cmd, cmd_line, sizeof(cmd_line));
-    if(size <= 0)
-    {
-        LOGI("Error! Cannot read /proc/cmdline");
-        goto set_graphics_fb_mode_error;
-    }
-
-    close(fp_cmd); fp_cmd = 0;
-
-    if(fb==0 && strstr(cmd_line, "di1_primary")) return 0;//XGA detected
-
-    sprintf(temp_name, "/sys/class/graphics/fb%d/modes", fb);
-    fp_modes = open(temp_name,O_RDONLY, 0);
-    if(fp_modes < 0) {
-        LOGI("Error! Cannot open %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(fb_modes, 0, sizeof(fb_modes));
-    size = read(fp_modes, fb_modes, sizeof(fb_modes));
-    if(size <= 0)
-    {
-        LOGI("Error! Cannot read %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    close(fp_modes); fp_modes = 0;
-
-    if(size == sizeof(fb_modes)) fb_modes[size -1] = 0;
-
-    disp_mode = find_available_mode(fb_modes, dual_disp);
-    if(!disp_mode)
-    {
-        LOGI("Error! Cannot find available mode for fb%d", fb);
-        goto set_graphics_fb_mode_error;
-    }
-
-    LOGI("find fb%d available mode %s", fb,disp_mode);
-
-    sprintf(temp_name, "/sys/class/graphics/fb%d/mode", fb);
-    fp_mode = open(temp_name,O_RDWR, 0);
-    if(fp_mode < 0) {
-        LOGI("Error! Cannot open %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(fb_mode, 0, sizeof(fb_mode));
-    size = read(fp_mode, fb_mode, sizeof(fb_mode));
-    if(size <= 0)
-    {
-        LOGI("Error! Cannot read %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    if(strncmp(fb_mode, disp_mode, strlen(fb_mode)))
-    {
-        write(fp_mode, disp_mode, strlen(disp_mode)+1);
-    }
-
-    close(fp_mode); fp_mode = 0;
-
-    return 0;
-
-set_graphics_fb_mode_error:
-
-    if(fp_modes > 0) close(fp_modes);
-    if(fp_mode > 0) close(fp_mode);
-    if(fp_cmd > 0) close(fp_cmd);
-
-    return -1;
-
-}
-
-int mapFrameBufferLocked(struct private_module_t* module)
-{
-    // already initialized...
-    if (module->framebuffer) {
-        return 0;
-    }
-        
-    char const * const device_template[] = {
-            "/dev/graphics/fb%u",
-            "/dev/fb%u",
-            0 };
-
-    int fd = -1;
-    int i=0;
-    char name[64];
-
-    char value[PROPERTY_VALUE_MAX];
-    property_get("ro.UI_TVOUT_DISPLAY", value, "");
-    if (strcmp(value, "1") != 0) {
-        set_graphics_fb_mode(0, 0);
-        while ((fd==-1) && device_template[i]) {
-            snprintf(name, 64, device_template[i], 0);
-            fd = open(name, O_RDWR, 0);
-            i++;
-        }
-    }
-    else{
-        set_graphics_fb_mode(1, 0);
-        while ((fd==-1) && device_template[i]) {
-            snprintf(name, 64, device_template[i], 1);
-            fd = open(name, O_RDWR, 0);
-            i++;
-        }
-    }
-
-    if (fd < 0)
-        return -errno;
-
-    struct fb_fix_screeninfo finfo;
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    struct fb_var_screeninfo info;
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-
-    if(info.bits_per_pixel == 32){
-        LOGW("32bpp setting of Framebuffer catched!");
-        /*
-         * Explicitly request BGRA 8/8/8
-         */
-        info.bits_per_pixel = 32;
-        info.red.offset     = 8;
-        info.red.length     = 8;
-        info.green.offset   = 16;
-        info.green.length   = 8;
-        info.blue.offset    = 24;
-        info.blue.length    = 8;
-        info.transp.offset  = 0;
-        info.transp.length  = 0;
-#ifndef FSL_EPDC_FB
-        /*
-         *  set the alpha in pixel
-         *  only when the fb set to 32bit
-         */
-        struct mxcfb_loc_alpha l_alpha;
-        l_alpha.enable = true;
-        l_alpha.alpha_in_pixel = true;
-        if (ioctl(fd, MXCFB_SET_LOC_ALPHA,
-                    &l_alpha) < 0) {
-            printf("Set local alpha failed\n");
-            close(fd);
-            return -errno;
-        }
-#endif
-    }
-    else{
-        /*
-         * Explicitly request 5/6/5
-         */
-        info.bits_per_pixel = 16;
-        info.red.offset     = 11;
-        info.red.length     = 5;
-        info.green.offset   = 5;
-        info.green.length   = 6;
-        info.blue.offset    = 0;
-        info.blue.length    = 5;
-        info.transp.offset  = 0;
-        info.transp.length  = 0;
-
-        if (!no_ipu) {
-            /* for the 16bit case, only involke the glb alpha */
-            struct mxcfb_gbl_alpha gbl_alpha;
-
-            gbl_alpha.alpha = 255;
-            gbl_alpha.enable = 1;
-            int ret = ioctl(fd, MXCFB_SET_GBL_ALPHA, &gbl_alpha);
-            if(ret <0) {
-	        LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
-	        return -1;
-            }
-
-            struct mxcfb_color_key key;
-            key.enable = 1;
-            key.color_key = 0x00000000; // Black
-            ret = ioctl(fd, MXCFB_SET_CLR_KEY, &key);
-            if(ret <0) {
-	        LOGE("Error!Colorkey setting failed for dev ");
-	        return -1;
-            }
-        }
-    }
-
-    /*
-     * Request nr_framebuffers screens (at lest 2 for page flipping)
-     */
-    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
-    info.xres_virtual = ALIGN_PIXEL(info.xres);
-    
-#ifdef FSL_EPDC_FB
-    info.bits_per_pixel = 16;
-    info.grayscale = 0;
-    info.yoffset = 0;
-#endif
-
-    uint32_t flags = PAGE_FLIP;
-    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        LOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
-    }
-
-    if (info.yres_virtual < ALIGN_PIXEL_128(info.yres) * 2) {
-        // we need at least 2 for page-flipping
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        LOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
-                info.yres_virtual, ALIGN_PIXEL_128(info.yres)*2);
-    }
-
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-#ifdef FSL_EPDC_FB
-    int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-    int retval = ioctl(fd, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
-    if (retval < 0) {
-	LOGE("Error! set auto update mode error!\n");
-	return -errno;
-    }
-
-    int scheme_mode = UPDATE_SCHEME_QUEUE_AND_MERGE;
-    retval = ioctl(fd, MXCFB_SET_UPDATE_SCHEME, &scheme_mode);
-    if (retval < 0) {
-	LOGE("Error! set update scheme error!\n");
-	return -errno;
-    }
-#endif
-    int refreshRate = 1000000000000000LLU /
-    (
-            uint64_t( info.upper_margin + info.lower_margin + info.yres )
-            * ( info.left_margin  + info.right_margin + info.xres )
-            * info.pixclock
-    );
-
-    if (refreshRate == 0) {
-        // bleagh, bad info from the driver
-        refreshRate = 60*1000;  // 60 Hz
-    }
-
-    if (int(info.width) <= 0 || int(info.height) <= 0) {
-        // the driver doesn't return that information
-        // default to 160 dpi
-        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
-        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
-    }
-
-    float xdpi = (info.xres * 25.4f) / info.width;
-    float ydpi = (info.yres * 25.4f) / info.height;
-    float fps  = refreshRate / 1000.0f;
-
-    LOGI(   "using (fd=%d)\n"
-            "id           = %s\n"
-            "xres         = %d px\n"
-            "yres         = %d px\n"
-            "xres_virtual = %d px\n"
-            "yres_virtual = %d px\n"
-            "bpp          = %d\n"
-            "r            = %2u:%u\n"
-            "g            = %2u:%u\n"
-            "b            = %2u:%u\n",
-            fd,
-            finfo.id,
-            info.xres,
-            info.yres,
-            info.xres_virtual,
-            info.yres_virtual,
-            info.bits_per_pixel,
-            info.red.offset, info.red.length,
-            info.green.offset, info.green.length,
-            info.blue.offset, info.blue.length
-    );
-
-    LOGI(   "width        = %d mm (%f dpi)\n"
-            "height       = %d mm (%f dpi)\n"
-            "refresh rate = %.2f Hz\n",
-            info.width,  xdpi,
-            info.height, ydpi,
-            fps
-    );
-
-
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    if (finfo.smem_len <= 0)
-        return -errno;
-
-
-    module->flags = flags;
-    module->info = info;
-    module->finfo = finfo;
-    module->xdpi = xdpi;
-    module->ydpi = ydpi;
-    module->fps = fps;
-
-    /*
-     * map the framebuffer
-     */
-
-    int err;
-    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-    module->framebuffer = new private_handle_t(dup(fd), fbSize,
-            private_handle_t::PRIV_FLAGS_USES_PMEM);
-
-    module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
-    module->bufferMask = 0;
-
-    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
-    if (vaddr == MAP_FAILED) {
-        LOGE("Error mapping the framebuffer (%s)", strerror(errno));
-        return -errno;
-    }
-    module->framebuffer->base = intptr_t(vaddr);
-    module->framebuffer->phys = intptr_t(finfo.smem_start);
-    memset(vaddr, 0, fbSize);
-    return 0;
-}
-
-static int mapFrameBuffer(struct private_module_t* module)
-{
-    pthread_mutex_lock(&module->lock);
-    int err = mapFrameBufferLocked(module);
-    pthread_mutex_unlock(&module->lock);
-    return err;
-}
-
-#ifdef SECOND_DISPLAY_SUPPORT
-static int mapSecFrameBuffer(fb_context_t* ctx)
-{
-    int retCode = 0;
-    int sec_fp = 0,fp_property = 0;
-    size_t fbSize = 0;
-    int blank;
-    void* vaddr = NULL;
-    struct mxcfb_gbl_alpha gbl_alpha;
-    struct mxcfb_color_key key; 
-    char overlayStr[32];
-    int fb2_fp;
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            ctx->device.common.module);
-
-    set_graphics_fb_mode(1,1);
-
-    sec_fp = open("/dev/graphics/fb1",O_RDWR, 0);
-    if (sec_fp < 0){
-        LOGE("Error!Cannot open the /dev/graphics/fb1 for second display");
-        goto disp_init_error;
-    }
-
-    //Switch overlay to second display after ipu deinit
-    //echo 1-layer-fb >  /sys/class/graphics/fb0/fsl_disp_property 
-    blank = 1;
-
-    fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
-    if (fb2_fp < 0){
-        LOGE("Error!Cannot open the /dev/graphics/fb2");
-        goto disp_init_error;
-    }
-    if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
-		LOGI("Error!BLANK FB0 failed!\n");
-        goto disp_init_error;
-	}
-    close(fb2_fp);
-
-	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
-		LOGI("Error!BLANK FB1 failed!\n");
-        goto disp_init_error;
-	}
-
-    if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
-		LOGI("Error!BLANK FB0 failed!\n");
-        goto disp_init_error;
-	}
-    
-    LOGI("Open fb0/fsl_disp_property");
-    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0); 
-    if(fp_property < 0) {
-         LOGI("Error!Cannot switch the overlay to second disp");
-         goto disp_init_error;
-    }
-    
-    memset(overlayStr, 0 ,32);
-    strcpy(overlayStr, "1-layer-fb\n");
-    LOGI("WRITE 1-layer-fb to fb0/fsl_disp_property");
-    write(fp_property, overlayStr, strlen(overlayStr)+1);
-    close(fp_property);
-
-    blank = FB_BLANK_UNBLANK;
-	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
-		LOGI("Error!UNBLANK FB1 failed!\n");
-        goto disp_init_error;
-	}
-
-	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
-		LOGI("Error!UNBLANK FB0 failed!\n");
-        goto disp_init_error;
-	}
-
-    struct fb_fix_screeninfo finfo;
-    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1)
-       goto disp_init_error;
-                
-    struct fb_var_screeninfo info;
-    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1)
-        goto disp_init_error;
-                
-    LOGI("Second display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
-         info.xres,info.xres_virtual,info.yres,info.yres_virtual);
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-                
-    /*
-    * Explicitly request 5/6/5
-    */
-    info.bits_per_pixel = 16;
-    info.nonstd = 0;
-    info.red.offset     = 11;
-    info.red.length     = 5;
-    info.green.offset   = 5;
-    info.green.length   = 6;
-    info.blue.offset    = 0;
-    info.blue.length    = 5;
-    info.transp.offset  = 0;
-    info.transp.length  = 0;
-    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
-    info.xres_virtual = ALIGN_PIXEL(info.xres);
-                        
-    if (ioctl(sec_fp, FBIOPUT_VSCREENINFO, &info) == -1) {
-        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1){
-        LOGE("Error!Second display FBIOGET_VSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1){
-        LOGE("Error!Second display FBIOGET_FSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if(finfo.smem_len <= 0)
-        goto disp_init_error;
-
-    fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  
-                   
-    vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, sec_fp, 0);
-    if (vaddr == MAP_FAILED) {
-        LOGE("Error!mapping the framebuffer (%s)", strerror(errno));
-        goto disp_init_error;
-    }
-
-    key.enable = 1;
-    key.color_key = 0x00000000; // Black
-    LOGI("MXCFB_SET_CLR_KEY");
-    if( ioctl(sec_fp, MXCFB_SET_CLR_KEY, &key) < 0)
-    {
-        LOGE("Error!MXCFB_SET_CLR_KEY");
-        goto disp_init_error;
-    }
-
-    gbl_alpha.alpha = 255;
-    gbl_alpha.enable = 1;
-    LOGI("MXCFB_SET_GBL_ALPHA");
-    if(ioctl(sec_fp, MXCFB_SET_GBL_ALPHA, &gbl_alpha) <0)
-    {
-        LOGI("Error!MXCFB_SET_GBL_ALPHA error");
-        goto disp_init_error;
-    }
-
-    ctx->sec_disp_base = intptr_t(vaddr);
-    ctx->sec_disp_phys = intptr_t(finfo.smem_start);
-    memset(vaddr, 0, fbSize);
-    ctx->sec_fp = sec_fp;
-    ctx->sec_disp_w = info.xres;
-    ctx->sec_disp_h = info.yres;
-    ctx->sec_frame_size = fbSize/nr_framebuffers;
-    ctx->sec_disp_next_buf = ((info.yoffset * nr_framebuffers / info.yres_virtual) + 1) % nr_framebuffers;
-    ctx->sec_info = info;
-    ctx->sec_finfo = finfo;
-#if 0
-    struct fb_fix_screeninfo fb0_finfo;
-    if (ioctl(m->framebuffer->fd, FBIOGET_FSCREENINFO, &fb0_finfo) == -1)
-       goto disp_init_error;
-                
-    struct fb_var_screeninfo fb0_info;
-    if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO, &fb0_info) == -1)
-        goto disp_init_error;
-                
-    LOGI("fb0_info display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
-         fb0_info.xres,fb0_info.xres_virtual,
-         fb0_info.yres,fb0_info.yres_virtual);
-
-    fb0_info.reserved[0] = 0;
-    fb0_info.reserved[1] = 0;
-    fb0_info.reserved[2] = 0;
-    fb0_info.xoffset = 0;
-    fb0_info.yoffset = 0;
-    fb0_info.activate = FB_ACTIVATE_NOW;
-                
-    /*
-    * Explicitly request 5/6/5
-    */
-    fb0_info.bits_per_pixel = 16;
-    fb0_info.nonstd = 0;
-    fb0_info.red.offset     = 11;
-    fb0_info.red.length     = 5;
-    fb0_info.green.offset   = 5;
-    fb0_info.green.length   = 6;
-    fb0_info.blue.offset    = 0;
-    fb0_info.blue.length    = 5;
-    fb0_info.transp.offset  = 0;
-    fb0_info.transp.length  = 0;
-    fb0_info.yres_virtual = ALIGN_PIXEL_128(fb0_info.yres) * nr_framebuffers;
-	fb0_info.xres_virtual = fb0_info.xres;
-#endif
-    if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
-        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
-        goto disp_init_error;
-    }
-
-    return 0;
-
- disp_init_error:
-    if(sec_fp) {
-        close(sec_fp);
-        sec_fp = 0;
-        ctx->sec_fp = 0;
-    }
-    return -1;
-}
-
-static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx)
-{
-    ipu_lib_input_param_t sIPUInputParam;   
-    ipu_lib_output_param_t sIPUOutputParam; 
-    ipu_lib_handle_t            sIPUHandle;
-    int iIPURet = 0;
-    memset(&sIPUInputParam,0,sizeof(sIPUInputParam));
-    memset(&sIPUOutputParam,0,sizeof(sIPUOutputParam));
-    memset(&sIPUHandle,0,sizeof(sIPUHandle));
-
-    //Setting input format
-    sIPUInputParam.width = ctx->device.width;
-    sIPUInputParam.height = ctx->device.height;
-
-    sIPUInputParam.input_crop_win.pos.x = 0;
-    sIPUInputParam.input_crop_win.pos.y = 0;  
-    sIPUInputParam.input_crop_win.win_w = ctx->device.width;
-    sIPUInputParam.input_crop_win.win_h = ctx->device.height;
-    sIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-    sIPUInputParam.user_def_paddr[0] = phys;
-        
-    //Setting output format
-    //Should align with v4l
-    sIPUOutputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-    sIPUOutputParam.width = ctx->sec_disp_w;
-    sIPUOutputParam.height = ctx->sec_disp_h;   
-    sIPUOutputParam.show_to_fb = 0;
-    //Output param should be same as input, since no resize,crop
-    sIPUOutputParam.output_win.pos.x = 0;
-    sIPUOutputParam.output_win.pos.y = 0;
-    sIPUOutputParam.output_win.win_w = ctx->sec_disp_w;
-    sIPUOutputParam.output_win.win_h = ctx->sec_disp_h;
-    
-    int output_w = 0;
-    int output_h = 0;
-    //Make sure the output w/h proportion is align with the primary display
-    if((ctx->sec_rotation == 0x0)||(ctx->sec_rotation == 0x3))
-    {
-        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.width/ctx->device.height){
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
-        }
-        else{
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
-        }
-    }
-    else{
-        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.height/ctx->device.width){
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
-        }
-        else{
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
-        }
-    }
-    sIPUOutputParam.output_win.pos.x = (ctx->sec_disp_w - sIPUOutputParam.output_win.win_w)/2;
-    sIPUOutputParam.output_win.pos.y = (ctx->sec_disp_h - sIPUOutputParam.output_win.win_h)/2;
-
-
-    //sIPUOutputParam.rot = 0;
-    sIPUOutputParam.rot = ctx->sec_rotation;
-    //LOGI("Sec Rotation %d",ctx->sec_rotation);
-
-    sIPUOutputParam.user_def_paddr[0] = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    //LOGI("Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-    //sIPUOutputParam.width,
-    //sIPUOutputParam.height,
-    //sIPUOutputParam.output_win.pos.x,
-    //sIPUOutputParam.output_win.pos.y,
-    //sIPUOutputParam.output_win.win_w,
-    //sIPUOutputParam.output_win.win_h,
-    //sIPUOutputParam.rot);
-                                         
-    //LOGI("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-    //sIPUInputParam.width,
-    //sIPUInputParam.height,
-    //sIPUInputParam.fmt,
-    //sIPUInputParam.input_crop_win.pos.x,
-    //sIPUInputParam.input_crop_win.pos.y,
-    //sIPUInputParam.input_crop_win.win_w,
-    //sIPUInputParam.input_crop_win.win_h);     
-        
-    iIPURet =  mxc_ipu_lib_task_init(&sIPUInputParam,NULL,&sIPUOutputParam,OP_NORMAL_MODE|TASK_VF_MODE,&sIPUHandle);
-    if (iIPURet < 0) {
-        LOGE("Error!mxc_ipu_lib_task_init failed mIPURet %d!",iIPURet);
-        return -1;
-    }  
-    //LOGI("mxc_ipu_lib_task_init success");
-    iIPURet = mxc_ipu_lib_task_buf_update(&sIPUHandle,phys,sIPUOutputParam.user_def_paddr[0],NULL,NULL,NULL);
-    if (iIPURet < 0) {
-        LOGE("Error!mxc_ipu_lib_task_buf_update failed mIPURet %d!",iIPURet);
-        mxc_ipu_lib_task_uninit(&sIPUHandle);
-        return -1;
-    }
-    //LOGI("mxc_ipu_lib_task_buf_update success");
-    mxc_ipu_lib_task_uninit(&sIPUHandle);
-
-    return 0;
-}
-
-/** convert HAL_PIXEL_FORMAT to C2D format */
-static C2D_COLORFORMAT get_format(int format) {
-    switch (format) {
-	case HAL_PIXEL_FORMAT_BGRA_8888:   return C2D_COLOR_8888;
-    case HAL_PIXEL_FORMAT_RGB_565:     return C2D_COLOR_0565;
-    default:                           return C2D_COLOR_0565;
-    }
-}
-
-/** get  pixelbit from HAL_PIXEL_FORMAT format */
-static int get_pixelbit(int format) {
-    switch (format) {
-    case HAL_PIXEL_FORMAT_BGRA_8888:   return 32;
-    case HAL_PIXEL_FORMAT_RGB_565:     return 16;
-    default:                           return 16;
-    }
-}
-
-static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx)
-{
-    C2D_SURFACE_DEF srcSurfaceDef;
-    C2D_SURFACE_DEF dstSurfaceDef;
-    C2D_SURFACE srcSurface;
-    C2D_SURFACE dstSurface; 
-    C2D_RECT dstRect;
-
-    if(!ctx || !ctx->c2dctx) return -1;
-
-    srcSurfaceDef.format = get_format(ctx->device.format);
-    srcSurfaceDef.width =  ctx->device.width;
-    srcSurfaceDef.height = ctx->device.height;
-
-	//make sure stride is 32 pixel aligned
-    srcSurfaceDef.stride = ((ctx->device.width + 31) & ~31)*get_pixelbit(ctx->device.format)>>3;
-
-    srcSurfaceDef.buffer = (void *)phys;
-    srcSurfaceDef.host = (void *)base;
-    srcSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-
-    if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
-    {
-        LOGE("srcSurface c2dSurfAlloc fail");
-        return -EINVAL;
-    }
-
-    dstSurfaceDef.format = get_format(HAL_PIXEL_FORMAT_RGB_565);
-    dstSurfaceDef.width =  ctx->sec_disp_w;
-    dstSurfaceDef.height = ctx->sec_disp_h;
-
-    //make sure stride is 32 pixel aligned
-    dstSurfaceDef.stride = ((ctx->sec_disp_w + 31) & ~31)*get_pixelbit(HAL_PIXEL_FORMAT_RGB_565)>>3;
-
-    dstSurfaceDef.buffer = (void *)ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    dstSurfaceDef.host = (void *)ctx->sec_disp_base + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    dstSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-
-    dstRect.x = dstRect.y = 0;
-    dstRect.width = dstSurfaceDef.width;
-    dstRect.height = dstSurfaceDef.height;
-                
-    if((ctx->mRotate == 0)||(ctx->mRotate == 180))
-    {
-        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
-            dstRect.width = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
-        }
-        else{
-            dstRect.height = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
-        }
-    }
-    else{
-        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
-            dstRect.width = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
-        }
-        else{
-            dstRect.height = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
-        }
-    }
-
-    dstRect.x = (ctx->sec_disp_w - dstRect.width)/2;
-    dstRect.y = (ctx->sec_disp_h - dstRect.height)/2;
-            
-    if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
-    {
-        LOGE("dstSurface c2dSurfAlloc fail");
-        c2dSurfFree(ctx->c2dctx, srcSurface);
-        return -EINVAL;
-    }
-
-    c2dSetSrcSurface(ctx->c2dctx, srcSurface);
-    c2dSetDstSurface(ctx->c2dctx, dstSurface); 
-    c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
-
-    c2dSetStretchMode(ctx->c2dctx, C2D_STRETCH_BILINEAR_SAMPLING);
-    c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);         
-    c2dSetDither(ctx->c2dctx, 0); 
- 
-    c2dSetDstRectangle(ctx->c2dctx, &dstRect);
-    c2dDrawBlit(ctx->c2dctx); 
-        
-    c2dFinish(ctx->c2dctx);
-    c2dSurfFree(ctx->c2dctx, srcSurface);
-    c2dSurfFree(ctx->c2dctx, dstSurface);
-
-    return 0;
-}
-
-void * secDispShowFrames(void * arg)
-{
-    private_module_t* m = NULL;
-    private_handle_t const* hnd = NULL;
-    fb_context_t* ctx = (fb_context_t*)arg;
-    
-    while(1)
-    {
-        sem_wait(&ctx->sec_display_begin);
-
-        if(!ctx->sec_display_inited)
-        {
-            sem_post(&ctx->sec_display_end);
-            break;
-        }
-
-        char value[PROPERTY_VALUE_MAX];
-        property_get("ro.secfb.disable-overlay", value, "0");
-        if (!strcmp(value, "1"))
-        {
-            property_get("media.VIDEO_PLAYING", value, "0");
-        }
-
-        if (strcmp(value, "1") == 0)
-        {
-            if(ctx->cleancount)
-            {
-                sem_post(&ctx->sec_display_end);
-                continue;
-            }
-
-            ctx->cleancount++;
-            memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-        }
-        else
-        {
-           ctx->cleancount = 0;
-        }
-
-        if(!ctx->cleancount)
-        {
-            hnd = reinterpret_cast<private_handle_t const*>(ctx->buffer);
-            m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
-
-            if(ctx->c2dctx != NULL)
-            {
-                resizeToSecFrameBuffer_c2d(hnd->base,
-                           m->framebuffer->phys + hnd->base - m->framebuffer->base,
-                           ctx);
-            }
-            else
-            {
-                resizeToSecFrameBuffer(hnd->base,
-                                   m->framebuffer->phys + hnd->base - m->framebuffer->base,
-                                   ctx);
-            }
-        }
-
-        sem_post(&ctx->sec_display_end);
-        
-        ctx->sec_info.yoffset = (ctx->sec_info.yres_virtual/nr_framebuffers) * ctx->sec_disp_next_buf;
-        ctx->sec_disp_next_buf = (ctx->sec_disp_next_buf + 1) % nr_framebuffers;
-        ctx->sec_info.activate = FB_ACTIVATE_VBL;
-
-        ioctl(ctx->sec_fp, FBIOPAN_DISPLAY, &ctx->sec_info);
-    }
-
-    return NULL;
-}
-
-#endif
-
-/*****************************************************************************/
-
-static int fb_close(struct hw_device_t *dev)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (ctx) {
-        free(ctx);
-    }
-    return 0;
-}
-
-int fb_device_open(hw_module_t const* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    char value[PROPERTY_VALUE_MAX];
-
-    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
-        alloc_device_t* gralloc_device;
-        framebuffer_device_t *fbdev;
-
-        nr_framebuffers = NUM_BUFFERS;
-        property_get("ro.product.device", value, "");
-        if (0 == strcmp(value, "imx50_rdp")) {
-            nr_framebuffers = 2;
-            no_ipu = 1;
-        }
-
-        status = gralloc_open(module, &gralloc_device);
-        if (status < 0)
-            return status;
-
-        /* initialize our state here */
-        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = fb_close;
-        dev->device.setSwapInterval = fb_setSwapInterval;
-        dev->device.post            = fb_post;
-        #ifndef FSL_EPDC_FB
-        dev->device.setUpdateRect = 0;
-        #else
-        dev->device.setUpdateRect = fb_setUpdateRect;
-        #endif
-        dev->device.compositionComplete = fb_compositionComplete;
-        #ifdef SECOND_DISPLAY_SUPPORT
-        dev->device.setSecRotation = fb_setSecRotation;
-        #endif
-
-        private_module_t* m = (private_module_t*)module;
-        status = mapFrameBuffer(m);
-        if (status >= 0) {
-            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
-            const_cast<uint32_t&>(dev->device.flags) = 0xfb0;
-            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
-            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
-            const_cast<int&>(dev->device.stride) = stride;
-            if(m->info.bits_per_pixel != 32) {
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
-            }
-            else{
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
-            }
-            const_cast<float&>(dev->device.xdpi) = m->xdpi;
-            const_cast<float&>(dev->device.ydpi) = m->ydpi;
-            const_cast<float&>(dev->device.fps) = m->fps;
-            const_cast<int&>(dev->device.minSwapInterval) = 1;
-            const_cast<int&>(dev->device.maxSwapInterval) = 1;
-            *device = &dev->device.common;
-            fbdev = (framebuffer_device_t*) *device;
-            fbdev->reserved[0] = nr_framebuffers;
-        }
-
-	/* initialize the IPU lib IPC */
-        if (!no_ipu)
-            mxc_ipu_lib_ipc_init();
-
-    fslwatermark_sem_open();
-
-    }
-    return status;
-}
diff --git a/libgralloc/gr.h b/libgralloc/gr.h
deleted file mode 100755
index 1775bfa..0000000
--- a/libgralloc/gr.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef GR_H_
-#define GR_H_
-
-#include <stdint.h>
-#ifdef HAVE_ANDROID_OS      // just want PAGE_SIZE define
-# include <asm/page.h>
-#else
-# include <sys/user.h>
-#endif
-#include <limits.h>
-#include <sys/cdefs.h>
-#include <hardware/gralloc.h>
-#include <pthread.h>
-#include <errno.h>
-
-#include <cutils/native_handle.h>
-
-/*****************************************************************************/
-
-struct private_module_t;
-struct private_handle_t;
-
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-int mapFrameBufferLocked(struct private_module_t* module);
-int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
-
-/*****************************************************************************/
-
-class Locker {
-    pthread_mutex_t mutex;
-public:
-    class Autolock {
-        Locker& locker;
-    public:
-        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
-        inline ~Autolock() { locker.unlock(); }
-    };
-    inline Locker()        { pthread_mutex_init(&mutex, 0); }
-    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
-    inline void lock()     { pthread_mutex_lock(&mutex); }
-    inline void unlock()   { pthread_mutex_unlock(&mutex); }
-};
-
-#endif /* GR_H_ */
diff --git a/libgralloc/gralloc.cpp b/libgralloc/gralloc.cpp
deleted file mode 100755
index f65099e..0000000
--- a/libgralloc/gralloc.cpp
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <limits.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-#include "allocator.h"
-
-#if HAVE_ANDROID_OS
-#include <linux/android_pmem.h>
-#endif
-
-/*****************************************************************************/
-
-static SimpleBestFitAllocator sAllocator;
-
-/*****************************************************************************/
-
-struct gralloc_context_t {
-    alloc_device_t  device;
-    /* our private data here */
-};
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle);
-
-/*****************************************************************************/
-
-int fb_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-static int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-extern int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr);
-
-extern int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle);
-
-extern int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-extern int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-/*****************************************************************************/
-
-static struct hw_module_methods_t gralloc_module_methods = {
-        open: gralloc_device_open
-};
-
-struct private_module_t HAL_MODULE_INFO_SYM = {
-    base: {
-        common: {
-            tag: HARDWARE_MODULE_TAG,
-            version_major: 1,
-            version_minor: 0,
-            id: GRALLOC_HARDWARE_MODULE_ID,
-            name: "Graphics Memory Allocator Module",
-            author: "The Android Open Source Project",
-            methods: &gralloc_module_methods
-        },
-        registerBuffer: gralloc_register_buffer,
-        unregisterBuffer: gralloc_unregister_buffer,
-        lock: gralloc_lock,
-        unlock: gralloc_unlock,
-    },
-    framebuffer: 0,
-    flags: 0,
-    numBuffers: 0,
-    bufferMask: 0,
-    lock: PTHREAD_MUTEX_INITIALIZER,
-    currentBuffer: 0,
-    pmem_master: -1,
-    pmem_master_base: 0,
-    master_phys: 0
-};
-
-/*****************************************************************************/
-
-static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-
-    // allocate the framebuffer
-    if (m->framebuffer == NULL) {
-        // initialize the framebuffer, the framebuffer is mapped once
-        // and forever.
-        int err = mapFrameBufferLocked(m);
-        if (err < 0) {
-            return err;
-        }
-    }
-
-    const uint32_t bufferMask = m->bufferMask;
-    const uint32_t numBuffers = m->numBuffers;
-    const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-    if (numBuffers == 1) {
-        // If we have only one buffer, we never use page-flipping. Instead,
-        // we return a regular buffer which will be memcpy'ed to the main
-        // screen when post is called.
-        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
-        pthread_mutex_unlock(&m->lock);
-        int ret = gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);
-        pthread_mutex_lock(&m->lock);
-        return ret;
-    }
-
-    if (bufferMask >= ((1LU<<numBuffers)-1)) {
-        // We ran out of buffers.
-        return -ENOMEM;
-    }
-
-    // create a "fake" handles for it
-    intptr_t vaddr = intptr_t(m->framebuffer->base);
-    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer->fd), size,
-            private_handle_t::PRIV_FLAGS_USES_PMEM |
-            private_handle_t::PRIV_FLAGS_FRAMEBUFFER);
-
-    // find a free slot
-    for (uint32_t i=0 ; i<numBuffers ; i++) {
-        if ((bufferMask & (1LU<<i)) == 0) {
-            m->bufferMask |= (1LU<<i);
-            break;
-        }
-        vaddr += bufferSize;
-    }
-    
-    hnd->base = vaddr;
-    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
-    hnd->phys = intptr_t(m->framebuffer->phys) + hnd->offset;
-    *pHandle = hnd;
-
-    return 0;
-}
-
-static int gralloc_alloc_framebuffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    pthread_mutex_lock(&m->lock);
-    int err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int init_pmem_area_locked(private_module_t* m)
-{
-    int err = 0;
-#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
-    int master_fd = open("/dev/pmem_gpu", O_RDWR, 0);
-    if (master_fd >= 0) {
-        
-        size_t size;
-        pmem_region region;
-        if (ioctl(master_fd, PMEM_GET_TOTAL_SIZE, &region) < 0) {
-            LOGE("PMEM_GET_TOTAL_SIZE failed, limp mode");
-            size = 8<<20;   // 8 MiB
-        } else {
-            size = region.len;
-        }
-        sAllocator.setSize(size);
-
-        void* base = mmap(0, size, 
-                PROT_READ|PROT_WRITE, MAP_SHARED, master_fd, 0);
-        if (base == MAP_FAILED) {
-            err = -errno;
-            base = 0;
-            close(master_fd);
-            master_fd = -1;
-        } else {
-            pmem_region region;
-            err = ioctl(master_fd, PMEM_GET_PHYS, &region);
-            if (err < 0) {
-                LOGE("PMEM_GET_PHYS failed (%s)", strerror(-errno));
-            } else {
-                m->master_phys = (unsigned long)region.offset;
-				LOGI("PMEM GPU enabled, size:%d, phys base:%x",size,m->master_phys);
-            }
-        }
-        m->pmem_master = master_fd;
-        m->pmem_master_base = base;
-    } else {
-        err = -errno;
-    }
-    return err;
-#else
-    return -1;
-#endif
-}
-
-static int init_pmem_area(private_module_t* m)
-{
-    pthread_mutex_lock(&m->lock);
-    int err = m->pmem_master;
-    if (err == -1) {
-        // first time, try to initialize pmem
-        err = init_pmem_area_locked(m);
-        if (err) {
-            m->pmem_master = err;
-        }
-    } else if (err < 0) {
-        // pmem couldn't be initialized, never use it
-    } else {
-        // pmem OK
-        err = 0;
-    }
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    int err = 0;
-    int flags = 0;
-
-    int fd = -1;
-    void* base = 0;
-    int offset = 0;
-    int lockState = 0;
-
-    size = roundUpToPageSize(size);
-    
-#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
-
-    if (usage & GRALLOC_USAGE_HW_TEXTURE) {
-        // enable pmem in that case, so our software GL can fallback to
-        // the copybit module.
-        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
-    }
-    
-    if (usage & GRALLOC_USAGE_HW_2D) {
-        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
-    }
-
-    if ((flags & private_handle_t::PRIV_FLAGS_USES_PMEM) == 0) {
-try_ashmem:
-        fd = ashmem_create_region("gralloc-buffer", size);
-        if (fd < 0) {
-            LOGE("couldn't create ashmem (%s)", strerror(-errno));
-            err = -errno;
-        }
-    } else {
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-
-        err = init_pmem_area(m);
-        if (err == 0) {
-            // PMEM buffers are always mmapped
-            base = m->pmem_master_base;
-            lockState |= private_handle_t::LOCK_STATE_MAPPED;
-
-            offset = sAllocator.allocate(size);
-            if (offset < 0) {
-                // no more pmem memory
-                err = -ENOMEM;
-            } else {
-                struct pmem_region sub = { offset, size };
-                
-                // now create the "sub-heap"
-                fd = open("/dev/pmem_gpu", O_RDWR, 0);
-                err = fd < 0 ? fd : 0;
-                
-                // and connect to it
-                if (err == 0)
-                    err = ioctl(fd, PMEM_CONNECT, m->pmem_master);
-
-                // and make it available to the client process
-                if (err == 0)
-                    err = ioctl(fd, PMEM_MAP, &sub);
-
-                if (err < 0) {
-                    err = -errno;
-                    close(fd);
-                    sAllocator.deallocate(offset);
-                    fd = -1;
-                }
-                //LOGD_IF(!err, "allocating pmem size=%d, offset=%d", size, offset);
-                memset((char*)base + offset, 0, size);
-            }
-        } else {
-            if ((usage & GRALLOC_USAGE_HW_2D) == 0) {
-                // the caller didn't request PMEM, so we can try something else
-                flags &= ~private_handle_t::PRIV_FLAGS_USES_PMEM;
-                err = 0;
-                goto try_ashmem;
-            } else {
-                LOGE("couldn't open pmem (%s)", strerror(-errno));
-            }
-        }
-    }
-
-#else // HAVE_ANDROID_OS
-    
-    fd = ashmem_create_region("Buffer", size);
-    if (fd < 0) {
-        LOGE("couldn't create ashmem (%s)", strerror(-errno));
-        err = -errno;
-    }
-
-#endif // HAVE_ANDROID_OS
-
-    if (err == 0) {
-        private_handle_t* hnd = new private_handle_t(fd, size, flags);
-        hnd->offset = offset;
-        hnd->base = int(base)+offset;
-        hnd->lockState = lockState;
-        if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
-            private_module_t* m = reinterpret_cast<private_module_t*>(
-                    dev->common.module);
-            hnd->phys = m->master_phys + offset;
-        }
-        *pHandle = hnd;
-    }
-    
-    LOGE_IF(err, "gralloc failed err=%s", strerror(-err));
-    
-    return err;
-}
-
-/*****************************************************************************/
-
-static int gralloc_alloc(alloc_device_t* dev,
-        int w, int h, int format, int usage,
-        buffer_handle_t* pHandle, int* pStride)
-{
-    if (!pHandle || !pStride)
-        return -EINVAL;
-
-    size_t size, alignedw, alignedh;
-    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || 
-            format == HAL_PIXEL_FORMAT_YCbCr_422_SP) 
-    {
-        // FIXME: there is no way to return the alignedh
-        alignedw = (w + 1) & ~1; 
-        switch (format) {
-            case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-                size = alignedw * h * 2;
-                break;
-            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-                alignedh = (h+1) & ~1;
-                size = (alignedw * alignedh) + (w/2 * h/2) * 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-    } else {
-        alignedw = ALIGN_PIXEL(w);
-        alignedh = ALIGN_PIXEL(h);
-        int bpp = 0;
-        switch (format) {
-            case HAL_PIXEL_FORMAT_RGBA_8888:
-            case HAL_PIXEL_FORMAT_RGBX_8888:
-            case HAL_PIXEL_FORMAT_BGRA_8888:
-                bpp = 4;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_888:
-                bpp = 3;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_565:
-            case HAL_PIXEL_FORMAT_RGBA_5551:
-            case HAL_PIXEL_FORMAT_RGBA_4444:
-                bpp = 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-        size = alignedw * alignedh * bpp;
-    }
-
-    int err;
-    if (usage & GRALLOC_USAGE_HW_FB) {
-        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);
-    } else {
-        err = gralloc_alloc_buffer(dev, size, usage, pHandle);
-    }
-
-    if (err < 0) {
-        return err;
-    }
-
-    *pStride = alignedw;
-    return 0;
-}
-
-static int gralloc_free(alloc_device_t* dev,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-        // free this buffer
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-        const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-        int index = (hnd->base - m->framebuffer->base) / bufferSize;
-        m->bufferMask &= ~(1<<index); 
-    } else { 
-#if HAVE_ANDROID_OS
-        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
-            if (hnd->fd >= 0) {
-                struct pmem_region sub = { hnd->offset, hnd->size };
-                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
-                LOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-                        "fd=%d, sub.offset=%lu, sub.size=%lu",
-                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
-                if (err == 0) {
-                    // we can't deallocate the memory in case of UNMAP failure
-                    // because it would give that process access to someone else's
-                    // surfaces, which would be a security breach.
-                    sAllocator.deallocate(hnd->offset);
-                }
-            }
-        }
-#endif // HAVE_ANDROID_OS
-        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>(
-                dev->common.module);
-        terminateBuffer(module, const_cast<private_handle_t*>(hnd));
-    }
-
-    close(hnd->fd);
-    delete hnd;
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int gralloc_close(struct hw_device_t *dev)
-{
-    gralloc_context_t* ctx = reinterpret_cast<gralloc_context_t*>(dev);
-    if (ctx) {
-        /* TODO: keep a list of all buffer_handle_t created, and free them
-         * all here.
-         */
-        free(ctx);
-    }
-    return 0;
-}
-
-int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
-        gralloc_context_t *dev;
-        dev = (gralloc_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = gralloc_close;
-
-        dev->device.alloc   = gralloc_alloc;
-        dev->device.free    = gralloc_free;
-
-        *device = &dev->device.common;
-        status = 0;
-    } else {
-        status = fb_device_open(module, name, device);
-    }
-    return status;
-}
diff --git a/libgralloc/gralloc_priv.h b/libgralloc/gralloc_priv.h
deleted file mode 100755
index 3801907..0000000
--- a/libgralloc/gralloc_priv.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef GRALLOC_PRIV_H_
-#define GRALLOC_PRIV_H_
-
-#include <stdint.h>
-#include <limits.h>
-#include <sys/cdefs.h>
-#include <hardware/gralloc.h>
-#include <pthread.h>
-#include <errno.h>
-#include <unistd.h>
-
-#include <cutils/native_handle.h>
-
-#include <linux/fb.h>
-
-#define  ALIGN_PIXEL(x)  ((x+ 31) & ~31)
-/** z430 core need 4k aligned memory, since xres has been 32 aligned, make yres
-    to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
-#define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
-/*****************************************************************************/
-
-struct private_module_t;
-struct private_handle_t;
-
-struct private_module_t {
-    gralloc_module_t base;
-
-    private_handle_t* framebuffer;
-    uint32_t flags;
-    uint32_t numBuffers;
-    uint32_t bufferMask;
-    pthread_mutex_t lock;
-    buffer_handle_t currentBuffer;
-    int pmem_master;
-    void* pmem_master_base;
-    unsigned long master_phys;
-
-    struct fb_var_screeninfo info;
-    struct fb_fix_screeninfo finfo;
-    float xdpi;
-    float ydpi;
-    float fps;
-    
-    enum {
-        // flag to indicate we'll post this buffer
-        PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
-    };
-};
-
-/*****************************************************************************/
-
-#ifdef __cplusplus
-struct private_handle_t : public native_handle {
-#else
-struct private_handle_t {
-    struct native_handle nativeHandle;
-#endif
-    
-    enum {
-        PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
-        PRIV_FLAGS_USES_PMEM   = 0x00000002,
-    };
-
-    enum {
-        LOCK_STATE_WRITE     =   1<<31,
-        LOCK_STATE_MAPPED    =   1<<30,
-        LOCK_STATE_READ_MASK =   0x3FFFFFFF
-    };
-
-    // file-descriptors
-    int     fd;
-    // ints
-    int     magic;
-    int     flags;
-    int     size;
-    int     offset;
-    int     gpu_fd; 
-
-    // FIXME: the attributes below should be out-of-line
-    int     base;
-    int     lockState;
-    int     writeOwner;
-    int     phys; // The physical address of that chunk of memory. If using ashmem, set to 0 They don't care
-    int     pid;
-
-#ifdef __cplusplus
-    static const int sNumInts = 10;
-    static const int sNumFds = 1;
-    static const int sMagic = 'pgpu';
-
-    private_handle_t(int fd, int size, int flags) :
-        fd(fd), magic(sMagic), flags(flags), size(size), offset(0),gpu_fd(-1),
-        base(0), lockState(0), writeOwner(0), phys(0),pid(getpid())
-    {
-        version = sizeof(native_handle);
-        numInts = sNumInts;
-        numFds = sNumFds;
-    }
-    ~private_handle_t() {
-        magic = 0;
-    }
-
-    bool usesPhysicallyContiguousMemory() {
-        return (flags & PRIV_FLAGS_USES_PMEM) != 0;
-    }
-
-    static int validate(const native_handle* h) {
-        const private_handle_t* hnd = (const private_handle_t*)h;
-        if (!h || h->version != sizeof(native_handle) ||
-                h->numInts != sNumInts || h->numFds != sNumFds ||
-                hnd->magic != sMagic) 
-        {
-            LOGE("invalid gralloc handle (at %p)", h);
-            return -EINVAL;
-        }
-        return 0;
-    }
-
-    static private_handle_t* dynamicCast(const native_handle* in) {
-        if (validate(in) == 0) {
-            return (private_handle_t*) in;
-        }
-        return NULL;
-    }
-#endif
-};
-
-#endif /* GRALLOC_PRIV_H_ */
diff --git a/libgralloc/mapper.cpp b/libgralloc/mapper.cpp
deleted file mode 100755
index e2caf79..0000000
--- a/libgralloc/mapper.cpp
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <limits.h>
-#include <errno.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-
-
-// we need this for now because pmem cannot mmap at an offset
-#define PMEM_HACK   1
-
-/* desktop Linux needs a little help with gettid() */
-#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
-#define __KERNEL__
-# include <linux/unistd.h>
-pid_t gettid() { return syscall(__NR_gettid);}
-#undef __KERNEL__
-#endif
-
-/*****************************************************************************/
-
-static int gralloc_map(gralloc_module_t const* module,
-        buffer_handle_t handle,
-        void** vaddr)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        size_t size = hnd->size;
-#if PMEM_HACK
-        size += hnd->offset;
-#endif
-        void* mappedAddress = mmap(0, size,
-                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
-        if (mappedAddress == MAP_FAILED) {
-            LOGE("Could not mmap %s", strerror(errno));
-            return -errno;
-        }
-        hnd->base = intptr_t(mappedAddress) + hnd->offset;
-        //LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", 
-        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
-    }
-    *vaddr = (void*)hnd->base;
-    return 0;
-}
-
-static int gralloc_unmap(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        void* base = (void*)hnd->base;
-        size_t size = hnd->size;
-#if PMEM_HACK
-        base = (void*)(intptr_t(base) - hnd->offset);
-        size += hnd->offset;
-#endif
-        //LOGD("unmapping from %p, size=%d", base, size);
-        if (munmap(base, size) < 0) {
-            LOGE("Could not unmap %s", strerror(errno));
-        }
-    }
-    hnd->base = 0;
-    return 0;
-}
-
-/*****************************************************************************/
-
-static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER; 
-
-/*****************************************************************************/
-
-int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    // In this implementation, we don't need to do anything here
-
-    /* NOTE: we need to initialize the buffer as not mapped/not locked
-     * because it shouldn't when this function is called the first time
-     * in a new process. Ideally these flags shouldn't be part of the
-     * handle, but instead maintained in the kernel or at least 
-     * out-of-line
-     */ 
-
-    // if this handle was created in this process, then we keep it as is.
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (hnd->pid != getpid()) {
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     * NOTE: the framebuffer is handled differently and is never unmapped.
-     */
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    
-    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[unregister] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-
-    // never unmap buffers that were created in this process
-    if (hnd->pid != getpid()) {
-        if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-            gralloc_unmap(module, handle);
-        }
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int terminateBuffer(gralloc_module_t const* module,
-        private_handle_t* hnd)
-{
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     */
-
-    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[terminate] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-    
-    if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-        // this buffer was mapped, unmap it now
-        if ((hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) && 
-            (hnd->pid == getpid())) {
-            // ... unless it's a "master" pmem buffer, that is a buffer
-            // mapped in the process it's been allocated.
-            // (see gralloc_alloc_buffer())
-        } else {
-            gralloc_unmap(module, hnd);
-        }
-    }
-
-    return 0;
-}
-
-int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    int err = 0;
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-    int retry;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // already locked for write 
-            LOGE("handle %p already locked for write", handle);
-            return -EBUSY;
-        } else if (current_value & private_handle_t::LOCK_STATE_READ_MASK) {
-            // already locked for read
-            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-                LOGE("handle %p already locked for read", handle);
-                return -EBUSY;
-            } else {
-                // this is not an error
-                //LOGD("%p already locked for read... count = %d", 
-                //        handle, (current_value & ~(1<<31)));
-            }
-        }
-
-        // not currently locked
-        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-            // locking for write
-            new_value |= private_handle_t::LOCK_STATE_WRITE;
-        }
-        new_value++;
-
-        retry = android_atomic_cmpxchg(current_value, new_value, 
-                (volatile int32_t*)&hnd->lockState);
-    } while (retry);
-
-    if (new_value & private_handle_t::LOCK_STATE_WRITE) {
-        // locking for write, store the tid
-        hnd->writeOwner = gettid();
-    }
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
-        if (!(current_value & private_handle_t::LOCK_STATE_MAPPED)) {
-            // we need to map for real
-            pthread_mutex_t* const lock = &sMapLock;
-            pthread_mutex_lock(lock);
-            if (!(hnd->lockState & private_handle_t::LOCK_STATE_MAPPED)) {
-                err = gralloc_map(module, handle, vaddr);
-                if (err == 0) {
-                    android_atomic_or(private_handle_t::LOCK_STATE_MAPPED,
-                            (volatile int32_t*)&(hnd->lockState));
-                }
-            }
-            pthread_mutex_unlock(lock);
-        }
-        *vaddr = (void*)hnd->base;
-    }
-
-    return err;
-}
-
-int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle)
-{
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // locked for write
-            if (hnd->writeOwner == gettid()) {
-                hnd->writeOwner = 0;
-                new_value &= ~private_handle_t::LOCK_STATE_WRITE;
-            }
-        }
-
-        if ((new_value & private_handle_t::LOCK_STATE_READ_MASK) == 0) {
-            LOGE("handle %p not locked", handle);
-            return -EINVAL;
-        }
-
-        new_value--;
-
-    } while (android_atomic_cmpxchg(current_value, new_value, 
-            (volatile int32_t*)&hnd->lockState));
-
-    return 0;
-}
diff --git a/liboverlay/overlay.cpp b/liboverlay/overlay.cpp
deleted file mode 100755
index be06a96..0000000
--- a/liboverlay/overlay.cpp
+++ /dev/null
@@ -1,2123 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <linux/videodev.h>
-#include <linux/fb.h>
-#include <sys/mman.h>
-#include <linux/mxcfb.h>
-
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-#include <hardware/hardware.h>
-#include <hardware/overlay.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/ashmem.h>
-#include <cutils/atomic.h>
-#include <time.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-#include <utils/List.h>
-#include <ui/PixelFormat.h>
-#include "overlay_utils.h"
-#include "overlay_pmem.h"
-
-static int bits_per_pixel(int32_t format);
-
-using namespace android;
-
-int fill_frame_back(char * frame,int frame_size, int xres, int yres, unsigned int pixelformat);
-
-
-/*****************************************************************************/
-class OverlayThread;
-class overlay_object;
-typedef struct
-{
-  uint32_t marker;
-  uint32_t size;
-  volatile int32_t refCnt;
-  int instance_id;
-  int crop_x;
-  int crop_y;
-  int crop_w;
-  int crop_h;
-  int num_buffer;
-  int free_count;
-  int free_head;
-  int free_tail;
-  unsigned int free_bufs[MAX_OVERLAY_BUFFER_NUM];//phy addr, FIFO queue
-  int queued_count;
-  int queued_head;
-  int queued_tail;
-  unsigned int queued_bufs[MAX_OVERLAY_BUFFER_NUM];//phy addr, FIFO queue
-  pthread_mutex_t obj_lock;
-  pthread_cond_t free_cond;
-  int wait_buf_flag;
-  unsigned int buf_showed;
-  int overlay_mode;
-  int in_destroy;
-  int buf_mixing;
-} overlay_data_shared_t;
-
-typedef struct
-{
-  uint32_t marker;
-  uint32_t size;
-  volatile int32_t refCnt;
-  sem_t overlay_sem;
-} overlay_control_shared_t;
-
-struct overlay_control_context_t {
-    struct overlay_control_device_t device;
-    /* our private state goes below here */
-    pthread_mutex_t control_lock;
-    overlay_object *overlay_intances[MAX_OVERLAY_INSTANCES];//Overlay device instance arrays
-    int overlay_instance_valid[MAX_OVERLAY_INSTANCES];
-    int overlay_number;//Overlay device instance number valid in instance arrays
-    OverlayThread *overlay_thread;//Overlay mixer thread
-    bool overlay_running;//Overlay mixer thread state
-    int control_shared_fd;
-    int control_shared_size;
-    overlay_control_shared_t *control_shared;
-    __u32 outpixelformat;
-    //foreground setting for fb0/1
-    int fb_dev;
-    int xres;//fb0/1's resolution
-    int yres;//fb0/1's resolution
-    //fb0/1's colorkey
-    int alpha_buf_size;
-    int cur_alpha_buffer;
-    OVERLAY_BUFFER alpha_buffers[DEFAULT_ALPHA_BUFFERS];//fb0/1's local alpha buffer
-
-    //tvout setting
-
-    //V4L setting
-    int v4l_id;//V4L Handler
-    bool stream_on;
-    char *v4lbuf_addr[MAX_V4L_BUFFERS];//V4L buffer arrays
-    struct v4l2_buffer v4l_buffers[MAX_V4L_BUFFERS];
-    int v4l_bufcount;//V4L buffer numbers
-    int video_frames;
-};
-
-struct handle_t;
-struct overlay_data_context_t {
-    struct overlay_data_device_t device;
-    /* our private state goes below here */
-    int control_shared_fd;//all overlay instances share the same control 
-    int control_shared_size;
-    int data_shared_fd;
-    int data_shared_size;
-    int width;
-    int height;
-    int32_t format;
-    int num_buffer;//Number of buffers for overlay
-    int queue_threshold;
-    int buf_size;
-    int buf_queued;
-    OverlayAllocator *allocator;
-    OVERLAY_BUFFER *overlay_buffer;
-    overlay_control_shared_t  *control_shared;
-    overlay_data_shared_t  *data_shared;
-};
-
-static int overlay_device_open(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device);
-
-static struct hw_module_methods_t overlay_module_methods = {
-    open: overlay_device_open
-};
-
-struct overlay_module_t HAL_MODULE_INFO_SYM = {
-    common: {
-        tag: HARDWARE_MODULE_TAG,
-        version_major: 1,
-        version_minor: 0,
-        id: OVERLAY_HARDWARE_MODULE_ID,
-        name: "FSL i.MX Overlay module",
-        author: "The Android Open Source Project",
-        methods: &overlay_module_methods,
-    }
-};
-
-static int  create_data_shared_data(overlay_data_shared_t **shared);
-static void destroy_data_shared_data(int shared_fd, overlay_data_shared_t *shared, bool closefd);
-static int  open_data_shared_data(overlay_data_context_t *ctx);
-static void close_data_shared_data(overlay_data_context_t *ctx);
-
-static int  create_control_shared_data(overlay_control_shared_t **shared);
-static void destroy_control_shared_data(int shared_fd, overlay_control_shared_t *shared, bool closefd);
-static int  open_control_shared_data(overlay_data_context_t *ctx);
-static void close_control_shared_data(overlay_data_context_t *ctx);
-
-/*****************************************************************************/
-
-
-struct handle_t : public native_handle {
-    /* add the data fields we need here, for instance: */
-    int control_shared_fd;
-    int data_shared_fd;
-    int control_shared_size;
-    int data_shared_size;
-    int width;
-    int height;
-    int32_t format;
-    int num_buffer;//Number of buffers for overlay
-    int buf_size;
-};
-
-/*
- * This is the overlay_t object, it is returned to the user and represents
- * an overlay.
- * This handles will be passed across processes and possibly given to other
- * HAL modules (for instance video decode modules).
- */
-
-class overlay_object : public overlay_t {
-    
-    static overlay_handle_t getHandleRef(struct overlay_t* overlay) {
-        /* returns a reference to the handle, caller doesn't take ownership */
-        overlay_handle_t retPtr = &(static_cast<overlay_object *>(overlay)->mHandle);
-        LOGI("getHandleRef return overlay_handle_t 0x%p",retPtr);
-        return retPtr;
-    }
-    
-public:
-    handle_t mHandle;
-    overlay_data_shared_t *mDataShared;
-    int rotation;
-    int outX;
-    int outY;
-    int outW;
-    int outH;
-    int zorder;//zorder for mutl-overlays
-    //Maybe need a lock here
-    int out_changed;
-
-    overlay_object(uint32_t w, uint32_t h, int32_t format,int control_fd, int control_size) {
-        OVERLAY_LOG_FUNC;
-        this->overlay_t::getHandleRef = getHandleRef;
-        this->overlay_t::format = format;
-        this->overlay_t::h = h;
-        this->overlay_t::h_stride = h;
-        this->overlay_t::w = w;
-        this->overlay_t::w_stride = w; 
-        
-        mHandle.version = sizeof(native_handle);
-        mHandle.width = w;
-        mHandle.height = h;
-        mHandle.format = format;
-        mHandle.num_buffer = DEFAULT_OVERLAY_BUFFER_NUM;
-        mHandle.numFds = 2;
-        mHandle.numInts = 7; // extra ints we have in  our handle
-        mHandle.buf_size = mHandle.width*mHandle.height*bits_per_pixel(format)/8;
-        
-        rotation = 0;
-        outX = 0;
-        outY = 0;
-        outW = 0;
-        outH = 0;
-        zorder = 0;//Should be set from Layerbase's drawing state
-
-        out_changed = 0;
-
-        //???creat share file for this obj
-        mHandle.data_shared_fd = create_data_shared_data(&mDataShared);
-        mHandle.data_shared_size = mDataShared->size;
-        //The control fd is opened in overlay hal init.
-        mHandle.control_shared_fd = control_fd;
-        mHandle.control_shared_size = control_size;
-
-        //init the crop setting
-        mDataShared->crop_x = 0;
-        mDataShared->crop_y = 0;
-        mDataShared->crop_w = mHandle.width&0xFFFFFFF8;
-        mDataShared->crop_h = mHandle.height&0xFFFFFFF8;
-        mDataShared->num_buffer = mHandle.num_buffer;
-        OVERLAY_LOG_INFO("num_buffer %d width %d,height %d,format %d,buf_size %d",
-         mHandle.num_buffer,mHandle.width,mHandle.height,
-         mHandle.format,mHandle.buf_size);
-
-    }
-    ~overlay_object(){
-        OVERLAY_LOG_INFO("~overlay_object()");
-        //???delete this share file;
-        destroy_data_shared_data(mHandle.data_shared_fd,mDataShared,true);
- 
-    }
-};
-
-#include "overlay_thread.h"
-
-
-/*
-*   Fill the rgb alpha buffer with alpha_val
-*/
-static int fill_alpha_buffer(void *alpha_buf, int buf_w,
-                             WIN_REGION *fill_region,char alpha_val);
-
-
-static int overlay_init_fbdev(struct overlay_control_context_t *dev);
-
-static int overlay_deinit_fbdev(struct overlay_control_context_t *dev);
-
-static int overlay_init_v4l(struct overlay_control_context_t *dev);
-
-static int overlay_deinit_v4l(struct overlay_control_context_t *dev);
-
-
-static int create_control_shared_data(overlay_control_shared_t **shared)
-{
-    OVERLAY_LOG_FUNC;
-    int fd;
-    // assuming sizeof(overlay_data_shared_t) < a single page
-    int size = (sizeof(overlay_control_shared_t) + getpagesize()-1) & ~(getpagesize()-1);
-    overlay_control_shared_t *p;
-
-    if ((fd = ashmem_create_region("overlay_control", size)) < 0) {
-        LOGE("Error!Failed to Create Overlay Shared control!\n");
-        return fd;
-    }
-
-    p = (overlay_control_shared_t*)mmap(NULL, size, PROT_READ | PROT_WRITE,
-                                MAP_SHARED, fd, 0);
-    if (p == MAP_FAILED) {
-        LOGE("Error!Failed to Map Overlay Shared control!\n");
-        close(fd);
-        return -1;
-    }
-
-    memset(p, 0, size);
-    p->marker = SHARED_CONTROL_MARKER;
-    p->size   = size;
-    p->refCnt = 1;
-
-    //Create the sem for control
-    if(sem_init(&p->overlay_sem, 1, 0) != 0){
-        OVERLAY_LOG_ERR("Error!init overlay_sem failed");
-        munmap(p, size);
-        close(fd);
-        return -1;
-    }
-
-    *shared = p;
-    return fd;
-}
-
-static void destroy_control_shared_data( int shared_fd, overlay_control_shared_t *shared, bool closefd )
-{
-    OVERLAY_LOG_FUNC;
-    if (shared == NULL)
-        return;
-
-    // Last side deallocated releases the mutex, otherwise the remaining
-    // side will deadlock trying to use an already released mutex
-    if (android_atomic_dec(&shared->refCnt) == 1) {
-        if (sem_destroy(&shared->overlay_sem)) {
-            OVERLAY_LOG_ERR("Error!Failed to Close Overlay control Semaphore!\n");
-        }
-        shared->marker = 0;
-    }
-
-    if (munmap(shared, shared->size)) {
-        OVERLAY_LOG_ERR("Error!Failed to Unmap Overlay Shared control!\n");
-    }
-
-    if (closefd && close(shared_fd)) {
-        OVERLAY_LOG_ERR("Error!Failed to Close Overlay Shared control!\n");
-    }
-}
-
-static int open_control_shared_data( overlay_data_context_t *ctx )
-{
-    OVERLAY_LOG_FUNC;
-    int rc   = -1;
-    int mode = PROT_READ | PROT_WRITE;
-    int fd   = ctx->control_shared_fd;
-    int size = ctx->control_shared_size;
-
-    if (ctx->control_shared != NULL) {
-        // Already open, return success
-        OVERLAY_LOG_ERR("Error!Overlay Shared Data Already Open\n");
-        return 0;
-    }
-    ctx->control_shared = (overlay_control_shared_t*)mmap(0, size, mode, MAP_SHARED, fd, 0);
-
-    if (ctx->control_shared == MAP_FAILED) {
-        OVERLAY_LOG_ERR("Error!Failed to Map Overlay Shared control!\n");
-    } else if ( ctx->control_shared->marker != SHARED_CONTROL_MARKER ) {
-        OVERLAY_LOG_ERR("Error!Invalid Overlay Shared control Marker!\n");
-        munmap( ctx->control_shared, size);
-    } else if ( (int)ctx->control_shared->size != size ) {
-        OVERLAY_LOG_ERR("Error!Invalid Overlay Shared control Size!\n");
-        munmap(ctx->control_shared, size);
-    } else {
-        android_atomic_inc(&ctx->control_shared->refCnt);
-        rc = 0;
-    }
-
-    return rc;
-}
-
-static void close_control_shared_data(overlay_data_context_t *ctx)
-{
-    OVERLAY_LOG_FUNC;
-    destroy_control_shared_data(ctx->control_shared_fd, ctx->control_shared, false);
-    ctx->control_shared = NULL;
-}
-
-static int create_data_shared_data(overlay_data_shared_t **shared)
-{
-    OVERLAY_LOG_FUNC;
-    int fd;
-    // assuming sizeof(overlay_data_shared_t) < a single page
-    int size = (sizeof(overlay_data_shared_t) + getpagesize()-1) & ~(getpagesize()-1);
-    overlay_data_shared_t *p;
-
-    if ((fd = ashmem_create_region("overlay_data", size)) < 0) {
-        OVERLAY_LOG_ERR("Error!Failed to Create Overlay Shared Data!\n");
-        return fd;
-    }
-
-    p = (overlay_data_shared_t*)mmap(NULL, size, PROT_READ | PROT_WRITE,
-                                MAP_SHARED, fd, 0);
-    if (p == MAP_FAILED) {
-        OVERLAY_LOG_ERR("Error!Failed to Map Overlay Shared Data!\n");
-        close(fd);
-        return -1;
-    }
-
-    memset(p, 0, size);
-    p->marker = SHARED_DATA_MARKER;
-    p->size   = size;
-    p->refCnt = 1;
-
-    pthread_mutexattr_t mutex_attr;
-    pthread_mutexattr_init(&mutex_attr);
-    pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
-    if (pthread_mutex_init(&p->obj_lock, &mutex_attr) != 0) {
-        OVERLAY_LOG_ERR("Error!Failed to Open Overlay Lock!\n");
-        munmap(p, size);
-        close(fd);
-        return -1;
-    }
-
-    pthread_condattr_t cond_attr;
-    pthread_condattr_init(&cond_attr);
-    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);
-    if (pthread_cond_init(&p->free_cond, &cond_attr) != 0) {
-        OVERLAY_LOG_ERR("Error!Failed to Open Overlay Lock!\n");
-        pthread_mutex_destroy(&p->obj_lock);
-        munmap(p, size);
-        close(fd);
-        return -1;
-    }
-
-    *shared = p;
-    return fd;
-}
-
-static void destroy_data_shared_data( int shared_fd, overlay_data_shared_t *shared, bool closefd )
-{
-    OVERLAY_LOG_INFO("destroy_data_shared_data shared %p closefd %d",shared,closefd);
-    if (shared == NULL)
-        return;
-
-    // Last side deallocated releases the mutex, otherwise the remaining
-    // side will deadlock trying to use an already released mutex
-    if (android_atomic_dec(&shared->refCnt) == 1) {
-        if (pthread_mutex_destroy(&shared->obj_lock)) {
-            OVERLAY_LOG_ERR("Error!Failed to Close Overlay Semaphore!\n");
-        }
-        //???delete this cond;
-        if (pthread_cond_destroy(&shared->free_cond)) {
-            OVERLAY_LOG_ERR("Error!Failed to Close Overlay Semaphore!\n");
-        }
-
-        shared->marker = 0;
-    }
-
-    if (munmap(shared, shared->size)) {
-        OVERLAY_LOG_ERR("Error!Failed to Unmap Overlay Shared Data!\n");
-    }
-
-    if (closefd && close(shared_fd)) {
-        OVERLAY_LOG_ERR("Error!Failed to Close Overlay Shared Data!\n");
-    }
-}
-
-static int open_data_shared_data( overlay_data_context_t *ctx )
-{
-    OVERLAY_LOG_FUNC;
-    int rc   = -1;
-    int mode = PROT_READ | PROT_WRITE;
-    int fd   = ctx->data_shared_fd;
-    int size = ctx->data_shared_size;
-
-    if (ctx->data_shared != NULL) {
-        // Already open, return success
-        OVERLAY_LOG_ERR("Error!Overlay Shared Data Already Open\n");
-        return 0;
-    }
-    ctx->data_shared = (overlay_data_shared_t*)mmap(0, size, mode, MAP_SHARED, fd, 0);
-
-    if (ctx->data_shared == MAP_FAILED) {
-        OVERLAY_LOG_ERR("Error!Failed to Map Overlay Shared Data!\n");
-    } else if ( ctx->data_shared->marker != SHARED_DATA_MARKER ) {
-        OVERLAY_LOG_ERR("Error!Invalid Overlay Shared Marker!\n");
-        munmap( ctx->data_shared, size);
-    } else if ( (int)ctx->data_shared->size != size ) {
-        OVERLAY_LOG_ERR("Error!Invalid Overlay Shared Size!\n");
-        munmap(ctx->data_shared, size);
-    } else {
-        android_atomic_inc(&ctx->data_shared->refCnt);
-        rc = 0;
-    }
-
-    return rc;
-}
-
-static void close_data_shared_data(overlay_data_context_t *ctx)
-{
-    OVERLAY_LOG_FUNC;
-    destroy_data_shared_data(ctx->data_shared_fd, ctx->data_shared, false);
-    ctx->data_shared = NULL;
-}
-
-static int bits_per_pixel(int32_t format)
-{
-    int bits = 0;
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RGB_888:
-            bits = 24;
-            break;
-        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_422_I:
-        case HAL_PIXEL_FORMAT_RGB_565:
-            bits = 16;
-            break;
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            bits = 32;
-            break;
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_420_I:
-            bits = 12;
-            break;
-        default:
-            bits = 0;
-            break;
-    }
-    return bits;
-}
-
-static int fill_alpha_buffer(void *alpha_buf, int buf_w, 
-                             WIN_REGION *fill_region,char alpha_val)
-{
-    //Check parameter
-    if((!alpha_buf)||(buf_w <0)||(!fill_region)) {
-        OVERLAY_LOG_ERR("Error!Invalid parameters in fill_alpha_buffer");
-        return -1;
-    }
-    OVERLAY_LOG_INFO("fill_alpha_buffer: buf_w %d,top %d, bottom %d, left %d,right %d",buf_w,
-         fill_region->top,fill_region->bottom,fill_region->left,fill_region->right);
-
-    char *pPointAlphaValue;
-	int x, y;
-
-	for (y = fill_region->top; y < fill_region->bottom; y++) {
-        pPointAlphaValue = (char *)alpha_buf +buf_w * y + fill_region->left;
-        memset(pPointAlphaValue,alpha_val,fill_region->right-fill_region->left);
-	}
-
-    return 0;
-}
-
-//pixelformat format for v4l2 setting
-int fill_frame_back(char * frame,int frame_size, int xres,
-                           int yres, unsigned int pixelformat)
-{
-    int ret = 0;
-    char * base;
-    int j, screen_size;
-    short * tmp;
-    short color;
-    if((xres<=0)||(yres<=0)||(!frame)) {
-        OVERLAY_LOG_ERR("Error!Not valid parameters in fill_frame_back");
-        return -1;
-    }
-    switch(pixelformat) {
-        case V4L2_PIX_FMT_RGB565:
-            memset(frame, 0, frame_size);
-            break;
-        case V4L2_PIX_FMT_YUYV:
-        case V4L2_PIX_FMT_UYVY:
-            tmp = (short *) frame;
-            if(pixelformat == V4L2_PIX_FMT_YUYV)
-               color = 0x8000;
-            else
-               color = 0x80;
-            for(int i = 0; i < frame_size/2;i++, tmp++)
-                *tmp = color;
-            break;
-        case V4L2_PIX_FMT_YUV422P:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size; i++, base++)
-                *base = 0x80;
-            break;
-        case V4L2_PIX_FMT_YUV420:
-        case V4L2_PIX_FMT_YVU420:
-        case V4L2_PIX_FMT_NV12:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size/2; i++, base++)
-                 *base = 0x80;
-            break;
-        defaule:
-            OVERLAY_LOG_ERR("Error!Not supported pixel format");
-            ret = -1;
-            break;
-    }
-    return ret;
-}
-
-static int overlay_init_fbdev(struct overlay_control_context_t *dev)
-{
-    OVERLAY_LOG_FUNC;
-    //Check fb0 dev
-    dev->fb_dev  = open(FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-    if(dev->fb_dev < 0) {
-        OVERLAY_LOG_ERR("Error!Open fb device %s failed",FB_DEV_NAME);
-        return -1;
-    }
-    
-    int ret = 0;
-    struct fb_var_screeninfo fb_var;
-
-    //disable the gbl alpha
-
-#if 0
-    struct mxcfb_gbl_alpha gbl_alpha;
-    gbl_alpha.alpha = 255;
-    gbl_alpha.enable = 1;
-    ret = ioctl(dev->fb_dev, MXCFB_SET_GBL_ALPHA, &gbl_alpha);
-    if(ret <0)
-    {
-        OVERLAY_LOG_ERR("Error!MXCFB_SET_GBL_ALPHA failed!");
-        return -1;
-    }
-
-
-
-    struct mxcfb_color_key key;       
-    key.enable = 1;
-    key.color_key = 0x00000000; // Black
-    ret = ioctl(dev->fb_dev, MXCFB_SET_CLR_KEY, &key);
-    if(ret <0)
-    {
-      OVERLAY_LOG_ERR("Error!Colorkey setting failed for dev %s",FB_DEV_NAME);
-      return -1;
-    }
-#endif
-
-    if ( ioctl(dev->fb_dev, FBIOGET_VSCREENINFO, &fb_var) < 0) {
-        OVERLAY_LOG_ERR("Error!VSCREENINFO getting failed for dev %s",FB_DEV_NAME);
-        return -1;
-    }
-    OVERLAY_LOG_INFO("%s fb_var: bits_per_pixel %d,xres %d,yres %d,xres_virtual %d,yres_virtual %d\n",
-            FB_DEV_NAME,fb_var.bits_per_pixel,
-            fb_var.xres,fb_var.yres,
-            fb_var.xres_virtual,fb_var.yres_virtual);
-    dev->xres = fb_var.xres;
-    dev->yres = fb_var.yres;
-
-    //Setting Local alpha buffer
-#if 0
-    struct mxcfb_loc_alpha l_alpha;       
-    l_alpha.enable = 1;
-    l_alpha.alpha_phy_addr0 = 0;
-    l_alpha.alpha_phy_addr1 = 0;
-    if (ioctl(dev->fb_dev, MXCFB_SET_LOC_ALPHA,
-          &l_alpha) < 0) {
-        OVERLAY_LOG_ERR("Error!LOC_ALPHA setting failed for dev %s",FB_DEV_NAME);
-        return -1;
-    }
-    
-
-    unsigned long loc_alpha_phy_addr0 =
-            (unsigned long)(l_alpha.alpha_phy_addr0);
-    unsigned long loc_alpha_phy_addr1 =
-            (unsigned long)(l_alpha.alpha_phy_addr1);
-    OVERLAY_LOG_INFO("Phy local alpha: buffer0 0x%x buffer1 0x%x",loc_alpha_phy_addr0,loc_alpha_phy_addr1);
-    dev->alpha_buf_size = dev->xres * dev->yres;
-    
-    char *alpha_buf0 = (char *)mmap(0, dev->alpha_buf_size,
-                     PROT_READ | PROT_WRITE,
-                     MAP_SHARED, dev->fb_dev,
-                     loc_alpha_phy_addr0);
-    if ((int)alpha_buf0 == -1) {
-        OVERLAY_LOG_ERR("Error!mmap local alpha buffer 0 failed for dev %s",FB_DEV_NAME);
-        return -1;
-    }
-    
-    dev->alpha_buffers[0].vir_addr = alpha_buf0;
-    dev->alpha_buffers[0].phy_addr = loc_alpha_phy_addr0;
-    dev->alpha_buffers[0].size = dev->alpha_buf_size;
-
-    char *alpha_buf1 = (char *)mmap(0, dev->alpha_buf_size,
-                 PROT_READ | PROT_WRITE,
-                 MAP_SHARED, dev->fb_dev,
-                 loc_alpha_phy_addr1);
-    if ((int)alpha_buf1 == -1) {
-        OVERLAY_LOG_ERR("Error!mmap local alpha buffer 1 failed for dev %s",FB_DEV_NAME);
-        return -1;
-    }
-
-    dev->alpha_buffers[1].vir_addr = alpha_buf1;
-    dev->alpha_buffers[1].phy_addr = loc_alpha_phy_addr1;
-    dev->alpha_buffers[1].size = dev->alpha_buf_size;
-    OVERLAY_LOG_INFO("Vir local alpha: buffer0 0x%x buffer1 0x%x",alpha_buf0,alpha_buf1);
-
-    //Fill the alpha buffer with init alpha setting
-    WIN_REGION win_region;
-    win_region.left = 0;
-    win_region.right = dev->xres;
-    win_region.top = 0;
-    win_region.bottom = dev->yres;
-
-    fill_alpha_buffer(dev->alpha_buffers[0].vir_addr,dev->xres,&win_region,128);
-    fill_alpha_buffer(dev->alpha_buffers[1].vir_addr,dev->xres,&win_region,128);
-
-    if (ioctl(dev->fb_dev, MXCFB_SET_LOC_ALP_BUF, &dev->alpha_buffers[0].phy_addr) < 0) {
-        OVERLAY_LOG_ERR("Error!SET_LOC_ALP_BUF setting failed for dev %s",FB_DEV_NAME);
-        return -1;
-    }
-    dev->cur_alpha_buffer = 0;
-#endif
-
-    return 0;
-}
-
-static int overlay_deinit_fbdev(struct overlay_control_context_t *dev)
-{
-    OVERLAY_LOG_FUNC;
-    if(!dev) {
-        return -1;
-    }
-#if 0
-    if(dev->alpha_buffers[0].vir_addr){
-        munmap((void *)dev->alpha_buffers[0].vir_addr, dev->alpha_buffers[0].size);
-        memset(&dev->alpha_buffers[0],0,sizeof(OVERLAY_BUFFER));
-    }
-    if(dev->alpha_buffers[1].vir_addr){
-        munmap((void *)dev->alpha_buffers[1].vir_addr, dev->alpha_buffers[1].size);
-        memset(&dev->alpha_buffers[1],0,sizeof(OVERLAY_BUFFER));
-    }
-#endif    
-    if(dev->fb_dev) {
-        close(dev->fb_dev);
-        dev->fb_dev = 0;
-    }
-    return 0;
-}
-
-static int overlay_init_v4l(struct overlay_control_context_t *dev)
-{
-        OVERLAY_LOG_FUNC;
-        //Open v4l2 device
-        dev->v4l_id = open(V4L_DEV_NAME, O_RDWR, 0);
-        if(dev->v4l_id < 0) {
-            OVERLAY_LOG_ERR("Error!Open v4l device %s failed",V4L_DEV_NAME);
-            return -1;
-        }
-        int layer = DEFAULT_V4L_LAYER;
-        if ( ioctl(dev->v4l_id,VIDIOC_S_OUTPUT, &layer) < 0) {
-    	    OVERLAY_LOG_ERR("Error!VIDIOC_S_OUTPUT getting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-
-        struct v4l2_cropcap cropcap;
-        memset(&cropcap, 0, sizeof(cropcap));
-        cropcap.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-        if ( ioctl(dev->v4l_id, VIDIOC_CROPCAP, &cropcap) < 0) {
-    	    OVERLAY_LOG_ERR("Error!VIDIOC_CROPCAP getting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-        dev->video_frames = 0;
-
-        struct v4l2_crop crop;
-        /* set the image rectangle of the display by 
-        setting the appropriate parameters */
-        crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-        crop.c.width = dev->xres;
-        crop.c.height = dev->yres;
-        crop.c.top = 0;
-        crop.c.left = 0;
-        if ( ioctl(dev->v4l_id, VIDIOC_S_CROP, &crop) < 0) {
-    	    OVERLAY_LOG_ERR("Error!VIDIOC_CROPCAP getting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-
-        //Set V4L format
-        struct v4l2_format fmt;
-        //struct v4l2_mxc_offset off;
-        memset(&fmt, 0, sizeof(fmt));
-        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-        fmt.fmt.pix.width = dev->xres;
-        fmt.fmt.pix.height = dev->yres;
-        fmt.fmt.pix.pixelformat = dev->outpixelformat;//in_fmt;
-        fmt.fmt.pix.bytesperline = dev->xres;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;//dev->xres * dev->yres * 3 / 2
-
-        if ( ioctl(dev->v4l_id, VIDIOC_S_FMT, &fmt) < 0) {
-            OVERLAY_LOG_ERR("Error!VIDIOC_S_FMT setting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-
-        if ( ioctl(dev->v4l_id, VIDIOC_G_FMT, &fmt) < 0) {
-            OVERLAY_LOG_ERR("Error!VIDIOC_G_FMT setting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-        OVERLAY_LOG_INFO("V4L setting: format 0x%x",fmt.fmt.pix.pixelformat);
-        struct v4l2_requestbuffers buf_req;
-        dev->v4l_bufcount = DEFAULT_V4L_BUFFERS;
-        buf_req.count = dev->v4l_bufcount;
-        buf_req.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-        buf_req.memory = V4L2_MEMORY_MMAP;
-        if ( ioctl(dev->v4l_id, VIDIOC_REQBUFS, &buf_req) < 0) {
-            OVERLAY_LOG_ERR("Error!VIDIOC_REQBUFS setting failed for dev %s",V4L_DEV_NAME);
-            return -1;
-        }
-
-
-        //for each buffer,get the vir/phy address
-        struct v4l2_buffer *v4lbuf = dev->v4l_buffers;
-        char * vir_addr;
-        OVERLAY_LOG_RUNTIME("dev->v4l_buffers 0x%x v4l2_buffer size %d",dev->v4l_buffers,sizeof(struct v4l2_buffer));
-        for(int buf_index=0;buf_index < dev->v4l_bufcount;buf_index++) {
-            v4lbuf->index = buf_index;
-            v4lbuf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-            v4lbuf->memory = V4L2_MEMORY_MMAP;
-            if( ioctl(dev->v4l_id, VIDIOC_QUERYBUF, v4lbuf) < 0) {
-                OVERLAY_LOG_ERR("Error!VIDIOC_QUERYBUF getting failed for dev %s",V4L_DEV_NAME);
-                return -1;
-            }
-
-            vir_addr = (char *)mmap(NULL,v4lbuf->length,
-                            PROT_READ | PROT_WRITE, MAP_SHARED,
-                            dev->v4l_id, v4lbuf->m.offset);
-            if ((int)vir_addr == -1) {
-                OVERLAY_LOG_ERR("Error!mmap V4L buffer %d failed for dev %s",buf_index,V4L_DEV_NAME);
-                return -1;
-            }
-
-            dev->v4lbuf_addr[buf_index] = vir_addr;
-            //v4l already init this buffer to black
-            //fill the v4l to black;
-            fill_frame_back(vir_addr,v4lbuf->length,dev->xres,dev->yres,dev->outpixelformat);
-            //LOGI("******0x%x 0x%x 0x%x 0x%x",*(vir_addr),*(vir_addr+1),*(vir_addr+2),*(vir_addr+3));
-            OVERLAY_LOG_INFO("v4l buf[%d] 0x%p: vir 0x%p,phy 0x%x, size %d",
-                             buf_index,v4lbuf,vir_addr,v4lbuf->m.offset,v4lbuf->length);
-            v4lbuf++;
-        }
-
-        return 0;
-}
-
-static int overlay_deinit_v4l(struct overlay_control_context_t *dev)
-{
-    OVERLAY_LOG_FUNC;
-    if(!dev) {
-        return -1;
-    }
-    for(int buf_index=0;buf_index < dev->v4l_bufcount;buf_index++) {
-       if(dev->v4lbuf_addr[buf_index])
-          munmap((void *)dev->v4lbuf_addr[buf_index], dev->v4l_buffers[buf_index].length);
-       memset(&dev->v4l_buffers[buf_index],0,sizeof(v4l2_buffer));
-       dev->v4lbuf_addr[buf_index] = NULL;
-    }
-    dev->v4l_bufcount = 0;
-
-    if(dev->v4l_id) {
-       close(dev->v4l_id);
-       dev->v4l_id = 0;
-    }
-    dev->video_frames = 0;
-    return 0;
-}
-
-int overlay_check_parameters(struct handle_t *overlay_handle)
-{
-    OVERLAY_LOG_FUNC;
-    //Make sure the parameters are within our support, as alinement or 
-    //something else
-    return 0;
-}
-// ****************************************************************************
-// Control module
-// ****************************************************************************
-
-static int overlay_get(struct overlay_control_device_t *dev, int name) {
-    OVERLAY_LOG_FUNC;
-    int result = -1;
-    switch (name) {
-        case OVERLAY_MINIFICATION_LIMIT:
-            result = 0; // 0 = no limit
-            break;
-        case OVERLAY_MAGNIFICATION_LIMIT:
-            result = 0; // 0 = no limit
-            break;
-        case OVERLAY_SCALING_FRAC_BITS:
-            result = 0; // 0 = infinite
-            break;
-        case OVERLAY_ROTATION_STEP_DEG:
-            result = 90; // 90 rotation steps (for instance)
-            break;
-        case OVERLAY_HORIZONTAL_ALIGNMENT:
-            result = 1; // 1-pixel alignment
-            break;
-        case OVERLAY_VERTICAL_ALIGNMENT:
-            result = 1; // 1-pixel alignment
-            break;
-        case OVERLAY_WIDTH_ALIGNMENT:
-            result = 1; // 1-pixel alignment
-            break;
-        case OVERLAY_HEIGHT_ALIGNMENT:
-            result = 1; // 1-pixel alignment
-            break;
-    }
-    return result;
-}
-
-static overlay_t* overlay_createOverlay(struct overlay_control_device_t *dev,
-         uint32_t w, uint32_t h, int32_t format) 
-{
-    OVERLAY_LOG_FUNC;
-    overlay_control_context_t *ctx = (overlay_control_context_t *)dev;
-    overlay_object* overlay = NULL;
-    OVERLAY_LOG_INFO("overlay_createOverlay w %d,h %d,format %d, pid %d,,gettid() %d",w,h,format,getpid(),gettid());
-
-    if((!ctx)||(!ctx->overlay_running)){
-        OVERLAY_LOG_ERR("Error!overlay_control_device_t not in good state");
-        return NULL;
-    }
-    /* check the input params, reject if not supported or invalid */
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RGB_888:
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-            OVERLAY_LOG_ERR("Error!Not a valid format for overlay");
-            return NULL;
-        case HAL_PIXEL_FORMAT_RGB_565:
-            break;
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-            break;
-        case HAL_PIXEL_FORMAT_YCbCr_420_I:
-            break;
-        default:
-            OVERLAY_LOG_ERR("Error!Not a valid format for overlay");
-            return NULL;
-    }
-    
-    /* Create overlay object. Talk to the h/w here and adjust to what it can
-     * do. the overlay_t returned can  be a C++ object, subclassing overlay_t
-     * if needed.
-     * 
-     * we probably want to keep a list of the overlay_t created so they can
-     * all be cleaned up in overlay_close(). 
-     */
-
-    overlay = new overlay_object( w, h, format,ctx->control_shared_fd,ctx->control_shared_size);
-    if(overlay) {
-        int instance = 0;
-
-        pthread_mutex_lock(&ctx->control_lock);
-        //Only init v4l as needed
-        if(ctx->overlay_number == 0) {
-             if(overlay_init_v4l(ctx)<0){
-                 OVERLAY_LOG_ERR("Error!init v4l failed");
-                 pthread_mutex_unlock(&ctx->control_lock);
-                 delete overlay;
-                 return NULL;
-             }
-        }
-
-        while(instance < MAX_OVERLAY_INSTANCES) {
-            if(!ctx->overlay_instance_valid[instance]) {
-                ctx->overlay_instance_valid[instance] = 1;
-                ctx->overlay_intances[instance] = overlay;
-                ctx->overlay_number++;
-                OVERLAY_LOG_INFO("Create overlay instance 0x%p id %d total %d",
-                     overlay,instance,ctx->overlay_number);
-                overlay->mDataShared->instance_id = instance;
-                break;
-            }
-            instance++;
-        }
-        pthread_mutex_unlock(&ctx->control_lock);
-
-        if(instance >= MAX_OVERLAY_INSTANCES) {
-            OVERLAY_LOG_ERR("Error!Cannot have more overlay instance in system");
-            delete overlay;
-            overlay = NULL;
-        }
-    }
-    else{
-        OVERLAY_LOG_ERR("Error!overlay_object creation failed w:%d,h%d,format:%d",w,h,format);
-    }
-
-    return (overlay_t *)overlay;
-}
-
-static void overlay_destroyOverlay(struct overlay_control_device_t *dev,
-         overlay_t* overlay) 
-{
-    struct timespec timeout;
-    struct timeval tv;
-    OVERLAY_LOG_INFO("overlay_destroyOverlay()");
-    overlay_control_context_t *ctx = (overlay_control_context_t *)dev;
-    int instance = 0;
-    overlay_object *obj = static_cast<overlay_object *>(overlay);
-
-    pthread_mutex_lock(&ctx->control_lock);
-
-    for(instance = 0;instance < MAX_OVERLAY_INSTANCES;instance++) {
-        if((ctx->overlay_instance_valid[instance])&&(ctx->overlay_intances[instance] == obj)) {
-            break;
-        }
-    }
-    
-    if(instance < MAX_OVERLAY_INSTANCES) {
-        OVERLAY_LOG_INFO("****Destory the overlay instance id %d",instance);
-        //Set a flag to indicate the overlay_obj is invalid.
-        //Flush the buffer in queue
-        overlay_data_shared_t *data_shared = ctx->overlay_intances[instance]->mDataShared;
-        if(data_shared != NULL) {
-            //Unlock the control lock incase the dead lock between overlay thread
-            pthread_mutex_unlock(&ctx->control_lock);
-            pthread_mutex_lock(&data_shared->obj_lock);
-            data_shared->in_destroy = true;
-            while(data_shared->queued_count > 0) {
-                OVERLAY_LOG_WARN("Warning!destroyOverlay Still %d buffer in queue",
-                                data_shared->queued_count);
-                //Wait a buffer be mixered
-                data_shared->wait_buf_flag = 1;
-                //post sempore to notify mixer thread, give mixer thread a chance to free a buffer
-                if(ctx->control_shared) {
-                    sem_post(&ctx->control_shared->overlay_sem);
-                }
-                gettimeofday(&tv, (struct timezone *) NULL);
-                timeout.tv_sec = tv.tv_sec;
-                timeout.tv_nsec = (tv.tv_usec + 200000) * 1000L;//200ms
-                //Overlay data close or Overlay destroy may both block in this, so only one can get the condition
-                //Make a time out here.
-                pthread_cond_timedwait(&data_shared->free_cond, &data_shared->obj_lock,&timeout);
-                if(data_shared->wait_buf_flag != 0) {
-                    OVERLAY_LOG_ERR("Error!cannot make a buffer flushed for destory overlay");
-               }
-            }
-
-            if(data_shared->buf_mixing) {
-                int wait_count = 0;
-                LOGW("Current this overlay is in buf_mixing! Have to wait it done");
-                pthread_mutex_unlock(&data_shared->obj_lock);
-                //Make a sleep for 10ms
-                do{
-                    usleep(2000);
-                    wait_count++;
-                    if(wait_count > 5) {
-                        OVERLAY_LOG_ERR("Error!Still cannot wait the buf mix done!");
-                        break;
-                    }
-                }while (data_shared->buf_mixing);
-            }
-            else{
-                pthread_mutex_unlock(&data_shared->obj_lock);
-            }
-
-            pthread_mutex_lock(&ctx->control_lock);
-        }
-
-        ctx->overlay_number--;
-        ctx->overlay_instance_valid[instance] = 0;
-        ctx->overlay_intances[instance] = NULL;
-
-    }
-
-    if((ctx->overlay_number == 0)&& ctx->stream_on) {
-        int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-        ioctl(ctx->v4l_id, VIDIOC_STREAMOFF, &type);
-        OVERLAY_LOG_INFO("V4L STREAMON OFF");
-        ctx->video_frames = 0;
-        ctx->stream_on = false;
-        //refill the back color
-        for(int i = 0;i < ctx->v4l_bufcount;i++) {
-            fill_frame_back(ctx->v4lbuf_addr[i],ctx->v4l_buffers[i].length,
-                            ctx->xres,ctx->yres,ctx->outpixelformat);
-        }
-    }
-
-    if(ctx->overlay_number == 0) {
-        overlay_deinit_v4l(ctx);
-    }
-
-    pthread_mutex_unlock(&ctx->control_lock);
-
-    /* free resources associated with this overlay_t */
-    delete obj;
-}
-
-static int overlay_setPosition(struct overlay_control_device_t *dev,
-         overlay_t* overlay, 
-         int x, int y, uint32_t w, uint32_t h) {
-    OVERLAY_LOG_FUNC;
-    /* set this overlay's position (talk to the h/w) */
-    overlay_object *obj = static_cast<overlay_object *>(overlay);
-
-    if (x <0 || y <0 )
-    {
-        OVERLAY_LOG_ERR ("!!!!Overlay pos set: x %d,y %d,w %d,h %d",x,y,w,h);
-        return 0;
-    }
-
-    //fetch the overlay obj lock
-    pthread_mutex_lock(&obj->mDataShared->obj_lock);
-    if((x!= obj->outX)||
-       (y!= obj->outY)||
-       (w!= (uint32_t)obj->outW)||
-       (h!= (uint32_t)obj->outH)) {
-        //Set out changed flag,so mixer thread will know
-        //output area changed
-        obj->out_changed = 1;
-    }
-    obj->outX = x&0xfffffff8;
-    obj->outY = y&0xfffffff8;
-    obj->outW = w&0xfffffff8;//output width should be 8 pixel alignment
-    obj->outH = h&0xfffffff8;//output height should be 8 pixel alignment
-    OVERLAY_LOG_INFO("Overlay pos set: x %d,y %d,w %d,h %d",x,y,w,h);
-    //release the overlay obj lock
-    pthread_mutex_unlock(&obj->mDataShared->obj_lock);
-
-    return 0;
-}
-
-static int overlay_getPosition(struct overlay_control_device_t *dev,
-         overlay_t* overlay, 
-         int* x, int* y, uint32_t* w, uint32_t* h) {
-    OVERLAY_LOG_FUNC;
-    /* get this overlay's position */
-    overlay_object *obj = static_cast<overlay_object *>(overlay);
-
-    //fetch the overlay obj lock
-    pthread_mutex_lock(&obj->mDataShared->obj_lock);
-    *x = obj->outX;
-    *y = obj->outY;
-    *w = obj->outW;
-    *y = obj->outH;
-    //release the overlay obj lock
-    pthread_mutex_unlock(&obj->mDataShared->obj_lock);
-
-    return -EINVAL;
-}
-
-static int overlay_setParameter(struct overlay_control_device_t *dev,
-         overlay_t* overlay, int param, int value) {
-    OVERLAY_LOG_FUNC;
-    overlay_object *obj = static_cast<overlay_object *>(overlay);
-    int result = 0;
-    /* set this overlay's parameter (talk to the h/w) */
-    OVERLAY_LOG_INFO("overlay_setParameter param %d value %d",param,value);
-    switch (param) {
-        case OVERLAY_ROTATION_DEG:
-            /* if only 90 rotations are supported, the call fails
-             * for other values */
-            OVERLAY_LOG_INFO("overlay_setParameter OVERLAY_ROTATION_DEG %d",value);
-            //fetch the overlay obj lock
-            pthread_mutex_lock(&obj->mDataShared->obj_lock);
-            obj->rotation = value;
-            //release the overlay obj lock
-            pthread_mutex_unlock(&obj->mDataShared->obj_lock);
-
-            break;
-        case OVERLAY_DITHER: 
-            break;
-        case OVERLAY_TRANSFORM: 
-            // see OVERLAY_TRANSFORM_*
-            OVERLAY_LOG_INFO("overlay_setParameter OVERLAY_TRANSFORM %d",value);
-            //fetch the overlay obj lock
-            pthread_mutex_lock(&obj->mDataShared->obj_lock);
-            obj->rotation = value;
-            //release the overlay obj lock
-            pthread_mutex_unlock(&obj->mDataShared->obj_lock);
-            break;
-        case OVERLAY_ZORDER: 
-            // see OVERLAY_ZORDER*
-            OVERLAY_LOG_INFO("overlay_setParameter OVERLAY_ZORDER %d",value);
-            //fetch the overlay obj lock
-            pthread_mutex_lock(&obj->mDataShared->obj_lock);
-            obj->zorder = value;
-            //release the overlay obj lock
-            pthread_mutex_unlock(&obj->mDataShared->obj_lock);
-            break;
-        
-        default:
-            result = -EINVAL;
-            break;
-    }
-    return result;
-}
-
-static int overlay_stage(struct overlay_control_device_t *dev,
-                          overlay_t* overlay) {
-    OVERLAY_LOG_FUNC;
-
-    return 0;
-}
-
-static int overlay_commit(struct overlay_control_device_t *dev,
-                          overlay_t* overlay) {
-    OVERLAY_LOG_FUNC;
-    return 0;
-}
-
-
-static int overlay_control_close(struct hw_device_t *dev) 
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_control_context_t* ctx = (struct overlay_control_context_t*)dev;
-    if (ctx) {
-        /* free all resources associated with this device here
-         * in particular the overlay_handle_t, outstanding overlay_t, etc...
-         */
-
-        ctx->overlay_running = false;
-        sem_post(&ctx->control_shared->overlay_sem);//post the sem to unblock overlay thread
-
-        if (ctx->overlay_thread != 0) {
-            ctx->overlay_thread->requestExitAndWait();
-        }
-        
-        //Destory all overlay instance here??, 
-        //should let it done by user
-        //v4l deinit should be called in overlay destory, but here is save also
-        overlay_deinit_v4l(ctx);
-        overlay_deinit_fbdev(ctx);
-
-        //???delete this share file;
-        destroy_control_shared_data(ctx->control_shared_fd,ctx->control_shared,true);
-
-        pthread_mutex_destroy(&ctx->control_lock);
-
-        free(ctx);
-    }
-    return 0;
-}
- 
-// ****************************************************************************
-// Data module
-// ****************************************************************************
-
-int overlay_data_initialize(struct overlay_data_device_t *dev,
-        overlay_handle_t handle)
-{
-    OVERLAY_LOG_FUNC;
-    struct handle_t *overlay_handle = (struct handle_t *)handle;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    OVERLAY_LOG_INFO("overlay_initialize overlay_handle 0x%p overlay_data_context_t 0x%p pid %d tid %d",
-         overlay_handle,ctx,getpid(),gettid());
-    /* 
-     * overlay_handle_t should contain all the information to "inflate" this
-     * overlay. Typically it'll have a file descriptor, informations about
-     * how many buffers are there, etc...
-     * It is also the place to mmap all buffers associated with this overlay
-     * (see getBufferAddress).
-     * 
-     * NOTE: this function doesn't take ownership of overlay_handle_t
-     * 
-     */
-    if(overlay_check_parameters(overlay_handle) < 0)
-    {
-        OVERLAY_LOG_ERR("Error!Invalid parameters in this overlay handle");
-        return -EINVAL;
-    }
-
-    OVERLAY_LOG_INFO("num_buffer %d width %d,height %d,format %d, buf_size %d",
-         overlay_handle->num_buffer,overlay_handle->width,overlay_handle->height,
-         overlay_handle->format,overlay_handle->buf_size);
-
-    ctx->control_shared_fd = overlay_handle->control_shared_fd;
-    ctx->control_shared_size = overlay_handle->control_shared_size;
-    ctx->data_shared_fd = overlay_handle->data_shared_fd;
-    ctx->data_shared_size = overlay_handle->data_shared_size;
-    ctx->width = overlay_handle->width;
-    ctx->height = overlay_handle->height;
-    ctx->format = overlay_handle->format;
-    ctx->num_buffer = overlay_handle->num_buffer;//Number of buffers for overlay
-    ctx->buf_size = overlay_handle->buf_size;
-    //Open Control Share file
-    if(open_control_shared_data(ctx) == -1)
-    {
-        OVERLAY_LOG_ERR("Error!Cannot open overlay control share file");
-        return -1;
-    }
-    //Open Data Share file
-    if(open_data_shared_data(ctx) == -1)
-    {
-        OVERLAY_LOG_ERR("Error!Cannot open overlay data share file");
-        close_control_shared_data(ctx);
-        return -1;
-    }
-    if(ctx->data_shared->num_buffer != overlay_handle->num_buffer) {
-        OVERLAY_LOG_ERR("Warning!num_buffer %d in overlay_handle is not the same as %d in data_shared",
-                        overlay_handle->num_buffer,ctx->data_shared->num_buffer);
-    }
-
-    int bufcount = overlay_handle->num_buffer;
-    int bufsize = overlay_handle->buf_size;
-    ctx->allocator = new PmemAllocator(bufcount,bufsize);
-    if(!ctx->allocator) {
-        OVERLAY_LOG_ERR("Error!Cannot create PmemAllocator");
-        close_control_shared_data(ctx);
-        close_data_shared_data(ctx);
-        return -1;
-    }
-
-    //overlay_buffer should be reallocated if num_buffer changed
-    ctx->overlay_buffer = (OVERLAY_BUFFER *)malloc(sizeof(OVERLAY_BUFFER)*bufcount);
-    if(!ctx->overlay_buffer) {
-       OVERLAY_LOG_ERR("Error!Cannot allocate overlay buffer hdr");
-       close_control_shared_data(ctx);
-       close_data_shared_data(ctx);
-       delete ctx->allocator;
-       return -1;
-    }
-    else{
-       memset(ctx->overlay_buffer,0,sizeof(OVERLAY_BUFFER)*bufcount);
-       OVERLAY_LOG_INFO("overlay_buffer 0x%p",ctx->overlay_buffer);
-    }
-
-
-    pthread_mutex_lock(&ctx->data_shared->obj_lock);
-
-    ctx->data_shared->free_count = 0;
-    ctx->data_shared->free_head = 0;
-    ctx->data_shared->free_tail = 0;
-    memset(ctx->data_shared->free_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-    ctx->data_shared->queued_count = 0;
-    ctx->data_shared->queued_head = 0;
-    ctx->data_shared->queued_tail = 0;
-    memset(ctx->data_shared->queued_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-
-    //Allocate the buffer
-    //Insert all allocated buffer into buffer freequeue
-    OVERLAY_BUFFER *pOverlayBuf = ctx->overlay_buffer;
-    for(int index =0;index < bufcount; index++) {
-        int ret = -1;
-        ret = ctx->allocator->allocate(pOverlayBuf, bufsize);
-        if(ret<0) {
-            OVERLAY_LOG_ERR("Error!Cannot allocate overlay buffer");
-            pthread_mutex_unlock(&ctx->data_shared->obj_lock);
-            close_control_shared_data(ctx);
-            close_data_shared_data(ctx);
-            delete ctx->allocator;
-            return -1;
-
-        }
-
-        OVERLAY_LOG_INFO("buffer %d: vir 0x%p, phy 0x%x",index,pOverlayBuf->vir_addr,pOverlayBuf->phy_addr);
-        ctx->data_shared->free_bufs[ctx->data_shared->free_tail] = pOverlayBuf->phy_addr;
-        ctx->data_shared->free_count++;
-        ctx->data_shared->free_tail++;
-        pOverlayBuf++;
-    }
-    ctx->queue_threshold = OVERLAY_QUEUE_THRESHOLD;
-    pthread_mutex_unlock(&ctx->data_shared->obj_lock);
-    OVERLAY_LOG_INFO("Overlay init success for Id %d",ctx->data_shared->instance_id);
-    
-    return 0;
-}
-
-int overlay_data_dequeueBuffer(struct overlay_data_device_t *dev,
-			  overlay_buffer_t* buf) 
-{
-    OVERLAY_LOG_FUNC;
-    int ret = 0;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if(!dev||!buf||!ctx->data_shared) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for dequeuBuffer");
-       *buf = NULL;
-       return -EINVAL;
-    }
-
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    if(data_shared->overlay_mode == OVERLAY_PUSH_MODE){
-        OVERLAY_LOG_ERR("Error!Push mode not support dequeueBuffer API");
-        *buf = NULL;
-        return -EINVAL;
-    }
-
-    /* blocks until a buffer is available and return an opaque structure
-     * representing this buffer.
-     */
-    //Maybe we should limited the loop count
-    //to avoid block calling thread too much
-    //in case error condition
-    do{
-        pthread_mutex_lock(&data_shared->obj_lock);
-
-        //check whether is in destroying
-        if(data_shared->in_destroy){
-           OVERLAY_LOG_ERR("Error!Cannot dequeueBuffer when it is under destroying");
-           *buf = NULL;
-           pthread_mutex_unlock(&data_shared->obj_lock);
-           return -EINVAL;
-        }
-
-        //Check the free buffer queue
-        if(data_shared->free_count == 0)
-        {
-            OVERLAY_LOG_RUNTIME("Id %d: No buffer for dequeueBuffer,have to wait",data_shared->instance_id);
-            //pthread_cond_wait will unlock mutex firstly, before calling thread
-            //will be blocked 
-            //pthread_cond_timedwait() may be more suitable here
-            data_shared->wait_buf_flag = 1;
-            //if buffer waiting flag be setted
-            //wait buffer free semphore here
-            //the semphore be post in mixer thread, if a buffer has 
-            //been mixed, and the waint flag be setted
-            //and waiting flag should be reset in mixer thread
-            
-            //post sempore to notify mixer thread, give mixer thread a chance to free a buffer
-            if(ctx->control_shared) {
-                sem_post(&ctx->control_shared->overlay_sem);
-            }
-            pthread_cond_wait(&data_shared->free_cond, &data_shared->obj_lock);
-            if(data_shared->wait_buf_flag != 0) {
-                OVERLAY_LOG_ERR("Error!Instance %d:Cannot wait a free buffer",data_shared->instance_id);
-                ret = -EINVAL;
-            }
-        }
-
-        if(data_shared->free_count > 0) 
-        {
-            //fetch the buffer handle
-            //return the buffer handle
-            unsigned int phy_addr = data_shared->free_bufs[data_shared->free_head];
-            OVERLAY_LOG_RUNTIME("Id %d:Have free buffer %d,head %d, tail %d,phy 0x%x",
-                                data_shared->instance_id,
-                                data_shared->free_count,
-                                data_shared->free_head,
-                                data_shared->free_tail,
-                                phy_addr);
-            data_shared->free_bufs[data_shared->free_head] = 0;
-            data_shared->free_head++;
-            data_shared->free_head = data_shared->free_head%MAX_OVERLAY_BUFFER_NUM;
-            data_shared->free_count--;
-
-            OVERLAY_BUFFER *overlay_buf = NULL;
-            for(int index = 0;index< ctx->num_buffer;index ++) {
-                if(ctx->overlay_buffer[index].phy_addr == phy_addr) {
-                    overlay_buf = &ctx->overlay_buffer[index];
-                    OVERLAY_LOG_RUNTIME("Instance %d:Dequeued a overlay buffer %d: phy 0x%x, vir 0x%x",
-                         data_shared->instance_id,
-                         index,overlay_buf->phy_addr,overlay_buf->vir_addr);
-                }
-            }
-
-            if(!overlay_buf||!overlay_buf->vir_addr) {
-                OVERLAY_LOG_ERR("Error!Instance %d:Not a valid buffer",data_shared->instance_id);
-                pthread_mutex_unlock(&data_shared->obj_lock);
-                return -1;
-            }
-            
-            *buf = (overlay_buffer_t)overlay_buf;
-
-            pthread_mutex_unlock(&data_shared->obj_lock);
-            return 0;
-        }
-
-        //If not free buffer in queue, try again
-        pthread_mutex_unlock(&data_shared->obj_lock);
- 
-    }while (ret <0);
- 
-    return ret;
-}
-
-int overlay_data_queueBuffer(struct overlay_data_device_t *dev,
-        overlay_buffer_t buffer)
-{
-    OVERLAY_LOG_FUNC;;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    //Push mode, should be a mothod for user to flush all buffer in overlay hal
-    if(!dev||!ctx->data_shared) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for dequeuBuffer");
-       return -EINVAL;
-    }
-
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    OVERLAY_BUFFER *overlay_buf = NULL;
-    //Check whether it is a valid buffer
-    //Further check maybe needed:
-    //Cannot be queued twice(not a duplicated node in display buffer queue)
-    if(data_shared->overlay_mode != OVERLAY_PUSH_MODE)
-    {
-        if(buffer == 0) {
-            OVERLAY_LOG_ERR("Error!Invalid parameters for dequeuBuffer");
-            return -EINVAL;
-        }
-
-        overlay_buf = (OVERLAY_BUFFER *)buffer;
-        if((overlay_buf < ctx->overlay_buffer)||
-           (overlay_buf >= (ctx->overlay_buffer+ctx->num_buffer))) {
-           OVERLAY_LOG_ERR("Error!Id %d:Not a valid overlay buffer for queueBuffer",
-                           data_shared->instance_id);
-           return -EINVAL;
-        }
-    }
-
-
-    pthread_mutex_lock(&data_shared->obj_lock);
-    //check whether is in destroying
-    if(data_shared->in_destroy){
-       OVERLAY_LOG_ERR("Error!Cannot queueBuffer when it is under destroying");
-       pthread_mutex_unlock(&data_shared->obj_lock);
-       return -EINVAL;
-    }
-
-
-    //Insert buffer to display buffer queue
-    if(data_shared->queued_count >= ctx->queue_threshold ||
-        ((data_shared->queued_count == (ctx->queue_threshold-1))&&(data_shared->buf_mixing == true))) {
-        //Wait a buffer be mixered
-        data_shared->wait_buf_flag = 1;
-        //post sempore to notify mixer thread, give mixer thread a chance to free a buffer
-        if(ctx->control_shared) {
-            sem_post(&ctx->control_shared->overlay_sem);
-        }
-        pthread_cond_wait(&data_shared->free_cond, &data_shared->obj_lock);
-        if(data_shared->wait_buf_flag != 0) {
-            OVERLAY_LOG_ERR("Error!Id %d:Queued overlay buffer is out of number buffers supported,so dropped",
-                    data_shared->instance_id);
-            pthread_mutex_unlock(&data_shared->obj_lock);
-            return -EINVAL;
-
-        }
-        OVERLAY_LOG_RUNTIME("Id %d:Wait a free slot for queue buffer",data_shared->instance_id);
-    }
-    unsigned int phy_addr;
-    if(data_shared->overlay_mode != OVERLAY_PUSH_MODE){
-        phy_addr = overlay_buf->phy_addr;
-    }
-    else{
-        phy_addr = (unsigned int)buffer;
-        //Push mode, should be a mothod for user to flush all buffer in overlay hal
-        if(buffer == 0) {
-            OVERLAY_LOG_WARN("Flush overlay hal by push null buffer!");
-            pthread_mutex_unlock(&data_shared->obj_lock);
-            return 0;
-        }
-    }
-
-
-    OVERLAY_LOG_RUNTIME("Id %d:Queue buffer 0x%x at %d,queued count %d",
-                        data_shared->instance_id,
-                        phy_addr,data_shared->queued_tail,data_shared->queued_count+1);
-
-    //Check whether it is duplicated in the queue
-    for(int i= 0;i < data_shared->queued_count;i++) {
-        if(phy_addr == data_shared->queued_bufs[(data_shared->queued_head+i)%MAX_OVERLAY_BUFFER_NUM]) {
-            OVERLAY_LOG_WARN("Warning!This buffer is duplicated at queue,will be ignored");
-            pthread_mutex_unlock(&data_shared->obj_lock);
-            return -EINVAL;
-        }
-    }
-
-    data_shared->queued_bufs[data_shared->queued_tail] = phy_addr;
-    data_shared->queued_tail++;
-    data_shared->queued_tail = data_shared->queued_tail%MAX_OVERLAY_BUFFER_NUM;
-    data_shared->queued_count++;
-    ctx->buf_queued++;
-    pthread_mutex_unlock(&data_shared->obj_lock);
-
-    //post sempore to notify mixer thread, new buffer is coming for mixing
-    if(ctx->control_shared) {
-        sem_post(&ctx->control_shared->overlay_sem);
-    }
-
-    return 0;
-}
-
-void *overlay_data_getBufferAddress(struct overlay_data_device_t *dev,
-        overlay_buffer_t buffer)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if(!dev) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for getBufferAddress");
-       return NULL;
-    }
-
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    if(data_shared->overlay_mode == OVERLAY_PUSH_MODE){
-        OVERLAY_LOG_ERR("Error!Push mode not support getBufferAddress API");
-        return NULL;
-    }
-
-    /* this may fail (NULL) if this feature is not supported. In that case,
-     * presumably, there is some other HAL module that can fill the buffer,
-     * using a DSP for instance */
-
-    //Check it is a valid buffer
-    //return virtual addree of this buffer
-    OVERLAY_BUFFER *overlay_buf = (OVERLAY_BUFFER *)buffer;
-    //Check whether it is a valid buffer
-    //Further check maybe needed:
-    //Cannot be queued twice(not a duplicated node in display buffer queue)
-    if((overlay_buf < ctx->overlay_buffer)||
-       (overlay_buf >= (ctx->overlay_buffer+ctx->num_buffer))) {
-       OVERLAY_LOG_ERR("Error!Id %d:Not a valid overlay buffer for queueBuffer",
-                       ctx->data_shared->instance_id);
-       return NULL;
-    }
-
-    return overlay_buf->vir_addr;
-
-
-}
-
-unsigned int overlay_data_getBufferAddressPhy(struct overlay_data_device_t *dev,
-        overlay_buffer_t buffer)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if(!dev) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for getBufferAddressPhy");
-       return NULL;
-    }
-
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    if(data_shared->overlay_mode == OVERLAY_PUSH_MODE){
-        OVERLAY_LOG_ERR("Error!Push mode not support getBufferAddress API");
-        return 0;
-    }
-
-    /* this may fail (NULL) if this feature is not supported. In that case,
-     * presumably, there is some other HAL module that can fill the buffer,
-     * using a DSP for instance */
-
-    //Check it is a valid buffer
-    //return virtual addree of this buffer
-    OVERLAY_BUFFER *overlay_buf = (OVERLAY_BUFFER *)buffer;
-    //Check whether it is a valid buffer
-    //Further check maybe needed:
-    //Cannot be queued twice(not a duplicated node in display buffer queue)
-    if((overlay_buf < ctx->overlay_buffer)||
-       (overlay_buf >= (ctx->overlay_buffer+ctx->num_buffer))) {
-       OVERLAY_LOG_ERR("Error!Id %d:Not a valid overlay buffer for queueBuffer",
-                       ctx->data_shared->instance_id);
-       return 0;
-    }
-
-    return overlay_buf->phy_addr;
-
-}
-
-int overlay_data_resizeInput(struct overlay_data_device_t *dev,
-            uint32_t w, uint32_t h)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if((!dev)||(w=0)||(h=0)||
-       (w> MAX_OVERLAY_INPUT_W)||
-       (h> MAX_OVERLAY_INPUT_H)) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for overlay_data_resizeInput");
-       return -EINVAL;
-    }
-    OVERLAY_LOG_ERR("Error!overlay_data_resizeInput not supported");
-    return -1;
-#if 0
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    pthread_mutex_lock(&data_shared->obj_lock);
-    //Deallocate the overlay buffer
-    //reallocate the overlay buffer
-    //reinit the free/queue list
-    pthread_mutex_unlock(&data_shared->obj_lock);
-    return 0;
-#endif
-}
-
-int overlay_data_setCrop(struct overlay_data_device_t *dev,
-            uint32_t x, uint32_t y, uint32_t w, uint32_t h)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if((!dev)||
-       ((x+w)> (uint32_t)ctx->width)||
-       ((y+h)> (uint32_t)ctx->height)) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for overlay_data_setCrop");
-       return -EINVAL;
-    }
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    OVERLAY_LOG_INFO("Id %d:overlay_data_setCrop %d %d %d %d",
-                     data_shared->instance_id,x,y,w,h);
-    pthread_mutex_lock(&data_shared->obj_lock);
-    //Set the  crop setting for the overlay instance
-    data_shared->crop_x = x&0xFFFFFFF8;
-    data_shared->crop_y = y&0xFFFFFFF8;
-    data_shared->crop_w = w&0xFFFFFFF8;
-    data_shared->crop_h = h&0xFFFFFFF8;
-    pthread_mutex_unlock(&data_shared->obj_lock);
-    return 0;
-}
-
-int overlay_data_getCrop(struct overlay_data_device_t *dev,
-       uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if((!dev)||(!x)||(!y)||(!w)||(!h)) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for overlay_data_getCrop");
-       return -EINVAL;
-    }
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    pthread_mutex_lock(&data_shared->obj_lock);
-    //Get the  crop setting for the overlay instance
-    *x = data_shared->crop_x;
-    *y = data_shared->crop_y;
-    *w = data_shared->crop_w;
-    *h = data_shared->crop_h;
-    pthread_mutex_unlock(&data_shared->obj_lock);
-    return 0;
-}
-
-int overlay_data_setParameter(struct overlay_data_device_t *dev,
-            int param, int value)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if((!dev)) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for overlay_data_setParameter");
-       return -EINVAL;
-    }
-    overlay_data_shared_t  *data_shared = ctx->data_shared;
-    switch(param) {
-        case OVERLAY_MODE:
-            {
-                OVERLAY_LOG_INFO("Id %d:overlay_data_setParameter push mode %d",
-                                 data_shared->instance_id,value);
-                pthread_mutex_lock(&data_shared->obj_lock);
-
-                if(data_shared->overlay_mode == value) {
-                    OVERLAY_LOG_INFO("No mode change needed");
-                    pthread_mutex_unlock(&data_shared->obj_lock);
-                    return 0;
-                }
-                //We only support the change from normal mode to push mode
-                //Default setting of mode should be normal mode
-                if(value != OVERLAY_PUSH_MODE) {
-                    OVERLAY_LOG_ERR("Error!Mode change not supported");
-                    pthread_mutex_unlock(&data_shared->obj_lock);
-                    return 0;
-                }               
-                if(data_shared->free_count != data_shared->num_buffer) {
-                    //The buffer may be used by mixer
-                    //should hold until all buffer are in free queue
-                    OVERLAY_LOG_ERR("Error!Id %d:There are still %d buffers been used",
-                                    data_shared->instance_id,
-                                    data_shared->num_buffer-data_shared->free_count);
-                    pthread_mutex_unlock(&data_shared->obj_lock);
-                    return -EINVAL;
-                }
-    
-                //DeAllocate all buffers
-                for(int i = 0; i< ctx->num_buffer;i++) {
-                    ctx->allocator->deAllocate(&ctx->overlay_buffer[i]);
-                }
-    
-                //DeAllocate all buffer hdr
-                if(ctx->overlay_buffer) {
-                    free(ctx->overlay_buffer);
-                    ctx->overlay_buffer = NULL;
-                }
-    
-                //Delete allocator
-                if(ctx->allocator) {
-                    delete ctx->allocator;
-                    ctx->allocator = NULL;
-                }
-    
-                data_shared->free_count = 0;
-                data_shared->free_head = 0;
-                data_shared->free_tail = 0;
-                memset(data_shared->free_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-                data_shared->queued_count = 0;
-                data_shared->queued_head = 0;
-                data_shared->queued_tail = 0;
-                memset(data_shared->queued_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-                data_shared->overlay_mode = OVERLAY_PUSH_MODE;
-                ctx->num_buffer = 0;
-                data_shared->num_buffer = 0;
-                //Set the threashold to 1 for push mode, to avoid the conflict buffer sharing
-                //between vpu and ipu
-                ctx->queue_threshold = 1;
-                pthread_mutex_unlock(&data_shared->obj_lock);
-            }
-            break;
-        case OVERLAY_BUFNUM:
-            {
-                OVERLAY_LOG_INFO("Id %d:overlay_data_setParameter buf num %d",
-                                 data_shared->instance_id,value);
-                if(MAX_OVERLAY_BUFFER_NUM < value) {
-                    OVERLAY_LOG_ERR("Error!Id %d:Invalid vaule %d for OVERLAY_BUFNUM setting",
-                                    data_shared->instance_id,value);
-                    return -EINVAL;
-                }
-                pthread_mutex_lock(&data_shared->obj_lock);
-                if(data_shared->free_count != data_shared->num_buffer) {
-                    //The buffer may be used by mixer
-                    //should hold until all buffer are in free queue
-                    OVERLAY_LOG_ERR("Error!Id %d:There are still %d buffers been used",
-                                    data_shared->instance_id,
-                                    data_shared->num_buffer-data_shared->free_count);
-                    pthread_mutex_unlock(&data_shared->obj_lock);
-                    return -EINVAL;
-                }
-    
-                //DeAllocate all buffers
-                for(int i = 0; i< ctx->num_buffer;i++) {
-                    ctx->allocator->deAllocate(&ctx->overlay_buffer[i]);
-                }
-    
-                //DeAllocate all buffer hdr
-                if(ctx->overlay_buffer) {
-                    free(ctx->overlay_buffer);
-                    ctx->overlay_buffer = NULL;
-                }
-    
-                //Delete allocator
-                if(ctx->allocator) {
-                    delete ctx->allocator;
-                    ctx->allocator = NULL;
-                }
-    
-                data_shared->free_count = 0;
-                data_shared->free_head = 0;
-                data_shared->free_tail = 0;
-                memset(data_shared->free_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-                data_shared->queued_count = 0;
-                data_shared->queued_head = 0;
-                data_shared->queued_tail = 0;
-                memset(data_shared->queued_bufs, 0, sizeof(int)*MAX_OVERLAY_BUFFER_NUM);
-                ctx->num_buffer = value;
-                data_shared->num_buffer = value;
-    
-                int bufcount = ctx->num_buffer;
-                int bufsize = ctx->buf_size;
-                ctx->allocator = new PmemAllocator(bufcount,bufsize);
-                if(!ctx->allocator) {
-                    OVERLAY_LOG_ERR("Error!Cannot create PmemAllocator");
-                    return -1;
-                }
-            
-                //overlay_buffer should be reallocated if num_buffer changed
-                ctx->overlay_buffer = (OVERLAY_BUFFER *)malloc(sizeof(OVERLAY_BUFFER)*bufcount);
-                if(!ctx->overlay_buffer) {
-                   OVERLAY_LOG_ERR("Error!Cannot allocate overlay buffer hdr");
-                   delete ctx->allocator;
-                   ctx->allocator = NULL;
-                   pthread_mutex_unlock(&data_shared->obj_lock);
-                   return -1;
-                }
-                else{
-                   memset(ctx->overlay_buffer,0,sizeof(OVERLAY_BUFFER)*bufcount);
-                   OVERLAY_LOG_INFO("overlay_buffer 0x%p",ctx->overlay_buffer);
-                }
-                //Allocate the buffer
-                //Insert all allocated buffer into buffer freequeue
-                OVERLAY_BUFFER *pOverlayBuf = ctx->overlay_buffer;
-                for(int index =0;index < bufcount; index++) {
-                    int ret = -1;
-                    ret = ctx->allocator->allocate(pOverlayBuf, bufsize);
-                    if(ret<0) {
-                        OVERLAY_LOG_ERR("Error!Cannot allocate overlay buffer");
-                        pthread_mutex_unlock(&ctx->data_shared->obj_lock);
-                        delete ctx->allocator;
-                        return -1;
-            
-                    }
-            
-                    OVERLAY_LOG_INFO("buffer %d: vir 0x%p, phy 0x%x",index,pOverlayBuf->vir_addr,pOverlayBuf->phy_addr);
-                    ctx->data_shared->free_bufs[ctx->data_shared->free_tail] = pOverlayBuf->phy_addr;
-                    ctx->data_shared->free_count++;
-                    ctx->data_shared->free_tail++;
-                    pOverlayBuf++;
-                }
-                pthread_mutex_unlock(&data_shared->obj_lock);
-            }
-
-            break;
-        default:
-            break;
-    }
-
-    return 0;
-}
-
-int overlay_data_getBufferCount(struct overlay_data_device_t *dev)
-{
-    OVERLAY_LOG_FUNC;
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    if((!dev)) {
-       OVERLAY_LOG_ERR("Error!Invalid parameters for overlay_data_getBufferCount");
-       return 0;
-    }
-    return ctx->num_buffer;
-}
-
-static int overlay_data_close(struct hw_device_t *dev) 
-{
-    struct overlay_data_context_t* ctx = (struct overlay_data_context_t*)dev;
-    overlay_data_shared_t  *data_shared;
-    struct timespec timeout;
-    struct timeval  tv;
-
-    OVERLAY_LOG_INFO("overlay_data_close()");
-    if (ctx) {
-        /* free all resources associated with this device here
-         * in particular all pending overlay_buffer_t if needed.
-         * 
-         * NOTE: overlay_handle_t passed in initialize() is NOT freed and
-         * its file descriptors are not closed (this is the responsibility
-         * of the caller).
-         */
-        OVERLAY_LOG_INFO("overlay_data_close ctx %p buf_queued %d",ctx,ctx->buf_queued);
-        data_shared = ctx->data_shared;
-
-        if(data_shared != NULL) {
-            pthread_mutex_lock(&data_shared->obj_lock);
-            data_shared->in_destroy = true;
-            while(data_shared->queued_count > 0) {
-                OVERLAY_LOG_WARN("Warning!data close Still %d buffer in queue",
-                                data_shared->queued_count);
-                //Wait a buffer be mixered
-                data_shared->wait_buf_flag = 1;
-                //post sempore to notify mixer thread, give mixer thread a chance to free a buffer
-                if(ctx->control_shared) {
-                    sem_post(&ctx->control_shared->overlay_sem);
-                }
-                gettimeofday(&tv, (struct timezone *) NULL);
-                timeout.tv_sec = tv.tv_sec;
-                timeout.tv_nsec = (tv.tv_usec + 200000) * 1000L;//200ms
-                pthread_cond_timedwait(&data_shared->free_cond, &data_shared->obj_lock,&timeout);
-                if(data_shared->wait_buf_flag != 0) {
-                    OVERLAY_LOG_ERR("Error!cannot make a buffer flushed");
-               }
-            }
-
-            if(data_shared->buf_mixing) {
-                int wait_count = 0;
-                LOGW("Current this overlay is in buf_mixing! Have to wait it done");
-                pthread_mutex_unlock(&data_shared->obj_lock);
-                //Make a sleep for 10ms
-                do{
-                    usleep(2000);
-                    wait_count++;
-                    if(wait_count > 5) {
-                        OVERLAY_LOG_ERR("Error!Still cannot wait the buf mix done!");
-                        break;
-                    }
-                }while (data_shared->buf_mixing);
-            }
-            else{
-                pthread_mutex_unlock(&data_shared->obj_lock);
-            }
-        }
-
-        //Close the share file for data and control
-        close_data_shared_data(ctx);
-        close_control_shared_data(ctx);
-
-        //DeAllocate all buffers
-        for(int i = 0; i< ctx->num_buffer;i++) {
-            ctx->allocator->deAllocate(&ctx->overlay_buffer[i]);
-        }
-        
-        //DeAllocate all buffer hdr
-        if(ctx->overlay_buffer) {
-            free(ctx->overlay_buffer);
-        }
-
-        //Delete allocator
-        if(ctx->allocator) {
-            delete ctx->allocator;
-        }
-        free(ctx);
-        OVERLAY_LOG_INFO("overlay_data_close exit");
-    }
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int overlay_device_open(const struct hw_module_t* module, const char* name,
-        struct hw_device_t** device)
-{
-    OVERLAY_LOG_FUNC;
-    int status = -EINVAL;
-    OVERLAY_LOG_INFO("overlay_device_open %s pid %d,tid %d",name,getpid(),gettid());
-    if (!strcmp(name, OVERLAY_HARDWARE_CONTROL)) {
-        
-        struct overlay_control_context_t *dev;
-
-        dev = (overlay_control_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = overlay_control_close;
-        
-        dev->device.get = overlay_get;
-        dev->device.createOverlay = overlay_createOverlay;
-        dev->device.destroyOverlay = overlay_destroyOverlay;
-        dev->device.setPosition = overlay_setPosition;
-        dev->device.getPosition = overlay_getPosition;
-        dev->device.setParameter = overlay_setParameter;
-        dev->device.stage = overlay_stage;
-        dev->device.commit = overlay_commit;
-
-        *device = &dev->device.common;
-        dev->outpixelformat = V4L2_PIX_FMT_UYVY;
-        //dev->outpixelformat = V4L2_PIX_FMT_YUV420;
-        if(pthread_mutex_init(&(dev->control_lock), NULL)!=0 ){
-            OVERLAY_LOG_ERR("Error!init control_lock failed");
-            goto err_control_exit;
-        }
-
-        if(overlay_init_fbdev(dev)<0){
-            OVERLAY_LOG_ERR("Error!init fbdev failed");
-            goto err_control_exit;
-        }
-
-        //Only init v4l as needed
-        //if(overlay_init_v4l(dev)<0){
-        //    OVERLAY_LOG_ERR("Error!init v4l failed");
-        //    goto err_control_exit;
-        //}
-        dev->control_shared_fd = create_control_shared_data(&dev->control_shared);
-        dev->control_shared_size = dev->control_shared->size;
-        if(dev->control_shared_fd < 0 || !dev->control_shared){
-            OVERLAY_LOG_ERR("Error!init control share failed");
-            goto err_control_exit;
-        }
-
-        dev->overlay_running = true;
-        dev->overlay_thread = new OverlayThread(dev);
-        dev->overlay_thread->run("OverlayThread", PRIORITY_URGENT_DISPLAY);
-        status = 0;
-        OVERLAY_LOG_INFO("Overlay HAL control device Created successfully");
-        return status;
-
-err_control_exit:
-        OVERLAY_LOG_ERR("Error!init overlay_control_context_t failed");
-        if(dev) {
-            if(dev->overlay_thread) {
-                delete dev->overlay_thread;
-                dev->overlay_thread = NULL;
-            }
-
-            for(int buf_index=0;buf_index < dev->v4l_bufcount;buf_index++) {
-               if(dev->v4lbuf_addr[buf_index])
-                  munmap((void *)dev->v4lbuf_addr[buf_index], dev->v4l_buffers[buf_index].length);
-               memset(&dev->v4l_buffers[buf_index],0,sizeof(v4l2_buffer));
-               dev->v4lbuf_addr[buf_index] = NULL;
-            }
-
-            dev->v4l_bufcount = 0;
-
-            if(dev->v4l_id) {
-                close(dev->v4l_id);
-                dev->v4l_id = 0;
-            }
-
-            if(dev->alpha_buffers[0].vir_addr){
-                munmap((void *)dev->alpha_buffers[0].vir_addr, dev->alpha_buffers[0].size);
-                memset(&dev->alpha_buffers[0],0,sizeof(OVERLAY_BUFFER));
-            }
-            if(dev->alpha_buffers[1].vir_addr){
-                munmap((void *)dev->alpha_buffers[1].vir_addr, dev->alpha_buffers[1].size);
-                memset(&dev->alpha_buffers[1],0,sizeof(OVERLAY_BUFFER));
-            }
-
-            if(dev->fb_dev) {
-                close(dev->fb_dev);
-                dev->fb_dev = 0;
-            }
-
-            free(dev);
-        }
-        status = -1;
-
-    } else if (!strcmp(name, OVERLAY_HARDWARE_DATA)) {
-        struct overlay_data_context_t *dev;
-        dev = (overlay_data_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = overlay_data_close;
-        
-        dev->device.initialize = overlay_data_initialize;
-        dev->device.dequeueBuffer = overlay_data_dequeueBuffer;
-        dev->device.queueBuffer = overlay_data_queueBuffer;
-        dev->device.getBufferAddress = overlay_data_getBufferAddress;
-        dev->device.getBufferAddressPhy = overlay_data_getBufferAddressPhy;
-        dev->device.resizeInput = overlay_data_resizeInput;
-        dev->device.setCrop = overlay_data_setCrop;
-        dev->device.getCrop = overlay_data_getCrop;
-        dev->device.setParameter = overlay_data_setParameter;
-        dev->device.getBufferCount = overlay_data_getBufferCount;
-
-        *device = &dev->device.common;
-        status = 0;
-    }
-    return status;
-}
diff --git a/liboverlay/overlay_pmem.cpp b/liboverlay/overlay_pmem.cpp
deleted file mode 100755
index ff26c2b..0000000
--- a/liboverlay/overlay_pmem.cpp
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <linux/videodev.h>
-#include <linux/fb.h>
-#include <sys/mman.h>
-#include <linux/mxcfb.h>
-
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-
-#include <hardware/hardware.h>
-#include <hardware/overlay.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-#include <utils/List.h>
-#include <ui/PixelFormat.h>
-#include <linux/android_pmem.h>
-#include "overlay_pmem.h"
-
-/*
-*   input parameter: 
-*/
-PmemAllocator::PmemAllocator(int bufCount, int bufSize):
-    mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
-    mVirBase(NULL),mPhyBase(NULL)
-{
-    OVERLAY_LOG_FUNC;
-    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
-
-    int err;
-    struct pmem_region region;
-    mFD = open(PMEM_DEV, O_RDWR);
-    if (mFD < 0) {
-         OVERLAY_LOG_ERR("Error!PmemAllocator constructor");
-         return;
-    }
-
-    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
-    if (err == 0)
-    {
-         OVERLAY_LOG_INFO("Info!get pmem total size %d",(int)region.len);
-    }
-    else
-    {
-        OVERLAY_LOG_ERR("Error!Cannot get total length in PmemAllocator constructor");
-        return;
-    }
-    
-    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
-    
-    mTotalSize = mBufSize*bufCount;
-    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
-        OVERLAY_LOG_ERR("Error!Out of PmemAllocator capability");
-    }
-    else
-    {
-        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
-            PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
-
-        if (virtualbase == MAP_FAILED) {
-           OVERLAY_LOG_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
-                   mFD, (unsigned int)mTotalSize, strerror(errno));
-           return;
-        }
-
-        memset(&region, 0, sizeof(region));
-    
-        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
-        {
-          OVERLAY_LOG_ERR("Error!Failed to get physical address of source!\n");
-          munmap(virtualbase, mTotalSize);
-          return;
-        }
-        mVirBase = (void *)virtualbase;
-        mPhyBase = region.offset;
-        OVERLAY_LOG_INFO("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
-    }
-}
-
-PmemAllocator::~PmemAllocator()
-{
-    OVERLAY_LOG_FUNC;
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(mSlotAllocated[index]) {
-            OVERLAY_LOG_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
-        }
-    }
-
-    if(mVirBase) {
-        munmap(mVirBase, mTotalSize);
-    }
-    if(mFD) {
-        close(mFD);
-    }
-     
-}
-
-int PmemAllocator::allocate(struct OVERLAY_BUFFER *overlay_buf, int size)
-{
-    OVERLAY_LOG_FUNC;
-    if((!mVirBase)||(!overlay_buf)||(size>mBufSize)) {
-        OVERLAY_LOG_ERR("Error!No memory for allocator");
-        return -1;
-    }
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(!mSlotAllocated[index]) {
-            OVERLAY_LOG_RUNTIME("Free slot %d for allocating mBufSize %d request size %d",
-                             index,mBufSize,size);
-
-            overlay_buf->vir_addr = (void *)((char *)mVirBase+index*mBufSize); 
-            overlay_buf->phy_addr = mPhyBase+index*mBufSize;
-            overlay_buf->size = mBufSize;
-            mSlotAllocated[index] = true;
-            return 0;
-        }
-    }
-    return -1;
-}
-
-int PmemAllocator::deAllocate(OVERLAY_BUFFER *overlay_buf)
-{
-    OVERLAY_LOG_FUNC;
-    if((!mVirBase)||(!overlay_buf)) {
-        OVERLAY_LOG_ERR("Error!No memory for allocator");
-        return -1;
-    }
-    int nSlot = ((unsigned int)overlay_buf->vir_addr - (unsigned int)mVirBase)/mBufSize;
-    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
-        OVERLAY_LOG_RUNTIME("Info!deAllocate for slot %d",nSlot);
-        mSlotAllocated[nSlot] = false;
-        return 0;
-    }
-    else{
-        OVERLAY_LOG_ERR("Error!Not a valid buffer");
-        return -1;
-    }
-}
diff --git a/liboverlay/overlay_pmem.h b/liboverlay/overlay_pmem.h
deleted file mode 100755
index e7e7d65..0000000
--- a/liboverlay/overlay_pmem.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __OVERLAY_H__
-#define __OVERLAY_H__
-
-#include "overlay_utils.h"
-#define DEFAULT_PMEM_ALIGN (4096)
-#define PMEM_DEV "/dev/pmem_adsp"
-#define MAX_SLOT 64
-
-class PmemAllocator: public OverlayAllocator
-{
-public:
-    PmemAllocator(int bufCount,int bufSize);
-    virtual ~PmemAllocator();
-    virtual int allocate(OVERLAY_BUFFER *overlay_buf, int size);
-    virtual int deAllocate(OVERLAY_BUFFER *overlay_buf);
-    virtual int getHeapID(){  return mFD;  }
-private:
-    int mFD;
-    unsigned long mTotalSize;
-    int mBufCount;
-    int mBufSize;
-    void *mVirBase;
-    unsigned int mPhyBase;
-    bool mSlotAllocated[MAX_SLOT];
-};
-
-#endif
diff --git a/liboverlay/overlay_thread.h b/liboverlay/overlay_thread.h
deleted file mode 100755
index 5da3612..0000000
--- a/liboverlay/overlay_thread.h
+++ /dev/null
@@ -1,724 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __OVERLAY_THREAD_H__
-#define __OVERLAY_THREAD_H__
-
-#include <utils/threads.h>
-
-
-class OverlayThread: public Thread {
-    struct overlay_control_context_t *m_dev;
-    struct v4l2_buffer mLatestQueuedBuf;
-    ipu_lib_input_param_t mIPUInputParam;   
-    ipu_lib_output_param_t mIPUOutputParam; 
-    ipu_lib_handle_t            mIPUHandle;
-    int mIPURet;
-	unsigned int ClearBufMask;
-	unsigned int DisplayChanged;
-	unsigned int DisplayBufMask;
-
-    public:
-    OverlayThread(struct overlay_control_context_t *dev)
-        : Thread(false),m_dev(dev){
-        memset(&mIPUInputParam,0,sizeof(mIPUInputParam));
-        memset(&mIPUOutputParam,0,sizeof(mIPUOutputParam));
-        memset(&mIPUHandle,0,sizeof(mIPUHandle));
-        memset(&mLatestQueuedBuf,0,sizeof(mLatestQueuedBuf));
-		ClearBufMask = 0;
-		DisplayBufMask =0;
-		DisplayChanged = 0;
-    }
-
-    virtual void onFirstRef() {
-        OVERLAY_LOG_FUNC;
-        //run("OverlayThread", PRIORITY_URGENT_DISPLAY);
-    }
-    virtual bool threadLoop() {
-        int index = 0;
-        overlay_object *overlayObj0;
-        overlay_object *overlayObj1;
-        overlay_data_shared_t *dataShared0;
-        overlay_data_shared_t *dataShared1;
-        unsigned int overlay_buf0;
-        unsigned int overlay_buf1;
-        bool outchange0;
-        bool outchange1;
-        WIN_REGION overlay0_outregion;
-        WIN_REGION overlay1_outregion;
-        int rotation0;
-        int rotation1;
-        int crop_x0 = 0,crop_y0 = 0,crop_w0 = 0,crop_h0 = 0;
-        int crop_x1 = 0,crop_y1 = 0,crop_w1 = 0,crop_h1 = 0;
-
-
-        while(m_dev&&(m_dev->overlay_running)) {
-            OVERLAY_LOG_RUNTIME("Overlay thread running pid %d tid %d", getpid(),gettid());
-
-            //Wait for semphore for overlay instance buffer queueing
-            sem_wait(&m_dev->control_shared->overlay_sem);
-            OVERLAY_LOG_RUNTIME("Get overlay semphore here pid %d tid %d",getpid(),gettid());
-            overlayObj0 = NULL;
-            overlayObj1 = NULL;
-            dataShared0 = NULL;
-            dataShared1 = NULL;
-            overlay_buf0 = NULL;
-            overlay_buf1 = NULL;
-            outchange0 = false;
-            outchange1 = false;
-            memset(&overlay0_outregion, 0, sizeof(overlay0_outregion));
-            memset(&overlay1_outregion, 0, sizeof(overlay1_outregion));
-
-            //Check current active overlay instance
-            pthread_mutex_lock(&m_dev->control_lock);
-    
-            if(m_dev->overlay_number >= 1) {
-                for(index= 0;index < MAX_OVERLAY_INSTANCES;index++) {
-                    if(m_dev->overlay_instance_valid[index]) {
-                        if(!overlayObj0) {
-                            overlayObj0 = m_dev->overlay_intances[index];
-                        }
-                        //For those small zorder, it should be drawn firstly
-                        else if(m_dev->overlay_intances[index]->zorder < overlayObj0->zorder){
-                            overlayObj1 = overlayObj0;
-                            overlayObj0 = m_dev->overlay_intances[index];
-                        }
-                        else{
-                            overlayObj1 = m_dev->overlay_intances[index];
-                        }
-                    }
-                }
-            }
-
-            pthread_mutex_unlock(&m_dev->control_lock);            
-               
-
-            if(overlayObj0) {
-                dataShared0 = overlayObj0->mDataShared;
-                OVERLAY_LOG_RUNTIME("Process obj 0 instance_id %d, dataShared0 0x%x",
-                                    dataShared0->instance_id,dataShared0);
-                pthread_mutex_lock(&dataShared0->obj_lock);
-                //Fetch one buffer from each overlay instance buffer queue
-                OVERLAY_LOG_RUNTIME("queued_count %d,queued_head %d",
-                     dataShared0->queued_count,dataShared0->queued_head);
-
-                //If this overlay is under destroy, just return all buffers in queue
-                //The user should guarantee the buffer all to be flushed before destroy it.
-                if(dataShared0->in_destroy) {
-                     OVERLAY_LOG_INFO("Overlay in destroy,flush queue as queued_count %d,queued_head %d",
-                     dataShared0->queued_count,dataShared0->queued_head);
-                     while(dataShared0->queued_count > 0) {
-                        //fetch the head buffer in queued buffers
-                        overlay_buf0 = dataShared0->queued_bufs[dataShared0->queued_head];
-                        OVERLAY_LOG_RUNTIME("id %d Get queue buffer for Overlay Instance 0: 0x%x queued_count %d",
-                             dataShared0->instance_id,overlay_buf0,dataShared0->queued_count);
-                        dataShared0->queued_bufs[dataShared0->queued_head] = 0;
-                        dataShared0->queued_head ++;
-                        dataShared0->queued_head = dataShared0->queued_head%MAX_OVERLAY_BUFFER_NUM;
-                        dataShared0->queued_count --;
-
-                        //For push mode, no need to return the buffer back
-                        if(dataShared0->overlay_mode == OVERLAY_NORAML_MODE) {
-                            dataShared0->free_bufs[dataShared0->free_tail] = overlay_buf0;
-                            OVERLAY_LOG_RUNTIME("Id %d back buffer to free queue for Overlay Instance 0: 0x%x at %d free_count %d",
-                                 dataShared0->instance_id,overlay_buf0,dataShared0->free_tail,dataShared0->free_count+1);
-                            dataShared0->free_tail++;
-                            dataShared0->free_tail = dataShared0->free_tail%MAX_OVERLAY_BUFFER_NUM;
-                            dataShared0->free_count++;
-                            if(dataShared0->free_count > dataShared0->num_buffer) {
-                                OVERLAY_LOG_ERR("Error!free_count %d is greater the total number %d",
-                                                dataShared0->free_count,dataShared0->num_buffer);
-                            }
-                        }
-
-                        if(dataShared0->wait_buf_flag) {
-                            dataShared0->wait_buf_flag = 0;
-                            OVERLAY_LOG_RUNTIME("Id %d Condition signal for Overlay Instance 0",dataShared0->instance_id);
-                            pthread_cond_signal(&dataShared0->free_cond);
-                        }
-                     }
-                     overlay_buf0 = NULL;
-                }
-
-                if(dataShared0->queued_count > 0) 
-                {
-                    //fetch the head buffer in queued buffers
-                    overlay_buf0 = dataShared0->queued_bufs[dataShared0->queued_head];
-                    OVERLAY_LOG_RUNTIME("id %d Get queue buffer for Overlay Instance 0: 0x%x queued_count %d",
-                         dataShared0->instance_id,overlay_buf0,dataShared0->queued_count);
-                    dataShared0->queued_bufs[dataShared0->queued_head] = 0;
-                    dataShared0->queued_head ++;
-                    dataShared0->queued_head = dataShared0->queued_head%MAX_OVERLAY_BUFFER_NUM;
-                    dataShared0->queued_count --;
-                    dataShared0->buf_mixing = true;
-                }       
-
-                //Check whether output area and zorder changing occure, so 
-                //to paint v4l2 buffer or setting fb0/1's local 
-                //alpha buffer                 
-                outchange0 = overlayObj0->out_changed;
-                if(overlay_buf0) {
-                    overlayObj0->out_changed = 0;
-                }
-                overlay0_outregion.left = overlayObj0->outX;
-                overlay0_outregion.right = overlayObj0->outX+overlayObj0->outW;
-                overlay0_outregion.top = overlayObj0->outY;
-                overlay0_outregion.bottom = overlayObj0->outY+overlayObj0->outH;
-                rotation0 = overlayObj0->rotation;
-                crop_x0 = dataShared0->crop_x;
-                crop_y0 = dataShared0->crop_y;  
-                crop_w0 = dataShared0->crop_w;
-                crop_h0 = dataShared0->crop_h;
-                pthread_mutex_unlock(&dataShared0->obj_lock); 
-            }
-
-            if(overlayObj1) {
-                dataShared1 = overlayObj1->mDataShared;
-                OVERLAY_LOG_RUNTIME("Process obj 0 instance_id %d dataShared0 0x%x",
-                                    dataShared0->instance_id,dataShared0);
-                pthread_mutex_lock(&dataShared1->obj_lock);
-
-                //If this overlay is under destroy, just return all buffers in queue
-                //The user should guarantee the buffer all to be flushed before destroy it.
-                if(dataShared1->in_destroy) {
-                     OVERLAY_LOG_INFO("Overlay in destroy,flush queue as queued_count %d,queued_head %d",
-                     dataShared1->queued_count,dataShared1->queued_head);
-                     while(dataShared1->queued_count > 0) {
-                        //fetch the head buffer in queued buffers
-                        overlay_buf1 = dataShared1->queued_bufs[dataShared1->queued_head];
-                        OVERLAY_LOG_RUNTIME("id %d Get queue buffer for Overlay Instance 0: 0x%x queued_count %d",
-                             dataShared1->instance_id,overlay_buf1,dataShared1->queued_count);
-                        dataShared1->queued_bufs[dataShared1->queued_head] = 0;
-                        dataShared1->queued_head ++;
-                        dataShared1->queued_head = dataShared1->queued_head%MAX_OVERLAY_BUFFER_NUM;
-                        dataShared1->queued_count --;
-
-                        //For push mode, no need to return the buffer back
-                        if(dataShared1->overlay_mode == OVERLAY_NORAML_MODE) {
-                            dataShared1->free_bufs[dataShared1->free_tail] = overlay_buf1;
-                            OVERLAY_LOG_RUNTIME("Id %d back buffer to free queue for Overlay Instance 0: 0x%x at %d free_count %d",
-                                 dataShared1->instance_id,overlay_buf1,dataShared1->free_tail,dataShared1->free_count+1);
-                            dataShared1->free_tail++;
-                            dataShared1->free_tail = dataShared1->free_tail%MAX_OVERLAY_BUFFER_NUM;
-                            dataShared1->free_count++;
-                            if(dataShared1->free_count > dataShared1->num_buffer) {
-                                OVERLAY_LOG_ERR("Error!free_count %d is greater the total number %d",
-                                                dataShared1->free_count,dataShared1->num_buffer);
-                            }
-                        }
-
-                        if(dataShared1->wait_buf_flag) {
-                            dataShared1->wait_buf_flag = 0;
-                            OVERLAY_LOG_RUNTIME("Id %d Condition signal for Overlay Instance 0",dataShared1->instance_id);
-                            pthread_cond_signal(&dataShared1->free_cond);
-                        }
-
-                     }
-                     overlay_buf1 = NULL;
-                }
-
-
-                //Fetch one buffer from each overlay instance buffer queue
-                if(dataShared1->queued_count > 0) 
-                {
-                    //fetch the head buffer in queued buffers
-                    overlay_buf1 = dataShared1->queued_bufs[dataShared1->queued_head];
-                    OVERLAY_LOG_RUNTIME("Id %d Get queue buffer for Overlay Instance 1: 0x%x queued_count %d",
-                         dataShared1->instance_id,overlay_buf1,dataShared1->queued_count);
-                    dataShared1->queued_bufs[dataShared1->queued_head] = 0;
-                    dataShared1->queued_head ++;
-                    dataShared1->queued_head = dataShared1->queued_head%MAX_OVERLAY_BUFFER_NUM;
-                    dataShared1->queued_count --;
-                    dataShared1->buf_mixing = true;
-                }       
-
-                //Check whether output area and zorder changing occure, so 
-                //to paint v4l2 buffer or setting fb0/1's local 
-                //alpha buffer                 
-                outchange1 = overlayObj1->out_changed;
-                if(overlay_buf1) {
-                    overlayObj1->out_changed = 0;
-                }
-                overlay1_outregion.left = overlayObj1->outX;
-                overlay1_outregion.right = overlayObj1->outX+overlayObj1->outW;
-                overlay1_outregion.top = overlayObj1->outY;
-                overlay1_outregion.bottom = overlayObj1->outY+overlayObj1->outH;
-                rotation1 = overlayObj1->rotation;
-                crop_x1 = dataShared1->crop_x;
-                crop_y1 = dataShared1->crop_y;  
-                crop_w1 = dataShared1->crop_w;
-                crop_h1 = dataShared1->crop_h;
-                pthread_mutex_unlock(&dataShared1->obj_lock); 
-            }
-
-            if((!overlay_buf0)&&(!overlay_buf1)) {
-                OVERLAY_LOG_RUNTIME("Nothing to do in overlay mixer thread!");
-                //It is just a loop function in the loopless of this thread
-                //So make a break here, and it will come back later
-                continue;
-            }
-            if((overlay_buf0)&&(overlay_buf1)) {
-                OVERLAY_LOG_RUNTIME("Two instance mixer needed");
-            } 
-                      
-            //Check whether refill the origin area to black
-            if(outchange0||outchange1) {
-				DisplayChanged = 1;
-				ClearBufMask |= DisplayBufMask;
-				DisplayBufMask = 0;
-                OVERLAY_LOG_INFO("Mixer thread refill the origin area to black");
-            }
-
-            //Check whether need copy back the latest frame to current frame
-            //If only buf0  is available, copy back the overlay1's area in v4l latest buffer after show buf0
-            //to v4l current buffer
-            //If only buf1  is available, copy back the overlay1's area in v4l latest buffer before show buf1
-            //to v4l current buffer
-
-            //Dequeue a V4L2 Buffer
-            struct v4l2_buffer *pV4LBuf;
-            struct v4l2_buffer v4lbuf;
-            memset(&v4lbuf, 0, sizeof(v4l2_buffer));
-            if(m_dev->video_frames < m_dev->v4l_bufcount) {
-                pV4LBuf = &m_dev->v4l_buffers[m_dev->video_frames];
-            }
-            else{
-                v4lbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-                v4lbuf.memory = V4L2_MEMORY_MMAP;
-                if(ioctl(m_dev->v4l_id, VIDIOC_DQBUF, &v4lbuf) < 0){
-                    OVERLAY_LOG_ERR("Error!Cannot DQBUF a buffer from v4l");
-
-                    //stream off it,so to make it recover
-                    int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-                    ioctl(m_dev->v4l_id, VIDIOC_STREAMOFF, &type);
-                    m_dev->stream_on = false;
-                    m_dev->video_frames = 0;
-                    //reset latest queued buffer, since all buffer will start as init
-                    memset(&mLatestQueuedBuf,0,sizeof(mLatestQueuedBuf));
-                    goto free_buf_exit;
-                }
-                pV4LBuf = &v4lbuf;
-            }
-
-            {	//record the displayed mask
-                unsigned int CurBufMask = 1 << (pV4LBuf->index);
-                DisplayBufMask |= CurBufMask;
-                if(DisplayChanged == 1){
-                    if ((ClearBufMask & CurBufMask) != 0){
-                        fill_frame_back(m_dev->v4lbuf_addr[pV4LBuf->index], pV4LBuf->length, m_dev->xres, m_dev->yres, m_dev->outpixelformat);
-                        ClearBufMask &= ~CurBufMask;
-                    }
-                    if (ClearBufMask == 0)
-                        DisplayChanged = 0;
-                }
-            }
-
-            OVERLAY_LOG_RUNTIME("DQBUF from v4l 0x%x:index %d, vir 0x%x, phy 0x%x, len %d",
-                                pV4LBuf,pV4LBuf->index,m_dev->v4lbuf_addr[pV4LBuf->index],
-                                pV4LBuf->m.offset,pV4LBuf->length);   
-                      
-            //Copyback before ipu update when two active instance, and obj0 has no buffer to update
-            //obj1 has buffer to update
-            if((overlayObj0)&&(overlayObj1)&&
-               (!overlay_buf0)&&(overlay_buf1)&&
-               (dataShared0->buf_showed))
-            {
-                OVERLAY_LOG_RUNTIME("Copyback before ipu update");
-                if((mLatestQueuedBuf.m.offset)&&
-                   (mLatestQueuedBuf.m.offset != pV4LBuf->m.offset)) {
-                    //Copy back the region of obj0 to the current v4l buffer
-                    //Setting input format
-                    mIPUInputParam.width = m_dev->xres;
-                    mIPUInputParam.height = m_dev->yres;
-
-                    mIPUInputParam.input_crop_win.pos.x = overlay0_outregion.left;
-                    mIPUInputParam.input_crop_win.pos.y = overlay0_outregion.top;  
-                    mIPUInputParam.input_crop_win.win_w = overlay0_outregion.right - overlay0_outregion.left;
-                    mIPUInputParam.input_crop_win.win_h = overlay0_outregion.bottom - overlay0_outregion.top;
-                    mIPUInputParam.fmt = m_dev->outpixelformat;
-                    mIPUInputParam.user_def_paddr[0] = mLatestQueuedBuf.m.offset;
-
-                    //Setting output format
-                    //Should align with v4l
-                    mIPUOutputParam.fmt = m_dev->outpixelformat;
-                    mIPUOutputParam.width = m_dev->xres;
-                    mIPUOutputParam.height = m_dev->yres;   
-                    mIPUOutputParam.show_to_fb = 0;
-                    //Output param should be same as input, since no resize,crop
-                    mIPUOutputParam.output_win.pos.x = mIPUInputParam.input_crop_win.pos.x;
-                    mIPUOutputParam.output_win.pos.y = mIPUInputParam.input_crop_win.pos.y;
-                    mIPUOutputParam.output_win.win_w = mIPUInputParam.input_crop_win.win_w;
-                    mIPUOutputParam.output_win.win_h = mIPUInputParam.input_crop_win.win_h;
-                    mIPUOutputParam.rot = 0;
-                    mIPUOutputParam.user_def_paddr[0] = pV4LBuf->m.offset;
-                    OVERLAY_LOG_RUNTIME("Copyback(before) Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                          mIPUOutputParam.width,
-                          mIPUOutputParam.height,
-                          mIPUOutputParam.output_win.pos.x,
-                          mIPUOutputParam.output_win.pos.y,
-                          mIPUOutputParam.output_win.win_w,
-                          mIPUOutputParam.output_win.win_h,
-                          mIPUOutputParam.rot);
-                                     
-                    OVERLAY_LOG_RUNTIME("Copyback(before) Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                                     mIPUInputParam.width,
-                                     mIPUInputParam.height,
-                                     mIPUInputParam.fmt,
-                                     mIPUInputParam.input_crop_win.pos.x,
-                                     mIPUInputParam.input_crop_win.pos.y,
-                                     mIPUInputParam.input_crop_win.win_w,
-                                     mIPUInputParam.input_crop_win.win_h);     
-    
-                    mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-                    if (mIPURet < 0) {
-                       OVERLAY_LOG_ERR("Error!Copyback(before) mxc_ipu_lib_task_init failed mIPURet %d!",mIPURet);
-                       goto queue_buf_exit;
-                    }  
-                    OVERLAY_LOG_RUNTIME("Copyback(before) mxc_ipu_lib_task_init success");
-                    mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,overlay_buf0,pV4LBuf->m.offset,NULL,NULL,NULL);
-                    if (mIPURet < 0) {
-                          OVERLAY_LOG_ERR("Error!Copyback(before) mxc_ipu_lib_task_buf_update failed mIPURet %d!",mIPURet);
-                          mxc_ipu_lib_task_uninit(&mIPUHandle);
-                          memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                          goto queue_buf_exit;
-                    }
-                    OVERLAY_LOG_RUNTIME("Copyback(before) mxc_ipu_lib_task_buf_update success");
-                    mxc_ipu_lib_task_uninit(&mIPUHandle);
-                    memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                }
-                else{
-                    OVERLAY_LOG_ERR("Error!Cannot Copyback before ipu update last buf 0x%x,curr buf 0x%x",
-                                    mLatestQueuedBuf.m.offset,
-                                    pV4LBuf->m.offset);
-                }
-            }
-
-            //Mixer the first buffer from overlay instance0 to V4L2 Buffer
-            if(overlay_buf0 && (overlayObj0->outX != 0  ||
-                     overlayObj0->outY != 0  ||
-                     overlayObj0->outW != 0  ||
-                     overlayObj0->outH != 0)) {
-                //Setting input format
-                mIPUInputParam.width = overlayObj0->mHandle.width;
-                mIPUInputParam.height = overlayObj0->mHandle.height;
-                mIPUInputParam.input_crop_win.pos.x = crop_x0;
-                mIPUInputParam.input_crop_win.pos.y = crop_y0;  
-                mIPUInputParam.input_crop_win.win_w = crop_w0;
-                mIPUInputParam.input_crop_win.win_h = crop_h0;
-
-                if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-                    mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
-                }
-                else if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
-                    mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
-                }
-                else if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_RGB_565) {
-                    mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-                }else{
-                    OVERLAY_LOG_ERR("Error!Not supported input format %d",overlayObj0->mHandle.format);
-                    goto queue_buf_exit;
-                }
-                mIPUInputParam.user_def_paddr[0] = overlay_buf0;
-
-                //Setting output format
-                //Should align with v4l
-                mIPUOutputParam.fmt = m_dev->outpixelformat;
-                mIPUOutputParam.width = m_dev->xres;
-                mIPUOutputParam.height = m_dev->yres;   
-                mIPUOutputParam.show_to_fb = 0;
-                mIPUOutputParam.output_win.pos.x = overlayObj0->outX;
-                mIPUOutputParam.output_win.pos.y = overlayObj0->outY;
-                mIPUOutputParam.output_win.win_w = overlayObj0->outW;
-                mIPUOutputParam.output_win.win_h = overlayObj0->outH;
-                mIPUOutputParam.rot = overlayObj0->rotation;
-                mIPUOutputParam.user_def_paddr[0] = pV4LBuf->m.offset;
-                OVERLAY_LOG_RUNTIME("Obj0 Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                      mIPUOutputParam.width,
-                      mIPUOutputParam.height,
-                      mIPUOutputParam.output_win.pos.x,
-                      mIPUOutputParam.output_win.pos.y,
-                      mIPUOutputParam.output_win.win_w,
-                      mIPUOutputParam.output_win.win_h,
-                      mIPUOutputParam.rot);
-                                 
-                OVERLAY_LOG_RUNTIME("Obj0 Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                                 mIPUInputParam.width,
-                                 mIPUInputParam.height,
-                                 mIPUInputParam.fmt,
-                                 mIPUInputParam.input_crop_win.pos.x,
-                                 mIPUInputParam.input_crop_win.pos.y,
-                                 mIPUInputParam.input_crop_win.win_w,
-                                 mIPUInputParam.input_crop_win.win_h);     
-
-                mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-                if (mIPURet < 0) {
-                   OVERLAY_LOG_ERR("Error!Obj0 mxc_ipu_lib_task_init failed mIPURet %d!",mIPURet);
-                   goto queue_buf_exit;
-                }  
-                OVERLAY_LOG_RUNTIME("Obj0 mxc_ipu_lib_task_init success");
-                mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,overlay_buf0,pV4LBuf->m.offset,NULL,NULL,NULL);
-                if (mIPURet < 0) {
-                      OVERLAY_LOG_ERR("Error!Obj0 mxc_ipu_lib_task_buf_update failed mIPURet %d!",mIPURet);
-                      mxc_ipu_lib_task_uninit(&mIPUHandle);
-                      memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                      goto queue_buf_exit;
-                }
-                OVERLAY_LOG_RUNTIME("Obj0 mxc_ipu_lib_task_buf_update success");
-                mxc_ipu_lib_task_uninit(&mIPUHandle);
-                memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-            }
-
-            //Check whether we need to do another mixer, based on
-            //buffers in overlay instance1's buffer queue
-            if(overlay_buf1 && (overlayObj1->outX != 0  ||
-                     overlayObj1->outY != 0  ||
-                     overlayObj1->outW != 0  ||
-                     overlayObj1->outH != 0)) {
-                //Setting input format
-                mIPUInputParam.width = overlayObj1->mHandle.width;
-                mIPUInputParam.height = overlayObj1->mHandle.height;
-                mIPUInputParam.input_crop_win.pos.x = crop_x1;
-                mIPUInputParam.input_crop_win.pos.y = crop_y1;  
-                mIPUInputParam.input_crop_win.win_w = crop_w1;
-                mIPUInputParam.input_crop_win.win_h = crop_h1;
-
-
-                if(overlayObj1->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-                    mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
-                }
-                else if(overlayObj1->mHandle.format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
-                    mIPUInputParam.fmt = v4l2_fourcc('N', 'Y', '1', '2');
-                }
-                else if(overlayObj0->mHandle.format == HAL_PIXEL_FORMAT_RGB_565) {
-                    mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-                }else{
-                    OVERLAY_LOG_ERR("Error!Obj1 Not supported input format %d",overlayObj1->mHandle.format);
-                    goto queue_buf_exit;
-                }
-                mIPUInputParam.user_def_paddr[0] = overlay_buf1;
-
-                //Setting output format
-                mIPUOutputParam.fmt = v4l2_fourcc('U', 'Y', 'V', 'Y');
-                mIPUOutputParam.width = m_dev->xres;
-                mIPUOutputParam.height = m_dev->yres;   
-                mIPUOutputParam.show_to_fb = 0;
-                mIPUOutputParam.output_win.pos.x = overlayObj1->outX;
-                mIPUOutputParam.output_win.pos.y = overlayObj1->outY;
-                mIPUOutputParam.output_win.win_w = overlayObj1->outW;
-                mIPUOutputParam.output_win.win_h = overlayObj1->outH;
-                mIPUOutputParam.rot = overlayObj1->rotation;
-                mIPUOutputParam.user_def_paddr[0] = pV4LBuf->m.offset;
-                OVERLAY_LOG_RUNTIME("Obj1 Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                      mIPUOutputParam.width,
-                      mIPUOutputParam.height,
-                      mIPUOutputParam.output_win.pos.x,
-                      mIPUOutputParam.output_win.pos.y,
-                      mIPUOutputParam.output_win.win_w,
-                      mIPUOutputParam.output_win.win_h,
-                      mIPUOutputParam.rot);
-                                 
-                OVERLAY_LOG_RUNTIME("Obj1 Input param:width %d,height %d,fmt %d,crop_win pos x %d,crop_win pos y %d,crop_win win_w %d,crop_win win_h %d",
-                                 mIPUInputParam.width,
-                                 mIPUInputParam.height,
-                                 mIPUInputParam.fmt,
-                                 mIPUInputParam.input_crop_win.pos.x,
-                                 mIPUInputParam.input_crop_win.pos.y,
-                                 mIPUInputParam.input_crop_win.win_w,
-                                 mIPUInputParam.input_crop_win.win_h);     
-
-                mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-                if (mIPURet < 0) {
-                   OVERLAY_LOG_ERR("Error!Obj1 mxc_ipu_lib_task_init failed mIPURet %d!",mIPURet);
-                   goto queue_buf_exit;
-                }  
-                OVERLAY_LOG_RUNTIME("Obj1 mxc_ipu_lib_task_init success");
-                mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,overlay_buf1,pV4LBuf->m.offset,NULL,NULL,NULL);
-                if (mIPURet < 0) {
-                      OVERLAY_LOG_ERR("Error!Obj1 mxc_ipu_lib_task_buf_update failed mIPURet %d!",mIPURet);
-                      mxc_ipu_lib_task_uninit(&mIPUHandle);
-                      memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                      goto queue_buf_exit;
-                }
-                OVERLAY_LOG_RUNTIME("Obj1 mxc_ipu_lib_task_buf_update success");
-                mxc_ipu_lib_task_uninit(&mIPUHandle);
-                memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-            }
-        
-            //Copyback after ipu update when two active instance, and obj0 has one buffer to update
-            //obj0 has no buffer to update
-            if((overlayObj0)&&(overlayObj1)&&
-               (overlay_buf0)&&(!overlay_buf1)&&
-               (dataShared1->buf_showed))
-            {
-                OVERLAY_LOG_RUNTIME("Copyback after ipu update");
-                if((mLatestQueuedBuf.m.offset)&&
-                   (mLatestQueuedBuf.m.offset != pV4LBuf->m.offset)) {
-                    //Copy back the region of obj0 to the current v4l buffer
-                    //Setting input format
-                    mIPUInputParam.width = m_dev->xres;
-                    mIPUInputParam.height = m_dev->yres;
-
-                    mIPUInputParam.input_crop_win.pos.x = overlay1_outregion.left;
-                    mIPUInputParam.input_crop_win.pos.y = overlay1_outregion.top;  
-                    mIPUInputParam.input_crop_win.win_w = overlay1_outregion.right - overlay1_outregion.left;
-                    mIPUInputParam.input_crop_win.win_h = overlay1_outregion.bottom - overlay1_outregion.top;
-                    mIPUInputParam.fmt = m_dev->outpixelformat;
-                    mIPUInputParam.user_def_paddr[0] = mLatestQueuedBuf.m.offset;
-    
-                    //Setting output format
-                    //Should align with v4l
-                    mIPUOutputParam.fmt = m_dev->outpixelformat;
-                    mIPUOutputParam.width = m_dev->xres;
-                    mIPUOutputParam.height = m_dev->yres;   
-                    mIPUOutputParam.show_to_fb = 0;
-                    //Output param should be same as input, since no resize,crop
-                    mIPUOutputParam.output_win.pos.x = mIPUInputParam.input_crop_win.pos.x;
-                    mIPUOutputParam.output_win.pos.y = mIPUInputParam.input_crop_win.pos.y;
-                    mIPUOutputParam.output_win.win_w = mIPUInputParam.input_crop_win.win_w;
-                    mIPUOutputParam.output_win.win_h = mIPUInputParam.input_crop_win.win_h;
-                    mIPUOutputParam.rot = 0;
-                    mIPUOutputParam.user_def_paddr[0] = pV4LBuf->m.offset;
-                    OVERLAY_LOG_RUNTIME("Copyback(after) Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                          mIPUOutputParam.width,
-                          mIPUOutputParam.height,
-                          mIPUOutputParam.output_win.pos.x,
-                          mIPUOutputParam.output_win.pos.y,
-                          mIPUOutputParam.output_win.win_w,
-                          mIPUOutputParam.output_win.win_h,
-                          mIPUOutputParam.rot);
-                                     
-                    OVERLAY_LOG_RUNTIME("Copyback(after) Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                                     mIPUInputParam.width,
-                                     mIPUInputParam.height,
-                                     mIPUInputParam.fmt,
-                                     mIPUInputParam.input_crop_win.pos.x,
-                                     mIPUInputParam.input_crop_win.pos.y,
-                                     mIPUInputParam.input_crop_win.win_w,
-                                     mIPUInputParam.input_crop_win.win_h);     
-    
-                    mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-                    if (mIPURet < 0) {
-                       OVERLAY_LOG_ERR("Error!Copyback(after) mxc_ipu_lib_task_init failed mIPURet %d!",mIPURet);
-                       goto queue_buf_exit;
-                    }  
-                    OVERLAY_LOG_RUNTIME("Copyback(after) mxc_ipu_lib_task_init success");
-                    mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,overlay_buf0,pV4LBuf->m.offset,NULL,NULL,NULL);
-                    if (mIPURet < 0) {
-                          OVERLAY_LOG_ERR("Error!Copyback(after) mxc_ipu_lib_task_buf_update failed mIPURet %d!",mIPURet);
-                          mxc_ipu_lib_task_uninit(&mIPUHandle);
-                          memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                          goto queue_buf_exit;
-                    }
-                    OVERLAY_LOG_RUNTIME("Copyback(after) mxc_ipu_lib_task_buf_update success");
-                    mxc_ipu_lib_task_uninit(&mIPUHandle);
-                    memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-                }
-                else{
-                    OVERLAY_LOG_ERR("Error!Cannot Copyback before ipu update last buf 0x%x,curr buf 0x%x",
-                                    mLatestQueuedBuf.m.offset,
-                                    pV4LBuf->m.offset);
-                }
-            }
-
-queue_buf_exit:
-            //Queue the mixed V4L2 Buffer for display
-            gettimeofday(&pV4LBuf->timestamp, 0);
-            if(ioctl(m_dev->v4l_id, VIDIOC_QBUF, pV4LBuf) < 0){
-                OVERLAY_LOG_ERR("Error!Cannot QBUF a buffer from v4l");
-                //reset latest queued buffer, since all buffer will start as init
-                memset(&mLatestQueuedBuf,0,sizeof(mLatestQueuedBuf));
-                goto free_buf_exit;
-            }
-            OVERLAY_LOG_RUNTIME("QBUF from v4l at frame %d:index %d, phy 0x%x at sec %d usec %d",
-                                m_dev->video_frames,pV4LBuf->index,pV4LBuf->m.offset,
-                                pV4LBuf->timestamp.tv_sec,pV4LBuf->timestamp.tv_usec); 
-
-            //record the latest buffer we queued
-            memcpy(&mLatestQueuedBuf,pV4LBuf,sizeof(mLatestQueuedBuf));
-            
-            //Only stream on after two frames queued 
-            m_dev->video_frames++;
-            if((m_dev->video_frames>=2)&&(!m_dev->stream_on)) {
-                int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-                ioctl(m_dev->v4l_id, VIDIOC_STREAMON, &type);
-                m_dev->stream_on = true;
-                OVERLAY_LOG_INFO("V4L STREAMON NOW");
-            }
-
-free_buf_exit:
-            //push back the buffer to overlay instance0 freequeue
-            //signal instance condition if wait flag is true
-            //reset wait flag
-            //pthread_cond_signal(&cond);  
-            if((overlayObj0)&&(overlay_buf0)) {
-                pthread_mutex_lock(&dataShared0->obj_lock);
-                dataShared0->buf_showed++;
-                //For push mode, no need to return the buffer back
-                if(dataShared0->overlay_mode == OVERLAY_NORAML_MODE) {
-                    dataShared0->free_bufs[dataShared0->free_tail] = overlay_buf0;
-                    OVERLAY_LOG_RUNTIME("Id %d back buffer to free queue for Overlay Instance 0: 0x%x at %d free_count %d",
-                         dataShared0->instance_id,overlay_buf0,dataShared0->free_tail,dataShared0->free_count+1);
-                    dataShared0->free_tail++;
-                    dataShared0->free_tail = dataShared0->free_tail%MAX_OVERLAY_BUFFER_NUM;
-                    dataShared0->free_count++;
-                    if(dataShared0->free_count > dataShared0->num_buffer) {
-                        OVERLAY_LOG_ERR("Error!free_count %d is greater the total number %d",
-                                        dataShared0->free_count,dataShared0->num_buffer);
-                    }
-                }
-
-                if(dataShared0->wait_buf_flag) {
-                    dataShared0->wait_buf_flag = 0;
-                    OVERLAY_LOG_RUNTIME("Id %d Condition signal for Overlay Instance 0",dataShared0->instance_id);
-                    pthread_cond_signal(&dataShared0->free_cond);
-                }
-                dataShared0->buf_mixing = false;
-                pthread_mutex_unlock(&dataShared0->obj_lock);
-            }
-
-            //push back the buffer of overlay instance1 freequeue
-            //signal instance condition if wait flag is true
-            //reset wait flag
-            //pthread_cond_signal(&cond);  
-            if((overlayObj1)&&(overlay_buf1)) {
-                pthread_mutex_lock(&dataShared1->obj_lock);
-                dataShared1->buf_showed++;
-                //For push mode, no need to return the buffer back
-                if(dataShared1->overlay_mode == OVERLAY_NORAML_MODE) {
-                    dataShared1->free_bufs[dataShared1->free_tail] = overlay_buf1;
-                    dataShared1->free_tail++;
-                    dataShared1->free_tail = dataShared1->free_tail%MAX_OVERLAY_BUFFER_NUM;
-                    dataShared1->free_count++;
-                    OVERLAY_LOG_RUNTIME("Id %d back buffer to free queue for Overlay Instance 0: 0x%x free_count %d",
-                         dataShared1->instance_id,overlay_buf1,dataShared1->free_count);
-                }
-
-                if(dataShared1->wait_buf_flag) {
-                    dataShared1->wait_buf_flag = 0;
-                    OVERLAY_LOG_RUNTIME("Id %d Condition signal for Overlay Instance 1",
-                                        dataShared1->instance_id);
-                    pthread_cond_signal(&dataShared1->free_cond);
-                }
-                dataShared1->buf_mixing = false;
-                pthread_mutex_unlock(&dataShared1->obj_lock);
-            }
-            
-        }
-        // loop until we need to quit
-        return true;
-    }
-};
-
-#endif
diff --git a/liboverlay/overlay_utils.h b/liboverlay/overlay_utils.h
deleted file mode 100755
index 7ab785e..0000000
--- a/liboverlay/overlay_utils.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __OVERLAY_UTILS_H__
-#define __OVERLAY_UTILS_H__
-
-#define LOG_TAG "FslOverlay"
-
-#define MAX_OVERLAY_INSTANCES 2
-#define DEFAULT_OVERLAY_BUFFER_NUM 3
-#define MAX_OVERLAY_BUFFER_NUM 24
-
-#define FB_DEV_NAME "/dev/graphics/fb0"
-#define V4L_DEV_NAME "/dev/video16"
-#define DEFAULT_V4L_LAYER 3
-#define DEFAULT_ALPHA_BUFFERS 2
-#define DEFAULT_V4L_BUFFERS 3
-#define MAX_V4L_BUFFERS 3
-
-#define MAX_OVERLAY_INPUT_W 1280
-#define MAX_OVERLAY_INPUT_H 720
-
-#define OVERLAY_QUEUE_THRESHOLD 2
-
-#define FULL_TRANSPARANT_VALUE 255
-
-#define SHARED_CONTROL_MARKER             (0x4F564354) //OVCT
-#define SHARED_DATA_MARKER             (0x4F564441) //OVDA
-
- 
-#define OVERLAY_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
-#define OVERLAY_LOG_ERR(format, ...) LOGE((format), ## __VA_ARGS__)
-#define OVERLAY_LOG_WARN(format, ...) LOGW((format), ## __VA_ARGS__)
-
-#ifdef OVERLAY_DEBUG_LOG
-#define OVERLAY_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
-#define OVERLAY_LOG_FUNC LOGI("%s: %s",  __FILE__, __FUNCTION__)
-#else
-#define OVERLAY_LOG_RUNTIME(format, ...) 
-#define OVERLAY_LOG_FUNC
-#endif
-
-struct OVERLAY_BUFFER{
-    void *vir_addr;
-    unsigned int phy_addr;
-    unsigned int size;
-};
-
-struct WIN_REGION {
-    int left;
-    int right;
-    int top;
-    int bottom;
-};
-
-class OverlayAllocator{
-public:
-    virtual ~OverlayAllocator(){}
-    virtual int allocate(OVERLAY_BUFFER *overlay_buf, int size){ return -1;}
-    virtual int deAllocate(OVERLAY_BUFFER *overlay_buf){  return -1;  }
-    virtual int getHeapID(){  return 0;  }
-};
-
-
-#endif
diff --git a/liboverlay/overlays_test.cpp b/liboverlay/overlays_test.cpp
deleted file mode 100755
index 1f0efff..0000000
--- a/liboverlay/overlays_test.cpp
+++ /dev/null
@@ -1,685 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <binder/IPCThreadState.h>
-#include <binder/ProcessState.h>
-#include <binder/IServiceManager.h>
-#include <utils/Log.h>
-
-#include <ui/DisplayInfo.h>
-#include <ui/Overlay.h>
-#include <surfaceflinger/Surface.h>
-#include <surfaceflinger/ISurface.h>
-#include <surfaceflinger/ISurfaceComposer.h>
-#include <surfaceflinger/SurfaceComposerClient.h>
-
-#include <fcntl.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <linux/fb.h>
-#include <linux/videodev.h>
-
-#define LOG_TAG "overlay_test"
-
-using namespace android;
-/*
-       Y = R *  .299 + G *  .587 + B *  .114;
-       U = R * -.169 + G * -.332 + B *  .500 + 128.;
-       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
-
-#define red(x) (((x & 0xE0) >> 5) * 0x24)
-#define green(x) (((x & 0x1C) >> 2) * 0x24)
-#define blue(x) ((x & 0x3) * 0x55)
-#define y(rgb) ((red(rgb)*299L + green(rgb)*587L + blue(rgb)*114L) / 1000)
-#define u(rgb) ((((blue(rgb)*500L) - (red(rgb)*169L) - (green(rgb)*332L)) / 1000))
-#define v(rgb) (((red(rgb)*500L - green(rgb)*419L - blue(rgb)*81L) / 1000))
-
-#define red_rgb565 (0b11111000000000000)
-#define green_rgb565 (0b00000111111000000)
-#define blue_rgb565 (0b00000000000011111)
-
-void gen_fill_pattern_rgb(char * buf, int in_width, int in_height,int h_step, int w_step)
-{
-	int h, w;
-	static unsigned short rgb = 0;
-
-    unsigned short  *rgb565 = (unsigned short *)buf;
-	for (h = 0; h < in_height; h++) {
-		unsigned short rgb_temp = rgb;
-
-		for (w = 0; w < in_width; w++) {
-			if (w % w_step == 0) {
-                rgb_temp += 0x004;//inc r,g,b by one
-			}
-			buf[(h*in_width) + w] = rgb_temp;
-		}
-		if ((h > 0) && (h % h_step == 0)) {
-			rgb_temp += 0x20;
-		}
-	}
-
-}
-void gen_fill_pattern_yuv(char * buf, int in_width, int in_height,int h_step, int w_step)
-{
-	int y_size = in_width * in_height;
-	//int h_step = in_height / 16;
-	//int w_step = in_width / 16;
-	int h, w;
-	uint32_t y_color = 0;
-	int32_t u_color = 0;
-	int32_t v_color = 0;
-	uint32_t rgb = 0;
-	static int32_t alpha = 0;
-	static int inc_alpha = 1;
-
-	for (h = 0; h < in_height; h++) {
-		int32_t rgb_temp = rgb;
-
-		for (w = 0; w < in_width; w++) {
-			if (w % w_step == 0) {
-				y_color = y(rgb_temp);
-				y_color = (y_color * alpha) / 255;
-
-				u_color = u(rgb_temp);
-				u_color = (u_color * alpha) / 255;
-				u_color += 128;
-
-				v_color = v(rgb_temp);
-				v_color = (v_color * alpha) / 255;
-				v_color += 128;
-
-				rgb_temp++;
-				if (rgb_temp > 255)
-					rgb_temp = 0;
-			}
-			buf[(h*in_width) + w] = y_color;
-			if (!(h & 0x1) && !(w & 0x1)) {
-				buf[y_size + (((h*in_width)/4) + (w/2)) ] = u_color;
-				buf[y_size + y_size/4 + (((h*in_width)/4) + (w/2))] = v_color;
-			}
-		}
-		if ((h > 0) && (h % h_step == 0)) {
-			rgb += 16;
-			if (rgb > 255)
-				rgb = 0;
-		}
-
-	}
-	if (inc_alpha) {
-		alpha+=4;
-		if (alpha >= 255) {
-			inc_alpha = 0;
-		}
-	} else {
-		alpha-=4;
-		if (alpha <= 0) {
-			inc_alpha = 1;
-		}
-	}
-}
-
-void gen_fill_pattern(char * buf, int in_width, int in_height,int h_step, int w_step,int32_t format)
-{
-    if(format == HAL_PIXEL_FORMAT_RGB_565) {
-        gen_fill_pattern_rgb(buf,in_width,in_height,h_step,w_step);
-    }
-    else if(format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-        gen_fill_pattern_yuv(buf,in_width,in_height,h_step,w_step);
-    }
-}
-
-
-namespace android {
-class Test {
-public:
-    static const sp<ISurface>& getISurface(const sp<SurfaceControl>& s) {
-        return s->getISurface();
-    }
-};
-};
-typedef struct {
-    int w;
-    int h;
-    int32_t format;
-    int frame_num;
-    int crop_x;
-    int crop_y;
-    int crop_w;
-    int crop_h;
-    int layer;
-    int pos_x;
-    int pos_y;
-    int win_w;
-    int win_h;
-    int show_num;
-    int step_line;
-    int performance_test;
-}OVERLAY_PARAM;
-
-
-void *overlay_instance_test(void *arg);
-bool performance_run = 0;
-int main(int argc, char** argv)
-{
-    int fd_fb = 0;
-    struct fb_var_screeninfo fb_var;
-    pthread_t thread0,thread1;
-    OVERLAY_PARAM overlay_param0;
-    OVERLAY_PARAM overlay_param1;
-    unsigned int panel_x,panel_y;
-    void *ret;
-    sp<SurfaceControl>			backgroundControl;
-    sp<Surface> 				background;
-    sp<SurfaceComposerClient> session;
-    memset(&overlay_param0, 0 ,sizeof(OVERLAY_PARAM));
-    memset(&overlay_param1, 0 ,sizeof(OVERLAY_PARAM));
- 
-    DisplayInfo dinfo;
-    session = new SurfaceComposerClient();
-    status_t status = session->getDisplayInfo(0, &dinfo);
-    if (status)
-        return -1;
-
-	panel_x=dinfo.w;
-	panel_y=dinfo.h;
-
-
-    backgroundControl = session->createSurface(getpid(), 0, panel_x, panel_y, PIXEL_FORMAT_RGB_565);
-	// set front surface to top
-    session->openTransaction();
-    backgroundControl->setLayer(0x40000000);
-    session->closeTransaction();
-	//get the rendering surface
-    background = backgroundControl->getSurface();
-	Surface::SurfaceInfo		sinfo_background;
-
-	background->lock(&sinfo_background);
-    //Draw to white
-	memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-	background->unlockAndPost();
-
-
-    overlay_param0.w = 720;
-    overlay_param0.h = 576;
-    overlay_param0.format = HAL_PIXEL_FORMAT_YCbCr_420_SP;
-    overlay_param0.frame_num = 8;
-    overlay_param0.crop_x = 0;
-    overlay_param0.crop_y = 0;
-    overlay_param0.crop_w = 720;
-    overlay_param0.crop_h = 576;
-    overlay_param0.layer = 0x40000000;
-    overlay_param0.pos_x = 0;
-    overlay_param0.pos_y = 0;
-    overlay_param0.win_w = panel_x;
-    overlay_param0.win_h = panel_y;
-    overlay_param0.show_num = 200;
-    overlay_param0.step_line = 16;
-
-    overlay_param1.w = 320;
-    overlay_param1.h = 240;
-    overlay_param1.format = HAL_PIXEL_FORMAT_YCbCr_420_SP;
-    overlay_param1.frame_num = 6;
-    overlay_param1.crop_x = 0;
-    overlay_param1.crop_y = 0;
-    overlay_param1.crop_w = 320;
-    overlay_param1.crop_h = 240;
-    overlay_param1.layer = 0x40000001;
-    overlay_param1.pos_x = panel_x/4;
-    overlay_param1.pos_y = panel_y/4;
-    overlay_param1.win_w = (panel_x/4+8)/8*8;
-    overlay_param1.win_h = (panel_y/4+8)/8*8;
-    overlay_param1.show_num = 200;
-    overlay_param1.step_line = 8;
-    //pthread_attr_t attr0,attr1;
-
-
-
-    LOGI("*******start main thread*******");
-    if(argc == 1) {
-        LOGI("****Run two overlay instances 720/576 & 320/240 test*****");
-        LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-        LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-             overlay_param0.w,overlay_param0.h,
-             overlay_param0.pos_x,overlay_param0.pos_y,
-             overlay_param0.win_w,overlay_param0.win_h);
-        LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-             overlay_param1.w,overlay_param1.h,
-             overlay_param1.pos_x,overlay_param1.pos_y,
-             overlay_param1.win_w,overlay_param1.win_h);
-
-        //draw the background to black
-        LOGI("Draw background to black");
-        background->lock(&sinfo_background);
-        memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-        char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-        for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-            memset(prgb565, 0, overlay_param0.win_w*2);
-            prgb565 += (sinfo_background.w*2);
-        }
-        prgb565 = (char *)sinfo_background.bits+(overlay_param1.pos_y*sinfo_background.w+overlay_param1.pos_x)*2;
-        for(int height = overlay_param1.pos_y; height < (overlay_param1.pos_y+overlay_param1.win_h); height++) {
-            memset(prgb565, 0, overlay_param1.win_w*2);
-            prgb565 += (sinfo_background.w*2);
-        }
-    	background->unlockAndPost();
-        LOGI("Overlay running");
-        pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-        pthread_create(&thread1, NULL, overlay_instance_test, (void *)(&overlay_param1));
-    
-    
-        pthread_join(thread0, &ret);
-        pthread_join(thread1, &ret);
-    }
-    else if((argc >= 2)&&(argc <=3)) {
-        if(!strcmp(argv[1],"-0")) {
-            LOGI("****Run one overlay instances 720/576 test*****");
-            //pthread_attr_init(&attr0);
-            //pthread_attr_setdetachstate(&attr0, PTHREAD_CREATE_DETACHED);
-            if(argc==3) {
-                overlay_param0.show_num = atoi(argv[2]);
-            }
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param0.w,overlay_param0.h,
-                 overlay_param0.pos_x,overlay_param0.pos_y,
-                 overlay_param0.win_w,overlay_param0.win_h);
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-            for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-                memset(prgb565, 0, overlay_param0.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-            LOGI("Overlay running");
-            pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-            pthread_join(thread0, &ret);
-        }
-        else if(!strcmp(argv[1],"-1")){
-            LOGI("****Run one overlay instances 320/240 test*****");
-            //pthread_attr_init(&attr1);
-            //pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_DETACHED);
-            if(argc==3) {
-                overlay_param1.show_num = atoi(argv[2]);
-            }
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param1.w,overlay_param1.h,
-                 overlay_param1.pos_x,overlay_param1.pos_y,
-                 overlay_param1.win_w,overlay_param1.win_h);
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param1.pos_y*sinfo_background.w+overlay_param1.pos_x)*2;
-            for(int height = overlay_param1.pos_y; height < (overlay_param1.pos_y+overlay_param1.win_h); height++) {
-                memset(prgb565, 0, overlay_param1.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-            LOGI("Overlay running");
-            pthread_create(&thread1, NULL, overlay_instance_test, (void *)(&overlay_param1));
-            pthread_join(thread1, &ret);
-        }
-        else if(!strcmp(argv[1],"-2")){
-            LOGI("****Run two overlay instances 720/576 & 320/240 test*****");
-            //pthread_attr_init(&attr1);
-            //pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_DETACHED);
-            if(argc==3) {
-                overlay_param0.show_num = atoi(argv[2]);
-                overlay_param1.show_num = atoi(argv[2]);
-            }
-
-            overlay_param0.pos_x = 0;
-            overlay_param0.pos_y = panel_y/2;
-            overlay_param0.win_w = panel_x;
-            overlay_param0.win_h = (panel_y/2)/8*8;
-        
-            overlay_param1.pos_x = 0;
-            overlay_param1.pos_y = 0;
-            overlay_param1.win_w = (panel_x/4+8)/8*8;
-            overlay_param1.win_h = (panel_y/4+8)/8*8;
-
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param0.w,overlay_param0.h,
-                 overlay_param0.pos_x,overlay_param0.pos_y,
-                 overlay_param0.win_w,overlay_param0.win_h);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param1.w,overlay_param1.h,
-                 overlay_param1.pos_x,overlay_param1.pos_y,
-                 overlay_param1.win_w,overlay_param1.win_h);
-
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-            for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-                memset(prgb565, 0, overlay_param0.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-            prgb565 = (char *)sinfo_background.bits+(overlay_param1.pos_y*sinfo_background.w+overlay_param1.pos_x)*2;
-            for(int height = overlay_param1.pos_y; height < (overlay_param1.pos_y+overlay_param1.win_h); height++) {
-                memset(prgb565, 0, overlay_param1.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-
-            LOGI("Overlay running");
-            pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-            pthread_create(&thread1, NULL, overlay_instance_test, (void *)(&overlay_param1));
-        
-            pthread_join(thread0, &ret);
-            pthread_join(thread1, &ret);
-        }
-        else if(!strcmp(argv[1],"-3")){
-            LOGI("****Run two overlay instances 720/576 & 320/240 performance test*****");
-            if(argc==3) {
-                overlay_param0.show_num = atoi(argv[2]);
-                overlay_param1.show_num = atoi(argv[2]);
-            }
-            overlay_param0.performance_test = 1;
-            overlay_param1.performance_test = 1;
-            performance_run = 1;
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param0.w,overlay_param0.h,
-                 overlay_param0.pos_x,overlay_param0.pos_y,
-                 overlay_param0.win_w,overlay_param0.win_h);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param1.w,overlay_param1.h,
-                 overlay_param1.pos_x,overlay_param1.pos_y,
-                 overlay_param1.win_w,overlay_param1.win_h);
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-            for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-                memset(prgb565, 0, overlay_param0.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-            prgb565 = (char *)sinfo_background.bits+(overlay_param1.pos_y*sinfo_background.w+overlay_param1.pos_x)*2;
-            for(int height = overlay_param1.pos_y; height < (overlay_param1.pos_y+overlay_param1.win_h); height++) {
-                memset(prgb565, 0, overlay_param1.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-
-            LOGI("Overlay running");
-            pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-            pthread_create(&thread1, NULL, overlay_instance_test, (void *)(&overlay_param1));
-        
-            pthread_join(thread0, &ret);
-            pthread_join(thread1, &ret);
-        }
-        else if(!strcmp(argv[1],"-4")){
-            LOGI("****Run two overlay instances 720/576 performance test*****");
-            if(argc==3) {
-                overlay_param0.show_num = atoi(argv[2]);
-            }
-            overlay_param0.performance_test = 1;
-
-            performance_run = 1;
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param0.w,overlay_param0.h,
-                 overlay_param0.pos_x,overlay_param0.pos_y,
-                 overlay_param0.win_w,overlay_param0.win_h);
-
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-            for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-                memset(prgb565, 0, overlay_param0.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-
-            LOGI("Overlay running");
-            pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-            pthread_join(thread0, &ret);
-        }
-        else if(!strcmp(argv[1],"-5")){
-            LOGI("****Run two overlay instances 320/240 performance test*****");
-            if(argc==3) {
-                overlay_param1.show_num = atoi(argv[2]);
-            }
-            overlay_param1.performance_test = 1;
-            performance_run = 1;
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param1.w,overlay_param1.h,
-                 overlay_param1.pos_x,overlay_param1.pos_y,
-                 overlay_param1.win_w,overlay_param1.win_h);
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param1.pos_y*sinfo_background.w+overlay_param1.pos_x)*2;
-            for(int height = overlay_param1.pos_y; height < (overlay_param1.pos_y+overlay_param1.win_h); height++) {
-                memset(prgb565, 0, overlay_param1.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-            LOGI("Overlay running");
-            pthread_create(&thread1, NULL, overlay_instance_test, (void *)(&overlay_param1));
-            pthread_join(thread1, &ret);
-        }
-        else if(!strcmp(argv[1],"-6")){
-            LOGI("****Run one overlay instances 720/576 RGB test*****");
-            //pthread_attr_init(&attr0);
-            //pthread_attr_setdetachstate(&attr0, PTHREAD_CREATE_DETACHED);
-            overlay_param0.format = PIXEL_FORMAT_RGB_565;
-            if(argc==3) {
-                overlay_param0.show_num = atoi(argv[2]);
-            }
-
-            LOGI("Display info: panel_x %d panel_y %d",panel_x,panel_y);
-            LOGI("Overlay paramater: w %d,h %d, pos_x %d, pos_y %d, win_h %d win_w %d",
-                 overlay_param0.w,overlay_param0.h,
-                 overlay_param0.pos_x,overlay_param0.pos_y,
-                 overlay_param0.win_w,overlay_param0.win_h);
-
-            //draw the background to black
-            LOGI("Draw background to black");
-            background->lock(&sinfo_background);
-            memset(sinfo_background.bits, 0xff, sinfo_background.w*sinfo_background.h*2);
-            char *prgb565 = (char *)sinfo_background.bits+(overlay_param0.pos_y*sinfo_background.w+overlay_param0.pos_x)*2;
-            for(int height = overlay_param0.pos_y; height < (overlay_param0.pos_y+overlay_param0.win_h); height++) {
-                memset(prgb565, 0, overlay_param0.win_w*2);
-                prgb565 += (sinfo_background.w*2);
-            }
-        	background->unlockAndPost();
-            LOGI("Overlay running");
-            pthread_create(&thread0, NULL, overlay_instance_test, (void *)(&overlay_param0));
-            pthread_join(thread0, &ret);
-        }
-        else{
-            LOGE("Error!Not support parameters");
-            LOGE("%s [-0] [-1] [-2] [-3] [-4] [-5] [-6] [frame num]",argv[0]);
-            LOGE("  [-0] verlay instances 720/576 YUV test");
-            LOGE("  [-1] verlay instances 320/240 YUV test");
-            LOGE("  [-2] verlay instances 720/576&320/240 YUV test");
-            LOGE("  [-3] verlay instances 720/576&320/240 YUV performance test");
-            LOGE("  [-4] verlay instances 720/576 YUV test");
-            LOGE("  [-5] verlay instances 320/240 YUV test");
-            LOGE("  [-6] verlay instances 720/576 RGB565 test");
-            LOGE("  [frame num] frame count number");
-        }
-    }
-    else{
-        LOGE("Error!Not support parameters");
-        LOGE("%s [-0] [-1] [-2] [-3] [-4] [-5] [-6] [frame num]",argv[0]);
-        LOGE("  [-0] verlay instances 720/576 YUV test");
-        LOGE("  [-1] verlay instances 320/240 YUV test");
-        LOGE("  [-2] verlay instances 720/576&320/240 YUV test");
-        LOGE("  [-3] verlay instances 720/576&320/240 YUV performance test");
-        LOGE("  [-4] verlay instances 720/576 YUV test");
-        LOGE("  [-5] verlay instances 320/240 YUV test");
-        LOGE("  [-6] verlay instances 720/576 RGB565 test");
-        LOGE("  [frame num] frame count number");
-    }
-
-    LOGI("*******Exit main thread*******");
-    close(fd_fb);
-    return 0;
-}
-
-
-
-void *overlay_instance_test(void *arg)
-{
-    // set up the thread-pool
-    OVERLAY_PARAM *overlay_param = (OVERLAY_PARAM *)arg;
-
-    LOGI("FSL OVERLAY test: current pid %d uid %d",getpid(),getuid());
-    sp<ProcessState> proc(ProcessState::self());
-    ProcessState::self()->startThreadPool();
-
-    // create a client to surfaceflinger
-    sp<SurfaceComposerClient> client = new SurfaceComposerClient();
-    
-
-    // create pushbuffer surface
-    sp<SurfaceControl> surface = client->createSurface(getpid(), 0, overlay_param->win_w, overlay_param->win_h, 
-            PIXEL_FORMAT_UNKNOWN, ISurfaceComposer::ePushBuffers);
-    client->openTransaction();
-    LOGI("Set layer 0x%x, posx %d, posy %d",
-         overlay_param->layer,overlay_param->pos_x,overlay_param->pos_y);
-    surface->setLayer(overlay_param->layer);
-    surface->setPosition(overlay_param->pos_x, overlay_param->pos_y);
-    client->closeTransaction();
-
-    // get to the isurface
-    sp<ISurface> isurface = Test::getISurface(surface);
-    LOGI("isurface = %p", isurface.get());
-    
-    // now request an overlay
-    LOGI("createOverlay()");
-    sp<OverlayRef> ref = isurface->createOverlay(overlay_param->w, overlay_param->h,
-                                                 overlay_param->format, 0);
-    LOGI("createOverlay() AFTER");
-    LOGI("new Overlay(ref) start");
-    sp<Overlay> overlay = new Overlay(ref);
-    LOGI("Overlay(ref)()");
-    //Just to give a chance the other instance creation
-    usleep(30000);
-    int bufcount = overlay_param->frame_num;
-    int ret;
-    if(overlay->getBufferCount() != bufcount) {
-        ret = overlay->setParameter(OVERLAY_BUFNUM,bufcount);
-        if(ret < 0) {
-            LOGE("Error! Not support parameter setting for overlay");
-            return NULL;
-        }
-    }
-
-    ret = overlay->setCrop(overlay_param->crop_x,overlay_param->crop_y,
-                           overlay_param->crop_w,overlay_param->crop_h);
-    if(ret < 0) {
-        LOGE("Error! Not support parameter setting for overlay");
-        return NULL;
-    }
-
-    /*
-     * here we can use the overlay API 
-     */
-    if(!overlay_param->performance_test) {
-        overlay_buffer_t buffer; 
-        LOGI("Start queue/dequeue test");
-        for(int i = 0; i < overlay_param->show_num; i++) {
-            overlay->dequeueBuffer(&buffer);
-            //LOGI("dequeueBuffer buffer = 0x%x\n", buffer);
-
-            void* address = overlay->getBufferAddress(buffer);
-            //LOGI("getBufferAddress = 0x%x\n", address);
-            unsigned int phy_addr = overlay->getBufferAddressPhy(buffer);
-            //LOGI("getBufferAddressPhy = 0x%x\n", phy_addr);
-
-            //Draw the data to the buffer address(YUV420 format as setting)
-            gen_fill_pattern((char *)address,overlay_param->w,overlay_param->h,
-                             overlay_param->w/overlay_param->step_line,
-                             overlay_param->w/overlay_param->step_line,
-                             overlay_param->format);
-            overlay->queueBuffer(buffer);
-        }
-    }
-    else{
-        overlay_buffer_t buffer[32];
-        LOGI("Start performance queue/dequeue test");
-        memset(buffer,0,sizeof(overlay_buffer_t)*32);
-        for(int i = 0; i < overlay_param->frame_num; i++) {
-            overlay->dequeueBuffer(&buffer[i]);
-            void* address = overlay->getBufferAddress(buffer[i]);
-            gen_fill_pattern((char *)address,overlay_param->w,overlay_param->h,
-                             overlay_param->w/overlay_param->step_line,
-                             overlay_param->w/overlay_param->step_line,
-                             overlay_param->format);
-        }
-        struct timeval startTime,lastTime;
-        int frameshow = 0;
-        gettimeofday(&startTime, 0);
-        for(int i = 0; i < overlay_param->frame_num; i++) {
-            overlay->queueBuffer(buffer[i]);
-            frameshow++;
-        }
-        for(int i = 0; i < overlay_param->show_num; i++){
-            overlay->dequeueBuffer(&buffer[0]);
-            overlay->queueBuffer(buffer[0]);
-            frameshow++;
-            //Exit performance test if one instance finished testing.
-            if(!performance_run) {
-                break;
-            }
-        }
-        performance_run = 0;
-        gettimeofday(&lastTime, 0);
-        int timeInMs = (lastTime.tv_sec - startTime.tv_sec)*1000 +(lastTime.tv_usec - startTime.tv_usec)/1000;
-        float fps = 1000.0*frameshow/timeInMs;
-        LOGI("Performance test for Input %d %d, Output %d %d",
-             overlay_param->w,overlay_param->h,
-             overlay_param->win_w,overlay_param->win_h);
-        LOGI("Total frame %d, total time %d ms, fps %f",
-             frameshow,timeInMs,fps);
-    }
-
-    
-    return NULL;
-}
diff --git a/modules/alsa/Android.mk b/modules/alsa/Android.mk
deleted file mode 100755
index 3a90838..0000000
--- a/modules/alsa/Android.mk
+++ /dev/null
@@ -1,45 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# This is the Freescale ALSA module for i.MX5x
-
-ifeq ($(strip $(BOARD_USES_ALSA_AUDIO)),true)
-
-  LOCAL_PATH := $(call my-dir)
-
-  include $(CLEAR_VARS)
-
-  LOCAL_PRELINK_MODULE := false
-
-  LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-
-  LOCAL_CFLAGS := -D_POSIX_SOURCE -Wno-multichar
-
-  LOCAL_C_INCLUDES += hardware/alsa_sound external/alsa-lib/include
-
-  LOCAL_SRC_FILES:= alsa_imx5x.cpp
-
-  LOCAL_SHARED_LIBRARIES := \
-	libaudio \
-  	libasound \
-  	liblog   \
-    libcutils
-
-  LOCAL_MODULE:= alsa.$(TARGET_BOARD_PLATFORM)
-
-  LOCAL_MODULE_TAGS := eng
-
-  include $(BUILD_SHARED_LIBRARY)
-
-endif
diff --git a/modules/alsa/alsa_imx5x.cpp b/modules/alsa/alsa_imx5x.cpp
deleted file mode 100755
index 5f4e8b3..0000000
--- a/modules/alsa/alsa_imx5x.cpp
+++ /dev/null
@@ -1,647 +0,0 @@
-/* alsa_imx51.cpp
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/* Copyright 2010-2011 Freescale Semiconductor Inc. */
-
-#define LOG_TAG "iMX51ALSA"
-#include <utils/Log.h>
-
-#include "AudioHardwareALSA.h"
-#include <media/AudioRecord.h>
-
-#include <cutils/properties.h>
-//#define BLUETOOTH_SCO_DEVICE "hw:0,1"
-//#define FM_TRANSMIT_DEVICE "hw:0,2"
-
-#ifndef ALSA_DEFAULT_SAMPLE_RATE
-#define ALSA_DEFAULT_SAMPLE_RATE 44100 // in Hz
-#endif
-
-#define DEVICE_DEFAULT    0
-#define DEVICE_SPDIF      1
-#define DEVICE_SGTL5000   2
-
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
-
-namespace android
-{
-
-static int s_device_open(const hw_module_t*, const char*, hw_device_t**);
-static int s_device_close(hw_device_t*);
-static status_t s_init(alsa_device_t *, ALSAHandleList &);
-static status_t s_open(alsa_handle_t *, uint32_t, int);
-static status_t s_close(alsa_handle_t *);
-static status_t s_route(alsa_handle_t *, uint32_t, int);
-
-char spdifcardname[32];
-char sgtlcardname[32];
-int  selecteddevice ;    
-    
-static hw_module_methods_t s_module_methods = {
-    open            : s_device_open
-};
-
-extern "C" const hw_module_t HAL_MODULE_INFO_SYM = {
-    tag             : HARDWARE_MODULE_TAG,
-    version_major   : 1,
-    version_minor   : 0,
-    id              : ALSA_HARDWARE_MODULE_ID,
-    name            : "i.MX51 ALSA module",
-    author          : "Freescale Semiconductor",
-    methods         : &s_module_methods,
-    dso             : 0,
-    reserved        : {0,},
-};
-
-static int s_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device)
-{
-    alsa_device_t *dev;
-    dev = (alsa_device_t *) malloc(sizeof(*dev));
-    if (!dev) return -ENOMEM;
-
-    memset(dev, 0, sizeof(*dev));
-
-    /* initialize the procs */
-    dev->common.tag = HARDWARE_DEVICE_TAG;
-    dev->common.version = 0;
-    dev->common.module = (hw_module_t *) module;
-    dev->common.close = s_device_close;
-    dev->init = s_init;
-    dev->open = s_open;
-    dev->close = s_close;
-    dev->route = s_route;
-
-    *device = &dev->common;
-
-    LOGD("i.MX51 ALSA module opened");
-
-    return 0;
-}
-
-static int s_device_close(hw_device_t* device)
-{
-    free(device);
-    return 0;
-}
-
-// ----------------------------------------------------------------------------
-
-static const int DEFAULT_SAMPLE_RATE = ALSA_DEFAULT_SAMPLE_RATE;
-
-static void setDefaultControls(uint32_t devices, int mode, const char *cardname);
-
-typedef void (*AlsaControlSet)(uint32_t devices, int mode, const char *cardname);
-
-#define IMX51_OUT_CODEC_DEFAULT   (\
-        AudioSystem::DEVICE_OUT_EARPIECE | \
-        AudioSystem::DEVICE_OUT_SPEAKER | \
-        AudioSystem::DEVICE_OUT_WIRED_HEADSET | \
-        AudioSystem::DEVICE_OUT_WIRED_HEADPHONE | \
-        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP | \
-        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES | \
-        AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | \
-        AudioSystem::DEVICE_OUT_DEFAULT \
-	)
-#define IMX51_OUT_SPDIF_DEFAULT   (\
-        AudioSystem::DEVICE_OUT_AUX_DIGITAL \
-        )
-#define IMX51_IN_CODEC_DEFAULT    (\
-        AudioSystem::DEVICE_IN_ALL &\
-	~AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET \
-	)
-
-static alsa_handle_t _defaults[] = {
-    {
-        module      : 0,
-        devices     : IMX51_OUT_CODEC_DEFAULT,
-        curDev      : 0,
-        curMode     : 0,
-        handle      : 0,
-        format      : SND_PCM_FORMAT_S16_LE, // AudioSystem::PCM_16_BIT
-        channels    : 2,
-        sampleRate  : DEFAULT_SAMPLE_RATE,
-        latency     : 200000, // Desired Delay in usec
-        bufferSize  : 6144, // Desired Number of samples
-        modPrivate  : (void *)&setDefaultControls,
-    },
-    {
-        module      : 0,
-        devices     : IMX51_OUT_SPDIF_DEFAULT,
-        curDev      : 0,
-        curMode     : 0,
-        handle      : 0,
-        format      : SND_PCM_FORMAT_S16_LE, // AudioSystem::PCM_16_BIT
-        channels    : 2,
-        sampleRate  : DEFAULT_SAMPLE_RATE,
-        latency     : 200000, // Desired Delay in usec
-        bufferSize  : 6144, // Desired Number of samples
-        modPrivate  : (void *)&setDefaultControls,
-    },
-    {
-        module      : 0,
-        devices     : IMX51_IN_CODEC_DEFAULT,
-        curDev      : 0,
-        curMode     : 0,
-        handle      : 0,
-        format      : SND_PCM_FORMAT_S16_LE, // AudioSystem::PCM_16_BIT
-        channels    : 2,
-        sampleRate  : DEFAULT_SAMPLE_RATE,
-        latency     : 250000, // Desired Delay in usec
-        bufferSize  : 6144, // Desired Number of samples
-        modPrivate  : (void *)&setDefaultControls,
-    },
-};
-
-// ----------------------------------------------------------------------------
-
-snd_pcm_stream_t direction(alsa_handle_t *handle)
-{
-    return (handle->devices & AudioSystem::DEVICE_OUT_ALL) ? SND_PCM_STREAM_PLAYBACK
-            : SND_PCM_STREAM_CAPTURE;
-}
-
-//card_device =0, return the card name, card_device=1, return the card device name
-const char *deviceName(alsa_handle_t *alsa_handle, uint32_t device, int mode, int card_device)
-{
-
-	snd_ctl_t *handle;
-	int card, err, dev, idx;
-	snd_ctl_card_info_t *info;
-	snd_pcm_info_t *pcminfo;
-	snd_ctl_card_info_alloca(&info);
-	snd_pcm_info_alloca(&pcminfo);
-    int  cardnum = 0;
-    char value[PROPERTY_VALUE_MAX];
-    snd_pcm_stream_t stream = direction(alsa_handle);
-    bool havespdifdevice = false;
-    bool havesgtldevice = false;
-    
-	card = -1;
-	if (snd_card_next(&card) < 0 || card < 0) {
-		LOGD("no soundcards found...");
-		return "default";
-	}
-	LOGD("**** List of %s Hardware Devices ****\n",
-	       snd_pcm_stream_name(stream));
-	while (card >= 0) {
-		char name[32];
-		sprintf(name, "hw:%d", card);
-		if ((err = snd_ctl_open(&handle, name, 0)) < 0) {
-			LOGD("control open (%i): %s", card, snd_strerror(err));
-			goto next_card;
-		}
-		if ((err = snd_ctl_card_info(handle, info)) < 0) {
-			LOGD("control hardware info (%i): %s", card, snd_strerror(err));
-			snd_ctl_close(handle);
-			goto next_card;
-		}
-		dev = -1;
-		while (1) {
-			unsigned int count;
-			if (snd_ctl_pcm_next_device(handle, &dev)<0)
-				LOGD("snd_ctl_pcm_next_device");
-			if (dev < 0)
-				break;
-			snd_pcm_info_set_device(pcminfo, dev);
-			snd_pcm_info_set_subdevice(pcminfo, 0);
-			snd_pcm_info_set_stream(pcminfo, stream);
-			if ((err = snd_ctl_pcm_info(handle, pcminfo)) < 0) {
-				if (err != -ENOENT)
-					LOGD("control digital audio info (%i): %s", card, snd_strerror(err));
-				continue;
-			}
-			
-			LOGD("card %i: %s [%s], device %i: %s [%s]\n",
-				card, snd_ctl_card_info_get_id(info), snd_ctl_card_info_get_name(info),
-				dev,
-				snd_pcm_info_get_id(pcminfo),
-				snd_pcm_info_get_name(pcminfo));
-                			
-			if(strcmp(snd_pcm_info_get_id(pcminfo),"IMX SPDIF mxc spdif-0")==0) {
-			     if(card_device==0)  sprintf(spdifcardname, "hw:0%d", card);
-			     else         		 sprintf(spdifcardname, "hw:%d,%d", card, dev);
-			     havespdifdevice =  true;
-			}
-            
-			if(strcmp(snd_pcm_info_get_id(pcminfo),"SGTL5000 SGTL5000-0")==0) {
-			     if(card_device==0) sprintf(sgtlcardname, "hw:0%d", card);
-			     else               sprintf(sgtlcardname, "hw:%d,%d", card, dev);
-			     havesgtldevice =  true;                
-			}
-			cardnum++;
-		}
-		snd_ctl_close(handle);
-	next_card:
-
-		if (snd_card_next(&card) < 0) {
-			LOGD("snd_card_next");
-			break;
-		}
-	}
-        
-    property_get("ro.HDMI_AUDIO_OUTPUT", value, "");
-    if((device & AudioSystem::DEVICE_OUT_AUX_DIGITAL) && havespdifdevice && (strcmp(value, "1") == 0))
-    {
-        selecteddevice = DEVICE_SPDIF;
-        return spdifcardname;
-
-    }else if(havesgtldevice)
-    {
-        selecteddevice = DEVICE_SGTL5000;
-        return sgtlcardname;
-    }
-    selecteddevice = DEVICE_DEFAULT; 
-    return "default";
-}
-
-
-
-const char *streamName(alsa_handle_t *handle)
-{
-    return snd_pcm_stream_name(direction(handle));
-}
-
-status_t setHardwareParams(alsa_handle_t *handle)
-{
-    snd_pcm_hw_params_t *hardwareParams;
-    status_t err;
-    snd_pcm_access_mask_t *mask;
-
-    snd_pcm_uframes_t bufferSize = handle->bufferSize;
-    unsigned int requestedRate = handle->sampleRate;
-    unsigned int latency = handle->latency;
-
-    // snd_pcm_format_description() and snd_pcm_format_name() do not perform
-    // proper bounds checking.
-    bool validFormat = (static_cast<int> (handle->format)
-            > SND_PCM_FORMAT_UNKNOWN) && (static_cast<int> (handle->format)
-            <= SND_PCM_FORMAT_LAST);
-    const char *formatDesc = validFormat ? snd_pcm_format_description(
-            handle->format) : "Invalid Format";
-    const char *formatName = validFormat ? snd_pcm_format_name(handle->format)
-            : "UNKNOWN";
-
-    if (snd_pcm_hw_params_malloc(&hardwareParams) < 0) {
-        LOG_ALWAYS_FATAL("Failed to allocate ALSA hardware parameters!");
-        return NO_INIT;
-    }
-
-    err = snd_pcm_hw_params_any(handle->handle, hardwareParams);
-    if (err < 0) {
-        LOGE("Unable to configure hardware: %s", snd_strerror(err));
-        goto done;
-    }
-
-    // Set the interleaved read and write format.
-    mask = (snd_pcm_access_mask_t *)malloc(snd_pcm_access_mask_sizeof());
-    snd_pcm_access_mask_none(mask);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_INTERLEAVED);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_NONINTERLEAVED);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_COMPLEX);
-    err = snd_pcm_hw_params_set_access_mask(handle->handle, hardwareParams, mask);
-
-    if (err < 0) {
-        LOGW("Unable to enable MMAP access for PCM: %s", snd_strerror(err));
-        err = snd_pcm_hw_params_set_access(handle->handle, hardwareParams,
-                SND_PCM_ACCESS_RW_INTERLEAVED);
-        if (err < 0) {
-            LOGE("Unable to configure PCM read/write format: %s",
-                    snd_strerror(err));
-            free(mask);
-            goto done;
-        }
-        handle->mmap = 0;
-    } else {
-        handle->mmap = 1;
-        LOGW("enable MMAP access for PCM");
-    }
-    free(mask);
-
-    err = snd_pcm_hw_params_set_format(handle->handle, hardwareParams,
-            handle->format);
-    if (err < 0) {
-        LOGE("Unable to configure PCM format %s (%s): %s",
-                formatName, formatDesc, snd_strerror(err));
-        goto done;
-    }
-
-    LOGV("Set %s PCM format to %s (%s)", streamName(), formatName, formatDesc);
-
-    err = snd_pcm_hw_params_set_channels(handle->handle, hardwareParams,
-            handle->channels);
-    if (err < 0) {
-        LOGE("Unable to set channel count to %i: %s",
-                handle->channels, snd_strerror(err));
-        goto done;
-    }
-
-    LOGV("Using %i %s .", handle->channels,
-            handle->channels == 1 ? "channel" : "channels");
-
-    err = snd_pcm_hw_params_set_rate_near(handle->handle, hardwareParams,
-            &requestedRate, 0);
-
-    if (err < 0)
-        LOGE("Unable to set %s sample rate to %u: %s",
-                streamName(handle), handle->sampleRate, snd_strerror(err));
-    else if (requestedRate != handle->sampleRate)
-        // Some devices have a fixed sample rate, and can not be changed.
-        // This may cause resampling problems; i.e. PCM playback will be too
-        // slow or fast.
-        LOGW("Requested rate (%u HZ) does not match actual rate (%u HZ)",
-                handle->sampleRate, requestedRate);
-    else
-        LOGV("Set sample rate to %u HZ", requestedRate);
-
-    // get the max buffer size we can set
-    err = snd_pcm_hw_params_get_buffer_size_max(hardwareParams, &bufferSize);
-    if (err < 0) {
-        LOGE("Unable to get max buffer size:  %s", snd_strerror(err));
-        goto done;
-    }
-
-    // Make sure we have at least the size we originally wanted
-    err = snd_pcm_hw_params_set_buffer_size(handle->handle, hardwareParams,
-            bufferSize);
-    if (err < 0) {
-        LOGE("Unable to set buffer size to %d:  %s",
-                (int)bufferSize, snd_strerror(err));
-        goto done;
-    }
-
-    // Setup buffers for latency
-    err = snd_pcm_hw_params_set_buffer_time_near(handle->handle,
-            hardwareParams, &latency, NULL);
-    if (err < 0) {
-        /* That didn't work, set the period instead */
-        unsigned int periodTime = latency / 4;
-        err = snd_pcm_hw_params_set_period_time_near(handle->handle,
-                hardwareParams, &periodTime, NULL);
-        if (err < 0) {
-            LOGE("Unable to set the period time for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        snd_pcm_uframes_t periodSize;
-        err = snd_pcm_hw_params_get_period_size(hardwareParams, &periodSize,
-                NULL);
-        if (err < 0) {
-            LOGE("Unable to get the period size for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        bufferSize = periodSize * 4;
-        if (bufferSize < handle->bufferSize) bufferSize = handle->bufferSize;
-        err = snd_pcm_hw_params_set_buffer_size_near(handle->handle,
-                hardwareParams, &bufferSize);
-        if (err < 0) {
-            LOGE("Unable to set the buffer size for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        LOGV("Setup buffers time near for latency failed %d", latency);
-    } else {
-        // OK, we got buffer time near what we expect. See what that did for bufferSize.
-        err = snd_pcm_hw_params_get_buffer_size(hardwareParams, &bufferSize);
-        if (err < 0) {
-            LOGE("Unable to get the buffer size for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        // Does set_buffer_time_near change the passed value? It should.
-        err = snd_pcm_hw_params_get_buffer_time(hardwareParams, &latency, NULL);
-        if (err < 0) {
-            LOGE("Unable to get the buffer time for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        unsigned int periodTime = latency / 4;
-        err = snd_pcm_hw_params_set_period_time_near(handle->handle,
-                hardwareParams, &periodTime, NULL);
-        if (err < 0) {
-            LOGE("Unable to set the period time for latency: %s", snd_strerror(err));
-            goto done;
-        }
-        LOGV("Setup buffers time near for latency ok %d", latency);
-    }
-
-    LOGV("Buffer size: %d", (int)bufferSize);
-    LOGV("Latency: %d", (int)latency);
-
-    handle->bufferSize = bufferSize;
-    handle->latency = latency;
-
-    // Commit the hardware parameters back to the device.
-    err = snd_pcm_hw_params(handle->handle, hardwareParams);
-    if (err < 0) LOGE("Unable to set hardware parameters: %s", snd_strerror(err));
-
-    done:
-    snd_pcm_hw_params_free(hardwareParams);
-
-    return err;
-}
-
-status_t setSoftwareParams(alsa_handle_t *handle)
-{
-    snd_pcm_sw_params_t * softwareParams;
-    int err;
-
-    snd_pcm_uframes_t bufferSize = 0;
-    snd_pcm_uframes_t periodSize = 0;
-    snd_pcm_uframes_t startThreshold, stopThreshold;
-
-    if (snd_pcm_sw_params_malloc(&softwareParams) < 0) {
-        LOG_ALWAYS_FATAL("Failed to allocate ALSA software parameters!");
-        return NO_INIT;
-    }
-
-    // Get the current software parameters
-    err = snd_pcm_sw_params_current(handle->handle, softwareParams);
-    if (err < 0) {
-        LOGE("Unable to get software parameters: %s", snd_strerror(err));
-        goto done;
-    }
-
-    // Configure ALSA to start the transfer when the buffer is almost full.
-    snd_pcm_get_params(handle->handle, &bufferSize, &periodSize);
-
-    if (handle->devices & AudioSystem::DEVICE_OUT_ALL) {
-        // For playback, configure ALSA to start the transfer when the
-        // buffer is full.
-        startThreshold = bufferSize - 1;
-        stopThreshold = bufferSize;
-    } else {
-        // For recording, configure ALSA to start the transfer on the
-        // first frame.
-        startThreshold = 1;
-        stopThreshold = bufferSize;
-    }
-
-    err = snd_pcm_sw_params_set_start_threshold(handle->handle, softwareParams,
-            startThreshold);
-    if (err < 0) {
-        LOGE("Unable to set start threshold to %lu frames: %s",
-                startThreshold, snd_strerror(err));
-        goto done;
-    }
-
-    err = snd_pcm_sw_params_set_stop_threshold(handle->handle, softwareParams,
-            stopThreshold);
-    if (err < 0) {
-        LOGE("Unable to set stop threshold to %lu frames: %s",
-                stopThreshold, snd_strerror(err));
-        goto done;
-    }
-
-    // Allow the transfer to start when at least periodSize samples can be
-    // processed.
-    err = snd_pcm_sw_params_set_avail_min(handle->handle, softwareParams,
-            periodSize);
-    if (err < 0) {
-        LOGE("Unable to configure available minimum to %lu: %s",
-                periodSize, snd_strerror(err));
-        goto done;
-    }
-
-    // Commit the software parameters back to the device.
-    err = snd_pcm_sw_params(handle->handle, softwareParams);
-    if (err < 0) LOGE("Unable to configure software parameters: %s",
-            snd_strerror(err));
-
-    done:
-    snd_pcm_sw_params_free(softwareParams);
-
-    return err;
-}
-
-void setDefaultControls(uint32_t devices, int mode, const char *cardname)
-{
-    ALSAControl *ctl = new ALSAControl(cardname);
-    LOGD (" setDefaultControls set card :%s",cardname);
-    if(devices & IMX51_OUT_CODEC_DEFAULT)
-    {
-	if (devices & AudioSystem::DEVICE_OUT_SPEAKER ||
-		devices & AudioSystem::DEVICE_OUT_EARPIECE) {
-        	ctl->set("Speaker Function", "on"); // on
-    	} else {
-        	ctl->set("Speaker Function", "off"); // off
-    	}
-    }
-
-#if 0
-    if (devices & AudioSystem::DEVICE_OUT_WIRED_HEADSET ||
-        devices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE) {
-        control.set("Speader Function", 0); // on
-    } else {
-        control.set("Speader Function", 1); // on
-    }
-#endif
-}
-
-void setAlsaControls(alsa_handle_t *handle, uint32_t devices, int mode)
-{
-    AlsaControlSet set = (AlsaControlSet) handle->modPrivate;
-    const char *card = deviceName(handle, devices, mode, 0);
-    set(devices, mode, card);
-}
-
-// ----------------------------------------------------------------------------
-
-static status_t s_init(alsa_device_t *module, ALSAHandleList &list)
-{
-    LOGD("Initializing devices for IMX51 ALSA module");
-
-    list.clear();
-
-    for (size_t i = 0; i < ARRAY_SIZE(_defaults); i++) {
-
-        _defaults[i].module = module;
-        list.push_back(_defaults[i]);
-    }
-
-    return NO_ERROR;
-}
-
-static status_t s_open(alsa_handle_t *handle, uint32_t devices, int mode)
-{
-    // Close off previously opened device.
-    // It would be nice to determine if the underlying device actually
-    // changes, but we might be recovering from an error or manipulating
-    // mixer settings (see asound.conf).
-    //
-    s_close(handle);
-
-    LOGD("open called for devices %08x in mode %d...", devices, mode);
-
-    const char *stream = streamName(handle);
-    const char *devName = deviceName(handle, devices, mode, 1);
-
-    // The PCM stream is opened in blocking mode, per ALSA defaults.  The
-    // AudioFlinger seems to assume blocking mode too, so asynchronous mode
-    // should not be used.
-    int err = snd_pcm_open(&handle->handle, devName, direction(handle), 0);
-
-    if (err < 0) {
-        LOGE("Failed to Initialize any ALSA %s device: %s", stream, strerror(err));
-        return NO_INIT;
-    }
-
-    err = setHardwareParams(handle);
-
-    if (err == NO_ERROR) err = setSoftwareParams(handle);
-
-    setAlsaControls(handle, devices, mode);
-    LOGI("Initialized ALSA %s device %s", stream, devName);
-
-    handle->curDev = devices;
-    handle->curMode = mode;
-
-    return err;
-}
-
-static status_t s_close(alsa_handle_t *handle)
-{
-    LOGW("s_close--");
-    status_t err = NO_ERROR;
-    snd_pcm_t *h = handle->handle;
-    handle->handle = 0;
-    handle->curDev = 0;
-    handle->curMode = 0;
-    if (h) {
-        snd_pcm_drain(h);
-        err = snd_pcm_close(h);
-    }
-
-    return err;
-}
-
-static status_t s_route(alsa_handle_t *handle, uint32_t devices, int mode)
-{
-    status_t status = NO_ERROR;
-
-    LOGD("route called for devices %08x in mode %d...", devices, mode);
-    // below Always noting to do, so we open device every time.
-    if (handle->handle && handle->curDev == devices && handle->curMode == mode)
-        ; // Nothing to do
-    else if (handle->handle && (handle->devices & devices))
-    {
-        setAlsaControls(handle, devices, mode);
-        handle->curDev  = devices;
-        handle->curMode = mode;
-    }
-    else {
-        //LOGE("Why are we routing to a device that isn't supported by this object?!?!?!?!");
-        status = s_open(handle, devices, mode);
-    }
-    return status;
-}
-
-}
diff --git a/mx5x/hwcomposer/Android.mk b/mx5x/hwcomposer/Android.mk
new file mode 100755
index 0000000..eac0fd2
--- /dev/null
+++ b/mx5x/hwcomposer/Android.mk
@@ -0,0 +1,30 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+LOCAL_PATH := $(call my-dir)
+
+# HAL module implemenation, not prelinked and stored in
+# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
+include $(CLEAR_VARS)
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils
+LOCAL_SRC_FILES := hwcomposer.cpp BG_device.cpp FG_device.cpp hwc_common.cpp blit_gpu.cpp blit_ipu.cpp output_device.cpp
+LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
+LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
+LOCAL_C_INCLUDES += external/linux-lib/ipu
+LOCAL_CFLAGS:= -DLOG_TAG=\"hwcomposer\"
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
diff --git a/mx5x/hwcomposer/BG_device.cpp b/mx5x/hwcomposer/BG_device.cpp
new file mode 100755
index 0000000..6b6a067
--- /dev/null
+++ b/mx5x/hwcomposer/BG_device.cpp
@@ -0,0 +1,159 @@
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <hardware/hardware.h>
+//#include <hardware/overlay.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+//note: the fb1 in mx5x is hdmi port and should use 1080p=1920_1080. 
+BG_device::BG_device(const char *dev_name, int usage) 
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+BG_device::~BG_device()
+{
+		uninit();
+}
+
+int BG_device::init()
+{
+	  int status = -EINVAL;
+	  int fbSize = 0;
+	  void *vaddr = NULL;
+
+    if(m_dev <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_init invalid parameter!");
+    	  return -1;       	
+    }
+    
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+    
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+    
+   // m_left = 0;
+   // m_top = 0;
+    m_width = 1920;//info.xres;
+    m_height = 1080;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+  	
+  	info.reserved[0] = 0;
+  	info.reserved[1] = 0;
+  	info.reserved[2] = 0;  
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+  	
+  	info.bits_per_pixel = fmt_to_bpp(m_format);
+  	info.nonstd = m_format;
+  	info.red.offset = 0;
+  	info.red.length = 0;
+  	info.green.offset = 0;
+  	info.green.length = 0;
+  	info.blue.offset = 0;
+  	info.blue.length = 0;
+  	info.transp.offset = 0;
+  	info.transp.length = 0;	 
+  	
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+  	
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+  	
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init finfo.smem_len < 0!");
+    	  return -1;      		
+  	}
+  	
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;    		
+  	}
+
+        hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format); 
+        int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!BG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	} 	
+//  	key.enable = 1;
+//  	key.color_key = 0x00000000; //black
+//  	if(ioctl(m_dev, MXCFB_SET_CLR_KEY, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}
+//  	
+//  	gbl_alpha.alpha = 255;
+//  	gbl_alpha.enable = 1;
+//  	if(ioctl(m_dev, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}  	
+  	
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+  			(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+  			(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+  			(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+  			(mbuffers[i]).format = m_format;
+  	}
+	
+    status = 0;
+    return status;
+}
+
+int BG_device::uninit()
+{
+	  //int status = -EINVAL;    
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+    }	  
+    munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+
+    return 0;
+}
diff --git a/mx5x/hwcomposer/FG_device.cpp b/mx5x/hwcomposer/FG_device.cpp
new file mode 100755
index 0000000..5625948
--- /dev/null
+++ b/mx5x/hwcomposer/FG_device.cpp
@@ -0,0 +1,307 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <linux/fb.h>
+#include <linux/mxcfb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+FG_device::FG_device(const char *dev_name, int usage)
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+FG_device::~FG_device()
+{
+		uninit();
+}
+
+static int switch_set(int fd0, int fd1, int flag)
+{
+    struct mxcfb_gbl_alpha gbl_alpha;
+    struct mxcfb_color_key key;
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd0, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 128;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd0, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd1, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 255;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd1, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+		return 0;
+}
+
+static int overlay_switch(int fd0, int fd1, int fd2, int flag)
+{
+		int blank = 1;
+  	int fp_property;
+  	char overlayStr[32];
+  	// it may be modified in mx6x.
+
+		if(ioctl(fd2, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+        return -1;
+		}
+
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB1 failed!\n");
+	      return -1;
+		}
+
+	  if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+	      return -1;
+		}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+  			//fp_property;
+
+		    HWCOMPOSER_LOG_ERR("Open fb0/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb0/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+
+  	}
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		    HWCOMPOSER_LOG_ERR("Open fb1/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb1/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+  	}
+
+    blank = FB_BLANK_UNBLANK;
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB1 failed!\n");
+	      return -1;
+		}
+
+		if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB0 failed!\n");
+	      return -1;
+		}
+
+		return 0;
+}
+
+int FG_device::init()
+{
+    int status = -EINVAL;
+    int fbSize = 0;
+    void *vaddr = NULL;
+HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
+        return -1;
+    }
+#if 1
+    //fist open fb0 device that it is binded to.
+    //it may be modified in mx6x
+    int fd_def = -1;
+    int fd_fb1 = -1;
+    if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
+	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+
+  	}
+    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+	    fd_def = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+  	}
+  	//it may be modified in mx6x
+
+//    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
+
+    struct fb_var_screeninfo def_info;
+    if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo def_finfo;
+    if(ioctl(fd_def, FBIOGET_FSCREENINFO, &def_finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+   // m_left = 0;
+   // m_top = 0;
+    m_width = def_info.xres;//info.xres;
+    m_height = def_info.yres;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+
+  	info.reserved[0] = def_info.reserved[0];
+  	info.reserved[1] = def_info.reserved[0];
+  	info.reserved[2] = def_info.reserved[0];
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+
+  	info.bits_per_pixel = fmt_to_bpp(m_format);//def_info.bits_per_pixel;
+  	info.nonstd = m_format;
+  	info.red.offset = 0;//def_info.red.offset;
+  	info.red.length = 0;//def_info.red.length;
+  	info.green.offset = 0;//def_info.green.offset;
+  	info.green.length = 0;//def_info.green.length;
+  	info.blue.offset = 0;//def_info.blue.offset;
+  	info.blue.length = 0;//def_info.blue.length;
+  	info.transp.offset = 0;//def_info.transp.offset;
+  	info.transp.length = 0;//def_info.transp.length;
+
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init finfo.smem_len < 0!");
+    	  return -1;
+  	}
+
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;
+  	}
+    //memset(vaddr, 0, fbSize);
+    hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format);
+    int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	}
+  	//do it after switch fb2 to fb1 or fb0
+  	//status = switch_set(fd_def, fd_fb1, m_usage);
+  	close(fd_def);
+  	close(fd_fb1);
+
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+		(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+		(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+		(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+		(mbuffers[i]).format = m_format;
+  	}
+
+  	//pthread_mutex_init(&dev->buf_mutex, NULL);
+#endif
+    status = 0;
+    return status;
+}
+
+int FG_device::uninit()
+{
+	  //int status = -EINVAL;
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+	}
+	munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+    return 0;
+}
+
diff --git a/mx5x/hwcomposer/README.android b/mx5x/hwcomposer/README.android
new file mode 100755
index 0000000..4aa7203
--- /dev/null
+++ b/mx5x/hwcomposer/README.android
@@ -0,0 +1,3 @@
+
+Skeleton for the "hwcomposer" HAL module.
+
diff --git a/mx5x/hwcomposer/blit_gpu.cpp b/mx5x/hwcomposer/blit_gpu.cpp
new file mode 100755
index 0000000..d7b81c5
--- /dev/null
+++ b/mx5x/hwcomposer/blit_gpu.cpp
@@ -0,0 +1,43 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+/*****************************************************************************/
+using namespace android;
+
+blit_gpu::blit_gpu()
+{
+		init();
+}
+
+blit_gpu::~blit_gpu()
+{
+		uninit();
+}
+
+int blit_gpu::init()
+{
+		return 0;
+}
+
+int blit_gpu::uninit()
+{
+		return 0;
+}
+
+int blit_gpu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+		return 0;
+}
diff --git a/mx5x/hwcomposer/blit_gpu.h b/mx5x/hwcomposer/blit_gpu.h
new file mode 100755
index 0000000..04e86f0
--- /dev/null
+++ b/mx5x/hwcomposer/blit_gpu.h
@@ -0,0 +1,42 @@
+#ifndef _BLIT_GPU_H_
+#define _BLIT_GPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+
+class blit_gpu : public blit_device{
+public:  
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_gpu();
+		virtual ~blit_gpu();
+    
+private:
+		int init();
+    int uninit();
+	
+		blit_gpu& operator = (blit_gpu& out);
+		blit_gpu(const blit_gpu& out);  
+    //add private members.		    
+};
+
+
+//int gpu_init(struct blit_device *dev);
+//
+//int gpu_uninit(struct blit_device*dev);
+//
+//int gpu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif
diff --git a/mx5x/hwcomposer/blit_ipu.cpp b/mx5x/hwcomposer/blit_ipu.cpp
new file mode 100755
index 0000000..24c0fdd
--- /dev/null
+++ b/mx5x/hwcomposer/blit_ipu.cpp
@@ -0,0 +1,171 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+using namespace android;
+
+int blit_device::isIPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_IPU);
+}
+
+int blit_device::isGPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_GPU);
+}
+
+blit_ipu::blit_ipu()
+{
+		init();
+}
+
+blit_ipu::~blit_ipu()
+{
+		uninit();
+}
+
+int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
+{
+		//int status = -EINVAL;
+
+    return 0;
+}
+
+int blit_ipu::uninit()
+{
+	  //int status = -EINVAL;
+
+	  return 0;
+}
+
+static void fill_buffer(char *pbuf, int len)
+{
+    static int k = 0;
+    short * pframe = (short *)pbuf;
+    if(k == 0) {
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0xf800;
+        }
+    }
+
+    if(k == 1){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x001f;
+        }
+    }
+
+    if(k == 2){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x07E0;
+        }
+    }
+
+    k = (k+1)%3;
+}
+
+int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+	  int status = -EINVAL;
+	  if(layer == NULL || out_buf == NULL){
+	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
+	  	  return status;
+	  }
+	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
+
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^^^^^^^^^^^^^^^^^^^^^");
+	  hwc_rect_t *src_crop = &(layer->sourceCrop);
+	  hwc_rect_t *disp_frame = &(layer->displayFrame);
+	  private_handle_t *handle = (private_handle_t *)(layer->handle);
+
+    //fill_buffer((char *)(handle->base), handle->size);
+
+	  mIPUInputParam.width = src_crop->right - src_crop->left;
+	  mIPUInputParam.height = src_crop->bottom - src_crop->top;
+	  mIPUInputParam.input_crop_win.pos.x = src_crop->left;
+    mIPUInputParam.input_crop_win.pos.y = src_crop->top;
+    mIPUInputParam.input_crop_win.win_w = src_crop->right - src_crop->left;
+    mIPUInputParam.input_crop_win.win_h = src_crop->bottom - src_crop->top;
+
+    if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= NV12");
+        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }
+    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= I420");
+        mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+    }
+    else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= RGBP");
+       // mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }else{
+        HWCOMPOSER_LOG_ERR("Error!Not supported input format %d",handle->format);
+        return status;
+    }
+#if 0
+    if(handle->base != 0) {
+       int *pVal = (int *)handle->base;
+       HWCOMPOSER_LOG_RUNTIME("=========buff[%d]=%x, buff[%d]=%x, phy=%x", 0, pVal[0], 1, pVal[1], handle->phys);
+    }
+#endif
+    mIPUInputParam.user_def_paddr[0] = handle->phys;
+    //out_buf should has width and height to be checked with the display_frame.
+    mIPUOutputParam.fmt = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
+    mIPUOutputParam.show_to_fb = 0;
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^out_buf->format= %x, out->phy_addr=%x, in->phys=%x", out_buf->format, out_buf->phy_addr, handle->phys);
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK) {
+	    mIPUOutputParam.width = out_buf->width;
+	    mIPUOutputParam.height = out_buf->height;
+		mIPUOutputParam.output_win.pos.x = 0;
+		mIPUOutputParam.output_win.pos.y = 0;
+		mIPUOutputParam.output_win.win_w = out_buf->width;
+		mIPUOutputParam.output_win.win_h = out_buf->height;
+    }
+    else {
+	    mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
+	    mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
+	    mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
+	    mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
+	    mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+	    mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+  	}
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^^right=%d, left=%d, bottom=%d, top=%d", disp_frame->right, disp_frame->left, disp_frame->bottom, disp_frame->top);
+    mIPUOutputParam.rot = layer->transform;
+    mIPUOutputParam.user_def_paddr[0] = out_buf->phy_addr;
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_init-----in blit_ipu::blit()------\n");
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
+    else
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_init failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_buf_update-----in blit_ipu::blit()------\n");
+	  status = mxc_ipu_lib_task_buf_update(&mIPUHandle, handle->phys, out_buf->phy_addr, NULL,NULL,NULL);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_buf_update failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_uninit-----in blit_ipu::blit()------\n");
+		mxc_ipu_lib_task_uninit(&mIPUHandle);
+		status = 0;
+        HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^end^^^^^^^^^^^^^^^^^^^^");
+	  return status;
+}
diff --git a/mx5x/hwcomposer/blit_ipu.h b/mx5x/hwcomposer/blit_ipu.h
new file mode 100755
index 0000000..8f641a5
--- /dev/null
+++ b/mx5x/hwcomposer/blit_ipu.h
@@ -0,0 +1,52 @@
+#ifndef _BLIT_IPU_H_
+#define _BLIT_IPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+
+#define BLIT_PIXEL_FORMAT_RGB_565  209
+
+class blit_ipu : public blit_device
+{
+public:
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_ipu();
+		virtual ~blit_ipu();
+
+private:
+		ipu_lib_input_param_t  mIPUInputParam;
+    ipu_lib_output_param_t mIPUOutputParam;
+    ipu_lib_handle_t       mIPUHandle;
+//    int                    mIPURet;
+private:
+		int init();
+    int uninit();
+
+		blit_ipu& operator = (blit_ipu& out);
+		blit_ipu(const blit_ipu& out);
+};
+
+
+//int ipu_init(struct blit_device *dev);
+//
+//int ipu_uninit(struct blit_device*dev);
+//
+//int ipu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif // _BLIT_IPU_H_
diff --git a/mx5x/hwcomposer/hwc_common.cpp b/mx5x/hwcomposer/hwc_common.cpp
new file mode 100755
index 0000000..f0f147d
--- /dev/null
+++ b/mx5x/hwcomposer/hwc_common.cpp
@@ -0,0 +1,216 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+}
+/*****************************************************************************/
+using namespace android;
+//int hwc_check_property(hwc_context_t *dev)
+//{
+//    bool bValue = false;
+//    char value[10];
+//    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_TV)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_TV : DISPLAY_MODE_NORMAL;
+//        switchTvOut(dev);
+//        *mode_changed = true;
+//        return 0;
+//    }
+//
+//    bValue = false;
+//    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_DUAL_DISP)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_DUAL_DISP : DISPLAY_MODE_NORMAL;
+//        switchDualDisp(dev);
+//        *mode_changed = true;
+//    }    	
+//		return 0;
+//}
+
+
+unsigned long fmt_to_bpp(unsigned long pixelformat)
+{
+	unsigned long bpp;
+
+	switch (pixelformat)
+	{
+		case OUT_PIX_FMT_RGB565:
+		/*interleaved 422*/
+		case OUT_PIX_FMT_YUYV:
+		case OUT_PIX_FMT_UYVY:
+		/*non-interleaved 422*/
+		case OUT_PIX_FMT_YUV422P:
+		case OUT_PIX_FMT_YVU422P:
+			bpp = 16;
+			break;
+		case OUT_PIX_FMT_BGR24:
+		case OUT_PIX_FMT_RGB24:
+		case OUT_PIX_FMT_YUV444:
+			bpp = 24;
+			break;
+		case OUT_PIX_FMT_BGR32:
+		case OUT_PIX_FMT_BGRA32:
+		case OUT_PIX_FMT_RGB32:
+		case OUT_PIX_FMT_RGBA32:
+		case OUT_PIX_FMT_ABGR32:
+			bpp = 32;
+			break;
+		/*non-interleaved 420*/
+		case OUT_PIX_FMT_YUV420P:
+		case OUT_PIX_FMT_YVU420P:
+		case OUT_PIX_FMT_YUV420P2:
+		case OUT_PIX_FMT_NV12:
+			bpp = 12;
+			break;
+		default:
+			bpp = 8;
+			break;
+	}
+	return bpp;
+}
+
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat)
+{
+    int ret = 0;
+    char * base;
+    int j, screen_size;
+    short * tmp;
+    short color;
+    if((xres<=0)||(yres<=0)||(!frame)) {
+        HWCOMPOSER_LOG_ERR("Error!Not valid parameters in fill_frame_back");
+        return -1;
+    }
+    switch(pixelformat) {
+        case OUT_PIX_FMT_RGB565:
+            memset(frame, 0, frame_size);
+            break;
+        case OUT_PIX_FMT_YUYV:
+        case OUT_PIX_FMT_UYVY:
+            tmp = (short *) frame;
+            if(pixelformat == OUT_PIX_FMT_YUYV)
+               color = 0x8000;
+            else
+               color = 0x80;
+            for(int i = 0; i < frame_size/2;i++, tmp++)
+                *tmp = color;
+            break;
+        case OUT_PIX_FMT_YUV422P:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size; i++, base++)
+                *base = 0x80;
+            break;
+        case OUT_PIX_FMT_YUV420:
+        case OUT_PIX_FMT_YVU420:
+        case OUT_PIX_FMT_NV12:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size/2; i++, base++)
+                 *base = 0x80;
+            break;
+        defaule:
+            HWCOMPOSER_LOG_ERR("Error!Not supported pixel format");
+            ret = -1;
+            break;
+    }
+    return ret;
+}
+
+int blit_dev_open(const char *dev_name, blit_device **device)
+{
+	  int status = -EINVAL;
+	  
+	  int isIPU = blit_device::isIPUDevice(dev_name);	  
+	  if(isIPU) {
+	  	  blit_ipu *dev;
+	  	  dev = new blit_ipu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;
+	  }
+	  
+	  int isGPU = blit_device::isGPUDevice(dev_name);
+	  if(isGPU) {
+	  	  blit_gpu *dev;
+	  	  dev = new blit_gpu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	      	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;	  	  	  
+	  }	  
+	  
+	  return status;
+}
+
+int blit_dev_close(blit_device *dev)
+{
+		delete(dev);
+		return 0;
+}
+
+int output_dev_open(const char *dev_name, output_device **device, int flag)
+{
+   	int is_overlay = output_device::isFGDevice(dev_name);
+HWCOMPOSER_LOG_INFO("!!!!!!!!!!!!!!!!!!!!!!!!!output_dev_open: %s", dev_name);   	
+   	if(is_overlay < 0) {
+   			return HWC_EGL_ERROR;
+   	}
+   	
+    if(is_overlay == 1) {
+HWCOMPOSER_LOG_RUNTIME("******output_dev_open() is_overlay =1");    	
+			  FG_device *dev;
+			  dev = new FG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);					   	
+    		*device = (output_device *)dev;
+    }
+		else {
+			  BG_device *dev;
+			  dev = new BG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);	  	
+    		*device = (output_device *)dev;
+		}
+       
+    return 0;
+}
+
+int output_dev_close(output_device *dev)
+{
+  	delete(dev); 
+  	
+  	return 0;
+}
diff --git a/mx5x/hwcomposer/hwc_common.h b/mx5x/hwcomposer/hwc_common.h
new file mode 100755
index 0000000..fd9311a
--- /dev/null
+++ b/mx5x/hwcomposer/hwc_common.h
@@ -0,0 +1,214 @@
+
+#ifndef _HWC_FSL_H_
+#define _HWC_FSL_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <utils/threads.h>
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include <asm/page.h>
+
+#undef LOG_TAG
+#define LOG_TAG "FslHwcomposer"
+#include <utils/Log.h>
+
+//#define HWCOMPOSER__DEBUG_LOG
+
+#ifdef HWCOMPOSER_DEBUG_LOG
+#define HWCOMPOSER_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define HWCOMPOSER_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define HWCOMPOSER_LOG_RUNTIME(format, ...)
+#define HWCOMPOSER_LOG_FUNC
+#endif
+
+#define HWCOMPOSER_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define HWCOMPOSER_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define HWCOMPOSER_LOG_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+/*****************************************************************************/
+#define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
+#define FB1_DEV_NAME "/dev/graphics/fb1"
+#define FB2_DEV_NAME "/dev/graphics/fb2"
+#define V4L_DEV_NAME "/dev/video16"
+#define MAX_OUTPUT_DISPLAY  10
+
+#define BLIT_IPU "blt_ipu"
+#define BLIT_GPU "blt_gpu"
+
+#define DEFAULT_BUFFERS  3 
+
+using namespace android;
+
+//typedef unsigned long __u32;
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+#define OUT_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define OUT_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define OUT_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define OUT_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+
+#define OUT_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define OUT_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+#define OUT_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define OUT_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define OUT_PIX_FMT_YUV420  fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
+#define OUT_PIX_FMT_YVU420  fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+typedef enum {
+    DISPLAY_MODE_OVERLAY_DISP0 = 0x00000001,
+    DISPLAY_MODE_OVERLAY_DISP1 = 0x00000002,
+    DISPLAY_MODE_OVERLAY_DISP2 = 0x00000004,
+    DISPLAY_MODE_OVERLAY_DISP3 = 0x00000008,
+    DISPLAY_MODE_DISP1 = 0x00000010,
+    DISPLAY_MODE_DISP2 = 0x00000020,
+    DISPLAY_MODE_DISP3 = 0x00000040,
+}DISPLAY_MODE;
+
+//seperate into three groups. one group member can be or with other group member.
+//but the group member can not be or with that in the same group except display group.
+#define GRALLOC_USAGE_OVERLAY0_MASK   0x00300000
+#define GRALLOC_USAGE_OVERLAY1_MASK   0x00C00000
+#define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
+#define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
+
+typedef struct{
+    void *virt_addr;
+    unsigned long phy_addr;
+    unsigned long size;
+    int format;
+    int width;
+    int height;
+    int usage;
+}hwc_buffer;
+
+class output_device
+{
+public:
+		virtual int post(hwc_buffer *);
+		virtual int fetch(hwc_buffer *);
+
+		void setUsage(int usage);
+		int getUsage();
+		int getWidth();
+		int getHeight();
+
+		output_device(const char *dev_name, int usage);
+		virtual ~output_device();
+
+		static int isFGDevice(const char *dev_name);
+
+private:
+		output_device& operator = (output_device& out);
+		output_device(const output_device& out);
+
+protected:
+		int m_dev;
+		//int m_left;
+		//int m_top;
+		int m_usage;
+		int m_width;
+		int m_height;
+		int m_format;
+//		int is_overlay;
+
+		mutable Mutex mLock;
+		hwc_buffer mbuffers[DEFAULT_BUFFERS];
+		unsigned long mbuffer_count;
+		unsigned long mbuffer_cur;
+
+};
+
+//the normal display device
+class BG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		BG_device(const char *dev_name, int usage);
+		virtual ~BG_device();
+
+private:
+		BG_device& operator = (BG_device& out);
+		BG_device(const BG_device& out);
+
+		int init();
+		int uninit();
+
+public:
+		//add private data
+};
+
+//the overlay display device
+class FG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		FG_device(const char *dev_name, int usage);
+		virtual ~FG_device();
+
+private:
+		FG_device& operator = (FG_device& out);
+		FG_device(const FG_device& out);
+
+		int init();
+		int uninit();
+
+private:
+		//add private data
+		//int m_flag; //for display number flag.
+};
+
+class blit_device{
+public:
+		static int isIPUDevice(const char *dev_name);
+		static int isGPUDevice(const char *dev_name);
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
+		virtual ~blit_device(){}
+};
+
+//int FG_init(struct output_device *dev);
+//int FG_uninit(struct output_device *dev);
+//int FG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int FG_post(struct output_device *dev);
+//
+//int BG_init(struct output_device *dev);
+//int BG_uninit(struct output_device *dev);
+//int BG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int BG_post(struct output_device *dev);
+unsigned long fmt_to_bpp(unsigned long pixelformat);
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat);
+int blit_dev_open(const char *dev_name, blit_device **);
+int blit_dev_close(blit_device *);
+
+int output_dev_open(const char *dev_name, output_device **, int);
+int output_dev_close(output_device *);
+
+#endif
diff --git a/mx5x/hwcomposer/hwcomposer.cpp b/mx5x/hwcomposer/hwcomposer.cpp
new file mode 100755
index 0000000..7ff9e78
--- /dev/null
+++ b/mx5x/hwcomposer/hwcomposer.cpp
@@ -0,0 +1,556 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <hardware/hardware.h>
+#include <hardware/overlay.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+struct hwc_context_t {
+    hwc_composer_device_t device;
+    /* our private state goes below here */
+    //now the blit device may only changed in hwc_composer_device open or close.
+    blit_device *blit;
+
+    output_device *m_out[MAX_OUTPUT_DISPLAY];
+    char m_using[MAX_OUTPUT_DISPLAY]; //0 indicates no output_device, 1 indicates related index;
+
+    //the system property for dual display and overlay switch.
+    int display_mode;
+    int display_mode_changed; //the initial value is 0
+};
+
+static int hwc_device_open(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device);
+
+static struct hw_module_methods_t hwc_module_methods = {
+    open: hwc_device_open
+};
+
+hwc_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+        tag: HARDWARE_MODULE_TAG,
+        version_major: 1,
+        version_minor: 0,
+        id: HWC_HARDWARE_MODULE_ID,
+        name: "Sample hwcomposer module",
+        author: "The Android Open Source Project",
+        methods: &hwc_module_methods,
+    }
+};
+
+/*****************************************************************************/
+
+static void dump_layer(hwc_layer_t const* l) {
+    LOGD("\ttype=%d, flags=%08x, handle=%p, tr=%02x, blend=%04x, {%d,%d,%d,%d}, {%d,%d,%d,%d}",
+            l->compositionType, l->flags, l->handle, l->transform, l->blending,
+            l->sourceCrop.left,
+            l->sourceCrop.top,
+            l->sourceCrop.right,
+            l->sourceCrop.bottom,
+            l->displayFrame.left,
+            l->displayFrame.top,
+            l->displayFrame.right,
+            l->displayFrame.bottom);
+}
+
+static int hwc_check_property(hwc_context_t *dev)
+{
+    //bool bValue = false;
+    char value[10];
+    int orignMode = dev->display_mode;
+    /*note:rw.VIDEO_OVERLAY_DISPLAY means the overlay will be combined to which display.
+     *the default value is 0 and it indicates nothing.
+     *if the value is 1 and it indicates combined to display0.
+     *if the value is 2 and it indicates combined to display1.
+    */
+    property_get("rw.VIDEO_OVERLAY_DISPLAY", value, "");
+    dev->display_mode &= ~(DISPLAY_MODE_OVERLAY_DISP0 | DISPLAY_MODE_OVERLAY_DISP1 |
+        				DISPLAY_MODE_OVERLAY_DISP2 | DISPLAY_MODE_OVERLAY_DISP3);
+    if (strcmp(value, "1") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP0;
+    }
+    else if (strcmp(value, "2") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP1;
+    }
+
+		if (strcmp(value, "3") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
+    }
+    else if (strcmp(value, "4") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP3;
+    }
+    /*note:rw.VIDEO_DISPLAY means the display device.
+     *the default value is 0 and it indicates nothing.
+     *if the value is 1 and it indicates display1.
+     *if the value is 2 and it indicates display2.
+    */
+    property_get("sys.VIDEO_DISPLAY", value, "");
+    dev->display_mode &= ~(DISPLAY_MODE_DISP1 | DISPLAY_MODE_DISP2);
+    if (strcmp(value, "1") == 0){
+        dev->display_mode |= DISPLAY_MODE_DISP1;
+    }
+    if (strcmp(value, "2") == 0){
+        dev->display_mode |= DISPLAY_MODE_DISP2;
+    }
+
+		if(dev->display_mode ^ orignMode) {
+				dev->display_mode_changed = 1;
+		}
+//HWCOMPOSER_LOG_RUNTIME("*********display_mode=%x, display_mode_changed=%d\n", dev->display_mode, dev->display_mode_changed);
+		return 0;
+}
+
+static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
+{
+	handle->usage &= ~GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+
+    if(dev->display_mode & DISPLAY_MODE_DISP1){
+            handle->usage |= GRALLOC_USAGE_HWC_DISP1;
+            dev->display_mode &= ~DISPLAY_MODE_DISP1;
+			return 0;
+    }
+
+    if(dev->display_mode & DISPLAY_MODE_DISP2)
+            handle->usage |= GRALLOC_USAGE_HWC_DISP2;
+
+	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP0){
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP0;
+			dev->display_mode &= ~DISPLAY_MODE_OVERLAY_DISP0;
+	}
+	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP1)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP1;
+
+	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP2)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP2;
+	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP3)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP3;
+
+//HWCOMPOSER_LOG_RUNTIME("************handle->usage=%x", handle->usage);
+	return 0;
+}
+
+/*paramters:
+ * usage: devices need to open.
+ * ufg:devices not open.
+ * puse:index array when device open it need set.
+ *check if the output device is exist.
+ *return 0 indicates exist; 1 indicates not exist.
+*/
+static int checkOutputDevice(struct hwc_context_t *ctx, char *puse, int usage, int *ufg)//return -1 indicate not exist.
+{
+	output_device *out;
+	int uFlag = 0;
+	int usg = 0;
+
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i]) {
+			out = ctx->m_out[i];
+			usg = out->getUsage();
+			if(usg & usage) {
+				uFlag |= (usg & usage);
+				if(puse) puse[i] = 1;
+			}
+		}
+	}
+	if(ufg != NULL)
+		*ufg = usage & ~uFlag;
+
+	return uFlag ^ usage;
+}
+
+static int findOutputDevice(struct hwc_context_t *ctx, int *index, int usage, int *ufg)
+{
+	output_device *out;
+	int uFlag = 0;
+	int usg = 0;
+
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i]) {
+			out = ctx->m_out[i];
+			usg = out->getUsage();
+			if(usg & usage) {
+				uFlag = (usg & usage);
+				*index = i;
+				break;
+			}
+		}
+	}
+	if(ufg != NULL)
+		*ufg |= uFlag;
+
+	return (*ufg) ^ usage;
+}
+
+static int findEmpytIndex(struct hwc_context_t *ctx)
+{
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(!ctx->m_using[i])
+			return i;
+	}
+
+	HWCOMPOSER_LOG_ERR("the output device array not enough big.\n");
+	return -1;
+}
+
+//check the output device and delete unused device instance.
+static void deleteEmtpyIndex(struct hwc_context_t *ctx)
+{
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(!ctx->m_using[i]) {
+			if(ctx->m_out[i]) {
+				output_dev_close(ctx->m_out[i]);
+				ctx->m_out[i] = NULL;
+			}
+		}
+	}
+}
+
+static char* getDeviceName(int usage, int *pUse)
+{
+    if(usage & GRALLOC_USAGE_HWC_DISP1){
+    		*pUse = GRALLOC_USAGE_HWC_DISP1;
+    		return (char *)FB1_DEV_NAME;
+    }
+    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+    		*pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
+    		return (char *)FB2_DEV_NAME;
+    }
+    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+        *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP1;
+        return (char *)FB2_DEV_NAME;
+    }//end else if
+
+    return NULL;
+}
+
+#if 0
+static void setLayerFrame(hwc_layer_t *layer, output_device *out, int usage)
+{
+    if(usage & GRALLOC_USAGE_HWC_DISP1){
+    		layer->displayFrame.left = 0;
+    		layer->displayFrame.top = 0;
+    		layer->displayFrame.right = out->getWidth();
+    		layer->displayFrame.bottom = out->getHeight();
+    }
+//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP0) {
+//    		display_frame =;
+//    }
+//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP1) {
+//        display_frame =;
+//    }//end else if
+}
+#endif
+
+static int validate_displayFrame(hwc_layer_t *layer)
+{
+    int isValid = 0;
+    hwc_rect_t *disFrame = &(layer->displayFrame);
+    isValid = ((disFrame->left >= 0) && (disFrame->right >= 0) && (disFrame->top >= 0) &&
+            (disFrame->bottom >= 0) && ((disFrame->right - disFrame->left) >= 0) &&
+            ((disFrame->bottom  - disFrame->top) >= 0));
+    return isValid;
+}
+
+static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
+//#if 1
+		//HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---1>>>>>>>>>>>>>>>>>\n");
+		char out_using[MAX_OUTPUT_DISPLAY] = {0};
+
+//		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+//				out_using[i] = m_using[i];
+//		}
+
+		struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
+#if 1
+		if(ctx) {
+			hwc_check_property(ctx);
+		}
+#endif
+    if (list && dev && ((list->flags & HWC_GEOMETRY_CHANGED) || ctx->display_mode_changed)) {
+        for (size_t i=0 ; i<list->numHwLayers ; i++) {
+            //dump_layer(&list->hwLayers[i]);
+            //list->hwLayers[i].compositionType = HWC_FRAMEBUFFER;
+            hwc_layer_t *layer = &list->hwLayers[i];
+            /*
+             *the private_handle_t should expand to have usage and format member.
+            */
+		    if (private_handle_t::validate(layer->handle) < 0) {
+	    		//HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
+	    		continue;
+		    }
+		    //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
+            private_handle_t *handle = (private_handle_t *)(layer->handle);
+            if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
+            	//HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
+            	continue;
+            }
+            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---3>usage=%x, phy=%x>>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
+#if 1
+        	layer->compositionType = HWC_OVERLAY;
+    		//if(handle->usage & GRALLOC_USAGE_HWC_DISP1)
+    		//handle the display frame position for tv out.
+#endif
+#if 1
+        	hwc_modify_property(ctx, handle);
+
+            if(!validate_displayFrame(layer)) {
+                HWCOMPOSER_LOG_INFO("<<<<<<<<<<<<<<<hwc_prepare---3-2>>>>>>>>>>>>>>>>\n");
+                continue;
+            }
+
+            int status = -EINVAL;
+            int index = 0;
+            int retv = 0;
+            int m_usage = 0;
+            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+            //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---3-3>>>>>>>>>>>>>>>>\n");
+            retv = checkOutputDevice(ctx, out_using, i_usage, &m_usage);
+            while(retv && m_usage) {
+		        int ruse = 0;
+		        char *dev_name = NULL;
+				dev_name = getDeviceName(m_usage, &ruse);
+	            m_usage &= ~ruse;
+	            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---4>>>>>>>>>>>>>>>>>\n");
+	            if(dev_name == NULL) {
+					HWCOMPOSER_LOG_INFO("****Warnning: layer buffer usage(%x) does not support!", handle->usage);
+					HWCOMPOSER_LOG_INFO("****Warnning:  the layer buffer will be handled in surfaceflinger");
+					layer->compositionType = HWC_FRAMEBUFFER;
+					continue;
+	            }//end else
+
+	            index = findEmpytIndex(ctx);
+	            if(index == -1) {
+            		HWCOMPOSER_LOG_ERR("Error:findEmpytIndex failed");
+            		return HWC_EGL_ERROR;
+	            }
+	            if(ctx->m_out[index])
+	            		deleteEmtpyIndex(ctx);
+
+		        status = output_dev_open(dev_name, &(ctx->m_out[index]), ruse);
+		        if(status < 0){
+		        	  HWCOMPOSER_LOG_ERR("Error! open output device failed!");
+		        	  continue;
+		        }//end if
+		        out_using[index] = 1;
+		        ctx->m_using[index] = 1;
+		        //setLayerFrame(layer, ctx->m_out[index], ruse);
+            }//end while
+#endif
+        }//end for
+#if 1
+        ctx->display_mode_changed = 0;
+	    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+			if(!out_using[i] && ctx->m_using[i]) {
+				ctx->m_using[i] = 0;
+				deleteEmtpyIndex(ctx);
+			}
+			//ctx->m_using[i] = out_using[i];
+		}
+#endif
+    }//end if
+
+//#endif
+    return 0;
+}
+
+static int releaseAllOutput(struct hwc_context_t *ctx)
+{
+		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_using[i]) {
+						output_dev_close(ctx->m_out[i]);
+						ctx->m_using[i] = 0;
+						ctx->m_out[i] = NULL;
+				}
+		}
+
+		return 0;
+}
+
+static int getActiveOuputDevice(struct hwc_context_t *ctx)
+{
+		int num = 0;
+		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_out[i] && ctx->m_using[i])
+						num ++;
+		}
+
+		return num;
+}
+
+static int hwc_set(hwc_composer_device_t *dev,
+        hwc_display_t dpy,
+        hwc_surface_t sur,
+        hwc_layer_list_t* list)
+{
+		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=1==============\n");
+    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
+    //for (size_t i=0 ; i<list->numHwLayers ; i++) {
+    //    dump_layer(&list->hwLayers[i]);
+    //}
+    //hwc_buffer *outBuff[MAX_OUTPUT_DISPLAY];
+    //when displayhardware do releas function, it will come here.
+#if 1
+    if(ctx && (dpy == NULL) && (sur == NULL) && (list == NULL)) {
+		//close the output device.
+		releaseAllOutput(ctx);
+		ctx->display_mode_changed = 1;
+
+		return 0;
+    }
+#endif
+		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=2==============\n");
+#if 1 
+    EGLBoolean sucess = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
+    if (!sucess) {
+        return HWC_EGL_ERROR;
+    }
+#endif
+    if(list == NULL || dev == NULL) {
+    	return 0;
+    }
+#if 1
+ 		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=3==============\n");
+    if(getActiveOuputDevice(ctx) == 0) {return 0;}//eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur); return 0;}
+
+    int status = -EINVAL;
+	HWCOMPOSER_LOG_RUNTIME("==============hwc_set=4==============\n");
+	hwc_buffer out_buffer[MAX_OUTPUT_DISPLAY];
+	memset(out_buffer, 0, sizeof(out_buffer));
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i] && ctx->m_out[i])
+			status = ctx->m_out[i]->fetch(&out_buffer[i]);
+	}
+
+    blit_device *bltdev = ctx->blit;
+    for (size_t i=0 ; i<list->numHwLayers ; i++){
+		hwc_layer_t *layer = &list->hwLayers[i];
+	    if (private_handle_t::validate(layer->handle) < 0) {
+    		//HWCOMPOSER_LOG_INFO("2--it is not a valide buffer handle\n");
+    		continue;
+	    }
+
+        if(!validate_displayFrame(layer)) {
+            continue;
+        }
+
+		private_handle_t *handle = (private_handle_t *)(layer->handle);
+		if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY){
+            int retv = 0;
+            int m_usage = 0;
+            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+    	    HWCOMPOSER_LOG_RUNTIME("==============hwc_set=5==============\n");
+            do {
+    			output_device *outdev = NULL;
+    			int index = 0;
+        		retv = findOutputDevice(ctx, &index, i_usage, &m_usage);
+                if((index >= 0) && (index < MAX_OUTPUT_DISPLAY)) {
+                	outdev = ctx->m_out[index];
+                }
+    			if(outdev != NULL) {
+    				status = bltdev->blit(layer, &(out_buffer[index]));
+    				if(status < 0){
+    					HWCOMPOSER_LOG_ERR("Error! bltdev->blit() failed!");
+    					continue;
+    				}
+    			}//end if(outdev != NULL)
+            }while(retv);
+
+		}//end if
+    }//end for
+
+    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_using[i]) {
+						status = ctx->m_out[i]->post(&out_buffer[i]);
+						if(status < 0){
+								HWCOMPOSER_LOG_ERR("Error! output device post buffer failed!");
+								continue;
+						}
+				}
+		}
+#endif
+    return 0;
+}
+
+static int hwc_device_close(struct hw_device_t *dev)
+{
+    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
+    if (ctx) {
+    		if(ctx->blit)
+    				blit_dev_close(ctx->blit);
+        releaseAllOutput(ctx);
+        free(ctx);
+    }
+    return 0;
+}
+
+/*****************************************************************************/
+
+static int hwc_device_open(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, HWC_HARDWARE_COMPOSER)) {
+        struct hwc_context_t *dev;
+        dev = (hwc_context_t*)malloc(sizeof(*dev));
+
+        /* initialize our state here */
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = hwc_device_close;
+
+        dev->device.prepare = hwc_prepare;
+        dev->device.set = hwc_set;
+
+        *device = &dev->device.common;
+
+        /* our private state goes below here */
+        status = blit_dev_open(BLIT_IPU, &(dev->blit));
+        if(status < 0){
+        	  HWCOMPOSER_LOG_ERR("Error! blit_dev_open failed!");
+        	  goto err_exit;
+        }
+HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_device_open>>>>>>>>>>>>>>>>>\n");
+        return 0;
+err_exit:
+				if(dev){
+						if(dev->blit) {
+								blit_dev_close(dev->blit);
+						}
+					  free(dev);
+				}
+				//status = -EINVAL;
+        /****************************************/
+    }
+    return status;
+}
diff --git a/mx5x/hwcomposer/output_device.cpp b/mx5x/hwcomposer/output_device.cpp
new file mode 100755
index 0000000..ceff1be
--- /dev/null
+++ b/mx5x/hwcomposer/output_device.cpp
@@ -0,0 +1,140 @@
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+
+void output_device::setUsage(int usage)
+{
+    m_usage = usage;
+}
+
+int output_device::getUsage()
+{
+    return m_usage;
+}
+
+int output_device::getWidth()
+{
+    return m_width;
+}
+
+int output_device::getHeight()
+{
+    return m_height;
+}
+
+output_device::output_device(const char *dev_name, int usage)
+{
+    m_dev = open(dev_name, O_RDWR | O_NONBLOCK, 0);
+    if(m_dev < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device Open fb device %s failed!", dev_name);
+    }
+    m_usage = usage;
+}
+
+output_device::~output_device()
+{
+	if(m_dev > 0) {
+        close(m_dev);
+	}
+}
+
+int output_device::isFGDevice(const char *dev_name)
+{
+    int status = -EINVAL;
+    int fd = -1;
+    char fb_usage[32];
+    char fb_name[32];
+    int fd_n = 0;
+    int size = 0;
+    int is_overlay = 0;
+    char *psname;
+
+    memset(fb_name, 0, sizeof(fb_name));
+    psname = (char *)dev_name;
+    psname += (strlen(dev_name) - 1);
+    strcpy(fb_name, "/sys/class/graphics/fb");
+    strcat(fb_name, psname);
+    strcat(fb_name, "/name");
+    fd_n = open(fb_name, O_RDONLY, 0);
+    //fd_n = open("/sys/class/graphics/fb0/name", O_RDONLY, 0);
+    if(fd_n < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice  open %s failed!", fb_name);
+		return -1;
+    }
+    memset(fb_usage, 0, sizeof(fb_usage));
+    size = read(fd_n, fb_usage, sizeof(fb_usage));
+    if(size < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice read /sys/class/graphics/fb0/name failed!");
+		return -1;
+    }
+    close(fd_n);
+HWCOMPOSER_LOG_INFO("output_device::isFGDevice===%s, %s, %s", dev_name, fb_name, fb_usage);
+    if(strstr(fb_usage, "FG"))
+    	return 1;
+ 	return 0;
+}
+
+int output_device::fetch(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::fetch invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+
+	  Mutex::Autolock _l(mLock);
+	  buf->size = (mbuffers[mbuffer_cur]).size;
+	  buf->virt_addr = (mbuffers[mbuffer_cur]).virt_addr;
+	  buf->phy_addr = (mbuffers[mbuffer_cur]).phy_addr;
+	  buf->width = m_width;
+	  buf->height = m_height;
+	  buf->usage = m_usage;
+	  buf->format = m_format;
+	  //dev->buffer_cur = (dev->buffer_cur + 1) % DEFAULT_BUFFERS;
+
+	  return 0;
+}
+
+int output_device::post(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_post() invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()############");
+
+	Mutex::Autolock _l(mLock);
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post VSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post FSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    info.yoffset = ((unsigned long)buf->virt_addr - (unsigned long)(mbuffers[0]).virt_addr) / finfo.line_length;
+    //info.yoffset = ((info.yres_virtual * finfo.line_length)/ DEFAULT_BUFFERS) * mbuffer_cur;
+    mbuffer_cur = (mbuffer_cur + 1) % DEFAULT_BUFFERS;
+    info.activate = FB_ACTIVATE_VBL;
+//HWCOMPOSER_LOG_RUNTIME("#######yoffset=%d, mbuffer_cur=%d######", info.yoffset, mbuffer_cur);
+    ioctl(m_dev, FBIOPAN_DISPLAY, &info);
+
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()##end##########");
+    return 0;
+}
diff --git a/mx5x/libcopybit/Android.mk b/mx5x/libcopybit/Android.mk
new file mode 100755
index 0000000..f32c0b9
--- /dev/null
+++ b/mx5x/libcopybit/Android.mk
@@ -0,0 +1,44 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(HAVE_FSL_IMX_GPU),true)
+ifeq ($(BOARD_SOC_CLASS),IMX5X)
+
+LOCAL_PATH := $(call my-dir)
+
+# HAL module implemenation, not prelinked and stored in
+# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
+include $(CLEAR_VARS)
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
+LOCAL_SHARED_LIBRARIES := liblog
+ifeq ($(BOARD_SOC_TYPE),IMX50)
+LOCAL_SHARED_LIBRARIES += libc2d_z160
+else
+LOCAL_SHARED_LIBRARIES += libc2d_z430
+endif
+
+LOCAL_SRC_FILES := 	\
+	copybit.cpp
+	
+LOCAL_MODULE := copybit.$(TARGET_BOARD_PLATFORM)
+LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).copybit\" -D_LINUX
+
+LOCAL_MODULE_TAGS := eng
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif
+endif
diff --git a/mx5x/libcopybit/c2d_api.h b/mx5x/libcopybit/c2d_api.h
new file mode 100755
index 0000000..91e19e0
--- /dev/null
+++ b/mx5x/libcopybit/c2d_api.h
@@ -0,0 +1,541 @@
+/* -------------------------------------------------------------------------
+ *
+ *  Copyright (C) 2010  QUALCOMM Incorporated.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * $Id:
+ * $DateTime:
+ * $Author:
+ *
+ *//*!
+ * \file    c2d_api.h
+ * \brief   C2D API
+ *//*----------------------------------------------------------------------*/
+ 
+
+#ifndef __c2d_api_h_
+#define __c2d_api_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* -------------------------------------------------------------------------
+ * C2D Defines
+ *//*----------------------------------------------------------------------*/
+
+#ifndef _LINUX
+#define C2D_API __declspec (dllexport)     /*!< DLL exports */
+#ifndef C2D_API
+#ifdef WIN32
+#define C2D_API __declspec (dllexport)     /*!< DLL exports */
+#else
+#define C2D_API
+#endif
+#endif
+#else //_LINUX
+#define C2D_API
+#endif //_LINUX
+
+typedef void*                   C2D_CONTEXT; /*!< C2D Context type */
+typedef void*                   C2D_SURFACE; /*!< C2D Surface type */
+
+typedef enum __C2D_STATUS {         /*!< Status codes, returned by any c2d function */
+    C2D_STATUS_OK              = 0, /*!<   operation was successful     */ 
+    C2D_STATUS_FAILURE         = 1, /*!<   unspecified failure          */
+    C2D_STATUS_NOT_SUPPORTED   = 2, /*!<   not supported functionality  */ 
+    C2D_STATUS_OUT_OF_MEMORY   = 3, /*!<   memory allocation failed     */        
+    C2D_STATUS_INVALID_PARAM   = 4, /*!<   invalid parameter or combination of parameters */       
+} C2D_STATUS;
+
+
+typedef enum _C2D_COLORFORMAT {             /*!< Color formats */
+    /* 1bit formats (alpha mask) */
+    C2D_COLOR_A1                            = 0,    /*!< 1bit per pixel (alpha mask)    */
+    /* 4bit formats (alpha mask) */
+    C2D_COLOR_A4                            = 1,    /*!< 4bit per pixel (alpha mask)    */
+    /* 8bit formats */
+    C2D_COLOR_A8                            = 2,    /*!< 8bit per pixel (alpha mask)    */
+    C2D_COLOR_8                             = 3,    /*!< 8bit per pixel                 */  
+    /* 16bit formats */
+    C2D_COLOR_4444                          = 4,    /*!< 16bit per pixel 4444 ARGB      */
+    C2D_COLOR_4444_RGBA                     = 5,    /*!< 16bit per pixel 4444 RGBA      */
+    C2D_COLOR_1555                          = 6,    /*!< 16bit per pixel 1555 ARGB      */
+    C2D_COLOR_5551_RGBA                     = 7,    /*!< 16bit per pixel 5551 RGBA      */
+    C2D_COLOR_0565                          = 8,    /*!< 16bit per pixel 0565 RGB       */
+    /* 32bit formats */
+    C2D_COLOR_8888                          = 9,    /*!< 32bit per pixel 8888 ARGB      */
+    C2D_COLOR_8888_RGBA                     = 10,   /*!< 32bit per pixel 8888 RGBA      */
+    C2D_COLOR_8888_ABGR                     = 11,   /*!< 32bit per pixel 8888 ABGR      */
+    /* 24bit formats */
+    C2D_COLOR_888                           = 12,   /*!< 24bit per pixel 888 BGR        */
+    /* YUV Formats etc.   */
+    C2D_NUMBER_OF_COLORFORMATS              = 13,    /*!< number of color formats; keep this the last */
+    C2D_COLOR_DUMMY                         = (1<<30) /*!< dummy enum. C2D_COLORFORMAT is used in C2D_SURFACE_DEF struct,
+                                                           this makes sure that C2D_COLORFORMAT size is aligned to 32bit  */
+} C2D_COLORFORMAT;
+
+
+typedef struct _C2D_RECT /*!< c2d rectangle              */
+{
+    int x;         /*!<   upper-left x */
+    int y;         /*!<   upper-left y */
+    int width;     /*!<   width */
+    int height;    /*!<   height */
+} C2D_RECT;
+
+typedef struct _C2D_POINT
+{
+    int x;
+    int y;
+} C2D_POINT;
+
+
+typedef struct _C2D_SURFACE_DEF { /*!< Structure for creating a c2d surface                  */
+    C2D_COLORFORMAT format;     /*!< RGBA color format                                       */
+    unsigned int    width;      /*!< defines width in pixels                                 */
+    unsigned int    height;     /*!< defines height in pixels                                */
+    unsigned int    stride;     /*!< set by c2dSurfAlloc, defines stride in bytes            */
+    void           *buffer;     /*!< set by c2dSurfAlloc, physical address to surface buffer */ 
+    void           *host;       /*!< set by c2dSurfAlloc, virtual address to surface buffer  */ 
+    unsigned int    flags;      /*!< different flags to control the surface behavior         */
+} C2D_SURFACE_DEF;
+
+#define C2D_SURFACE_NO_BUFFER_ALLOC   1
+#define C2D_SURFACE_CLIPRECT_OVERRIDE 2
+
+
+typedef enum _C2D_GRADIENT_DIRECTION {  /*!< Direction of linear color fill */    
+    C2D_GD_LEFTTOP_RIGHTBOTTOM,  /*!< Left to Right, Top to Bottom */
+    C2D_GD_RIGHTTOP_LEFTBOTTOM,  /*!< Right to Left, Top to Bottom */
+    C2D_GD_LEFTBOTTOM_RIGHTTOP,  /*!< Left to Right, Bottom to Top */
+    C2D_GD_RIGHTBOTTOM_LEFTTOP,  /*!< Right to Left, Bottom to Top */
+    C2D_GD_TOP_BOTTOM,           /*!< Top to bottom */
+    C2D_GD_LEFT_RIGHT,           /*!< Left to right */
+    C2D_GD_BOTTOM_TOP,           /*!< Bottom up */
+    C2D_GD_RIGHT_LEFT            /*!< Right to left */
+} C2D_GRADIENT_DIRECTION;
+
+typedef enum __C2D_STRETCH_MODE {    /*!< Stretching modes */
+    C2D_STRETCH_POINT_SAMPLING,      /*!< Simple point sampling */
+    C2D_STRETCH_BILINEAR_SAMPLING    /*!< Linear interpolation in x- and y-direction */
+} C2D_STRETCH_MODE;
+
+typedef enum __C2D_ALPHA_BLEND_MODE {    /*!< Blending modes enumeration */
+    C2D_ALPHA_BLEND_NONE        = 0,     /*!< disables alpha blending */
+    C2D_ALPHA_BLEND_SRCOVER     = 1,     /*!< Source Over Destination */
+    C2D_ALPHA_BLEND_DIRECT      = 2,
+} C2D_ALPHA_BLEND_MODE;
+
+typedef enum __C2D_PARAMETERS {               /*!< Draw parameters                */
+    C2D_PARAM_FILL_BIT        = (1<<0),       /*!< fill rect or arc               */
+    C2D_PARAM_GRADIENT_BIT    = (1<<1),       /*!< fill with fg color to bg color */
+    C2D_PARAM_PATTERN_BIT     = (1<<2),       /*!< fill with brush                */
+    C2D_PARAM_TILING_BIT      = (1<<3),       /*!< tiling(repeat), no scaling for brush */
+    C2D_PARAM_MIRROR_BIT      = (1<<4),       /*!< horizontal mirroring           */
+    C2D_PARAM_LINE_LAST_PIXEL = (1<<5),       /*!< draw the last pixel of a line segment */
+} C2D_PARAMETERS;
+    
+
+ typedef enum _C2D_DISPLAY {               /*!< Display enumeration */
+    C2D_DISPLAY_MAIN        = (1 << 0),    /*!< main display */
+    C2D_DISPLAY_SECONDARY   = (1 << 1),    /*!< secondary display */
+    C2D_DISPLAY_TV_OUT      = (1 << 2),    /*!< tv-out etc. */
+    C2D_DISPLAY_OVERLAY     = (1 << 3),    /*!< overlay window bit for display surface if overlay surfaces are supported */
+    C2D_DISPLAY_BG          = (1 << 4),    /*!< background window bit */
+} C2D_DISPLAY;
+
+
+/* -------------------------------------------------------------------------
+ *                          C2D API
+ *//*----------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Create C2D context, 
+ *          allocates and returns new handle to the draw state
+ *  
+ * \param   a_c2dContext is pointer to C2D_CONTEXT where context id is stored
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dCreateContext(C2D_CONTEXT *a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Destroy C2D context,
+ *          free the given draw state
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT where context was created
+ *                       with c2dCreateContext function
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dDestroyContext(C2D_CONTEXT a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Alloc C2D surface, 
+ *          allocates surface and returns handle to it
+ *  
+ * \param   a_c2dSurface is the pointer to C2D_SURFACE where surface id is stored
+ * \param   a_surfaceDef is the pointer to C2D_SURFACE_DEF
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSurfAlloc(C2D_CONTEXT a_c2dContext, C2D_SURFACE *a_c2dSurface, C2D_SURFACE_DEF *a_surfaceDef);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Free C2D surface,
+ *          free the given surface
+ *
+ * \param   a_c2dSurface is the C2D_SURFACE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSurfFree(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Lock C2D surface,
+ *          Lock surface and return virtual address to surface buffer.
+ *
+ * \param   a_c2dContext is the context handle
+ * \param   a_c2dSurface is the C2D_SURFACE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSurfLock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, void** a_ptr);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Unlock C2D surface,
+ *          Give surface back for HW access
+ *
+ * \param   a_c2dContext is the context handle
+ * \param   a_c2dSurface is the C2D_SURFACE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSurfUnlock(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set destination surface
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_c2dSurface is C2D_SURFACE
+ * \param   a_type is the C2D_SURFACE_TYPE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDstSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set source surface
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_c2dSurface is C2D_SURFACE
+ * \param   a_type is the C2D_SURFACE_TYPE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetSrcSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set ROP mode
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_rop is the 32bit rop mode
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetRop(C2D_CONTEXT a_c2dContext, unsigned int a_rop);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set foreground color
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_fgColor is the 32bit value for the fgcolor
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetFgColor(C2D_CONTEXT a_c2dContext, unsigned int a_fgColor);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set background color
+ *
+ * \param   a_c2dContext, C2D_CONTEXT
+ * \param   a_bgColoris the 32bit value for the bgcolor
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetBgColor(C2D_CONTEXT a_c2dContext, unsigned int a_bgColor);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set gradient direction
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_direction is the C2D_GRADIENT_DIRECTION
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetGradientDirection(C2D_CONTEXT a_c2dContext, C2D_GRADIENT_DIRECTION a_direction);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set stretching mode
+ *
+ * \param   a_c2dContext, C2D_CONTEXT
+ * \param   a_mode, C2D_STRETCH_MODE, how to perform stretching
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetStretchMode(C2D_CONTEXT a_c2dContext, C2D_STRETCH_MODE a_mode);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set source rectangle
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_rect is the C2D_RECT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetSrcRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set destination rectangle
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_rect is the C2D_RECT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDstRectangle(C2D_CONTEXT a_c2dContext, C2D_RECT *a_rect);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Sets the region of the destination surface that is clipped
+ *          during rendering. Works similar to destination rectangle except
+ *          clipping rectangle can be used to clip a stretched blt.
+ *
+ * \param   a_c2dContext, C2D_CONTEXT
+ * \param   a_clipRect, *C2D_RECT, pass NULL to disable
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDstClipRect(C2D_CONTEXT a_c2dContext, C2D_RECT *a_clipRect);
+
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set source rotation
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_degree is the 32bit value for rotation
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetSrcRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set destination rotation
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_degree is the 32bit value for rotation
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDstRotate(C2D_CONTEXT a_c2dContext, unsigned int a_rotation);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set alpha blend mode
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_mode is the C2D_ALPHA_BLEND_MODE
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetBlendMode(C2D_CONTEXT a_c2dContext, C2D_ALPHA_BLEND_MODE a_mode);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set global alpha
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_value is the 32bit value for global alpha, (8bit used -> 0-255)
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetGlobalAlpha(C2D_CONTEXT a_c2dContext, unsigned int a_value);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set source colorkey
+ *
+ * \param   a_c2dContext, C2D_CONTEXT
+ * \param   a_color is the 32bit RGB value for source colorkey, alpha channel ignored
+ * \param   a_bEnable, int, enable or disable the use of color key
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetSrcColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set destination colorkey
+ *
+ * \param   a_c2dContext, C2D_CONTEXT
+ * \param   a_color, unsigned int, RGB, alpha channel ignored
+ * \param   a_bEnable, int, enable or disable the use of color key
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDstColorkey(C2D_CONTEXT a_c2dContext, unsigned int a_color, int a_bEnable);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set surface as the current brush
+ *
+ * \param   a_c2dContext is C2D_CONTEXT
+ * \param   a_c2dSurface is C2D_SURFACE
+ * \param   a_tilingOffset, C2D_POINT*, offset added to upper left corner of the destination rectangle
+ *          for brush aligment. Passing NULL equals to zero offset.
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetBrushSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_tilingOffset);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set mask surface, if a_c2dSurface is NULL the mask usage is disabled
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_c2dSurface is the C2D_SURFACE
+ * \param   a_offset, C2D_POINT*, mask offset to use, NULL means no offset
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetMaskSurface(C2D_CONTEXT a_c2dContext, C2D_SURFACE a_c2dSurface, C2D_POINT *a_offset);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Blits the source surface to the destination surface with current state
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dDrawBlit(C2D_CONTEXT a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Draws a rectangle,
+ *          The dest regtangle is used to set draw coordinates
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dDrawRect(C2D_CONTEXT a_c2dContext, C2D_PARAMETERS a_drawConfig);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Draws a line
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS. 
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dDrawLine(C2D_CONTEXT a_c2dContext,
+                               C2D_POINT *a_start, C2D_POINT *a_end,
+                               unsigned int a_drawConfig);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Draws a circular or elliptical arc with coordinates from
+ *          the destination rectangle
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_drawConfig is the 32bit param containing the C2D_PARAMETERS.
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dDrawArc(C2D_CONTEXT a_c2dContext, int a_startAngle, int a_arcAngle, unsigned int a_drawConfig);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Flush all the context draws to HW
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dFlush(C2D_CONTEXT a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Flush all the context draws to HW and waits them to be executed
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dFinish(C2D_CONTEXT a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Waits for the end-of-pipeline timestamp of the last submitted command buffer
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dWaitForTimestamp(C2D_CONTEXT a_c2dContext);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Get display info, a_displayInfo will be filled with information
+ *
+ * \param   a_display, C2D_DISPLAY
+ * \param   a_displayInfo is the pointer to the C2D_SURFACE_DEF
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dGetDisplayInfo(C2D_DISPLAY a_display, C2D_SURFACE_DEF *a_displayInfo);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set display surface
+ *
+ * \param   a_display is the C2D_DISPLAY
+ * \param   a_c2dSurface is the C2D_SURFACE
+ * \param   a_displayConfig is the colorkey enable etc. if supported by diplay controller
+ * \param   a_configParam is the colorkey value if supported by display controller
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE a_c2dSurface, unsigned int a_displayConfig, unsigned int a_configParam);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Get current display surface
+ *
+ * \param   a_display is the C2D_DISPLAY
+ * \param   a_c2dSurface is the pointer to the C2D_SURFACE where surface id is stored
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dGetCurrentDisplaySurface(C2D_DISPLAY a_display, C2D_SURFACE *a_c2dSurface);
+
+/*-------------------------------------------------------------------*//*!
+ * \external
+ * \brief   Set dither
+ *
+ * \param   a_c2dContext is the C2D_CONTEXT
+ * \param   a_bEnable int, enable or disable the effect of dither
+ * \return  C2D_STATUS
+ *//*-------------------------------------------------------------------*/ 
+C2D_API C2D_STATUS c2dSetDither(C2D_CONTEXT a_c2dContext, int a_bEnable);
+
+C2D_API C2D_STATUS c2dWaitIrq(C2D_CONTEXT a_c2dContext, unsigned int *Count, unsigned int timeout);
+C2D_API C2D_STATUS c2dLibOpen(void);
+C2D_API C2D_STATUS c2dLibClose(void);
+
+C2D_API C2D_STATUS c2dTranslatePhysaddr(void* virtAddr, unsigned int* physAddr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __c2d_api_h_ */
diff --git a/mx5x/libcopybit/copybit.cpp b/mx5x/libcopybit/copybit.cpp
new file mode 100755
index 0000000..1f2a630
--- /dev/null
+++ b/mx5x/libcopybit/copybit.cpp
@@ -0,0 +1,510 @@
+ /*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#define LOG_TAG "copybit"
+
+#include <cutils/log.h>
+ 
+#include <c2d_api.h>
+
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+#include <hardware/copybit.h>
+
+#include "gralloc_priv.h"
+
+
+/******************************************************************************/
+#define MAX_SCALE_FACTOR    (8)
+#define MDP_ALPHA_NOP 0xff
+/******************************************************************************/
+
+/* mFlags bit define */
+enum {
+    /* flip source image horizontally */
+    C2D_FLIP_H    = HAL_TRANSFORM_FLIP_H,
+    /* flip source image vertically */
+    C2D_FLIP_V    = HAL_TRANSFORM_FLIP_V,
+    /* enable or disable dithering */
+    C2D_DITHER = 0x4,
+    /* enable or disable alpha blend */
+    C2D_ALPHA_BLEND = 0x8,
+};
+
+/** State information for each device instance */
+struct copybit_context_t {
+    struct copybit_device_t device;
+    C2D_CONTEXT c2dctx;
+    int     mCache;
+    uint32_t mAlpha;
+    uint32_t mRotate;    
+    uint32_t mFlags;
+};
+
+
+/**
+ * Common hardware methods
+ */
+
+static int open_copybit(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device);
+
+static struct hw_module_methods_t copybit_module_methods = {
+    open:  open_copybit
+};
+
+/*
+ * The COPYBIT Module
+ */
+struct copybit_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+        tag: HARDWARE_MODULE_TAG,
+        version_major: 1,
+        version_minor: 0,
+        id: COPYBIT_HARDWARE_MODULE_ID,
+        name: "C2D Z160 COPYBIT Module",
+        author: "Freescale, Inc.",
+        methods: &copybit_module_methods
+    }
+};
+
+/*****************************************************************************/
+/** check pixel alpha */
+static bool hasAlpha(int format) {
+    switch (format) {
+    case COPYBIT_FORMAT_RGBA_8888:
+    case COPYBIT_FORMAT_BGRA_8888:
+    case COPYBIT_FORMAT_RGBA_5551:
+    case COPYBIT_FORMAT_RGBA_4444:
+        return true;
+    default:
+        return false;
+    }
+}
+
+/** min of int a, b */
+static inline int min(int a, int b) {
+    return (a<b) ? a : b;
+}
+
+/** max of int a, b */
+static inline int max(int a, int b) {
+    return (a>b) ? a : b;
+}
+
+/** scale each parameter by mul/div. Assume div isn't 0 */
+static inline void MULDIV(int *a, int *b, int mul, int div) {
+    if (mul != div) {
+        *a = (mul * *a) / div;
+        *b = (mul * *b) / div;
+    }
+}
+
+/** Determine the intersection of lhs & rhs store in out */
+static void intersect(struct copybit_rect_t *out,
+                      const struct copybit_rect_t *lhs,
+                      const struct copybit_rect_t *rhs) {
+    out->l = max(lhs->l, rhs->l);
+    out->t = max(lhs->t, rhs->t);
+    out->r = min(lhs->r, rhs->r);
+    out->b = min(lhs->b, rhs->b);
+}
+
+/** Set a parameter to value */
+static int set_parameter_copybit(
+        struct copybit_device_t *dev,
+        int name,
+        int value) 
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = 0;
+    if (ctx) {
+        switch(name) {
+        case COPYBIT_ROTATION_DEG:
+            switch (value) {
+            case 0:
+            case 90:
+            case 180:
+            case 270:
+                ctx->mRotate = value;
+                break;
+            default:
+                LOGE("Invalid value for COPYBIT_ROTATION");
+                status = -EINVAL;
+                break;
+            }
+            break;
+        case COPYBIT_PLANE_ALPHA:
+            if (value < 0)      value = 0;
+            if (value >= 256)   value = 255;
+                ctx->mAlpha = value;
+            break;
+        case COPYBIT_DITHER:
+            if (value == COPYBIT_ENABLE) {
+                ctx->mFlags |= C2D_DITHER;
+            } else if (value == COPYBIT_DISABLE) {
+                ctx->mFlags &= ~C2D_DITHER;
+            }
+            break;
+        case COPYBIT_TRANSFORM:
+            switch (value) {
+            case 0:
+                ctx->mRotate = 0;
+                break;            
+            case COPYBIT_TRANSFORM_ROT_90:
+                ctx->mRotate = 90;
+                break;
+            case COPYBIT_TRANSFORM_ROT_180:
+                ctx->mRotate = 180;
+                break;
+            case COPYBIT_TRANSFORM_ROT_270:
+                ctx->mRotate = 270;
+                break;
+            case COPYBIT_TRANSFORM_FLIP_H:
+                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
+                ctx->mFlags |= C2D_FLIP_H;
+                break;
+            case COPYBIT_TRANSFORM_FLIP_V:
+                ctx->mFlags &= ~(C2D_FLIP_H | C2D_FLIP_V);
+                ctx->mFlags |= C2D_FLIP_V;
+                break;
+            default:
+                LOGE("Invalid value for COPYBIT_ROTATION");
+                status = -EINVAL;
+                break;
+            }
+            break;        
+        case COPYBIT_BLUR:
+            LOGE("Not support for COPYBIT_BLUR");
+            status = -EINVAL;
+            break;
+        default:
+            status = -EINVAL;
+            break;
+        }
+    } else {
+        status = -EINVAL;
+    }
+    return status;
+}
+
+/** Get a static info value */
+static int get(struct copybit_device_t *dev, int name) 
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int value;
+    if (ctx) {
+        switch(name) {
+        case COPYBIT_MINIFICATION_LIMIT:
+            value = MAX_SCALE_FACTOR;
+            break;
+        case COPYBIT_MAGNIFICATION_LIMIT:
+            value = MAX_SCALE_FACTOR;
+            break;
+        case COPYBIT_SCALING_FRAC_BITS:
+            value = 32;
+            break;
+        case COPYBIT_ROTATION_STEP_DEG:
+            value = 90;
+            break;
+        default:
+            value = -EINVAL;
+        }
+    } else {
+        value = -EINVAL;
+    }
+    return value;
+}
+
+/** convert COPYBIT_FORMAT to C2D format */
+static C2D_COLORFORMAT get_format(int format) {
+    switch (format) {
+	case COPYBIT_FORMAT_RGBA_8888:     return C2D_COLOR_8888_ABGR;    
+    case COPYBIT_FORMAT_RGB_565:       return C2D_COLOR_0565;
+    case COPYBIT_FORMAT_RGBA_5551:     return C2D_COLOR_5551_RGBA;
+    case COPYBIT_FORMAT_RGBA_4444:     return C2D_COLOR_4444_RGBA;
+    case COPYBIT_FORMAT_RGBX_8888:	   return C2D_COLOR_8888_ABGR; //work-around, C2D does not support RGBX
+    case COPYBIT_FORMAT_RGB_888:
+	   return C2D_COLOR_888; //work-around, C2D supports BGR not RGB in this case
+    case COPYBIT_FORMAT_BGRA_8888:	   return C2D_COLOR_8888;//work-around, C2D supports ARGB not BGRA in this case
+    case COPYBIT_FORMAT_YCbCr_422_SP:  
+    case COPYBIT_FORMAT_YCbCr_420_SP:
+ 
+    default:                           return C2D_COLOR_0565;//work-around, C2D does not support YCbCr   
+    }
+}
+
+/** get  pixelbit from COPYBIT_FORMAT format */
+static int get_pixelbit(int format) {
+    switch (format) {
+    case COPYBIT_FORMAT_RGBA_8888:
+    case COPYBIT_FORMAT_RGBX_8888:
+    case COPYBIT_FORMAT_BGRA_8888:     return 32;
+    case COPYBIT_FORMAT_RGB_888:       return 24;
+    case COPYBIT_FORMAT_RGB_565:
+    case COPYBIT_FORMAT_RGBA_5551:
+    case COPYBIT_FORMAT_RGBA_4444:     return 16;
+    case COPYBIT_FORMAT_YCbCr_422_SP:
+    case COPYBIT_FORMAT_YCbCr_420_SP:
+    default:                           return 8;
+    }
+}
+
+/** do convert of image to c2d surface **/
+static void image_to_surface(copybit_image_t const *img, C2D_SURFACE_DEF *surfaceDef) 
+{
+    private_handle_t* hnd = (private_handle_t*)img->handle;
+    surfaceDef->format = get_format(img->format);
+    surfaceDef->width =  img->w;
+    surfaceDef->height = img->h;
+
+	//make sure stride is 32 pixel aligned
+    surfaceDef->stride = ((img->w + 31) & ~31)*get_pixelbit(img->format)>>3;
+
+    surfaceDef->buffer = (void *)hnd->phys;
+    surfaceDef->host = (void *)hnd->base;
+    surfaceDef->flags = C2D_SURFACE_NO_BUFFER_ALLOC;
+}
+
+/** setup rectangles */
+static void set_rects(struct copybit_context_t *dev,
+                      C2D_RECT *srcRect,
+                      C2D_RECT *dstRect,
+                      const struct copybit_rect_t *dst,
+                      const struct copybit_rect_t *src,
+                      const struct copybit_rect_t *scissor,
+                      copybit_image_t const *img) {
+    struct copybit_rect_t clip;
+    intersect(&clip, scissor, dst);
+
+    dstRect->x  = clip.l;
+    dstRect->y  = clip.t;
+    dstRect->width  = clip.r - clip.l;
+    dstRect->height  = clip.b - clip.t;
+
+    uint32_t W, H;
+    if ((dev->mRotate == 90) || ((dev->mRotate == 270))) {
+        srcRect->x = (clip.t - dst->t) + src->t;
+        srcRect->y = (dst->r - clip.r) + src->l;
+        srcRect->width = (clip.b - clip.t);
+        srcRect->height = (clip.r - clip.l);
+        W = dst->b - dst->t;
+        H = dst->r - dst->l;
+    } else {
+        srcRect->x  = (clip.l - dst->l) + src->l;
+        srcRect->y  = (clip.t - dst->t) + src->t;
+        srcRect->width  = (clip.r - clip.l);
+        srcRect->height  = (clip.b - clip.t);
+        W = dst->r - dst->l;
+        H = dst->b - dst->t;
+    }
+    MULDIV(&srcRect->x, &srcRect->width, src->r - src->l, W);
+    MULDIV(&srcRect->y, &srcRect->height, src->b - src->t, H);
+
+    if ((dev->mRotate == 180) || ((dev->mRotate == 270))) {
+        srcRect->y = src->b - src->t - (srcRect->y + srcRect->height);
+        srcRect->x = src->r - src->l - (srcRect->x + srcRect->width);
+    }
+}
+
+/** do a stretch blit type operation */
+static int stretch_copybit(
+        struct copybit_device_t *dev,
+        struct copybit_image_t const *dst,
+        struct copybit_image_t const *src,
+        struct copybit_rect_t const *dst_rect,
+        struct copybit_rect_t const *src_rect,
+        struct copybit_region_t const *region) 
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    C2D_SURFACE_DEF srcSurfaceDef;
+    C2D_SURFACE_DEF dstSurfaceDef;
+    C2D_SURFACE srcSurface;
+    C2D_SURFACE dstSurface;    
+    C2D_RECT srcRect;
+    C2D_RECT dstRect;
+    int status = 0;
+
+    if (ctx) {
+        if (ctx->mAlpha < 255) {
+            switch (src->format) {
+                // we don't support plane alpha with below formats
+                case COPYBIT_FORMAT_RGBX_8888:
+                case COPYBIT_FORMAT_RGB_888:
+                case COPYBIT_FORMAT_BGRA_8888:
+                case COPYBIT_FORMAT_YCbCr_422_SP:
+                case COPYBIT_FORMAT_YCbCr_420_SP:
+                    return -EINVAL;
+            }
+        }
+
+        if (src_rect->l < 0 || src_rect->r > src->w ||
+            src_rect->t < 0 || src_rect->b > src->h) {
+            // this is always invalid
+            LOGE("src_rect invalid");
+            return -EINVAL;
+        }
+
+        const struct copybit_rect_t bounds = { 0, 0, dst->w, dst->h };
+        struct copybit_rect_t clip;
+        status = 0;
+
+
+        image_to_surface(src, &srcSurfaceDef);
+        if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
+        {
+            LOGE("srcSurface c2dSurfAlloc fail");
+            return -EINVAL;
+        }
+                
+        image_to_surface(dst, &dstSurfaceDef);
+        if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
+        {
+            LOGE("dstSurface c2dSurfAlloc fail");
+            c2dSurfFree(ctx->c2dctx, srcSurface);
+            return -EINVAL;
+        }
+
+
+        c2dSetSrcSurface(ctx->c2dctx, srcSurface);
+        c2dSetDstSurface(ctx->c2dctx, dstSurface); 
+        c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
+        
+
+        //if (hasAlpha(src->format) || hasAlpha(dst->format))
+        if (hasAlpha(src->format) && (ctx->mFlags & C2D_ALPHA_BLEND))
+                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_SRCOVER);
+        else
+                c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);
+                   
+        c2dSetGlobalAlpha(ctx->c2dctx, ctx->mAlpha);  
+        c2dSetDither(ctx->c2dctx, (ctx->mFlags & C2D_DITHER) > 0 ? 1:0); 
+
+        while ((status == 0) && region->next(region, &clip)) {          
+                intersect(&clip, &bounds, &clip);
+                set_rects(ctx, &srcRect, &dstRect, dst_rect, src_rect, &clip, src);
+                if (srcRect.width<=0 || srcRect.height<=0)
+                {
+                        LOGE("srcRect invalid");
+                        continue;
+                }
+                if (dstRect.width<=0 || dstRect.height<=0)
+                {
+                        LOGE("dstRect invalid");
+                        continue;
+                }
+
+                c2dSetSrcRectangle(ctx->c2dctx, &srcRect);
+                c2dSetDstRectangle(ctx->c2dctx, &dstRect);      
+                c2dDrawBlit(ctx->c2dctx); 
+        }
+
+		c2dFinish(ctx->c2dctx);
+		c2dSurfFree(ctx->c2dctx, srcSurface);
+		c2dSurfFree(ctx->c2dctx, dstSurface);
+
+    } 
+    else {
+        status = -EINVAL;
+    }
+
+
+    return status;
+}
+
+/** Perform a blit type operation */
+/* Pay attention, from now on blit_copybit will only work on C2D_ALPHA_BLEND_NONE mode,
+ if need C2D_ALPHA_BLEND_SRCOVER mode pls use stretch_copybit */
+static int blit_copybit(
+        struct copybit_device_t *dev,
+        struct copybit_image_t const *dst,
+        struct copybit_image_t const *src,
+        struct copybit_region_t const *region) 
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    struct copybit_rect_t dr = { 0, 0, dst->w, dst->h };
+    struct copybit_rect_t sr = { 0, 0, src->w, src->h };
+    if (ctx->mFlags & C2D_ALPHA_BLEND)
+    {
+        int status = 0;
+        ctx->mFlags &= ~C2D_ALPHA_BLEND;
+        status = stretch_copybit(dev, dst, src, &dr, &sr, region);
+        ctx->mFlags |= C2D_ALPHA_BLEND;
+        return status;
+    }
+    else
+        return stretch_copybit(dev, dst, src, &dr, &sr, region);
+}
+
+/*****************************************************************************/
+
+/** Close the copybit device */
+static int close_copybit(struct hw_device_t *dev) 
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    if (ctx) {
+        C2D_STATUS c2dstatus;
+        if (ctx->c2dctx != NULL)
+        	c2dstatus = c2dDestroyContext(ctx->c2dctx);
+        free(ctx);
+    }
+    return 0;
+}
+
+/** Open a new instance of a copybit device using name */
+static int open_copybit(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device)
+{
+    int status = -EINVAL;
+       
+    copybit_context_t *ctx;
+    ctx = (copybit_context_t *)malloc(sizeof(copybit_context_t));
+    memset(ctx, 0, sizeof(*ctx));
+
+    ctx->device.common.tag = HARDWARE_DEVICE_TAG;
+    ctx->device.common.version = 1;
+    ctx->device.common.module = const_cast<hw_module_t*>(module);
+    ctx->device.common.close = close_copybit;
+    ctx->device.set_parameter = set_parameter_copybit;
+    ctx->device.get = get;
+    ctx->device.blit = blit_copybit;
+    ctx->device.stretch = stretch_copybit;
+    ctx->mAlpha = MDP_ALPHA_NOP;
+    ctx->mFlags |= C2D_ALPHA_BLEND;
+     
+    C2D_STATUS c2dstatus;
+    c2dstatus = c2dCreateContext(&ctx->c2dctx);
+    if (c2dstatus != C2D_STATUS_OK)
+        close_copybit(&ctx->device.common);
+    else
+    {
+        *device = &ctx->device.common;
+        status = 0;
+    }
+
+    return status;
+}
diff --git a/mx5x/libgralloc/Android.mk b/mx5x/libgralloc/Android.mk
new file mode 100755
index 0000000..b5797f9
--- /dev/null
+++ b/mx5x/libgralloc/Android.mk
@@ -0,0 +1,51 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+# HAL module implemenation, not prelinked and stored in
+# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
+include $(CLEAR_VARS)
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_SHARED_LIBRARIES := liblog libcutils libGLESv1_CM libipu
+ifeq ($(BOARD_SOC_TYPE),IMX50)
+LOCAL_SHARED_LIBRARIES += libc2d_z160
+else
+LOCAL_SHARED_LIBRARIES += libc2d_z430
+endif
+LOCAL_C_INCLUDES += external/linux-lib/ipu
+LOCAL_C_INCLUDES += hardware/imx/mx5x/libcopybit
+
+LOCAL_SRC_FILES := 	\
+	allocator.cpp 	\
+	gralloc.cpp 	\
+	framebuffer.cpp \
+	mapper.cpp
+	
+LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
+LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).gralloc\" -D_LINUX
+
+
+ifeq ($(HAVE_FSL_EPDC_FB),true)
+LOCAL_CFLAGS += -DFSL_EPDC_FB
+endif
+
+ifeq ($(HAVE_FSL_IMX_IPU),true)
+LOCAL_CFLAGS += -DSECOND_DISPLAY_SUPPORT
+endif
+
+LOCAL_MODULE_TAGS := eng
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/mx5x/libgralloc/allocator.cpp b/mx5x/libgralloc/allocator.cpp
new file mode 100755
index 0000000..4dad6a1
--- /dev/null
+++ b/mx5x/libgralloc/allocator.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/log.h>
+
+#include "allocator.h"
+
+
+// align all the memory blocks on a cache-line boundary
+const int SimpleBestFitAllocator::kMemoryAlign = 32;
+
+SimpleBestFitAllocator::SimpleBestFitAllocator()
+    : mHeapSize(0)
+{
+}
+
+SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
+    : mHeapSize(0)
+{
+    setSize(size);
+}
+
+SimpleBestFitAllocator::~SimpleBestFitAllocator()
+{
+    while(!mList.isEmpty()) {
+        delete mList.remove(mList.head());
+    }
+}
+
+ssize_t SimpleBestFitAllocator::setSize(size_t size)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize != 0) return -EINVAL;
+    size_t pagesize = getpagesize();
+    mHeapSize = ((size + pagesize-1) & ~(pagesize-1));
+    chunk_t* node = new chunk_t(0, mHeapSize / kMemoryAlign);
+    mList.insertHead(node);
+    return size;
+}
+    
+    
+size_t SimpleBestFitAllocator::size() const
+{
+    return mHeapSize;
+}
+
+ssize_t SimpleBestFitAllocator::allocate(size_t size, uint32_t flags)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    ssize_t offset = alloc(size, flags);
+    return offset;
+}
+
+ssize_t SimpleBestFitAllocator::deallocate(size_t offset)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    chunk_t const * const freed = dealloc(offset);
+    if (freed) {
+        return 0;
+    }
+    return -ENOENT;
+}
+
+ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
+{
+    if (size == 0) {
+        return 0;
+    }
+    size = (size + kMemoryAlign-1) / kMemoryAlign;
+    chunk_t* free_chunk = 0;
+    chunk_t* cur = mList.head();
+
+    size_t pagesize = getpagesize();
+    while (cur) {
+        int extra = ( -cur->start & ((pagesize/kMemoryAlign)-1) ) ;
+
+        // best fit
+        if (cur->free && (cur->size >= (size+extra))) {
+            if ((!free_chunk) || (cur->size < free_chunk->size)) {
+                free_chunk = cur;
+            }
+            if (cur->size == size) {
+                break;
+            }
+        }
+        cur = cur->next;
+    }
+
+    if (free_chunk) {
+        const size_t free_size = free_chunk->size;
+        free_chunk->free = 0;
+        free_chunk->size = size;
+        if (free_size > size) {
+            int extra = ( -free_chunk->start & ((pagesize/kMemoryAlign)-1) ) ;
+            if (extra) {
+                chunk_t* split = new chunk_t(free_chunk->start, extra);
+                free_chunk->start += extra;
+                mList.insertBefore(free_chunk, split);
+            }
+
+            LOGE_IF(((free_chunk->start*kMemoryAlign)&(pagesize-1)),
+                    "page is not aligned!!!");
+
+            const ssize_t tail_free = free_size - (size+extra);
+            if (tail_free > 0) {
+                chunk_t* split = new chunk_t(
+                        free_chunk->start + free_chunk->size, tail_free);
+                mList.insertAfter(free_chunk, split);
+            }
+        }
+        return (free_chunk->start)*kMemoryAlign;
+    }
+    return -ENOMEM;
+}
+
+SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
+{
+    start = start / kMemoryAlign;
+    chunk_t* cur = mList.head();
+    while (cur) {
+        if (cur->start == start) {
+            LOG_FATAL_IF(cur->free,
+                "block at offset 0x%08lX of size 0x%08lX already freed",
+                cur->start*kMemoryAlign, cur->size*kMemoryAlign);
+
+            // merge freed blocks together
+            chunk_t* freed = cur;
+            cur->free = 1;
+            do {
+                chunk_t* const p = cur->prev;
+                chunk_t* const n = cur->next;
+                if (p && (p->free || !cur->size)) {
+                    freed = p;
+                    p->size += cur->size;
+                    mList.remove(cur);
+                    delete cur;
+                }
+                cur = n;
+            } while (cur && cur->free);
+
+            #ifndef NDEBUG
+                if (!freed->free) {
+                    dump_l("dealloc (!freed->free)");
+                }
+            #endif
+            LOG_FATAL_IF(!freed->free,
+                "freed block at offset 0x%08lX of size 0x%08lX is not free!",
+                freed->start * kMemoryAlign, freed->size * kMemoryAlign);
+
+            return freed;
+        }
+        cur = cur->next;
+    }
+    return 0;
+}
diff --git a/mx5x/libgralloc/allocator.h b/mx5x/libgralloc/allocator.h
new file mode 100755
index 0000000..b0d89e9
--- /dev/null
+++ b/mx5x/libgralloc/allocator.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef GRALLOC_ALLOCATOR_H_
+#define GRALLOC_ALLOCATOR_H_
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "gr.h"
+
+// ----------------------------------------------------------------------------
+
+/*
+ * A simple templatized doubly linked-list implementation
+ */
+
+template <typename NODE>
+class LinkedList
+{
+    NODE*  mFirst;
+    NODE*  mLast;
+
+public:
+                LinkedList() : mFirst(0), mLast(0) { }
+    bool        isEmpty() const { return mFirst == 0; }
+    NODE const* head() const { return mFirst; }
+    NODE*       head() { return mFirst; }
+    NODE const* tail() const { return mLast; }
+    NODE*       tail() { return mLast; }
+
+    void insertAfter(NODE* node, NODE* newNode) {
+        newNode->prev = node;
+        newNode->next = node->next;
+        if (node->next == 0) mLast = newNode;
+        else                 node->next->prev = newNode;
+        node->next = newNode;
+    }
+
+    void insertBefore(NODE* node, NODE* newNode) {
+         newNode->prev = node->prev;
+         newNode->next = node;
+         if (node->prev == 0)   mFirst = newNode;
+         else                   node->prev->next = newNode;
+         node->prev = newNode;
+    }
+
+    void insertHead(NODE* newNode) {
+        if (mFirst == 0) {
+            mFirst = mLast = newNode;
+            newNode->prev = newNode->next = 0;
+        } else {
+            newNode->prev = 0;
+            newNode->next = mFirst;
+            mFirst->prev = newNode;
+            mFirst = newNode;
+        }
+    }
+    
+    void insertTail(NODE* newNode) {
+        if (mLast == 0) {
+            insertHead(newNode);
+        } else {
+            newNode->prev = mLast;
+            newNode->next = 0;
+            mLast->next = newNode;
+            mLast = newNode;
+        }
+    }
+
+    NODE* remove(NODE* node) {
+        if (node->prev == 0)    mFirst = node->next;
+        else                    node->prev->next = node->next;
+        if (node->next == 0)    mLast = node->prev;
+        else                    node->next->prev = node->prev;
+        return node;
+    }
+};
+
+class SimpleBestFitAllocator
+{
+public:
+
+    SimpleBestFitAllocator();
+    SimpleBestFitAllocator(size_t size);
+    ~SimpleBestFitAllocator();
+
+    ssize_t     setSize(size_t size);
+
+    ssize_t     allocate(size_t size, uint32_t flags = 0);
+    ssize_t     deallocate(size_t offset);
+    size_t      size() const;
+
+private:
+    struct chunk_t {
+        chunk_t(size_t start, size_t size) 
+            : start(start), size(size), free(1), prev(0), next(0) {
+        }
+        size_t              start;
+        size_t              size : 28;
+        int                 free : 4;
+        mutable chunk_t*    prev;
+        mutable chunk_t*    next;
+    };
+
+    ssize_t  alloc(size_t size, uint32_t flags);
+    chunk_t* dealloc(size_t start);
+
+    static const int    kMemoryAlign;
+    mutable Locker      mLock;
+    LinkedList<chunk_t> mList;
+    size_t              mHeapSize;
+};
+
+#endif /* GRALLOC_ALLOCATOR_H_ */
diff --git a/mx5x/libgralloc/framebuffer.cpp b/mx5x/libgralloc/framebuffer.cpp
new file mode 100755
index 0000000..4e3441b
--- /dev/null
+++ b/mx5x/libgralloc/framebuffer.cpp
@@ -0,0 +1,1698 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright 2010-2011 Freescale Semiconductor Inc. */
+
+#include <sys/mman.h>
+
+#include <dlfcn.h>
+
+#include <cutils/ashmem.h>
+#include <cutils/log.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+
+#if HAVE_ANDROID_OS
+#include <linux/fb.h>
+#include <linux/mxcfb.h>
+#include <linux/videodev.h>
+#include <sys/mman.h>
+
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+} 
+
+#endif
+#include <GLES/gl.h>
+#include <c2d_api.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+#include "gralloc_priv.h"
+#include "gr.h"
+#define  MAX_RECT_NUM   20
+/*****************************************************************************/
+
+// numbers of buffers for page flipping
+#define NUM_BUFFERS 3
+
+enum {
+    PAGE_FLIP = 0x00000001,
+    LOCKED = 0x00000002
+};
+
+struct fb_context_t {
+    framebuffer_device_t  device;
+#ifdef FSL_EPDC_FB
+    //Partial udate feature
+    bool rect_update;
+    int count;      //count need less than MAX_RECT_NUM ;
+    int updatemode[20];
+    int partial_left[20];
+    int partial_top[20];
+    int partial_width[20];
+    int partial_height[20];
+#endif
+#ifdef SECOND_DISPLAY_SUPPORT
+    bool sec_display_inited;
+    int sec_fp;
+    int sec_disp_w;
+    int sec_disp_h;
+    int sec_disp_base;
+    int sec_disp_phys;
+    int sec_frame_size;
+    int sec_disp_next_buf;
+    struct fb_var_screeninfo sec_info;
+    struct fb_fix_screeninfo sec_finfo;
+    struct framebuffer_device_t* dev;
+    buffer_handle_t buffer;
+    sem_t sec_display_begin;
+    sem_t sec_display_end;
+    pthread_t thread_id;
+    C2D_CONTEXT c2dctx;
+    int sec_rotation;
+    int cleancount;
+    int mRotate;
+#endif
+};
+
+static int nr_framebuffers;
+static int no_ipu = 0;
+
+#ifdef SECOND_DISPLAY_SUPPORT
+#define MAX_SEC_DISP_WIDTH (1024)
+#define MAX_SEC_DISP_HEIGHT (1024)
+static int mapSecFrameBuffer(fb_context_t* ctx);
+static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx);
+static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx);
+void * secDispShowFrames(void * arg);
+#endif
+
+#ifdef FSL_EPDC_FB
+#define WAVEFORM_MODE_INIT                      0x0   // Screen goes to white (clears)
+#define WAVEFORM_MODE_DU                        0x1   // Grey->white/grey->black
+#define WAVEFORM_MODE_GC16                      0x2   // High fidelity (flashing)
+#define WAVEFORM_MODE_GC4                       0x3   //
+//#define WAVEFORM_MODE_AUTO                    257  // defined in mxcfb.h
+
+
+#define EINK_WAVEFORM_MODE_INIT      0x00000000
+#define EINK_WAVEFORM_MODE_DU        0x00000001
+#define EINK_WAVEFORM_MODE_GC16      0x00000002
+#define EINK_WAVEFORM_MODE_GC4       0x00000003
+#define EINK_WAVEFORM_MODE_AUTO      0x00000004
+#define EINK_WAVEFORM_MODE_MASK      0x0000000F
+#define EINK_AUTO_MODE_REGIONAL      0x00000000
+#define EINK_AUTO_MODE_AUTOMATIC     0x00000010
+#define EINK_AUTO_MODE_MASK          0x00000010
+#define EINK_UPDATE_MODE_PARTIAL     0x00000000
+#define EINK_UPDATE_MODE_FULL        0x00000020
+#define EINK_UPDATE_MODE_MASK        0x00000020
+#define EINK_WAIT_MODE_NOWAIT        0x00000000
+#define EINK_WAIT_MODE_WAIT          0x00000040
+#define EINK_WAIT_MODE_MASK          0x00000040
+#define EINK_COMBINE_MODE_NOCOMBINE  0x00000000
+#define EINK_COMBINE_MODE_COMBINE    0x00000080
+#define EINK_COMBINE_MODE_MASK       0x00000080
+#define EINK_DITHER_MODE_NODITHER    0x00000000
+#define EINK_DITHER_MODE_DITHER      0x00000100
+#define EINK_DITHER_MODE_MASK        0x00000100
+#define EINK_INVERT_MODE_NOINVERT    0x00000000
+#define EINK_INVERT_MODE_INVERT      0x00000200
+#define EINK_INVERT_MODE_MASK        0x00000200
+#define EINK_CONVERT_MODE_NOCONVERT  0x00000000
+#define EINK_CONVERT_MODE_CONVERT    0x00000400
+#define EINK_CONVERT_MODE_MASK       0x00000400
+
+#define EINK_DEFAULT_MODE            0x00000004
+
+__u32 marker_val = 1;
+static void update_to_display(int left, int top, int width, int height, int updatemode, int fb_dev)
+{
+	struct mxcfb_update_data upd_data;
+	int retval;
+	bool wait_for_complete;
+	int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+	memset(&upd_data, 0, sizeof(mxcfb_update_data));
+
+    LOGI("update_to_display:left=%d, top=%d, width=%d, height=%d updatemode=%d\n", left, top, width, height,updatemode);
+
+
+    if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_DU)
+	   upd_data.waveform_mode = WAVEFORM_MODE_DU;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC4)
+	   upd_data.waveform_mode = WAVEFORM_MODE_GC4;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC16)
+	   upd_data.waveform_mode = WAVEFORM_MODE_GC16;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_AUTO)
+	   upd_data.waveform_mode = WAVEFORM_MODE_AUTO;
+	else 
+        LOGI("waveform_mode  wrong\n");
+	   
+    if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_REGIONAL)
+        auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+    else if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_AUTOMATIC)
+        auto_update_mode = AUTO_UPDATE_MODE_AUTOMATIC_MODE;
+    else 
+        LOGI("wait_for_complete  wrong\n");
+        
+    if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_PARTIAL)
+        upd_data.update_mode = UPDATE_MODE_PARTIAL;
+    else if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_FULL)
+        upd_data.update_mode = UPDATE_MODE_FULL;
+    else
+        LOGI("update_mode  wrong\n");
+
+    if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_NOWAIT)
+        wait_for_complete = false;
+    else if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_WAIT)
+        wait_for_complete = true;
+    else 
+        LOGI("wait_for_complete  wrong\n");
+
+    if((updatemode & EINK_INVERT_MODE_MASK) == EINK_INVERT_MODE_INVERT)
+	{
+	   upd_data.flags |= EPDC_FLAG_ENABLE_INVERSION;
+       LOGI("invert mode \n");
+    }
+
+	retval = ioctl(fb_dev, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
+	if (retval < 0) {
+		LOGI("set auto update mode failed.  Error = 0x%x", retval);
+	}    
+    
+    upd_data.temp = 24; //the temperature is get from linux team
+	upd_data.update_region.left = left;
+	upd_data.update_region.width = width;
+	upd_data.update_region.top = top;
+	upd_data.update_region.height = height;
+
+	if (wait_for_complete) {
+		/* Get unique marker value */
+		upd_data.update_marker = marker_val++;
+	} else {
+		upd_data.update_marker = 0;
+	}
+
+	retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
+	while (retval < 0) {
+		/* We have limited memory available for updates, so wait and
+		 * then try again after some updates have completed */
+		usleep(300000);
+		retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
+        LOGI("MXCFB_SEND_UPDATE  retval = 0x%x try again maybe", retval);
+	}
+
+	if (wait_for_complete) {
+		/* Wait for update to complete */
+		retval = ioctl(fb_dev, MXCFB_WAIT_FOR_UPDATE_COMPLETE, &upd_data.update_marker);
+		if (retval < 0) {
+			LOGI("Wait for update complete failed.  Error = 0x%x", retval);
+		}
+	}
+
+
+}
+#endif
+
+
+sem_t * fslwatermark_sem_open()
+{
+    int fd;
+    int ret;
+    sem_t *pSem = NULL;
+    char *shm_path, shm_file[256];
+
+    shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */ 
+
+    if (shm_path == NULL)
+        strcpy(shm_file, "/dev/shm");   /* default path */
+    else
+        strcpy(shm_file, shm_path);
+
+    strcat(shm_file, "/"); 
+    strcat(shm_file, "codec.shm");
+
+    fd = open(shm_file, O_RDWR, 0666);
+    if (fd < 0) { 
+        /* first thread/process need codec protection come here */
+        fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0666);
+       if(fd < 0)
+       {
+           return NULL;
+       }
+       ftruncate(fd, sizeof(sem_t));
+
+       /* map the semaphore variant in the file */ 
+       pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+       if((void *)(-1) == pSem)
+       {
+           return NULL;
+       }
+       /* do the semaphore initialization */
+       ret = sem_init(pSem, 0, 1);
+       if(-1 == ret)
+       {
+           return NULL;
+       }
+    }
+    else
+      pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+    close(fd);
+
+    return pSem;
+}
+
+
+/*****************************************************************************/
+
+static int fb_setSwapInterval(struct framebuffer_device_t* dev,
+            int interval)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
+        return -EINVAL;
+    // FIXME: implement fb_setSwapInterval
+    return 0;
+}
+
+#ifdef FSL_EPDC_FB
+static int fb_setUpdateRect(struct framebuffer_device_t* dev,
+        int* left, int* top, int* width, int* height, int* updatemode, int count)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if(count > MAX_RECT_NUM)
+    {
+        LOGE("count > MAX_RECT_NUM in fb_setUpdateRect\n");
+        return -EINVAL;
+    }
+
+    ctx->rect_update      = true;
+    ctx->count            = 0;
+    for(int i=0; i < count; i++)
+    {
+        if (((width[i]|height[i]) <= 0) || ((left[i]|top[i])<0))  return -EINVAL;
+        ctx->updatemode[i]       = updatemode[i];
+        ctx->partial_left[i]     = left[i];
+        ctx->partial_top[i]      = top[i];
+        ctx->partial_width[i]    = width[i];
+        ctx->partial_height[i]   = height[i];
+    }
+    ctx->count            = count;
+    return 0;
+}
+#else
+static int fb_setUpdateRect(struct framebuffer_device_t* dev,
+        int l, int t, int w, int h)
+{
+    if (((w|h) <= 0) || ((l|t)<0))
+        return -EINVAL;
+    return 0;
+}
+
+#ifdef SECOND_DISPLAY_SUPPORT
+static int fb_setSecRotation(struct framebuffer_device_t* dev,int secRotation)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    //LOGI("fb_setSecRotation %d",secRotation);
+    if((ctx->sec_rotation != secRotation)&&(ctx->sec_disp_base != 0))      
+       memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+    ctx->sec_rotation = secRotation;
+    switch(secRotation)
+    {
+    case 4:
+       ctx->mRotate = 90;
+       break;
+    case 3:
+       ctx->mRotate = 180;
+       break;
+    case 7:
+       ctx->mRotate = 270;
+       break;
+    case 0:
+    default:
+       ctx->mRotate = 0;
+       break;
+    }
+    return 0;
+}
+#endif
+#endif
+
+
+
+static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+    if (private_handle_t::validate(buffer) < 0)
+        return -EINVAL;
+
+    fb_context_t* ctx = (fb_context_t*)dev;
+
+    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+    if (m->currentBuffer) {
+        m->base.unlock(&m->base, m->currentBuffer);
+        m->currentBuffer = 0;
+    }
+
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+
+        m->base.lock(&m->base, buffer, 
+                private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), NULL);
+
+        const size_t offset = hnd->base - m->framebuffer->base;
+        m->info.activate = FB_ACTIVATE_VBL;
+        m->info.yoffset = offset / m->finfo.line_length;
+
+        #ifdef SECOND_DISPLAY_SUPPORT
+        //Check the prop rw.SECOND_DISPLAY_CONNECTED
+        char value[PROPERTY_VALUE_MAX];
+     
+        property_get("rw.SECOND_DISPLAY_CONNECTED", value, "");
+        if (strcmp(value, "1") == 0) {
+            if(!ctx->sec_display_inited) {
+                //Init the second display
+                if(mapSecFrameBuffer(ctx)== 0)
+                {    
+                    ctx->sec_display_inited = true;
+                    c2dCreateContext(&ctx->c2dctx); 
+
+                    sem_init(&ctx->sec_display_begin, 0, 0);
+                    sem_init(&ctx->sec_display_end, 0, 0);
+                     
+                    pthread_create(&ctx->thread_id, NULL, &secDispShowFrames, (void *)ctx);
+                                        
+                    //Set the prop rw.SECOND_DISPLAY_ENABLED to 1
+                    LOGI("sys.SECOND_DISPLAY_ENABLED Set to 1");
+                    property_set("sys.SECOND_DISPLAY_ENABLED", "1");
+                }
+            }
+
+            if(ctx->sec_display_inited) {
+                //Resize the primary display to the second display
+                ctx->dev = dev;
+                ctx->buffer = buffer;
+                sem_post(&ctx->sec_display_begin);
+            }
+        }
+        else{
+            if(ctx->sec_display_inited) {
+                
+                ctx->sec_display_inited = false;
+                
+                sem_post(&ctx->sec_display_begin);
+                sem_wait(&ctx->sec_display_end);
+                
+                sem_destroy(&ctx->sec_display_begin);
+                sem_destroy(&ctx->sec_display_end);
+                
+                if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
+                
+                //Set the prop rw.SECOND_DISPLAY_ENABLED to 0
+                LOGI("Switch back to display 0");
+                LOGI("sys.SECOND_DISPLAY_ENABLED Set to 0");
+                property_set("sys.SECOND_DISPLAY_ENABLED", "0");
+                memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+                //unmap the sec_disp_base
+                munmap((void *)ctx->sec_disp_base, ctx->sec_frame_size*nr_framebuffers);
+                ctx->sec_disp_base = 0;
+                //DeInit the second display
+                if(ctx->sec_fp) {
+                    int fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0); 
+                    if(fp_property >= 0) {
+                        char overlayStr[32];
+                        int blank;
+                        int fb2_fp;
+			struct fb_var_screeninfo fb0_var;
+
+                        blank = 1;
+
+                        fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
+                        if (fb2_fp < 0){
+                            LOGE("Error!Cannot open the /dev/graphics/fb2");
+                        }
+                        else{
+                            if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
+                        		LOGI("Error!BLANK FB2 failed!\n");
+                        	}
+                            close(fb2_fp);
+                        }
+
+                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB1 failed!\n");
+                    	}
+                    
+                        if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB0 failed!\n");
+                    	}
+
+                        memset(overlayStr, 0 ,32);
+                        strcpy(overlayStr, "1-layer-fb\n");
+                        LOGI("WRITE 1-layer-fb to fb1/fsl_disp_property");
+                        write(fp_property, overlayStr, strlen(overlayStr)+1);
+                        close(fp_property);
+
+                        blank = FB_BLANK_POWERDOWN;
+                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB1 failed!\n");
+                    	}
+                        blank = FB_BLANK_UNBLANK;
+                    	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!UNBLANK FB0 failed!\n");
+                    	}
+
+			if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO,
+				  &fb0_var) < 0) {
+                            LOGE("Error!Cannot get var info for fb0");
+			}
+
+			if (fb0_var.bits_per_pixel == 32) {
+				struct mxcfb_loc_alpha l_alpha;
+
+				l_alpha.enable = true;
+				l_alpha.alpha_in_pixel = true;
+				if (ioctl(m->framebuffer->fd, MXCFB_SET_LOC_ALPHA,
+				            &l_alpha) < 0) {
+				    LOGE("Error!MXCFB_SET_LOC_ALPHA failed!");
+				}
+			} else {
+				struct mxcfb_gbl_alpha gbl_alpha;
+	                        struct mxcfb_color_key key;
+
+				gbl_alpha.alpha = 255;
+				gbl_alpha.enable = 1;
+				if (ioctl(m->framebuffer->fd, MXCFB_SET_GBL_ALPHA,
+					  &gbl_alpha) < 0) {
+				    LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
+				}
+
+	                        key.enable = 1;
+	                        key.color_key = 0x00000000; // Black
+	                        LOGI("MXCFB_SET_CLR_KEY");
+	                        if( ioctl(m->framebuffer->fd, MXCFB_SET_CLR_KEY,
+					  &key) < 0)
+	                        {
+	                            LOGE("Error!MXCFB_SET_CLR_KEY for fb0");
+	                        }
+			}
+                    }
+                    close(ctx->sec_fp);
+                    ctx->sec_fp = 0;
+                }
+            }
+        }
+
+        #endif
+
+        if (ioctl(m->framebuffer->fd, FBIOPAN_DISPLAY, &m->info) == -1) {
+            LOGE("FBIOPAN_DISPLAY failed");
+            m->base.unlock(&m->base, buffer); 
+            return -errno;
+        }
+
+    #ifdef SECOND_DISPLAY_SUPPORT
+        if(ctx->sec_display_inited) sem_wait(&ctx->sec_display_end);
+    #endif
+
+#ifdef FSL_EPDC_FB
+        if(ctx->rect_update) {
+            for(int i=0; i < ctx->count; i++)
+            {
+                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
+                              ctx->partial_width[i],ctx->partial_height[i],
+                              ctx->updatemode[i],m->framebuffer->fd);
+            }
+
+            ctx->rect_update = false;
+        }
+        else{
+            update_to_display(0,0,m->info.xres,m->info.yres,EINK_DEFAULT_MODE,m->framebuffer->fd);
+        }
+#endif
+
+        m->currentBuffer = buffer;
+        
+    } else {
+        // If we can't do the page_flip, just copy the buffer to the front 
+        // FIXME: use copybit HAL instead of memcpy
+        
+        void* fb_vaddr;
+        void* buffer_vaddr;
+        
+        m->base.lock(&m->base, m->framebuffer, 
+                GRALLOC_USAGE_SW_WRITE_RARELY, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
+                &fb_vaddr);
+
+        m->base.lock(&m->base, buffer, 
+                GRALLOC_USAGE_SW_READ_RARELY, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
+                &buffer_vaddr);
+
+        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres));
+
+#ifdef FSL_EPDC_FB
+        if(ctx->rect_update) {
+            for(int i=0; i < ctx->count; i++)
+            {
+                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
+                              ctx->partial_width[i],ctx->partial_height[i],
+                              ctx->updatemode[i],m->framebuffer->fd);
+            }
+
+            ctx->rect_update = false;
+        }
+        else{
+            update_to_display(0,0,m->info.xres,m->info.yres, EINK_DEFAULT_MODE ,m->framebuffer->fd);
+        }
+#endif
+
+        m->base.unlock(&m->base, buffer); 
+        m->base.unlock(&m->base, m->framebuffer); 
+    }
+    
+    return 0;
+}
+
+static int fb_compositionComplete(struct framebuffer_device_t* dev)
+{
+    glFinish();
+    return 0;
+}
+
+/*****************************************************************************/
+#define SINGLE_DISPLAY_CAPABILITY  (1920 * 1080 * 60)
+#define DUAL_DISPLAY_CAPABILITY    (1920 * 1080 * 30)
+
+typedef struct
+{
+	char* start;
+	char* end;
+	int width;
+	int height;
+	int freq;
+}
+disp_mode;
+
+static int str2int(char *p)
+{
+	int val = 0;
+	if(!p) return -1;
+
+	while(p[0] >= '0' && p[0] <= '9')
+	{
+		val = val * 10 + p[0] - '0';
+		p++;
+	}
+
+	return val;
+}
+
+typedef enum {
+    CHECK_NEXT_STATE,
+    FIND_WIDTH_STATE,
+    FIND_JOINT_STATE,
+    FIND_HEIGHT_STATE,
+    PREFIX_FREQ_STATE,
+    FREQUENCY_STATE,
+    FIND_NEWLINE_STATE
+}
+read_state;
+
+static disp_mode disp_mode_list[128];
+static int disp_mode_compare( const void *arg1, const void *arg2)
+{
+	disp_mode *dm1 = (disp_mode *)arg1;
+	disp_mode *dm2 = (disp_mode *)arg2;
+
+	if(dm1->width * dm1->height > dm2->width * dm2->height) return -1;
+	if(dm1->width * dm1->height == dm2->width * dm2->height)
+	{
+		return dm1->freq > dm2->freq ? -1 : 1;
+	}
+
+	return 1;
+}
+static char* find_available_mode(const char *mode_list, int dual_disp)
+{
+	int disp_threshold = 0;
+	int i,disp_mode_count = 0;
+	read_state state = CHECK_NEXT_STATE;
+	char *p = (char *)mode_list;
+
+    if(!p) return NULL;
+
+	while(p[0])
+	{
+		switch(state)
+		{
+		case CHECK_NEXT_STATE:
+			if(!strncmp(p, "D:", 2)
+				|| !strncmp(p, "S:", 2)
+				|| !strncmp(p, "U:", 2)
+				|| !strncmp(p, "V:", 2))
+			{
+				disp_mode_list[disp_mode_count].start = p;
+				state = FIND_WIDTH_STATE;
+				p+=2;
+			}
+			else p++;
+			break;
+		case FIND_WIDTH_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].width = str2int(p);
+				state = FIND_JOINT_STATE;
+			}
+			p++;
+			break;
+		case FIND_JOINT_STATE:
+			if(p[0] == 'x' || p[0] == 'X')
+			{
+				state = FIND_HEIGHT_STATE;
+			}
+			p++;
+			break;
+		case FIND_HEIGHT_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].height = str2int(p);
+				state = PREFIX_FREQ_STATE;
+			}
+			p++;
+			break;
+		case PREFIX_FREQ_STATE:
+			if(!strncmp(p, "p-", 2) || !strncmp(p, "i-", 2))
+			{
+				state = FREQUENCY_STATE;
+				p+=2;
+			}
+			else p++;
+			break;
+		case  FREQUENCY_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].freq = str2int(p);
+				state = FIND_NEWLINE_STATE;
+			}
+			p++;
+			break;
+		case FIND_NEWLINE_STATE:
+			if(p[0] == '\n')
+			{
+				disp_mode_list[disp_mode_count++].end = p+1;
+				state = CHECK_NEXT_STATE;
+                if(disp_mode_count >= sizeof(disp_mode_list)/sizeof(disp_mode_list[0])) goto check_mode_end;
+			}
+			p++;
+			break;
+		default:
+			p++;
+			break;
+		}
+	}
+
+check_mode_end:
+
+	qsort(&disp_mode_list[0], disp_mode_count, sizeof(disp_mode), disp_mode_compare);
+
+	disp_threshold = dual_disp ? DUAL_DISPLAY_CAPABILITY : SINGLE_DISPLAY_CAPABILITY;
+
+	for(i=0; i<disp_mode_count; i++)
+	{
+		if(disp_mode_list[i].width * disp_mode_list[i].height * disp_mode_list[i].freq <= disp_threshold)
+			break;
+	}
+
+	if(disp_mode_list[i].end) disp_mode_list[i].end[0] = 0;
+
+    return disp_mode_list[i].start;
+}
+
+static int set_graphics_fb_mode(int fb, int dual_disp)
+{
+    int size=0;
+    int fp_cmd=0;
+    int fp_mode=0;
+    int fp_modes=0;
+    char fb_mode[256];
+    char fb_modes[1024];
+    char cmd_line[1024];
+    char temp_name[256];
+    char *disp_mode=NULL;
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.AUTO_CONFIG_DISPLAY", value, "0");
+    if (strcmp(value, "1") != 0)  return 0;
+
+    fp_cmd = open("/proc/cmdline",O_RDONLY, 0);
+    if(fp_cmd < 0) {
+        LOGI("Error! Cannot open /proc/cmdline");
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(cmd_line, 0, sizeof(cmd_line));
+    size = read(fp_cmd, cmd_line, sizeof(cmd_line));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read /proc/cmdline");
+        goto set_graphics_fb_mode_error;
+    }
+
+    close(fp_cmd); fp_cmd = 0;
+
+    if(fb==0 && strstr(cmd_line, "di1_primary")) return 0;//XGA detected
+
+    sprintf(temp_name, "/sys/class/graphics/fb%d/modes", fb);
+    fp_modes = open(temp_name,O_RDONLY, 0);
+    if(fp_modes < 0) {
+        LOGI("Error! Cannot open %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(fb_modes, 0, sizeof(fb_modes));
+    size = read(fp_modes, fb_modes, sizeof(fb_modes));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    close(fp_modes); fp_modes = 0;
+
+    if(size == sizeof(fb_modes)) fb_modes[size -1] = 0;
+
+    disp_mode = find_available_mode(fb_modes, dual_disp);
+    if(!disp_mode)
+    {
+        LOGI("Error! Cannot find available mode for fb%d", fb);
+        goto set_graphics_fb_mode_error;
+    }
+
+    LOGI("find fb%d available mode %s", fb,disp_mode);
+
+    sprintf(temp_name, "/sys/class/graphics/fb%d/mode", fb);
+    fp_mode = open(temp_name,O_RDWR, 0);
+    if(fp_mode < 0) {
+        LOGI("Error! Cannot open %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(fb_mode, 0, sizeof(fb_mode));
+    size = read(fp_mode, fb_mode, sizeof(fb_mode));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    if(strncmp(fb_mode, disp_mode, strlen(fb_mode)))
+    {
+        write(fp_mode, disp_mode, strlen(disp_mode)+1);
+    }
+
+    close(fp_mode); fp_mode = 0;
+
+    return 0;
+
+set_graphics_fb_mode_error:
+
+    if(fp_modes > 0) close(fp_modes);
+    if(fp_mode > 0) close(fp_mode);
+    if(fp_cmd > 0) close(fp_cmd);
+
+    return -1;
+
+}
+
+int mapFrameBufferLocked(struct private_module_t* module)
+{
+    // already initialized...
+    if (module->framebuffer) {
+        return 0;
+    }
+        
+    char const * const device_template[] = {
+            "/dev/graphics/fb%u",
+            "/dev/fb%u",
+            0 };
+
+    int fd = -1;
+    int i=0;
+    char name[64];
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.UI_TVOUT_DISPLAY", value, "");
+    if (strcmp(value, "1") != 0) {
+        set_graphics_fb_mode(0, 0);
+        while ((fd==-1) && device_template[i]) {
+            snprintf(name, 64, device_template[i], 0);
+            fd = open(name, O_RDWR, 0);
+            i++;
+        }
+    }
+    else{
+        set_graphics_fb_mode(1, 0);
+        while ((fd==-1) && device_template[i]) {
+            snprintf(name, 64, device_template[i], 1);
+            fd = open(name, O_RDWR, 0);
+            i++;
+        }
+    }
+
+    if (fd < 0)
+        return -errno;
+
+    struct fb_fix_screeninfo finfo;
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    struct fb_var_screeninfo info;
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+
+    if(info.bits_per_pixel == 32){
+        LOGW("32bpp setting of Framebuffer catched!");
+        /*
+         * Explicitly request BGRA 8/8/8
+         */
+        info.bits_per_pixel = 32;
+        info.red.offset     = 8;
+        info.red.length     = 8;
+        info.green.offset   = 16;
+        info.green.length   = 8;
+        info.blue.offset    = 24;
+        info.blue.length    = 8;
+        info.transp.offset  = 0;
+        info.transp.length  = 0;
+#ifndef FSL_EPDC_FB
+        /*
+         *  set the alpha in pixel
+         *  only when the fb set to 32bit
+         */
+        struct mxcfb_loc_alpha l_alpha;
+        l_alpha.enable = true;
+        l_alpha.alpha_in_pixel = true;
+        if (ioctl(fd, MXCFB_SET_LOC_ALPHA,
+                    &l_alpha) < 0) {
+            printf("Set local alpha failed\n");
+            close(fd);
+            return -errno;
+        }
+#endif
+    }
+    else{
+        /*
+         * Explicitly request 5/6/5
+         */
+        info.bits_per_pixel = 16;
+        info.red.offset     = 11;
+        info.red.length     = 5;
+        info.green.offset   = 5;
+        info.green.length   = 6;
+        info.blue.offset    = 0;
+        info.blue.length    = 5;
+        info.transp.offset  = 0;
+        info.transp.length  = 0;
+
+        if (!no_ipu) {
+            /* for the 16bit case, only involke the glb alpha */
+            struct mxcfb_gbl_alpha gbl_alpha;
+
+            gbl_alpha.alpha = 255;
+            gbl_alpha.enable = 1;
+            int ret = ioctl(fd, MXCFB_SET_GBL_ALPHA, &gbl_alpha);
+            if(ret <0) {
+	        LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
+	        return -1;
+            }
+
+            struct mxcfb_color_key key;
+            key.enable = 1;
+            key.color_key = 0x00000000; // Black
+            ret = ioctl(fd, MXCFB_SET_CLR_KEY, &key);
+            if(ret <0) {
+	        LOGE("Error!Colorkey setting failed for dev ");
+	        return -1;
+            }
+        }
+    }
+
+    /*
+     * Request nr_framebuffers screens (at lest 2 for page flipping)
+     */
+    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
+    info.xres_virtual = ALIGN_PIXEL(info.xres);
+    
+#ifdef FSL_EPDC_FB
+    info.bits_per_pixel = 16;
+    info.grayscale = 0;
+    info.yoffset = 0;
+#endif
+
+    uint32_t flags = PAGE_FLIP;
+    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
+        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
+        flags &= ~PAGE_FLIP;
+        LOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
+    }
+
+    if (info.yres_virtual < ALIGN_PIXEL_128(info.yres) * 2) {
+        // we need at least 2 for page-flipping
+        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
+        flags &= ~PAGE_FLIP;
+        LOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
+                info.yres_virtual, ALIGN_PIXEL_128(info.yres)*2);
+    }
+
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+#ifdef FSL_EPDC_FB
+    int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+    int retval = ioctl(fd, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
+    if (retval < 0) {
+	LOGE("Error! set auto update mode error!\n");
+	return -errno;
+    }
+
+    int scheme_mode = UPDATE_SCHEME_QUEUE_AND_MERGE;
+    retval = ioctl(fd, MXCFB_SET_UPDATE_SCHEME, &scheme_mode);
+    if (retval < 0) {
+	LOGE("Error! set update scheme error!\n");
+	return -errno;
+    }
+#endif
+    int refreshRate = 1000000000000000LLU /
+    (
+            uint64_t( info.upper_margin + info.lower_margin + info.yres )
+            * ( info.left_margin  + info.right_margin + info.xres )
+            * info.pixclock
+    );
+
+    if (refreshRate == 0) {
+        // bleagh, bad info from the driver
+        refreshRate = 60*1000;  // 60 Hz
+    }
+
+    if (int(info.width) <= 0 || int(info.height) <= 0) {
+        // the driver doesn't return that information
+        // default to 160 dpi
+        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
+        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
+    }
+
+    float xdpi = (info.xres * 25.4f) / info.width;
+    float ydpi = (info.yres * 25.4f) / info.height;
+    float fps  = refreshRate / 1000.0f;
+
+    LOGI(   "using (fd=%d)\n"
+            "id           = %s\n"
+            "xres         = %d px\n"
+            "yres         = %d px\n"
+            "xres_virtual = %d px\n"
+            "yres_virtual = %d px\n"
+            "bpp          = %d\n"
+            "r            = %2u:%u\n"
+            "g            = %2u:%u\n"
+            "b            = %2u:%u\n",
+            fd,
+            finfo.id,
+            info.xres,
+            info.yres,
+            info.xres_virtual,
+            info.yres_virtual,
+            info.bits_per_pixel,
+            info.red.offset, info.red.length,
+            info.green.offset, info.green.length,
+            info.blue.offset, info.blue.length
+    );
+
+    LOGI(   "width        = %d mm (%f dpi)\n"
+            "height       = %d mm (%f dpi)\n"
+            "refresh rate = %.2f Hz\n",
+            info.width,  xdpi,
+            info.height, ydpi,
+            fps
+    );
+
+
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    if (finfo.smem_len <= 0)
+        return -errno;
+
+
+    module->flags = flags;
+    module->info = info;
+    module->finfo = finfo;
+    module->xdpi = xdpi;
+    module->ydpi = ydpi;
+    module->fps = fps;
+
+    /*
+     * map the framebuffer
+     */
+
+    int err;
+    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+    module->framebuffer = new private_handle_t(dup(fd), fbSize,
+            private_handle_t::PRIV_FLAGS_USES_PMEM);
+
+    module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
+    module->bufferMask = 0;
+
+    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (vaddr == MAP_FAILED) {
+        LOGE("Error mapping the framebuffer (%s)", strerror(errno));
+        return -errno;
+    }
+    module->framebuffer->base = intptr_t(vaddr);
+    module->framebuffer->phys = intptr_t(finfo.smem_start);
+    memset(vaddr, 0, fbSize);
+    return 0;
+}
+
+static int mapFrameBuffer(struct private_module_t* module)
+{
+    pthread_mutex_lock(&module->lock);
+    int err = mapFrameBufferLocked(module);
+    pthread_mutex_unlock(&module->lock);
+    return err;
+}
+
+#ifdef SECOND_DISPLAY_SUPPORT
+static int mapSecFrameBuffer(fb_context_t* ctx)
+{
+    int retCode = 0;
+    int sec_fp = 0,fp_property = 0;
+    size_t fbSize = 0;
+    int blank;
+    void* vaddr = NULL;
+    struct mxcfb_gbl_alpha gbl_alpha;
+    struct mxcfb_color_key key; 
+    char overlayStr[32];
+    int fb2_fp;
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            ctx->device.common.module);
+
+    set_graphics_fb_mode(1,1);
+
+    sec_fp = open("/dev/graphics/fb1",O_RDWR, 0);
+    if (sec_fp < 0){
+        LOGE("Error!Cannot open the /dev/graphics/fb1 for second display");
+        goto disp_init_error;
+    }
+
+    //Switch overlay to second display after ipu deinit
+    //echo 1-layer-fb >  /sys/class/graphics/fb0/fsl_disp_property 
+    blank = 1;
+
+    fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
+    if (fb2_fp < 0){
+        LOGE("Error!Cannot open the /dev/graphics/fb2");
+        goto disp_init_error;
+    }
+    if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+    close(fb2_fp);
+
+	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB1 failed!\n");
+        goto disp_init_error;
+	}
+
+    if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+    
+    LOGI("Open fb0/fsl_disp_property");
+    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0); 
+    if(fp_property < 0) {
+         LOGI("Error!Cannot switch the overlay to second disp");
+         goto disp_init_error;
+    }
+    
+    memset(overlayStr, 0 ,32);
+    strcpy(overlayStr, "1-layer-fb\n");
+    LOGI("WRITE 1-layer-fb to fb0/fsl_disp_property");
+    write(fp_property, overlayStr, strlen(overlayStr)+1);
+    close(fp_property);
+
+    blank = FB_BLANK_UNBLANK;
+	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!UNBLANK FB1 failed!\n");
+        goto disp_init_error;
+	}
+
+	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+		LOGI("Error!UNBLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+
+    struct fb_fix_screeninfo finfo;
+    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1)
+       goto disp_init_error;
+                
+    struct fb_var_screeninfo info;
+    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1)
+        goto disp_init_error;
+                
+    LOGI("Second display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
+         info.xres,info.xres_virtual,info.yres,info.yres_virtual);
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+                
+    /*
+    * Explicitly request 5/6/5
+    */
+    info.bits_per_pixel = 16;
+    info.nonstd = 0;
+    info.red.offset     = 11;
+    info.red.length     = 5;
+    info.green.offset   = 5;
+    info.green.length   = 6;
+    info.blue.offset    = 0;
+    info.blue.length    = 5;
+    info.transp.offset  = 0;
+    info.transp.length  = 0;
+    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
+    info.xres_virtual = ALIGN_PIXEL(info.xres);
+                        
+    if (ioctl(sec_fp, FBIOPUT_VSCREENINFO, &info) == -1) {
+        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1){
+        LOGE("Error!Second display FBIOGET_VSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1){
+        LOGE("Error!Second display FBIOGET_FSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if(finfo.smem_len <= 0)
+        goto disp_init_error;
+
+    fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  
+                   
+    vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, sec_fp, 0);
+    if (vaddr == MAP_FAILED) {
+        LOGE("Error!mapping the framebuffer (%s)", strerror(errno));
+        goto disp_init_error;
+    }
+
+    key.enable = 1;
+    key.color_key = 0x00000000; // Black
+    LOGI("MXCFB_SET_CLR_KEY");
+    if( ioctl(sec_fp, MXCFB_SET_CLR_KEY, &key) < 0)
+    {
+        LOGE("Error!MXCFB_SET_CLR_KEY");
+        goto disp_init_error;
+    }
+
+    gbl_alpha.alpha = 255;
+    gbl_alpha.enable = 1;
+    LOGI("MXCFB_SET_GBL_ALPHA");
+    if(ioctl(sec_fp, MXCFB_SET_GBL_ALPHA, &gbl_alpha) <0)
+    {
+        LOGI("Error!MXCFB_SET_GBL_ALPHA error");
+        goto disp_init_error;
+    }
+
+    ctx->sec_disp_base = intptr_t(vaddr);
+    ctx->sec_disp_phys = intptr_t(finfo.smem_start);
+    memset(vaddr, 0, fbSize);
+    ctx->sec_fp = sec_fp;
+    ctx->sec_disp_w = info.xres;
+    ctx->sec_disp_h = info.yres;
+    ctx->sec_frame_size = fbSize/nr_framebuffers;
+    ctx->sec_disp_next_buf = ((info.yoffset * nr_framebuffers / info.yres_virtual) + 1) % nr_framebuffers;
+    ctx->sec_info = info;
+    ctx->sec_finfo = finfo;
+#if 0
+    struct fb_fix_screeninfo fb0_finfo;
+    if (ioctl(m->framebuffer->fd, FBIOGET_FSCREENINFO, &fb0_finfo) == -1)
+       goto disp_init_error;
+                
+    struct fb_var_screeninfo fb0_info;
+    if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO, &fb0_info) == -1)
+        goto disp_init_error;
+                
+    LOGI("fb0_info display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
+         fb0_info.xres,fb0_info.xres_virtual,
+         fb0_info.yres,fb0_info.yres_virtual);
+
+    fb0_info.reserved[0] = 0;
+    fb0_info.reserved[1] = 0;
+    fb0_info.reserved[2] = 0;
+    fb0_info.xoffset = 0;
+    fb0_info.yoffset = 0;
+    fb0_info.activate = FB_ACTIVATE_NOW;
+                
+    /*
+    * Explicitly request 5/6/5
+    */
+    fb0_info.bits_per_pixel = 16;
+    fb0_info.nonstd = 0;
+    fb0_info.red.offset     = 11;
+    fb0_info.red.length     = 5;
+    fb0_info.green.offset   = 5;
+    fb0_info.green.length   = 6;
+    fb0_info.blue.offset    = 0;
+    fb0_info.blue.length    = 5;
+    fb0_info.transp.offset  = 0;
+    fb0_info.transp.length  = 0;
+    fb0_info.yres_virtual = ALIGN_PIXEL_128(fb0_info.yres) * nr_framebuffers;
+	fb0_info.xres_virtual = fb0_info.xres;
+#endif
+    if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
+        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
+        goto disp_init_error;
+    }
+
+    return 0;
+
+ disp_init_error:
+    if(sec_fp) {
+        close(sec_fp);
+        sec_fp = 0;
+        ctx->sec_fp = 0;
+    }
+    return -1;
+}
+
+static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx)
+{
+    ipu_lib_input_param_t sIPUInputParam;   
+    ipu_lib_output_param_t sIPUOutputParam; 
+    ipu_lib_handle_t            sIPUHandle;
+    int iIPURet = 0;
+    memset(&sIPUInputParam,0,sizeof(sIPUInputParam));
+    memset(&sIPUOutputParam,0,sizeof(sIPUOutputParam));
+    memset(&sIPUHandle,0,sizeof(sIPUHandle));
+
+    //Setting input format
+    sIPUInputParam.width = ctx->device.width;
+    sIPUInputParam.height = ctx->device.height;
+
+    sIPUInputParam.input_crop_win.pos.x = 0;
+    sIPUInputParam.input_crop_win.pos.y = 0;  
+    sIPUInputParam.input_crop_win.win_w = ctx->device.width;
+    sIPUInputParam.input_crop_win.win_h = ctx->device.height;
+    sIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+    sIPUInputParam.user_def_paddr[0] = phys;
+        
+    //Setting output format
+    //Should align with v4l
+    sIPUOutputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+    sIPUOutputParam.width = ctx->sec_disp_w;
+    sIPUOutputParam.height = ctx->sec_disp_h;   
+    sIPUOutputParam.show_to_fb = 0;
+    //Output param should be same as input, since no resize,crop
+    sIPUOutputParam.output_win.pos.x = 0;
+    sIPUOutputParam.output_win.pos.y = 0;
+    sIPUOutputParam.output_win.win_w = ctx->sec_disp_w;
+    sIPUOutputParam.output_win.win_h = ctx->sec_disp_h;
+    
+    int output_w = 0;
+    int output_h = 0;
+    //Make sure the output w/h proportion is align with the primary display
+    if((ctx->sec_rotation == 0x0)||(ctx->sec_rotation == 0x3))
+    {
+        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.width/ctx->device.height){
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
+        }
+        else{
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
+        }
+    }
+    else{
+        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.height/ctx->device.width){
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
+        }
+        else{
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
+        }
+    }
+    sIPUOutputParam.output_win.pos.x = (ctx->sec_disp_w - sIPUOutputParam.output_win.win_w)/2;
+    sIPUOutputParam.output_win.pos.y = (ctx->sec_disp_h - sIPUOutputParam.output_win.win_h)/2;
+
+
+    //sIPUOutputParam.rot = 0;
+    sIPUOutputParam.rot = ctx->sec_rotation;
+    //LOGI("Sec Rotation %d",ctx->sec_rotation);
+
+    sIPUOutputParam.user_def_paddr[0] = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    //LOGI("Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+    //sIPUOutputParam.width,
+    //sIPUOutputParam.height,
+    //sIPUOutputParam.output_win.pos.x,
+    //sIPUOutputParam.output_win.pos.y,
+    //sIPUOutputParam.output_win.win_w,
+    //sIPUOutputParam.output_win.win_h,
+    //sIPUOutputParam.rot);
+                                         
+    //LOGI("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+    //sIPUInputParam.width,
+    //sIPUInputParam.height,
+    //sIPUInputParam.fmt,
+    //sIPUInputParam.input_crop_win.pos.x,
+    //sIPUInputParam.input_crop_win.pos.y,
+    //sIPUInputParam.input_crop_win.win_w,
+    //sIPUInputParam.input_crop_win.win_h);     
+        
+    iIPURet =  mxc_ipu_lib_task_init(&sIPUInputParam,NULL,&sIPUOutputParam,OP_NORMAL_MODE|TASK_VF_MODE,&sIPUHandle);
+    if (iIPURet < 0) {
+        LOGE("Error!mxc_ipu_lib_task_init failed mIPURet %d!",iIPURet);
+        return -1;
+    }  
+    //LOGI("mxc_ipu_lib_task_init success");
+    iIPURet = mxc_ipu_lib_task_buf_update(&sIPUHandle,phys,sIPUOutputParam.user_def_paddr[0],NULL,NULL,NULL);
+    if (iIPURet < 0) {
+        LOGE("Error!mxc_ipu_lib_task_buf_update failed mIPURet %d!",iIPURet);
+        mxc_ipu_lib_task_uninit(&sIPUHandle);
+        return -1;
+    }
+    //LOGI("mxc_ipu_lib_task_buf_update success");
+    mxc_ipu_lib_task_uninit(&sIPUHandle);
+
+    return 0;
+}
+
+/** convert HAL_PIXEL_FORMAT to C2D format */
+static C2D_COLORFORMAT get_format(int format) {
+    switch (format) {
+	case HAL_PIXEL_FORMAT_BGRA_8888:   return C2D_COLOR_8888;
+    case HAL_PIXEL_FORMAT_RGB_565:     return C2D_COLOR_0565;
+    default:                           return C2D_COLOR_0565;
+    }
+}
+
+/** get  pixelbit from HAL_PIXEL_FORMAT format */
+static int get_pixelbit(int format) {
+    switch (format) {
+    case HAL_PIXEL_FORMAT_BGRA_8888:   return 32;
+    case HAL_PIXEL_FORMAT_RGB_565:     return 16;
+    default:                           return 16;
+    }
+}
+
+static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx)
+{
+    C2D_SURFACE_DEF srcSurfaceDef;
+    C2D_SURFACE_DEF dstSurfaceDef;
+    C2D_SURFACE srcSurface;
+    C2D_SURFACE dstSurface; 
+    C2D_RECT dstRect;
+
+    if(!ctx || !ctx->c2dctx) return -1;
+
+    srcSurfaceDef.format = get_format(ctx->device.format);
+    srcSurfaceDef.width =  ctx->device.width;
+    srcSurfaceDef.height = ctx->device.height;
+
+	//make sure stride is 32 pixel aligned
+    srcSurfaceDef.stride = ((ctx->device.width + 31) & ~31)*get_pixelbit(ctx->device.format)>>3;
+
+    srcSurfaceDef.buffer = (void *)phys;
+    srcSurfaceDef.host = (void *)base;
+    srcSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
+
+    if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
+    {
+        LOGE("srcSurface c2dSurfAlloc fail");
+        return -EINVAL;
+    }
+
+    dstSurfaceDef.format = get_format(HAL_PIXEL_FORMAT_RGB_565);
+    dstSurfaceDef.width =  ctx->sec_disp_w;
+    dstSurfaceDef.height = ctx->sec_disp_h;
+
+    //make sure stride is 32 pixel aligned
+    dstSurfaceDef.stride = ((ctx->sec_disp_w + 31) & ~31)*get_pixelbit(HAL_PIXEL_FORMAT_RGB_565)>>3;
+
+    dstSurfaceDef.buffer = (void *)ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    dstSurfaceDef.host = (void *)ctx->sec_disp_base + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    dstSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
+
+    dstRect.x = dstRect.y = 0;
+    dstRect.width = dstSurfaceDef.width;
+    dstRect.height = dstSurfaceDef.height;
+                
+    if((ctx->mRotate == 0)||(ctx->mRotate == 180))
+    {
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
+            dstRect.width = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
+        }
+        else{
+            dstRect.height = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
+        }
+    }
+    else{
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
+            dstRect.width = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
+        }
+        else{
+            dstRect.height = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
+        }
+    }
+
+    dstRect.x = (ctx->sec_disp_w - dstRect.width)/2;
+    dstRect.y = (ctx->sec_disp_h - dstRect.height)/2;
+            
+    if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
+    {
+        LOGE("dstSurface c2dSurfAlloc fail");
+        c2dSurfFree(ctx->c2dctx, srcSurface);
+        return -EINVAL;
+    }
+
+    c2dSetSrcSurface(ctx->c2dctx, srcSurface);
+    c2dSetDstSurface(ctx->c2dctx, dstSurface); 
+    c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
+
+    c2dSetStretchMode(ctx->c2dctx, C2D_STRETCH_BILINEAR_SAMPLING);
+    c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);         
+    c2dSetDither(ctx->c2dctx, 0); 
+ 
+    c2dSetDstRectangle(ctx->c2dctx, &dstRect);
+    c2dDrawBlit(ctx->c2dctx); 
+        
+    c2dFinish(ctx->c2dctx);
+    c2dSurfFree(ctx->c2dctx, srcSurface);
+    c2dSurfFree(ctx->c2dctx, dstSurface);
+
+    return 0;
+}
+
+void * secDispShowFrames(void * arg)
+{
+    private_module_t* m = NULL;
+    private_handle_t const* hnd = NULL;
+    fb_context_t* ctx = (fb_context_t*)arg;
+    
+    while(1)
+    {
+        sem_wait(&ctx->sec_display_begin);
+
+        if(!ctx->sec_display_inited)
+        {
+            sem_post(&ctx->sec_display_end);
+            break;
+        }
+
+        char value[PROPERTY_VALUE_MAX];
+        property_get("ro.secfb.disable-overlay", value, "0");
+        if (!strcmp(value, "1"))
+        {
+            property_get("media.VIDEO_PLAYING", value, "0");
+        }
+
+        if (strcmp(value, "1") == 0)
+        {
+            if(ctx->cleancount)
+            {
+                sem_post(&ctx->sec_display_end);
+                continue;
+            }
+
+            ctx->cleancount++;
+            memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+        }
+        else
+        {
+           ctx->cleancount = 0;
+        }
+
+        if(!ctx->cleancount)
+        {
+            hnd = reinterpret_cast<private_handle_t const*>(ctx->buffer);
+            m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
+
+            if(ctx->c2dctx != NULL)
+            {
+                resizeToSecFrameBuffer_c2d(hnd->base,
+                           m->framebuffer->phys + hnd->base - m->framebuffer->base,
+                           ctx);
+            }
+            else
+            {
+                resizeToSecFrameBuffer(hnd->base,
+                                   m->framebuffer->phys + hnd->base - m->framebuffer->base,
+                                   ctx);
+            }
+        }
+
+        sem_post(&ctx->sec_display_end);
+        
+        ctx->sec_info.yoffset = (ctx->sec_info.yres_virtual/nr_framebuffers) * ctx->sec_disp_next_buf;
+        ctx->sec_disp_next_buf = (ctx->sec_disp_next_buf + 1) % nr_framebuffers;
+        ctx->sec_info.activate = FB_ACTIVATE_VBL;
+
+        ioctl(ctx->sec_fp, FBIOPAN_DISPLAY, &ctx->sec_info);
+    }
+
+    return NULL;
+}
+
+#endif
+
+/*****************************************************************************/
+
+static int fb_close(struct hw_device_t *dev)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if (ctx) {
+        free(ctx);
+    }
+    return 0;
+}
+
+int fb_device_open(hw_module_t const* module, const char* name,
+        hw_device_t** device)
+{
+    int status = -EINVAL;
+    char value[PROPERTY_VALUE_MAX];
+
+    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
+        alloc_device_t* gralloc_device;
+        framebuffer_device_t *fbdev;
+
+        nr_framebuffers = NUM_BUFFERS;
+        property_get("ro.product.device", value, "");
+        if (0 == strcmp(value, "imx50_rdp")) {
+            nr_framebuffers = 2;
+            no_ipu = 1;
+        }
+
+        status = gralloc_open(module, &gralloc_device);
+        if (status < 0)
+            return status;
+
+        /* initialize our state here */
+        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = fb_close;
+        dev->device.setSwapInterval = fb_setSwapInterval;
+        dev->device.post            = fb_post;
+        #ifndef FSL_EPDC_FB
+        dev->device.setUpdateRect = 0;
+        #else
+        dev->device.setUpdateRect = fb_setUpdateRect;
+        #endif
+        dev->device.compositionComplete = fb_compositionComplete;
+        #ifdef SECOND_DISPLAY_SUPPORT
+        dev->device.setSecRotation = fb_setSecRotation;
+        #endif
+
+        private_module_t* m = (private_module_t*)module;
+        status = mapFrameBuffer(m);
+        if (status >= 0) {
+            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
+            const_cast<uint32_t&>(dev->device.flags) = 0xfb0;
+            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
+            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
+            const_cast<int&>(dev->device.stride) = stride;
+            if(m->info.bits_per_pixel != 32) {
+                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
+            }
+            else{
+                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
+            }
+            const_cast<float&>(dev->device.xdpi) = m->xdpi;
+            const_cast<float&>(dev->device.ydpi) = m->ydpi;
+            const_cast<float&>(dev->device.fps) = m->fps;
+            const_cast<int&>(dev->device.minSwapInterval) = 1;
+            const_cast<int&>(dev->device.maxSwapInterval) = 1;
+            *device = &dev->device.common;
+            fbdev = (framebuffer_device_t*) *device;
+            fbdev->reserved[0] = nr_framebuffers;
+        }
+
+	/* initialize the IPU lib IPC */
+        if (!no_ipu)
+            mxc_ipu_lib_ipc_init();
+
+    fslwatermark_sem_open();
+
+    }
+    return status;
+}
diff --git a/mx5x/libgralloc/gr.h b/mx5x/libgralloc/gr.h
new file mode 100755
index 0000000..1775bfa
--- /dev/null
+++ b/mx5x/libgralloc/gr.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GR_H_
+#define GR_H_
+
+#include <stdint.h>
+#ifdef HAVE_ANDROID_OS      // just want PAGE_SIZE define
+# include <asm/page.h>
+#else
+# include <sys/user.h>
+#endif
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+
+#include <cutils/native_handle.h>
+
+/*****************************************************************************/
+
+struct private_module_t;
+struct private_handle_t;
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+int mapFrameBufferLocked(struct private_module_t* module);
+int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
+
+/*****************************************************************************/
+
+class Locker {
+    pthread_mutex_t mutex;
+public:
+    class Autolock {
+        Locker& locker;
+    public:
+        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
+        inline ~Autolock() { locker.unlock(); }
+    };
+    inline Locker()        { pthread_mutex_init(&mutex, 0); }
+    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
+    inline void lock()     { pthread_mutex_lock(&mutex); }
+    inline void unlock()   { pthread_mutex_unlock(&mutex); }
+};
+
+#endif /* GR_H_ */
diff --git a/mx5x/libgralloc/gralloc.cpp b/mx5x/libgralloc/gralloc.cpp
new file mode 100755
index 0000000..f65099e
--- /dev/null
+++ b/mx5x/libgralloc/gralloc.cpp
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include <cutils/ashmem.h>
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include "gralloc_priv.h"
+#include "allocator.h"
+
+#if HAVE_ANDROID_OS
+#include <linux/android_pmem.h>
+#endif
+
+/*****************************************************************************/
+
+static SimpleBestFitAllocator sAllocator;
+
+/*****************************************************************************/
+
+struct gralloc_context_t {
+    alloc_device_t  device;
+    /* our private data here */
+};
+
+static int gralloc_alloc_buffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle);
+
+/*****************************************************************************/
+
+int fb_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device);
+
+static int gralloc_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device);
+
+extern int gralloc_lock(gralloc_module_t const* module,
+        buffer_handle_t handle, int usage,
+        int l, int t, int w, int h,
+        void** vaddr);
+
+extern int gralloc_unlock(gralloc_module_t const* module, 
+        buffer_handle_t handle);
+
+extern int gralloc_register_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle);
+
+extern int gralloc_unregister_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle);
+
+/*****************************************************************************/
+
+static struct hw_module_methods_t gralloc_module_methods = {
+        open: gralloc_device_open
+};
+
+struct private_module_t HAL_MODULE_INFO_SYM = {
+    base: {
+        common: {
+            tag: HARDWARE_MODULE_TAG,
+            version_major: 1,
+            version_minor: 0,
+            id: GRALLOC_HARDWARE_MODULE_ID,
+            name: "Graphics Memory Allocator Module",
+            author: "The Android Open Source Project",
+            methods: &gralloc_module_methods
+        },
+        registerBuffer: gralloc_register_buffer,
+        unregisterBuffer: gralloc_unregister_buffer,
+        lock: gralloc_lock,
+        unlock: gralloc_unlock,
+    },
+    framebuffer: 0,
+    flags: 0,
+    numBuffers: 0,
+    bufferMask: 0,
+    lock: PTHREAD_MUTEX_INITIALIZER,
+    currentBuffer: 0,
+    pmem_master: -1,
+    pmem_master_base: 0,
+    master_phys: 0
+};
+
+/*****************************************************************************/
+
+static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+
+    // allocate the framebuffer
+    if (m->framebuffer == NULL) {
+        // initialize the framebuffer, the framebuffer is mapped once
+        // and forever.
+        int err = mapFrameBufferLocked(m);
+        if (err < 0) {
+            return err;
+        }
+    }
+
+    const uint32_t bufferMask = m->bufferMask;
+    const uint32_t numBuffers = m->numBuffers;
+    const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
+    if (numBuffers == 1) {
+        // If we have only one buffer, we never use page-flipping. Instead,
+        // we return a regular buffer which will be memcpy'ed to the main
+        // screen when post is called.
+        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
+        pthread_mutex_unlock(&m->lock);
+        int ret = gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);
+        pthread_mutex_lock(&m->lock);
+        return ret;
+    }
+
+    if (bufferMask >= ((1LU<<numBuffers)-1)) {
+        // We ran out of buffers.
+        return -ENOMEM;
+    }
+
+    // create a "fake" handles for it
+    intptr_t vaddr = intptr_t(m->framebuffer->base);
+    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer->fd), size,
+            private_handle_t::PRIV_FLAGS_USES_PMEM |
+            private_handle_t::PRIV_FLAGS_FRAMEBUFFER);
+
+    // find a free slot
+    for (uint32_t i=0 ; i<numBuffers ; i++) {
+        if ((bufferMask & (1LU<<i)) == 0) {
+            m->bufferMask |= (1LU<<i);
+            break;
+        }
+        vaddr += bufferSize;
+    }
+    
+    hnd->base = vaddr;
+    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
+    hnd->phys = intptr_t(m->framebuffer->phys) + hnd->offset;
+    *pHandle = hnd;
+
+    return 0;
+}
+
+static int gralloc_alloc_framebuffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+    pthread_mutex_lock(&m->lock);
+    int err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
+
+static int init_pmem_area_locked(private_module_t* m)
+{
+    int err = 0;
+#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
+    int master_fd = open("/dev/pmem_gpu", O_RDWR, 0);
+    if (master_fd >= 0) {
+        
+        size_t size;
+        pmem_region region;
+        if (ioctl(master_fd, PMEM_GET_TOTAL_SIZE, &region) < 0) {
+            LOGE("PMEM_GET_TOTAL_SIZE failed, limp mode");
+            size = 8<<20;   // 8 MiB
+        } else {
+            size = region.len;
+        }
+        sAllocator.setSize(size);
+
+        void* base = mmap(0, size, 
+                PROT_READ|PROT_WRITE, MAP_SHARED, master_fd, 0);
+        if (base == MAP_FAILED) {
+            err = -errno;
+            base = 0;
+            close(master_fd);
+            master_fd = -1;
+        } else {
+            pmem_region region;
+            err = ioctl(master_fd, PMEM_GET_PHYS, &region);
+            if (err < 0) {
+                LOGE("PMEM_GET_PHYS failed (%s)", strerror(-errno));
+            } else {
+                m->master_phys = (unsigned long)region.offset;
+				LOGI("PMEM GPU enabled, size:%d, phys base:%x",size,m->master_phys);
+            }
+        }
+        m->pmem_master = master_fd;
+        m->pmem_master_base = base;
+    } else {
+        err = -errno;
+    }
+    return err;
+#else
+    return -1;
+#endif
+}
+
+static int init_pmem_area(private_module_t* m)
+{
+    pthread_mutex_lock(&m->lock);
+    int err = m->pmem_master;
+    if (err == -1) {
+        // first time, try to initialize pmem
+        err = init_pmem_area_locked(m);
+        if (err) {
+            m->pmem_master = err;
+        }
+    } else if (err < 0) {
+        // pmem couldn't be initialized, never use it
+    } else {
+        // pmem OK
+        err = 0;
+    }
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
+
+static int gralloc_alloc_buffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    int err = 0;
+    int flags = 0;
+
+    int fd = -1;
+    void* base = 0;
+    int offset = 0;
+    int lockState = 0;
+
+    size = roundUpToPageSize(size);
+    
+#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
+
+    if (usage & GRALLOC_USAGE_HW_TEXTURE) {
+        // enable pmem in that case, so our software GL can fallback to
+        // the copybit module.
+        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
+    }
+    
+    if (usage & GRALLOC_USAGE_HW_2D) {
+        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
+    }
+
+    if ((flags & private_handle_t::PRIV_FLAGS_USES_PMEM) == 0) {
+try_ashmem:
+        fd = ashmem_create_region("gralloc-buffer", size);
+        if (fd < 0) {
+            LOGE("couldn't create ashmem (%s)", strerror(-errno));
+            err = -errno;
+        }
+    } else {
+        private_module_t* m = reinterpret_cast<private_module_t*>(
+                dev->common.module);
+
+        err = init_pmem_area(m);
+        if (err == 0) {
+            // PMEM buffers are always mmapped
+            base = m->pmem_master_base;
+            lockState |= private_handle_t::LOCK_STATE_MAPPED;
+
+            offset = sAllocator.allocate(size);
+            if (offset < 0) {
+                // no more pmem memory
+                err = -ENOMEM;
+            } else {
+                struct pmem_region sub = { offset, size };
+                
+                // now create the "sub-heap"
+                fd = open("/dev/pmem_gpu", O_RDWR, 0);
+                err = fd < 0 ? fd : 0;
+                
+                // and connect to it
+                if (err == 0)
+                    err = ioctl(fd, PMEM_CONNECT, m->pmem_master);
+
+                // and make it available to the client process
+                if (err == 0)
+                    err = ioctl(fd, PMEM_MAP, &sub);
+
+                if (err < 0) {
+                    err = -errno;
+                    close(fd);
+                    sAllocator.deallocate(offset);
+                    fd = -1;
+                }
+                //LOGD_IF(!err, "allocating pmem size=%d, offset=%d", size, offset);
+                memset((char*)base + offset, 0, size);
+            }
+        } else {
+            if ((usage & GRALLOC_USAGE_HW_2D) == 0) {
+                // the caller didn't request PMEM, so we can try something else
+                flags &= ~private_handle_t::PRIV_FLAGS_USES_PMEM;
+                err = 0;
+                goto try_ashmem;
+            } else {
+                LOGE("couldn't open pmem (%s)", strerror(-errno));
+            }
+        }
+    }
+
+#else // HAVE_ANDROID_OS
+    
+    fd = ashmem_create_region("Buffer", size);
+    if (fd < 0) {
+        LOGE("couldn't create ashmem (%s)", strerror(-errno));
+        err = -errno;
+    }
+
+#endif // HAVE_ANDROID_OS
+
+    if (err == 0) {
+        private_handle_t* hnd = new private_handle_t(fd, size, flags);
+        hnd->offset = offset;
+        hnd->base = int(base)+offset;
+        hnd->lockState = lockState;
+        if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
+            private_module_t* m = reinterpret_cast<private_module_t*>(
+                    dev->common.module);
+            hnd->phys = m->master_phys + offset;
+        }
+        *pHandle = hnd;
+    }
+    
+    LOGE_IF(err, "gralloc failed err=%s", strerror(-err));
+    
+    return err;
+}
+
+/*****************************************************************************/
+
+static int gralloc_alloc(alloc_device_t* dev,
+        int w, int h, int format, int usage,
+        buffer_handle_t* pHandle, int* pStride)
+{
+    if (!pHandle || !pStride)
+        return -EINVAL;
+
+    size_t size, alignedw, alignedh;
+    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || 
+            format == HAL_PIXEL_FORMAT_YCbCr_422_SP) 
+    {
+        // FIXME: there is no way to return the alignedh
+        alignedw = (w + 1) & ~1; 
+        switch (format) {
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+                size = alignedw * h * 2;
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+                alignedh = (h+1) & ~1;
+                size = (alignedw * alignedh) + (w/2 * h/2) * 2;
+                break;
+            default:
+                return -EINVAL;
+        }
+    } else {
+        alignedw = ALIGN_PIXEL(w);
+        alignedh = ALIGN_PIXEL(h);
+        int bpp = 0;
+        switch (format) {
+            case HAL_PIXEL_FORMAT_RGBA_8888:
+            case HAL_PIXEL_FORMAT_RGBX_8888:
+            case HAL_PIXEL_FORMAT_BGRA_8888:
+                bpp = 4;
+                break;
+            case HAL_PIXEL_FORMAT_RGB_888:
+                bpp = 3;
+                break;
+            case HAL_PIXEL_FORMAT_RGB_565:
+            case HAL_PIXEL_FORMAT_RGBA_5551:
+            case HAL_PIXEL_FORMAT_RGBA_4444:
+                bpp = 2;
+                break;
+            default:
+                return -EINVAL;
+        }
+        size = alignedw * alignedh * bpp;
+    }
+
+    int err;
+    if (usage & GRALLOC_USAGE_HW_FB) {
+        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);
+    } else {
+        err = gralloc_alloc_buffer(dev, size, usage, pHandle);
+    }
+
+    if (err < 0) {
+        return err;
+    }
+
+    *pStride = alignedw;
+    return 0;
+}
+
+static int gralloc_free(alloc_device_t* dev,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+        // free this buffer
+        private_module_t* m = reinterpret_cast<private_module_t*>(
+                dev->common.module);
+        const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
+        int index = (hnd->base - m->framebuffer->base) / bufferSize;
+        m->bufferMask &= ~(1<<index); 
+    } else { 
+#if HAVE_ANDROID_OS
+        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
+            if (hnd->fd >= 0) {
+                struct pmem_region sub = { hnd->offset, hnd->size };
+                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
+                LOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
+                        "fd=%d, sub.offset=%lu, sub.size=%lu",
+                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
+                if (err == 0) {
+                    // we can't deallocate the memory in case of UNMAP failure
+                    // because it would give that process access to someone else's
+                    // surfaces, which would be a security breach.
+                    sAllocator.deallocate(hnd->offset);
+                }
+            }
+        }
+#endif // HAVE_ANDROID_OS
+        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>(
+                dev->common.module);
+        terminateBuffer(module, const_cast<private_handle_t*>(hnd));
+    }
+
+    close(hnd->fd);
+    delete hnd;
+    return 0;
+}
+
+/*****************************************************************************/
+
+static int gralloc_close(struct hw_device_t *dev)
+{
+    gralloc_context_t* ctx = reinterpret_cast<gralloc_context_t*>(dev);
+    if (ctx) {
+        /* TODO: keep a list of all buffer_handle_t created, and free them
+         * all here.
+         */
+        free(ctx);
+    }
+    return 0;
+}
+
+int gralloc_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
+        gralloc_context_t *dev;
+        dev = (gralloc_context_t*)malloc(sizeof(*dev));
+
+        /* initialize our state here */
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = gralloc_close;
+
+        dev->device.alloc   = gralloc_alloc;
+        dev->device.free    = gralloc_free;
+
+        *device = &dev->device.common;
+        status = 0;
+    } else {
+        status = fb_device_open(module, name, device);
+    }
+    return status;
+}
diff --git a/mx5x/libgralloc/gralloc_priv.h b/mx5x/libgralloc/gralloc_priv.h
new file mode 100755
index 0000000..3801907
--- /dev/null
+++ b/mx5x/libgralloc/gralloc_priv.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GRALLOC_PRIV_H_
+#define GRALLOC_PRIV_H_
+
+#include <stdint.h>
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <cutils/native_handle.h>
+
+#include <linux/fb.h>
+
+#define  ALIGN_PIXEL(x)  ((x+ 31) & ~31)
+/** z430 core need 4k aligned memory, since xres has been 32 aligned, make yres
+    to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
+#define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
+/*****************************************************************************/
+
+struct private_module_t;
+struct private_handle_t;
+
+struct private_module_t {
+    gralloc_module_t base;
+
+    private_handle_t* framebuffer;
+    uint32_t flags;
+    uint32_t numBuffers;
+    uint32_t bufferMask;
+    pthread_mutex_t lock;
+    buffer_handle_t currentBuffer;
+    int pmem_master;
+    void* pmem_master_base;
+    unsigned long master_phys;
+
+    struct fb_var_screeninfo info;
+    struct fb_fix_screeninfo finfo;
+    float xdpi;
+    float ydpi;
+    float fps;
+    
+    enum {
+        // flag to indicate we'll post this buffer
+        PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
+    };
+};
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+struct private_handle_t : public native_handle {
+#else
+struct private_handle_t {
+    struct native_handle nativeHandle;
+#endif
+    
+    enum {
+        PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
+        PRIV_FLAGS_USES_PMEM   = 0x00000002,
+    };
+
+    enum {
+        LOCK_STATE_WRITE     =   1<<31,
+        LOCK_STATE_MAPPED    =   1<<30,
+        LOCK_STATE_READ_MASK =   0x3FFFFFFF
+    };
+
+    // file-descriptors
+    int     fd;
+    // ints
+    int     magic;
+    int     flags;
+    int     size;
+    int     offset;
+    int     gpu_fd; 
+
+    // FIXME: the attributes below should be out-of-line
+    int     base;
+    int     lockState;
+    int     writeOwner;
+    int     phys; // The physical address of that chunk of memory. If using ashmem, set to 0 They don't care
+    int     pid;
+
+#ifdef __cplusplus
+    static const int sNumInts = 10;
+    static const int sNumFds = 1;
+    static const int sMagic = 'pgpu';
+
+    private_handle_t(int fd, int size, int flags) :
+        fd(fd), magic(sMagic), flags(flags), size(size), offset(0),gpu_fd(-1),
+        base(0), lockState(0), writeOwner(0), phys(0),pid(getpid())
+    {
+        version = sizeof(native_handle);
+        numInts = sNumInts;
+        numFds = sNumFds;
+    }
+    ~private_handle_t() {
+        magic = 0;
+    }
+
+    bool usesPhysicallyContiguousMemory() {
+        return (flags & PRIV_FLAGS_USES_PMEM) != 0;
+    }
+
+    static int validate(const native_handle* h) {
+        const private_handle_t* hnd = (const private_handle_t*)h;
+        if (!h || h->version != sizeof(native_handle) ||
+                h->numInts != sNumInts || h->numFds != sNumFds ||
+                hnd->magic != sMagic) 
+        {
+            LOGE("invalid gralloc handle (at %p)", h);
+            return -EINVAL;
+        }
+        return 0;
+    }
+
+    static private_handle_t* dynamicCast(const native_handle* in) {
+        if (validate(in) == 0) {
+            return (private_handle_t*) in;
+        }
+        return NULL;
+    }
+#endif
+};
+
+#endif /* GRALLOC_PRIV_H_ */
diff --git a/mx5x/libgralloc/mapper.cpp b/mx5x/libgralloc/mapper.cpp
new file mode 100755
index 0000000..e2caf79
--- /dev/null
+++ b/mx5x/libgralloc/mapper.cpp
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include "gralloc_priv.h"
+
+
+// we need this for now because pmem cannot mmap at an offset
+#define PMEM_HACK   1
+
+/* desktop Linux needs a little help with gettid() */
+#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
+#define __KERNEL__
+# include <linux/unistd.h>
+pid_t gettid() { return syscall(__NR_gettid);}
+#undef __KERNEL__
+#endif
+
+/*****************************************************************************/
+
+static int gralloc_map(gralloc_module_t const* module,
+        buffer_handle_t handle,
+        void** vaddr)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        size_t size = hnd->size;
+#if PMEM_HACK
+        size += hnd->offset;
+#endif
+        void* mappedAddress = mmap(0, size,
+                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
+        if (mappedAddress == MAP_FAILED) {
+            LOGE("Could not mmap %s", strerror(errno));
+            return -errno;
+        }
+        hnd->base = intptr_t(mappedAddress) + hnd->offset;
+        //LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", 
+        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
+    }
+    *vaddr = (void*)hnd->base;
+    return 0;
+}
+
+static int gralloc_unmap(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        void* base = (void*)hnd->base;
+        size_t size = hnd->size;
+#if PMEM_HACK
+        base = (void*)(intptr_t(base) - hnd->offset);
+        size += hnd->offset;
+#endif
+        //LOGD("unmapping from %p, size=%d", base, size);
+        if (munmap(base, size) < 0) {
+            LOGE("Could not unmap %s", strerror(errno));
+        }
+    }
+    hnd->base = 0;
+    return 0;
+}
+
+/*****************************************************************************/
+
+static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER; 
+
+/*****************************************************************************/
+
+int gralloc_register_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    // In this implementation, we don't need to do anything here
+
+    /* NOTE: we need to initialize the buffer as not mapped/not locked
+     * because it shouldn't when this function is called the first time
+     * in a new process. Ideally these flags shouldn't be part of the
+     * handle, but instead maintained in the kernel or at least 
+     * out-of-line
+     */ 
+
+    // if this handle was created in this process, then we keep it as is.
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (hnd->pid != getpid()) {
+        hnd->base = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+int gralloc_unregister_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     * NOTE: the framebuffer is handled differently and is never unmapped.
+     */
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+    
+    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
+            "[unregister] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+
+    // never unmap buffers that were created in this process
+    if (hnd->pid != getpid()) {
+        if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
+            gralloc_unmap(module, handle);
+        }
+        hnd->base = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+int terminateBuffer(gralloc_module_t const* module,
+        private_handle_t* hnd)
+{
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     */
+
+    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
+            "[terminate] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+    
+    if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
+        // this buffer was mapped, unmap it now
+        if ((hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) && 
+            (hnd->pid == getpid())) {
+            // ... unless it's a "master" pmem buffer, that is a buffer
+            // mapped in the process it's been allocated.
+            // (see gralloc_alloc_buffer())
+        } else {
+            gralloc_unmap(module, hnd);
+        }
+    }
+
+    return 0;
+}
+
+int gralloc_lock(gralloc_module_t const* module,
+        buffer_handle_t handle, int usage,
+        int l, int t, int w, int h,
+        void** vaddr)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    int err = 0;
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int32_t current_value, new_value;
+    int retry;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
+            // already locked for write 
+            LOGE("handle %p already locked for write", handle);
+            return -EBUSY;
+        } else if (current_value & private_handle_t::LOCK_STATE_READ_MASK) {
+            // already locked for read
+            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+                LOGE("handle %p already locked for read", handle);
+                return -EBUSY;
+            } else {
+                // this is not an error
+                //LOGD("%p already locked for read... count = %d", 
+                //        handle, (current_value & ~(1<<31)));
+            }
+        }
+
+        // not currently locked
+        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+            // locking for write
+            new_value |= private_handle_t::LOCK_STATE_WRITE;
+        }
+        new_value++;
+
+        retry = android_atomic_cmpxchg(current_value, new_value, 
+                (volatile int32_t*)&hnd->lockState);
+    } while (retry);
+
+    if (new_value & private_handle_t::LOCK_STATE_WRITE) {
+        // locking for write, store the tid
+        hnd->writeOwner = gettid();
+    }
+
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
+        if (!(current_value & private_handle_t::LOCK_STATE_MAPPED)) {
+            // we need to map for real
+            pthread_mutex_t* const lock = &sMapLock;
+            pthread_mutex_lock(lock);
+            if (!(hnd->lockState & private_handle_t::LOCK_STATE_MAPPED)) {
+                err = gralloc_map(module, handle, vaddr);
+                if (err == 0) {
+                    android_atomic_or(private_handle_t::LOCK_STATE_MAPPED,
+                            (volatile int32_t*)&(hnd->lockState));
+                }
+            }
+            pthread_mutex_unlock(lock);
+        }
+        *vaddr = (void*)hnd->base;
+    }
+
+    return err;
+}
+
+int gralloc_unlock(gralloc_module_t const* module, 
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int32_t current_value, new_value;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
+            // locked for write
+            if (hnd->writeOwner == gettid()) {
+                hnd->writeOwner = 0;
+                new_value &= ~private_handle_t::LOCK_STATE_WRITE;
+            }
+        }
+
+        if ((new_value & private_handle_t::LOCK_STATE_READ_MASK) == 0) {
+            LOGE("handle %p not locked", handle);
+            return -EINVAL;
+        }
+
+        new_value--;
+
+    } while (android_atomic_cmpxchg(current_value, new_value, 
+            (volatile int32_t*)&hnd->lockState));
+
+    return 0;
+}
diff --git a/mx6/hwcomposer/Android.mk b/mx6/hwcomposer/Android.mk
new file mode 100755
index 0000000..f85449b
--- /dev/null
+++ b/mx6/hwcomposer/Android.mk
@@ -0,0 +1,30 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+LOCAL_PATH := $(call my-dir)
+
+# HAL module implemenation, not prelinked and stored in
+# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
+include $(CLEAR_VARS)
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils
+LOCAL_SRC_FILES := hwcomposer.cpp BG_device.cpp FG_device.cpp hwc_common.cpp blit_gpu.cpp blit_ipu.cpp output_device.cpp
+LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
+LOCAL_C_INCLUDES += hardware/imx/mx6/libgralloc
+LOCAL_C_INCLUDES += external/linux-lib/ipu
+LOCAL_CFLAGS:= -DLOG_TAG=\"hwcomposer\"
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
diff --git a/mx6/hwcomposer/BG_device.cpp b/mx6/hwcomposer/BG_device.cpp
new file mode 100755
index 0000000..6b6a067
--- /dev/null
+++ b/mx6/hwcomposer/BG_device.cpp
@@ -0,0 +1,159 @@
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <hardware/hardware.h>
+//#include <hardware/overlay.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+//note: the fb1 in mx5x is hdmi port and should use 1080p=1920_1080. 
+BG_device::BG_device(const char *dev_name, int usage) 
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+BG_device::~BG_device()
+{
+		uninit();
+}
+
+int BG_device::init()
+{
+	  int status = -EINVAL;
+	  int fbSize = 0;
+	  void *vaddr = NULL;
+
+    if(m_dev <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_init invalid parameter!");
+    	  return -1;       	
+    }
+    
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+    
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+    
+   // m_left = 0;
+   // m_top = 0;
+    m_width = 1920;//info.xres;
+    m_height = 1080;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+  	
+  	info.reserved[0] = 0;
+  	info.reserved[1] = 0;
+  	info.reserved[2] = 0;  
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+  	
+  	info.bits_per_pixel = fmt_to_bpp(m_format);
+  	info.nonstd = m_format;
+  	info.red.offset = 0;
+  	info.red.length = 0;
+  	info.green.offset = 0;
+  	info.green.length = 0;
+  	info.blue.offset = 0;
+  	info.blue.length = 0;
+  	info.transp.offset = 0;
+  	info.transp.length = 0;	 
+  	
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+  	
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+  	
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init finfo.smem_len < 0!");
+    	  return -1;      		
+  	}
+  	
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;    		
+  	}
+
+        hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format); 
+        int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!BG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	} 	
+//  	key.enable = 1;
+//  	key.color_key = 0x00000000; //black
+//  	if(ioctl(m_dev, MXCFB_SET_CLR_KEY, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}
+//  	
+//  	gbl_alpha.alpha = 255;
+//  	gbl_alpha.enable = 1;
+//  	if(ioctl(m_dev, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}  	
+  	
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+  			(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+  			(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+  			(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+  			(mbuffers[i]).format = m_format;
+  	}
+	
+    status = 0;
+    return status;
+}
+
+int BG_device::uninit()
+{
+	  //int status = -EINVAL;    
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+    }	  
+    munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+
+    return 0;
+}
diff --git a/mx6/hwcomposer/FG_device.cpp b/mx6/hwcomposer/FG_device.cpp
new file mode 100755
index 0000000..784c5c1
--- /dev/null
+++ b/mx6/hwcomposer/FG_device.cpp
@@ -0,0 +1,307 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <linux/fb.h>
+#include <linux/mxcfb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+FG_device::FG_device(const char *dev_name, int usage)
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+FG_device::~FG_device()
+{
+		uninit();
+}
+
+static int switch_set(int fd0, int fd1, int flag)
+{
+    struct mxcfb_gbl_alpha gbl_alpha;
+    struct mxcfb_color_key key;
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd0, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 128;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd0, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd1, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 255;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd1, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+		return 0;
+}
+
+static int overlay_switch(int fd0, int fd1, int fd2, int flag)
+{
+		int blank = 1;
+  	int fp_property;
+  	char overlayStr[32];
+  	// it may be modified in mx6x.
+
+		if(ioctl(fd2, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+        return -1;
+		}
+
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB1 failed!\n");
+	      return -1;
+		}
+
+	  if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+	      return -1;
+		}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+  			//fp_property;
+
+		    HWCOMPOSER_LOG_ERR("Open fb0/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb0/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+
+  	}
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		    HWCOMPOSER_LOG_ERR("Open fb1/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb1/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+  	}
+
+    blank = FB_BLANK_UNBLANK;
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB1 failed!\n");
+	      return -1;
+		}
+
+		if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB0 failed!\n");
+	      return -1;
+		}
+
+		return 0;
+}
+
+int FG_device::init()
+{
+    int status = -EINVAL;
+    int fbSize = 0;
+    void *vaddr = NULL;
+HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
+        return -1;
+    }
+#if 1
+    //fist open fb0 device that it is binded to.
+    //it may be modified in mx6x
+    int fd_def = -1;
+    int fd_fb1 = -1;
+    if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
+	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(FB2_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+
+  	}
+    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+	    fd_def = open(FB2_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+  	}
+  	//it may be modified in mx6x
+
+//    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
+
+    struct fb_var_screeninfo def_info;
+    if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo def_finfo;
+    if(ioctl(fd_def, FBIOGET_FSCREENINFO, &def_finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+   // m_left = 0;
+   // m_top = 0;
+    m_width = def_info.xres;//info.xres;
+    m_height = def_info.yres;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+
+  	info.reserved[0] = def_info.reserved[0];
+  	info.reserved[1] = def_info.reserved[0];
+  	info.reserved[2] = def_info.reserved[0];
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+
+  	info.bits_per_pixel = fmt_to_bpp(m_format);//def_info.bits_per_pixel;
+  	info.nonstd = m_format;
+  	info.red.offset = 0;//def_info.red.offset;
+  	info.red.length = 0;//def_info.red.length;
+  	info.green.offset = 0;//def_info.green.offset;
+  	info.green.length = 0;//def_info.green.length;
+  	info.blue.offset = 0;//def_info.blue.offset;
+  	info.blue.length = 0;//def_info.blue.length;
+  	info.transp.offset = 0;//def_info.transp.offset;
+  	info.transp.length = 0;//def_info.transp.length;
+
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init finfo.smem_len < 0!");
+    	  return -1;
+  	}
+
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;
+  	}
+    //memset(vaddr, 0, fbSize);
+    hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format);
+    int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	}
+  	//do it after switch fb2 to fb1 or fb0
+  	//status = switch_set(fd_def, fd_fb1, m_usage);
+  	close(fd_def);
+  	close(fd_fb1);
+
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+		(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+		(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+		(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+		(mbuffers[i]).format = m_format;
+  	}
+
+  	//pthread_mutex_init(&dev->buf_mutex, NULL);
+#endif
+    status = 0;
+    return status;
+}
+
+int FG_device::uninit()
+{
+	  //int status = -EINVAL;
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+	}
+	munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+    return 0;
+}
+
diff --git a/mx6/hwcomposer/README.android b/mx6/hwcomposer/README.android
new file mode 100755
index 0000000..4aa7203
--- /dev/null
+++ b/mx6/hwcomposer/README.android
@@ -0,0 +1,3 @@
+
+Skeleton for the "hwcomposer" HAL module.
+
diff --git a/mx6/hwcomposer/blit_gpu.cpp b/mx6/hwcomposer/blit_gpu.cpp
new file mode 100755
index 0000000..d7b81c5
--- /dev/null
+++ b/mx6/hwcomposer/blit_gpu.cpp
@@ -0,0 +1,43 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+/*****************************************************************************/
+using namespace android;
+
+blit_gpu::blit_gpu()
+{
+		init();
+}
+
+blit_gpu::~blit_gpu()
+{
+		uninit();
+}
+
+int blit_gpu::init()
+{
+		return 0;
+}
+
+int blit_gpu::uninit()
+{
+		return 0;
+}
+
+int blit_gpu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+		return 0;
+}
diff --git a/mx6/hwcomposer/blit_gpu.h b/mx6/hwcomposer/blit_gpu.h
new file mode 100755
index 0000000..04e86f0
--- /dev/null
+++ b/mx6/hwcomposer/blit_gpu.h
@@ -0,0 +1,42 @@
+#ifndef _BLIT_GPU_H_
+#define _BLIT_GPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+
+class blit_gpu : public blit_device{
+public:  
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_gpu();
+		virtual ~blit_gpu();
+    
+private:
+		int init();
+    int uninit();
+	
+		blit_gpu& operator = (blit_gpu& out);
+		blit_gpu(const blit_gpu& out);  
+    //add private members.		    
+};
+
+
+//int gpu_init(struct blit_device *dev);
+//
+//int gpu_uninit(struct blit_device*dev);
+//
+//int gpu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif
diff --git a/mx6/hwcomposer/blit_ipu.cpp b/mx6/hwcomposer/blit_ipu.cpp
new file mode 100755
index 0000000..24c0fdd
--- /dev/null
+++ b/mx6/hwcomposer/blit_ipu.cpp
@@ -0,0 +1,171 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+using namespace android;
+
+int blit_device::isIPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_IPU);
+}
+
+int blit_device::isGPUDevice(const char *dev_name)
+{
+		return !strcmp(dev_name, BLIT_GPU);
+}
+
+blit_ipu::blit_ipu()
+{
+		init();
+}
+
+blit_ipu::~blit_ipu()
+{
+		uninit();
+}
+
+int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
+{
+		//int status = -EINVAL;
+
+    return 0;
+}
+
+int blit_ipu::uninit()
+{
+	  //int status = -EINVAL;
+
+	  return 0;
+}
+
+static void fill_buffer(char *pbuf, int len)
+{
+    static int k = 0;
+    short * pframe = (short *)pbuf;
+    if(k == 0) {
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0xf800;
+        }
+    }
+
+    if(k == 1){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x001f;
+        }
+    }
+
+    if(k == 2){
+        for(int i=0; i<len; i+=2) {
+            *pframe = 0x07E0;
+        }
+    }
+
+    k = (k+1)%3;
+}
+
+int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+	  int status = -EINVAL;
+	  if(layer == NULL || out_buf == NULL){
+	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
+	  	  return status;
+	  }
+	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
+
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^^^^^^^^^^^^^^^^^^^^^");
+	  hwc_rect_t *src_crop = &(layer->sourceCrop);
+	  hwc_rect_t *disp_frame = &(layer->displayFrame);
+	  private_handle_t *handle = (private_handle_t *)(layer->handle);
+
+    //fill_buffer((char *)(handle->base), handle->size);
+
+	  mIPUInputParam.width = src_crop->right - src_crop->left;
+	  mIPUInputParam.height = src_crop->bottom - src_crop->top;
+	  mIPUInputParam.input_crop_win.pos.x = src_crop->left;
+    mIPUInputParam.input_crop_win.pos.y = src_crop->top;
+    mIPUInputParam.input_crop_win.win_w = src_crop->right - src_crop->left;
+    mIPUInputParam.input_crop_win.win_h = src_crop->bottom - src_crop->top;
+
+    if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= NV12");
+        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }
+    else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= I420");
+        mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+    }
+    else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
+HWCOMPOSER_LOG_RUNTIME("^^^^^^^^handle->format= RGBP");
+       // mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+    }else{
+        HWCOMPOSER_LOG_ERR("Error!Not supported input format %d",handle->format);
+        return status;
+    }
+#if 0
+    if(handle->base != 0) {
+       int *pVal = (int *)handle->base;
+       HWCOMPOSER_LOG_RUNTIME("=========buff[%d]=%x, buff[%d]=%x, phy=%x", 0, pVal[0], 1, pVal[1], handle->phys);
+    }
+#endif
+    mIPUInputParam.user_def_paddr[0] = handle->phys;
+    //out_buf should has width and height to be checked with the display_frame.
+    mIPUOutputParam.fmt = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
+    mIPUOutputParam.show_to_fb = 0;
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^out_buf->format= %x, out->phy_addr=%x, in->phys=%x", out_buf->format, out_buf->phy_addr, handle->phys);
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK) {
+	    mIPUOutputParam.width = out_buf->width;
+	    mIPUOutputParam.height = out_buf->height;
+		mIPUOutputParam.output_win.pos.x = 0;
+		mIPUOutputParam.output_win.pos.y = 0;
+		mIPUOutputParam.output_win.win_w = out_buf->width;
+		mIPUOutputParam.output_win.win_h = out_buf->height;
+    }
+    else {
+	    mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
+	    mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
+	    mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
+	    mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
+	    mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+	    mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+  	}
+//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^^right=%d, left=%d, bottom=%d, top=%d", disp_frame->right, disp_frame->left, disp_frame->bottom, disp_frame->top);
+    mIPUOutputParam.rot = layer->transform;
+    mIPUOutputParam.user_def_paddr[0] = out_buf->phy_addr;
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_init-----in blit_ipu::blit()------\n");
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
+    else
+        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_init failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_buf_update-----in blit_ipu::blit()------\n");
+	  status = mxc_ipu_lib_task_buf_update(&mIPUHandle, handle->phys, out_buf->phy_addr, NULL,NULL,NULL);
+	  if(status < 0) {
+	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_buf_update failed %d",status);
+	  		return status;
+	  }
+HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_uninit-----in blit_ipu::blit()------\n");
+		mxc_ipu_lib_task_uninit(&mIPUHandle);
+		status = 0;
+        HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^end^^^^^^^^^^^^^^^^^^^^");
+	  return status;
+}
diff --git a/mx6/hwcomposer/blit_ipu.h b/mx6/hwcomposer/blit_ipu.h
new file mode 100755
index 0000000..8f641a5
--- /dev/null
+++ b/mx6/hwcomposer/blit_ipu.h
@@ -0,0 +1,52 @@
+#ifndef _BLIT_IPU_H_
+#define _BLIT_IPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+
+#define BLIT_PIXEL_FORMAT_RGB_565  209
+
+class blit_ipu : public blit_device
+{
+public:
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_ipu();
+		virtual ~blit_ipu();
+
+private:
+		ipu_lib_input_param_t  mIPUInputParam;
+    ipu_lib_output_param_t mIPUOutputParam;
+    ipu_lib_handle_t       mIPUHandle;
+//    int                    mIPURet;
+private:
+		int init();
+    int uninit();
+
+		blit_ipu& operator = (blit_ipu& out);
+		blit_ipu(const blit_ipu& out);
+};
+
+
+//int ipu_init(struct blit_device *dev);
+//
+//int ipu_uninit(struct blit_device*dev);
+//
+//int ipu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif // _BLIT_IPU_H_
diff --git a/mx6/hwcomposer/hwc_common.cpp b/mx6/hwcomposer/hwc_common.cpp
new file mode 100755
index 0000000..f0f147d
--- /dev/null
+++ b/mx6/hwcomposer/hwc_common.cpp
@@ -0,0 +1,216 @@
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+}
+/*****************************************************************************/
+using namespace android;
+//int hwc_check_property(hwc_context_t *dev)
+//{
+//    bool bValue = false;
+//    char value[10];
+//    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_TV)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_TV : DISPLAY_MODE_NORMAL;
+//        switchTvOut(dev);
+//        *mode_changed = true;
+//        return 0;
+//    }
+//
+//    bValue = false;
+//    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_DUAL_DISP)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_DUAL_DISP : DISPLAY_MODE_NORMAL;
+//        switchDualDisp(dev);
+//        *mode_changed = true;
+//    }    	
+//		return 0;
+//}
+
+
+unsigned long fmt_to_bpp(unsigned long pixelformat)
+{
+	unsigned long bpp;
+
+	switch (pixelformat)
+	{
+		case OUT_PIX_FMT_RGB565:
+		/*interleaved 422*/
+		case OUT_PIX_FMT_YUYV:
+		case OUT_PIX_FMT_UYVY:
+		/*non-interleaved 422*/
+		case OUT_PIX_FMT_YUV422P:
+		case OUT_PIX_FMT_YVU422P:
+			bpp = 16;
+			break;
+		case OUT_PIX_FMT_BGR24:
+		case OUT_PIX_FMT_RGB24:
+		case OUT_PIX_FMT_YUV444:
+			bpp = 24;
+			break;
+		case OUT_PIX_FMT_BGR32:
+		case OUT_PIX_FMT_BGRA32:
+		case OUT_PIX_FMT_RGB32:
+		case OUT_PIX_FMT_RGBA32:
+		case OUT_PIX_FMT_ABGR32:
+			bpp = 32;
+			break;
+		/*non-interleaved 420*/
+		case OUT_PIX_FMT_YUV420P:
+		case OUT_PIX_FMT_YVU420P:
+		case OUT_PIX_FMT_YUV420P2:
+		case OUT_PIX_FMT_NV12:
+			bpp = 12;
+			break;
+		default:
+			bpp = 8;
+			break;
+	}
+	return bpp;
+}
+
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat)
+{
+    int ret = 0;
+    char * base;
+    int j, screen_size;
+    short * tmp;
+    short color;
+    if((xres<=0)||(yres<=0)||(!frame)) {
+        HWCOMPOSER_LOG_ERR("Error!Not valid parameters in fill_frame_back");
+        return -1;
+    }
+    switch(pixelformat) {
+        case OUT_PIX_FMT_RGB565:
+            memset(frame, 0, frame_size);
+            break;
+        case OUT_PIX_FMT_YUYV:
+        case OUT_PIX_FMT_UYVY:
+            tmp = (short *) frame;
+            if(pixelformat == OUT_PIX_FMT_YUYV)
+               color = 0x8000;
+            else
+               color = 0x80;
+            for(int i = 0; i < frame_size/2;i++, tmp++)
+                *tmp = color;
+            break;
+        case OUT_PIX_FMT_YUV422P:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size; i++, base++)
+                *base = 0x80;
+            break;
+        case OUT_PIX_FMT_YUV420:
+        case OUT_PIX_FMT_YVU420:
+        case OUT_PIX_FMT_NV12:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size/2; i++, base++)
+                 *base = 0x80;
+            break;
+        defaule:
+            HWCOMPOSER_LOG_ERR("Error!Not supported pixel format");
+            ret = -1;
+            break;
+    }
+    return ret;
+}
+
+int blit_dev_open(const char *dev_name, blit_device **device)
+{
+	  int status = -EINVAL;
+	  
+	  int isIPU = blit_device::isIPUDevice(dev_name);	  
+	  if(isIPU) {
+	  	  blit_ipu *dev;
+	  	  dev = new blit_ipu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;
+	  }
+	  
+	  int isGPU = blit_device::isGPUDevice(dev_name);
+	  if(isGPU) {
+	  	  blit_gpu *dev;
+	  	  dev = new blit_gpu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	      	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;	  	  	  
+	  }	  
+	  
+	  return status;
+}
+
+int blit_dev_close(blit_device *dev)
+{
+		delete(dev);
+		return 0;
+}
+
+int output_dev_open(const char *dev_name, output_device **device, int flag)
+{
+   	int is_overlay = output_device::isFGDevice(dev_name);
+HWCOMPOSER_LOG_INFO("!!!!!!!!!!!!!!!!!!!!!!!!!output_dev_open: %s", dev_name);   	
+   	if(is_overlay < 0) {
+   			return HWC_EGL_ERROR;
+   	}
+   	
+    if(is_overlay == 1) {
+HWCOMPOSER_LOG_RUNTIME("******output_dev_open() is_overlay =1");    	
+			  FG_device *dev;
+			  dev = new FG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);					   	
+    		*device = (output_device *)dev;
+    }
+		else {
+			  BG_device *dev;
+			  dev = new BG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);	  	
+    		*device = (output_device *)dev;
+		}
+       
+    return 0;
+}
+
+int output_dev_close(output_device *dev)
+{
+  	delete(dev); 
+  	
+  	return 0;
+}
diff --git a/mx6/hwcomposer/hwc_common.h b/mx6/hwcomposer/hwc_common.h
new file mode 100755
index 0000000..fd9311a
--- /dev/null
+++ b/mx6/hwcomposer/hwc_common.h
@@ -0,0 +1,214 @@
+
+#ifndef _HWC_FSL_H_
+#define _HWC_FSL_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <utils/threads.h>
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include <asm/page.h>
+
+#undef LOG_TAG
+#define LOG_TAG "FslHwcomposer"
+#include <utils/Log.h>
+
+//#define HWCOMPOSER__DEBUG_LOG
+
+#ifdef HWCOMPOSER_DEBUG_LOG
+#define HWCOMPOSER_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define HWCOMPOSER_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define HWCOMPOSER_LOG_RUNTIME(format, ...)
+#define HWCOMPOSER_LOG_FUNC
+#endif
+
+#define HWCOMPOSER_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define HWCOMPOSER_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define HWCOMPOSER_LOG_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+/*****************************************************************************/
+#define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
+#define FB1_DEV_NAME "/dev/graphics/fb1"
+#define FB2_DEV_NAME "/dev/graphics/fb2"
+#define V4L_DEV_NAME "/dev/video16"
+#define MAX_OUTPUT_DISPLAY  10
+
+#define BLIT_IPU "blt_ipu"
+#define BLIT_GPU "blt_gpu"
+
+#define DEFAULT_BUFFERS  3 
+
+using namespace android;
+
+//typedef unsigned long __u32;
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+#define OUT_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define OUT_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define OUT_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define OUT_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+
+#define OUT_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define OUT_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+#define OUT_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define OUT_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define OUT_PIX_FMT_YUV420  fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
+#define OUT_PIX_FMT_YVU420  fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+typedef enum {
+    DISPLAY_MODE_OVERLAY_DISP0 = 0x00000001,
+    DISPLAY_MODE_OVERLAY_DISP1 = 0x00000002,
+    DISPLAY_MODE_OVERLAY_DISP2 = 0x00000004,
+    DISPLAY_MODE_OVERLAY_DISP3 = 0x00000008,
+    DISPLAY_MODE_DISP1 = 0x00000010,
+    DISPLAY_MODE_DISP2 = 0x00000020,
+    DISPLAY_MODE_DISP3 = 0x00000040,
+}DISPLAY_MODE;
+
+//seperate into three groups. one group member can be or with other group member.
+//but the group member can not be or with that in the same group except display group.
+#define GRALLOC_USAGE_OVERLAY0_MASK   0x00300000
+#define GRALLOC_USAGE_OVERLAY1_MASK   0x00C00000
+#define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
+#define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
+
+typedef struct{
+    void *virt_addr;
+    unsigned long phy_addr;
+    unsigned long size;
+    int format;
+    int width;
+    int height;
+    int usage;
+}hwc_buffer;
+
+class output_device
+{
+public:
+		virtual int post(hwc_buffer *);
+		virtual int fetch(hwc_buffer *);
+
+		void setUsage(int usage);
+		int getUsage();
+		int getWidth();
+		int getHeight();
+
+		output_device(const char *dev_name, int usage);
+		virtual ~output_device();
+
+		static int isFGDevice(const char *dev_name);
+
+private:
+		output_device& operator = (output_device& out);
+		output_device(const output_device& out);
+
+protected:
+		int m_dev;
+		//int m_left;
+		//int m_top;
+		int m_usage;
+		int m_width;
+		int m_height;
+		int m_format;
+//		int is_overlay;
+
+		mutable Mutex mLock;
+		hwc_buffer mbuffers[DEFAULT_BUFFERS];
+		unsigned long mbuffer_count;
+		unsigned long mbuffer_cur;
+
+};
+
+//the normal display device
+class BG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		BG_device(const char *dev_name, int usage);
+		virtual ~BG_device();
+
+private:
+		BG_device& operator = (BG_device& out);
+		BG_device(const BG_device& out);
+
+		int init();
+		int uninit();
+
+public:
+		//add private data
+};
+
+//the overlay display device
+class FG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		FG_device(const char *dev_name, int usage);
+		virtual ~FG_device();
+
+private:
+		FG_device& operator = (FG_device& out);
+		FG_device(const FG_device& out);
+
+		int init();
+		int uninit();
+
+private:
+		//add private data
+		//int m_flag; //for display number flag.
+};
+
+class blit_device{
+public:
+		static int isIPUDevice(const char *dev_name);
+		static int isGPUDevice(const char *dev_name);
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
+		virtual ~blit_device(){}
+};
+
+//int FG_init(struct output_device *dev);
+//int FG_uninit(struct output_device *dev);
+//int FG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int FG_post(struct output_device *dev);
+//
+//int BG_init(struct output_device *dev);
+//int BG_uninit(struct output_device *dev);
+//int BG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int BG_post(struct output_device *dev);
+unsigned long fmt_to_bpp(unsigned long pixelformat);
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat);
+int blit_dev_open(const char *dev_name, blit_device **);
+int blit_dev_close(blit_device *);
+
+int output_dev_open(const char *dev_name, output_device **, int);
+int output_dev_close(output_device *);
+
+#endif
diff --git a/mx6/hwcomposer/hwcomposer.cpp b/mx6/hwcomposer/hwcomposer.cpp
new file mode 100755
index 0000000..147a818
--- /dev/null
+++ b/mx6/hwcomposer/hwcomposer.cpp
@@ -0,0 +1,554 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <hardware/hardware.h>
+#include <hardware/overlay.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+struct hwc_context_t {
+    hwc_composer_device_t device;
+    /* our private state goes below here */
+    //now the blit device may only changed in hwc_composer_device open or close.
+    blit_device *blit;
+
+    output_device *m_out[MAX_OUTPUT_DISPLAY];
+    char m_using[MAX_OUTPUT_DISPLAY]; //0 indicates no output_device, 1 indicates related index;
+
+    //the system property for dual display and overlay switch.
+    int display_mode;
+    int display_mode_changed; //the initial value is 0
+};
+
+static int hwc_device_open(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device);
+
+static struct hw_module_methods_t hwc_module_methods = {
+    open: hwc_device_open
+};
+
+hwc_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+        tag: HARDWARE_MODULE_TAG,
+        version_major: 1,
+        version_minor: 0,
+        id: HWC_HARDWARE_MODULE_ID,
+        name: "Sample hwcomposer module",
+        author: "The Android Open Source Project",
+        methods: &hwc_module_methods,
+    }
+};
+
+/*****************************************************************************/
+
+static void dump_layer(hwc_layer_t const* l) {
+    LOGD("\ttype=%d, flags=%08x, handle=%p, tr=%02x, blend=%04x, {%d,%d,%d,%d}, {%d,%d,%d,%d}",
+            l->compositionType, l->flags, l->handle, l->transform, l->blending,
+            l->sourceCrop.left,
+            l->sourceCrop.top,
+            l->sourceCrop.right,
+            l->sourceCrop.bottom,
+            l->displayFrame.left,
+            l->displayFrame.top,
+            l->displayFrame.right,
+            l->displayFrame.bottom);
+}
+
+static int hwc_check_property(hwc_context_t *dev)
+{
+    //bool bValue = false;
+    char value[10];
+    int orignMode = dev->display_mode;
+    /*note:rw.VIDEO_OVERLAY_DISPLAY means the overlay will be combined to which display.
+     *the default value is 0 and it indicates nothing.
+     *if the value is 1 and it indicates combined to display0.
+     *if the value is 2 and it indicates combined to display1.
+    */
+    property_get("rw.VIDEO_OVERLAY_DISPLAY", value, "");
+    dev->display_mode &= ~(DISPLAY_MODE_OVERLAY_DISP0 | DISPLAY_MODE_OVERLAY_DISP1 |
+        				DISPLAY_MODE_OVERLAY_DISP2 | DISPLAY_MODE_OVERLAY_DISP3);
+    if (strcmp(value, "1") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP0;
+    }
+    else if (strcmp(value, "2") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP1;
+    }
+
+		if (strcmp(value, "3") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
+    }
+    else if (strcmp(value, "4") == 0){
+        dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP3;
+    }
+    /*note:rw.VIDEO_DISPLAY means the display device.
+     *the default value is 0 and it indicates nothing.
+     *if the value is 1 and it indicates display1.
+     *if the value is 2 and it indicates display2.
+    */
+    property_get("sys.VIDEO_DISPLAY", value, "");
+    dev->display_mode &= ~(DISPLAY_MODE_DISP1 | DISPLAY_MODE_DISP2);
+    if (strcmp(value, "1") == 0){
+        dev->display_mode |= DISPLAY_MODE_DISP1;
+    }
+    if (strcmp(value, "2") == 0){
+        dev->display_mode |= DISPLAY_MODE_DISP2;
+    }
+
+		if(dev->display_mode ^ orignMode) {
+				dev->display_mode_changed = 1;
+		}
+//HWCOMPOSER_LOG_RUNTIME("*********display_mode=%x, display_mode_changed=%d\n", dev->display_mode, dev->display_mode_changed);
+		return 0;
+}
+
+static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
+{
+	handle->usage &= ~GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+
+	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP0){
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP0;
+			dev->display_mode &= ~DISPLAY_MODE_OVERLAY_DISP0;
+			return 0;
+	}
+	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP1)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP1;
+
+	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP2)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP2;
+	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP3)
+			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP3;
+
+	if(dev->display_mode & DISPLAY_MODE_DISP1){
+			handle->usage |= GRALLOC_USAGE_HWC_DISP1;
+			dev->display_mode &= ~DISPLAY_MODE_DISP1;
+	}
+	if(dev->display_mode & DISPLAY_MODE_DISP2)
+			handle->usage |= GRALLOC_USAGE_HWC_DISP2;
+//HWCOMPOSER_LOG_RUNTIME("************handle->usage=%x", handle->usage);
+	return 0;
+}
+
+/*paramters:
+ * usage: devices need to open.
+ * ufg:devices not open.
+ * puse:index array when device open it need set.
+ *check if the output device is exist.
+ *return 0 indicates exist; 1 indicates not exist.
+*/
+static int checkOutputDevice(struct hwc_context_t *ctx, char *puse, int usage, int *ufg)//return -1 indicate not exist.
+{
+	output_device *out;
+	int uFlag = 0;
+	int usg = 0;
+
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i]) {
+			out = ctx->m_out[i];
+			usg = out->getUsage();
+			if(usg & usage) {
+				uFlag |= (usg & usage);
+				if(puse) puse[i] = 1;
+			}
+		}
+	}
+	if(ufg != NULL)
+		*ufg = usage & ~uFlag;
+
+	return uFlag ^ usage;
+}
+
+static int findOutputDevice(struct hwc_context_t *ctx, int *index, int usage, int *ufg)
+{
+	output_device *out;
+	int uFlag = 0;
+	int usg = 0;
+
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i]) {
+			out = ctx->m_out[i];
+			usg = out->getUsage();
+			if(usg & usage) {
+				uFlag = (usg & usage);
+				*index = i;
+				break;
+			}
+		}
+	}
+	if(ufg != NULL)
+		*ufg |= uFlag;
+
+	return (*ufg) ^ usage;
+}
+
+static int findEmpytIndex(struct hwc_context_t *ctx)
+{
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(!ctx->m_using[i])
+			return i;
+	}
+
+	HWCOMPOSER_LOG_ERR("the output device array not enough big.\n");
+	return -1;
+}
+
+//check the output device and delete unused device instance.
+static void deleteEmtpyIndex(struct hwc_context_t *ctx)
+{
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(!ctx->m_using[i]) {
+			if(ctx->m_out[i]) {
+				output_dev_close(ctx->m_out[i]);
+				ctx->m_out[i] = NULL;
+			}
+		}
+	}
+}
+
+static char* getDeviceName(int usage, int *pUse)
+{
+    if(usage & GRALLOC_USAGE_HWC_DISP1){
+    		*pUse = GRALLOC_USAGE_HWC_DISP1;
+    		return (char *)FB2_DEV_NAME;
+    }
+    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+    		*pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
+    		return (char *)FB1_DEV_NAME;
+    }
+    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+        *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP1;
+        return (char *)FB1_DEV_NAME;
+    }//end else if
+
+    return NULL;
+}
+
+#if 0
+static void setLayerFrame(hwc_layer_t *layer, output_device *out, int usage)
+{
+    if(usage & GRALLOC_USAGE_HWC_DISP1){
+    		layer->displayFrame.left = 0;
+    		layer->displayFrame.top = 0;
+    		layer->displayFrame.right = out->getWidth();
+    		layer->displayFrame.bottom = out->getHeight();
+    }
+//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP0) {
+//    		display_frame =;
+//    }
+//    if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY0_DISP1) {
+//        display_frame =;
+//    }//end else if
+}
+#endif
+
+static int validate_displayFrame(hwc_layer_t *layer)
+{
+    int isValid = 0;
+    hwc_rect_t *disFrame = &(layer->displayFrame);
+    isValid = ((disFrame->left >= 0) && (disFrame->right >= 0) && (disFrame->top >= 0) &&
+            (disFrame->bottom >= 0) && ((disFrame->right - disFrame->left) >= 0) &&
+            ((disFrame->bottom  - disFrame->top) >= 0));
+    return isValid;
+}
+
+static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
+//#if 1
+		//HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---1>>>>>>>>>>>>>>>>>\n");
+		char out_using[MAX_OUTPUT_DISPLAY] = {0};
+
+//		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+//				out_using[i] = m_using[i];
+//		}
+
+		struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
+#if 1
+		if(ctx) {
+			hwc_check_property(ctx);
+		}
+#endif
+    if (list && dev && ((list->flags & HWC_GEOMETRY_CHANGED) || ctx->display_mode_changed)) {
+        for (size_t i=0 ; i<list->numHwLayers ; i++) {
+            //dump_layer(&list->hwLayers[i]);
+            //list->hwLayers[i].compositionType = HWC_FRAMEBUFFER;
+            hwc_layer_t *layer = &list->hwLayers[i];
+            /*
+             *the private_handle_t should expand to have usage and format member.
+            */
+		    if (private_handle_t::validate(layer->handle) < 0) {
+	    		//HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
+	    		continue;
+		    }
+		    //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
+            private_handle_t *handle = (private_handle_t *)(layer->handle);
+            if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
+            	//HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
+            	continue;
+            }
+            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---3>usage=%x, phy=%x>>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
+#if 1
+        	layer->compositionType = HWC_OVERLAY;
+    		//if(handle->usage & GRALLOC_USAGE_HWC_DISP1)
+    		//handle the display frame position for tv out.
+#endif
+#if 1
+        	hwc_modify_property(ctx, handle);
+
+            if(!validate_displayFrame(layer)) {
+                HWCOMPOSER_LOG_INFO("<<<<<<<<<<<<<<<hwc_prepare---3-2>>>>>>>>>>>>>>>>\n");
+                continue;
+            }
+
+            int status = -EINVAL;
+            int index = 0;
+            int retv = 0;
+            int m_usage = 0;
+            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+            //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---3-3>>>>>>>>>>>>>>>>\n");
+            retv = checkOutputDevice(ctx, out_using, i_usage, &m_usage);
+            while(retv && m_usage) {
+		        int ruse = 0;
+		        char *dev_name = NULL;
+				dev_name = getDeviceName(m_usage, &ruse);
+	            m_usage &= ~ruse;
+	            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---4>>>>>>>>>>>>>>>>>\n");
+	            if(dev_name == NULL) {
+					HWCOMPOSER_LOG_INFO("****Warnning: layer buffer usage(%x) does not support!", handle->usage);
+					HWCOMPOSER_LOG_INFO("****Warnning:  the layer buffer will be handled in surfaceflinger");
+					layer->compositionType = HWC_FRAMEBUFFER;
+					continue;
+	            }//end else
+
+	            index = findEmpytIndex(ctx);
+	            if(index == -1) {
+            		HWCOMPOSER_LOG_ERR("Error:findEmpytIndex failed");
+            		return HWC_EGL_ERROR;
+	            }
+	            if(ctx->m_out[index])
+	            		deleteEmtpyIndex(ctx);
+
+		        status = output_dev_open(dev_name, &(ctx->m_out[index]), ruse);
+		        if(status < 0){
+		        	  HWCOMPOSER_LOG_ERR("Error! open output device failed!");
+		        	  continue;
+		        }//end if
+		        out_using[index] = 1;
+		        ctx->m_using[index] = 1;
+		        //setLayerFrame(layer, ctx->m_out[index], ruse);
+            }//end while
+#endif
+        }//end for
+#if 1
+        ctx->display_mode_changed = 0;
+	    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+			if(!out_using[i] && ctx->m_using[i]) {
+				ctx->m_using[i] = 0;
+				deleteEmtpyIndex(ctx);
+			}
+			//ctx->m_using[i] = out_using[i];
+		}
+#endif
+    }//end if
+
+//#endif
+    return 0;
+}
+
+static int releaseAllOutput(struct hwc_context_t *ctx)
+{
+		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_using[i]) {
+						output_dev_close(ctx->m_out[i]);
+						ctx->m_using[i] = 0;
+						ctx->m_out[i] = NULL;
+				}
+		}
+
+		return 0;
+}
+
+static int getActiveOuputDevice(struct hwc_context_t *ctx)
+{
+		int num = 0;
+		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_out[i] && ctx->m_using[i])
+						num ++;
+		}
+
+		return num;
+}
+
+static int hwc_set(hwc_composer_device_t *dev,
+        hwc_display_t dpy,
+        hwc_surface_t sur,
+        hwc_layer_list_t* list)
+{
+		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=1==============\n");
+    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
+    //for (size_t i=0 ; i<list->numHwLayers ; i++) {
+    //    dump_layer(&list->hwLayers[i]);
+    //}
+    //hwc_buffer *outBuff[MAX_OUTPUT_DISPLAY];
+    //when displayhardware do releas function, it will come here.
+#if 1
+    if(ctx && (dpy == NULL) && (sur == NULL) && (list == NULL)) {
+		//close the output device.
+		releaseAllOutput(ctx);
+		ctx->display_mode_changed = 1;
+
+		return 0;
+    }
+#endif
+		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=2==============\n");
+#if 1 
+    EGLBoolean sucess = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
+    if (!sucess) {
+        return HWC_EGL_ERROR;
+    }
+#endif
+    if(list == NULL || dev == NULL) {
+    	return 0;
+    }
+#if 1
+ 		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=3==============\n");
+    if(getActiveOuputDevice(ctx) == 0) {return 0;}//eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur); return 0;}
+
+    int status = -EINVAL;
+	HWCOMPOSER_LOG_RUNTIME("==============hwc_set=4==============\n");
+	hwc_buffer out_buffer[MAX_OUTPUT_DISPLAY];
+	memset(out_buffer, 0, sizeof(out_buffer));
+	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(ctx->m_using[i] && ctx->m_out[i])
+			status = ctx->m_out[i]->fetch(&out_buffer[i]);
+	}
+
+    blit_device *bltdev = ctx->blit;
+    for (size_t i=0 ; i<list->numHwLayers ; i++){
+		hwc_layer_t *layer = &list->hwLayers[i];
+	    if (private_handle_t::validate(layer->handle) < 0) {
+    		//HWCOMPOSER_LOG_INFO("2--it is not a valide buffer handle\n");
+    		continue;
+	    }
+
+        if(!validate_displayFrame(layer)) {
+            continue;
+        }
+
+		private_handle_t *handle = (private_handle_t *)(layer->handle);
+		if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY){
+            int retv = 0;
+            int m_usage = 0;
+            int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+    	    HWCOMPOSER_LOG_RUNTIME("==============hwc_set=5==============\n");
+            do {
+    			output_device *outdev = NULL;
+    			int index = 0;
+        		retv = findOutputDevice(ctx, &index, i_usage, &m_usage);
+                if((index >= 0) && (index < MAX_OUTPUT_DISPLAY)) {
+                	outdev = ctx->m_out[index];
+                }
+    			if(outdev != NULL) {
+    				status = bltdev->blit(layer, &(out_buffer[index]));
+    				if(status < 0){
+    					HWCOMPOSER_LOG_ERR("Error! bltdev->blit() failed!");
+    					continue;
+    				}
+    			}//end if(outdev != NULL)
+            }while(retv);
+
+		}//end if
+    }//end for
+
+    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+				if(ctx->m_using[i]) {
+						status = ctx->m_out[i]->post(&out_buffer[i]);
+						if(status < 0){
+								HWCOMPOSER_LOG_ERR("Error! output device post buffer failed!");
+								continue;
+						}
+				}
+		}
+#endif
+    return 0;
+}
+
+static int hwc_device_close(struct hw_device_t *dev)
+{
+    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
+    if (ctx) {
+    		if(ctx->blit)
+    				blit_dev_close(ctx->blit);
+        releaseAllOutput(ctx);
+        free(ctx);
+    }
+    return 0;
+}
+
+/*****************************************************************************/
+
+static int hwc_device_open(const struct hw_module_t* module, const char* name,
+        struct hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, HWC_HARDWARE_COMPOSER)) {
+        struct hwc_context_t *dev;
+        dev = (hwc_context_t*)malloc(sizeof(*dev));
+
+        /* initialize our state here */
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = hwc_device_close;
+
+        dev->device.prepare = hwc_prepare;
+        dev->device.set = hwc_set;
+
+        *device = &dev->device.common;
+
+        /* our private state goes below here */
+        status = blit_dev_open(BLIT_IPU, &(dev->blit));
+        if(status < 0){
+        	  HWCOMPOSER_LOG_ERR("Error! blit_dev_open failed!");
+        	  goto err_exit;
+        }
+HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_device_open>>>>>>>>>>>>>>>>>\n");
+        return 0;
+err_exit:
+				if(dev){
+						if(dev->blit) {
+								blit_dev_close(dev->blit);
+						}
+					  free(dev);
+				}
+				//status = -EINVAL;
+        /****************************************/
+    }
+    return status;
+}
diff --git a/mx6/hwcomposer/output_device.cpp b/mx6/hwcomposer/output_device.cpp
new file mode 100755
index 0000000..ceff1be
--- /dev/null
+++ b/mx6/hwcomposer/output_device.cpp
@@ -0,0 +1,140 @@
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+
+void output_device::setUsage(int usage)
+{
+    m_usage = usage;
+}
+
+int output_device::getUsage()
+{
+    return m_usage;
+}
+
+int output_device::getWidth()
+{
+    return m_width;
+}
+
+int output_device::getHeight()
+{
+    return m_height;
+}
+
+output_device::output_device(const char *dev_name, int usage)
+{
+    m_dev = open(dev_name, O_RDWR | O_NONBLOCK, 0);
+    if(m_dev < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device Open fb device %s failed!", dev_name);
+    }
+    m_usage = usage;
+}
+
+output_device::~output_device()
+{
+	if(m_dev > 0) {
+        close(m_dev);
+	}
+}
+
+int output_device::isFGDevice(const char *dev_name)
+{
+    int status = -EINVAL;
+    int fd = -1;
+    char fb_usage[32];
+    char fb_name[32];
+    int fd_n = 0;
+    int size = 0;
+    int is_overlay = 0;
+    char *psname;
+
+    memset(fb_name, 0, sizeof(fb_name));
+    psname = (char *)dev_name;
+    psname += (strlen(dev_name) - 1);
+    strcpy(fb_name, "/sys/class/graphics/fb");
+    strcat(fb_name, psname);
+    strcat(fb_name, "/name");
+    fd_n = open(fb_name, O_RDONLY, 0);
+    //fd_n = open("/sys/class/graphics/fb0/name", O_RDONLY, 0);
+    if(fd_n < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice  open %s failed!", fb_name);
+		return -1;
+    }
+    memset(fb_usage, 0, sizeof(fb_usage));
+    size = read(fd_n, fb_usage, sizeof(fb_usage));
+    if(size < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice read /sys/class/graphics/fb0/name failed!");
+		return -1;
+    }
+    close(fd_n);
+HWCOMPOSER_LOG_INFO("output_device::isFGDevice===%s, %s, %s", dev_name, fb_name, fb_usage);
+    if(strstr(fb_usage, "FG"))
+    	return 1;
+ 	return 0;
+}
+
+int output_device::fetch(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::fetch invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+
+	  Mutex::Autolock _l(mLock);
+	  buf->size = (mbuffers[mbuffer_cur]).size;
+	  buf->virt_addr = (mbuffers[mbuffer_cur]).virt_addr;
+	  buf->phy_addr = (mbuffers[mbuffer_cur]).phy_addr;
+	  buf->width = m_width;
+	  buf->height = m_height;
+	  buf->usage = m_usage;
+	  buf->format = m_format;
+	  //dev->buffer_cur = (dev->buffer_cur + 1) % DEFAULT_BUFFERS;
+
+	  return 0;
+}
+
+int output_device::post(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_post() invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()############");
+
+	Mutex::Autolock _l(mLock);
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post VSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post FSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    info.yoffset = ((unsigned long)buf->virt_addr - (unsigned long)(mbuffers[0]).virt_addr) / finfo.line_length;
+    //info.yoffset = ((info.yres_virtual * finfo.line_length)/ DEFAULT_BUFFERS) * mbuffer_cur;
+    mbuffer_cur = (mbuffer_cur + 1) % DEFAULT_BUFFERS;
+    info.activate = FB_ACTIVATE_VBL;
+//HWCOMPOSER_LOG_RUNTIME("#######yoffset=%d, mbuffer_cur=%d######", info.yoffset, mbuffer_cur);
+    ioctl(m_dev, FBIOPAN_DISPLAY, &info);
+
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()##end##########");
+    return 0;
+}
diff --git a/mx6/libgralloc/allocator.cpp b/mx6/libgralloc/allocator.cpp
new file mode 100755
index 0000000..4dad6a1
--- /dev/null
+++ b/mx6/libgralloc/allocator.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/log.h>
+
+#include "allocator.h"
+
+
+// align all the memory blocks on a cache-line boundary
+const int SimpleBestFitAllocator::kMemoryAlign = 32;
+
+SimpleBestFitAllocator::SimpleBestFitAllocator()
+    : mHeapSize(0)
+{
+}
+
+SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
+    : mHeapSize(0)
+{
+    setSize(size);
+}
+
+SimpleBestFitAllocator::~SimpleBestFitAllocator()
+{
+    while(!mList.isEmpty()) {
+        delete mList.remove(mList.head());
+    }
+}
+
+ssize_t SimpleBestFitAllocator::setSize(size_t size)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize != 0) return -EINVAL;
+    size_t pagesize = getpagesize();
+    mHeapSize = ((size + pagesize-1) & ~(pagesize-1));
+    chunk_t* node = new chunk_t(0, mHeapSize / kMemoryAlign);
+    mList.insertHead(node);
+    return size;
+}
+    
+    
+size_t SimpleBestFitAllocator::size() const
+{
+    return mHeapSize;
+}
+
+ssize_t SimpleBestFitAllocator::allocate(size_t size, uint32_t flags)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    ssize_t offset = alloc(size, flags);
+    return offset;
+}
+
+ssize_t SimpleBestFitAllocator::deallocate(size_t offset)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    chunk_t const * const freed = dealloc(offset);
+    if (freed) {
+        return 0;
+    }
+    return -ENOENT;
+}
+
+ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
+{
+    if (size == 0) {
+        return 0;
+    }
+    size = (size + kMemoryAlign-1) / kMemoryAlign;
+    chunk_t* free_chunk = 0;
+    chunk_t* cur = mList.head();
+
+    size_t pagesize = getpagesize();
+    while (cur) {
+        int extra = ( -cur->start & ((pagesize/kMemoryAlign)-1) ) ;
+
+        // best fit
+        if (cur->free && (cur->size >= (size+extra))) {
+            if ((!free_chunk) || (cur->size < free_chunk->size)) {
+                free_chunk = cur;
+            }
+            if (cur->size == size) {
+                break;
+            }
+        }
+        cur = cur->next;
+    }
+
+    if (free_chunk) {
+        const size_t free_size = free_chunk->size;
+        free_chunk->free = 0;
+        free_chunk->size = size;
+        if (free_size > size) {
+            int extra = ( -free_chunk->start & ((pagesize/kMemoryAlign)-1) ) ;
+            if (extra) {
+                chunk_t* split = new chunk_t(free_chunk->start, extra);
+                free_chunk->start += extra;
+                mList.insertBefore(free_chunk, split);
+            }
+
+            LOGE_IF(((free_chunk->start*kMemoryAlign)&(pagesize-1)),
+                    "page is not aligned!!!");
+
+            const ssize_t tail_free = free_size - (size+extra);
+            if (tail_free > 0) {
+                chunk_t* split = new chunk_t(
+                        free_chunk->start + free_chunk->size, tail_free);
+                mList.insertAfter(free_chunk, split);
+            }
+        }
+        return (free_chunk->start)*kMemoryAlign;
+    }
+    return -ENOMEM;
+}
+
+SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
+{
+    start = start / kMemoryAlign;
+    chunk_t* cur = mList.head();
+    while (cur) {
+        if (cur->start == start) {
+            LOG_FATAL_IF(cur->free,
+                "block at offset 0x%08lX of size 0x%08lX already freed",
+                cur->start*kMemoryAlign, cur->size*kMemoryAlign);
+
+            // merge freed blocks together
+            chunk_t* freed = cur;
+            cur->free = 1;
+            do {
+                chunk_t* const p = cur->prev;
+                chunk_t* const n = cur->next;
+                if (p && (p->free || !cur->size)) {
+                    freed = p;
+                    p->size += cur->size;
+                    mList.remove(cur);
+                    delete cur;
+                }
+                cur = n;
+            } while (cur && cur->free);
+
+            #ifndef NDEBUG
+                if (!freed->free) {
+                    dump_l("dealloc (!freed->free)");
+                }
+            #endif
+            LOG_FATAL_IF(!freed->free,
+                "freed block at offset 0x%08lX of size 0x%08lX is not free!",
+                freed->start * kMemoryAlign, freed->size * kMemoryAlign);
+
+            return freed;
+        }
+        cur = cur->next;
+    }
+    return 0;
+}
diff --git a/mx6/libgralloc/allocator.h b/mx6/libgralloc/allocator.h
new file mode 100755
index 0000000..b0d89e9
--- /dev/null
+++ b/mx6/libgralloc/allocator.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef GRALLOC_ALLOCATOR_H_
+#define GRALLOC_ALLOCATOR_H_
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "gr.h"
+
+// ----------------------------------------------------------------------------
+
+/*
+ * A simple templatized doubly linked-list implementation
+ */
+
+template <typename NODE>
+class LinkedList
+{
+    NODE*  mFirst;
+    NODE*  mLast;
+
+public:
+                LinkedList() : mFirst(0), mLast(0) { }
+    bool        isEmpty() const { return mFirst == 0; }
+    NODE const* head() const { return mFirst; }
+    NODE*       head() { return mFirst; }
+    NODE const* tail() const { return mLast; }
+    NODE*       tail() { return mLast; }
+
+    void insertAfter(NODE* node, NODE* newNode) {
+        newNode->prev = node;
+        newNode->next = node->next;
+        if (node->next == 0) mLast = newNode;
+        else                 node->next->prev = newNode;
+        node->next = newNode;
+    }
+
+    void insertBefore(NODE* node, NODE* newNode) {
+         newNode->prev = node->prev;
+         newNode->next = node;
+         if (node->prev == 0)   mFirst = newNode;
+         else                   node->prev->next = newNode;
+         node->prev = newNode;
+    }
+
+    void insertHead(NODE* newNode) {
+        if (mFirst == 0) {
+            mFirst = mLast = newNode;
+            newNode->prev = newNode->next = 0;
+        } else {
+            newNode->prev = 0;
+            newNode->next = mFirst;
+            mFirst->prev = newNode;
+            mFirst = newNode;
+        }
+    }
+    
+    void insertTail(NODE* newNode) {
+        if (mLast == 0) {
+            insertHead(newNode);
+        } else {
+            newNode->prev = mLast;
+            newNode->next = 0;
+            mLast->next = newNode;
+            mLast = newNode;
+        }
+    }
+
+    NODE* remove(NODE* node) {
+        if (node->prev == 0)    mFirst = node->next;
+        else                    node->prev->next = node->next;
+        if (node->next == 0)    mLast = node->prev;
+        else                    node->next->prev = node->prev;
+        return node;
+    }
+};
+
+class SimpleBestFitAllocator
+{
+public:
+
+    SimpleBestFitAllocator();
+    SimpleBestFitAllocator(size_t size);
+    ~SimpleBestFitAllocator();
+
+    ssize_t     setSize(size_t size);
+
+    ssize_t     allocate(size_t size, uint32_t flags = 0);
+    ssize_t     deallocate(size_t offset);
+    size_t      size() const;
+
+private:
+    struct chunk_t {
+        chunk_t(size_t start, size_t size) 
+            : start(start), size(size), free(1), prev(0), next(0) {
+        }
+        size_t              start;
+        size_t              size : 28;
+        int                 free : 4;
+        mutable chunk_t*    prev;
+        mutable chunk_t*    next;
+    };
+
+    ssize_t  alloc(size_t size, uint32_t flags);
+    chunk_t* dealloc(size_t start);
+
+    static const int    kMemoryAlign;
+    mutable Locker      mLock;
+    LinkedList<chunk_t> mList;
+    size_t              mHeapSize;
+};
+
+#endif /* GRALLOC_ALLOCATOR_H_ */
diff --git a/mx6/libgralloc/framebuffer.cpp b/mx6/libgralloc/framebuffer.cpp
new file mode 100755
index 0000000..723b628
--- /dev/null
+++ b/mx6/libgralloc/framebuffer.cpp
@@ -0,0 +1,1697 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright 2010-2011 Freescale Semiconductor Inc. */
+
+#include <sys/mman.h>
+
+#include <dlfcn.h>
+
+#include <cutils/ashmem.h>
+#include <cutils/log.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/properties.h>
+
+#if HAVE_ANDROID_OS
+#include <linux/fb.h>
+#include <linux/mxcfb.h>
+#include <linux/videodev.h>
+#include <sys/mman.h>
+
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+} 
+
+#endif
+#include <GLES/gl.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+#include "gralloc_priv.h"
+#include "gr.h"
+#define  MAX_RECT_NUM   20
+/*****************************************************************************/
+
+// numbers of buffers for page flipping
+#define NUM_BUFFERS 3
+
+enum {
+    PAGE_FLIP = 0x00000001,
+    LOCKED = 0x00000002
+};
+
+struct fb_context_t {
+    framebuffer_device_t  device;
+#ifdef FSL_EPDC_FB
+    //Partial udate feature
+    bool rect_update;
+    int count;      //count need less than MAX_RECT_NUM ;
+    int updatemode[20];
+    int partial_left[20];
+    int partial_top[20];
+    int partial_width[20];
+    int partial_height[20];
+#endif
+#ifdef SECOND_DISPLAY_SUPPORT
+    bool sec_display_inited;
+    int sec_fp;
+    int sec_disp_w;
+    int sec_disp_h;
+    int sec_disp_base;
+    int sec_disp_phys;
+    int sec_frame_size;
+    int sec_disp_next_buf;
+    struct fb_var_screeninfo sec_info;
+    struct fb_fix_screeninfo sec_finfo;
+    struct framebuffer_device_t* dev;
+    buffer_handle_t buffer;
+    sem_t sec_display_begin;
+    sem_t sec_display_end;
+    pthread_t thread_id;
+    C2D_CONTEXT c2dctx;
+    int sec_rotation;
+    int cleancount;
+    int mRotate;
+#endif
+};
+
+static int nr_framebuffers;
+static int no_ipu = 0;
+
+#ifdef SECOND_DISPLAY_SUPPORT
+#define MAX_SEC_DISP_WIDTH (1024)
+#define MAX_SEC_DISP_HEIGHT (1024)
+static int mapSecFrameBuffer(fb_context_t* ctx);
+static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx);
+static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx);
+void * secDispShowFrames(void * arg);
+#endif
+
+#ifdef FSL_EPDC_FB
+#define WAVEFORM_MODE_INIT                      0x0   // Screen goes to white (clears)
+#define WAVEFORM_MODE_DU                        0x1   // Grey->white/grey->black
+#define WAVEFORM_MODE_GC16                      0x2   // High fidelity (flashing)
+#define WAVEFORM_MODE_GC4                       0x3   //
+//#define WAVEFORM_MODE_AUTO                    257  // defined in mxcfb.h
+
+
+#define EINK_WAVEFORM_MODE_INIT      0x00000000
+#define EINK_WAVEFORM_MODE_DU        0x00000001
+#define EINK_WAVEFORM_MODE_GC16      0x00000002
+#define EINK_WAVEFORM_MODE_GC4       0x00000003
+#define EINK_WAVEFORM_MODE_AUTO      0x00000004
+#define EINK_WAVEFORM_MODE_MASK      0x0000000F
+#define EINK_AUTO_MODE_REGIONAL      0x00000000
+#define EINK_AUTO_MODE_AUTOMATIC     0x00000010
+#define EINK_AUTO_MODE_MASK          0x00000010
+#define EINK_UPDATE_MODE_PARTIAL     0x00000000
+#define EINK_UPDATE_MODE_FULL        0x00000020
+#define EINK_UPDATE_MODE_MASK        0x00000020
+#define EINK_WAIT_MODE_NOWAIT        0x00000000
+#define EINK_WAIT_MODE_WAIT          0x00000040
+#define EINK_WAIT_MODE_MASK          0x00000040
+#define EINK_COMBINE_MODE_NOCOMBINE  0x00000000
+#define EINK_COMBINE_MODE_COMBINE    0x00000080
+#define EINK_COMBINE_MODE_MASK       0x00000080
+#define EINK_DITHER_MODE_NODITHER    0x00000000
+#define EINK_DITHER_MODE_DITHER      0x00000100
+#define EINK_DITHER_MODE_MASK        0x00000100
+#define EINK_INVERT_MODE_NOINVERT    0x00000000
+#define EINK_INVERT_MODE_INVERT      0x00000200
+#define EINK_INVERT_MODE_MASK        0x00000200
+#define EINK_CONVERT_MODE_NOCONVERT  0x00000000
+#define EINK_CONVERT_MODE_CONVERT    0x00000400
+#define EINK_CONVERT_MODE_MASK       0x00000400
+
+#define EINK_DEFAULT_MODE            0x00000004
+
+__u32 marker_val = 1;
+static void update_to_display(int left, int top, int width, int height, int updatemode, int fb_dev)
+{
+	struct mxcfb_update_data upd_data;
+	int retval;
+	bool wait_for_complete;
+	int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+	memset(&upd_data, 0, sizeof(mxcfb_update_data));
+
+    LOGI("update_to_display:left=%d, top=%d, width=%d, height=%d updatemode=%d\n", left, top, width, height,updatemode);
+
+
+    if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_DU)
+	   upd_data.waveform_mode = WAVEFORM_MODE_DU;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC4)
+	   upd_data.waveform_mode = WAVEFORM_MODE_GC4;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC16)
+	   upd_data.waveform_mode = WAVEFORM_MODE_GC16;
+	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_AUTO)
+	   upd_data.waveform_mode = WAVEFORM_MODE_AUTO;
+	else 
+        LOGI("waveform_mode  wrong\n");
+	   
+    if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_REGIONAL)
+        auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+    else if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_AUTOMATIC)
+        auto_update_mode = AUTO_UPDATE_MODE_AUTOMATIC_MODE;
+    else 
+        LOGI("wait_for_complete  wrong\n");
+        
+    if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_PARTIAL)
+        upd_data.update_mode = UPDATE_MODE_PARTIAL;
+    else if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_FULL)
+        upd_data.update_mode = UPDATE_MODE_FULL;
+    else
+        LOGI("update_mode  wrong\n");
+
+    if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_NOWAIT)
+        wait_for_complete = false;
+    else if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_WAIT)
+        wait_for_complete = true;
+    else 
+        LOGI("wait_for_complete  wrong\n");
+
+    if((updatemode & EINK_INVERT_MODE_MASK) == EINK_INVERT_MODE_INVERT)
+	{
+	   upd_data.flags |= EPDC_FLAG_ENABLE_INVERSION;
+       LOGI("invert mode \n");
+    }
+
+	retval = ioctl(fb_dev, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
+	if (retval < 0) {
+		LOGI("set auto update mode failed.  Error = 0x%x", retval);
+	}    
+    
+    upd_data.temp = 24; //the temperature is get from linux team
+	upd_data.update_region.left = left;
+	upd_data.update_region.width = width;
+	upd_data.update_region.top = top;
+	upd_data.update_region.height = height;
+
+	if (wait_for_complete) {
+		/* Get unique marker value */
+		upd_data.update_marker = marker_val++;
+	} else {
+		upd_data.update_marker = 0;
+	}
+
+	retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
+	while (retval < 0) {
+		/* We have limited memory available for updates, so wait and
+		 * then try again after some updates have completed */
+		usleep(300000);
+		retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
+        LOGI("MXCFB_SEND_UPDATE  retval = 0x%x try again maybe", retval);
+	}
+
+	if (wait_for_complete) {
+		/* Wait for update to complete */
+		retval = ioctl(fb_dev, MXCFB_WAIT_FOR_UPDATE_COMPLETE, &upd_data.update_marker);
+		if (retval < 0) {
+			LOGI("Wait for update complete failed.  Error = 0x%x", retval);
+		}
+	}
+
+
+}
+#endif
+
+
+sem_t * fslwatermark_sem_open()
+{
+    int fd;
+    int ret;
+    sem_t *pSem = NULL;
+    char *shm_path, shm_file[256];
+
+    shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */ 
+
+    if (shm_path == NULL)
+        strcpy(shm_file, "/dev/shm");   /* default path */
+    else
+        strcpy(shm_file, shm_path);
+
+    strcat(shm_file, "/"); 
+    strcat(shm_file, "codec.shm");
+
+    fd = open(shm_file, O_RDWR, 0666);
+    if (fd < 0) { 
+        /* first thread/process need codec protection come here */
+        fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0666);
+       if(fd < 0)
+       {
+           return NULL;
+       }
+       ftruncate(fd, sizeof(sem_t));
+
+       /* map the semaphore variant in the file */ 
+       pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+       if((void *)(-1) == pSem)
+       {
+           return NULL;
+       }
+       /* do the semaphore initialization */
+       ret = sem_init(pSem, 0, 1);
+       if(-1 == ret)
+       {
+           return NULL;
+       }
+    }
+    else
+      pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+    close(fd);
+
+    return pSem;
+}
+
+
+/*****************************************************************************/
+
+static int fb_setSwapInterval(struct framebuffer_device_t* dev,
+            int interval)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
+        return -EINVAL;
+    // FIXME: implement fb_setSwapInterval
+    return 0;
+}
+
+#ifdef FSL_EPDC_FB
+static int fb_setUpdateRect(struct framebuffer_device_t* dev,
+        int* left, int* top, int* width, int* height, int* updatemode, int count)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if(count > MAX_RECT_NUM)
+    {
+        LOGE("count > MAX_RECT_NUM in fb_setUpdateRect\n");
+        return -EINVAL;
+    }
+
+    ctx->rect_update      = true;
+    ctx->count            = 0;
+    for(int i=0; i < count; i++)
+    {
+        if (((width[i]|height[i]) <= 0) || ((left[i]|top[i])<0))  return -EINVAL;
+        ctx->updatemode[i]       = updatemode[i];
+        ctx->partial_left[i]     = left[i];
+        ctx->partial_top[i]      = top[i];
+        ctx->partial_width[i]    = width[i];
+        ctx->partial_height[i]   = height[i];
+    }
+    ctx->count            = count;
+    return 0;
+}
+#else
+static int fb_setUpdateRect(struct framebuffer_device_t* dev,
+        int l, int t, int w, int h)
+{
+    if (((w|h) <= 0) || ((l|t)<0))
+        return -EINVAL;
+    return 0;
+}
+
+#ifdef SECOND_DISPLAY_SUPPORT
+static int fb_setSecRotation(struct framebuffer_device_t* dev,int secRotation)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    //LOGI("fb_setSecRotation %d",secRotation);
+    if((ctx->sec_rotation != secRotation)&&(ctx->sec_disp_base != 0))      
+       memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+    ctx->sec_rotation = secRotation;
+    switch(secRotation)
+    {
+    case 4:
+       ctx->mRotate = 90;
+       break;
+    case 3:
+       ctx->mRotate = 180;
+       break;
+    case 7:
+       ctx->mRotate = 270;
+       break;
+    case 0:
+    default:
+       ctx->mRotate = 0;
+       break;
+    }
+    return 0;
+}
+#endif
+#endif
+
+
+
+static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+    if (private_handle_t::validate(buffer) < 0)
+        return -EINVAL;
+
+    fb_context_t* ctx = (fb_context_t*)dev;
+
+    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+    if (m->currentBuffer) {
+        m->base.unlock(&m->base, m->currentBuffer);
+        m->currentBuffer = 0;
+    }
+
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+
+        m->base.lock(&m->base, buffer, 
+                private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), NULL);
+
+        const size_t offset = hnd->base - m->framebuffer->base;
+        m->info.activate = FB_ACTIVATE_VBL;
+        m->info.yoffset = offset / m->finfo.line_length;
+
+        #ifdef SECOND_DISPLAY_SUPPORT
+        //Check the prop rw.SECOND_DISPLAY_CONNECTED
+        char value[PROPERTY_VALUE_MAX];
+     
+        property_get("rw.SECOND_DISPLAY_CONNECTED", value, "");
+        if (strcmp(value, "1") == 0) {
+            if(!ctx->sec_display_inited) {
+                //Init the second display
+                if(mapSecFrameBuffer(ctx)== 0)
+                {    
+                    ctx->sec_display_inited = true;
+                    c2dCreateContext(&ctx->c2dctx); 
+
+                    sem_init(&ctx->sec_display_begin, 0, 0);
+                    sem_init(&ctx->sec_display_end, 0, 0);
+                     
+                    pthread_create(&ctx->thread_id, NULL, &secDispShowFrames, (void *)ctx);
+                                        
+                    //Set the prop rw.SECOND_DISPLAY_ENABLED to 1
+                    LOGI("sys.SECOND_DISPLAY_ENABLED Set to 1");
+                    property_set("sys.SECOND_DISPLAY_ENABLED", "1");
+                }
+            }
+
+            if(ctx->sec_display_inited) {
+                //Resize the primary display to the second display
+                ctx->dev = dev;
+                ctx->buffer = buffer;
+                sem_post(&ctx->sec_display_begin);
+            }
+        }
+        else{
+            if(ctx->sec_display_inited) {
+                
+                ctx->sec_display_inited = false;
+                
+                sem_post(&ctx->sec_display_begin);
+                sem_wait(&ctx->sec_display_end);
+                
+                sem_destroy(&ctx->sec_display_begin);
+                sem_destroy(&ctx->sec_display_end);
+                
+                if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
+                
+                //Set the prop rw.SECOND_DISPLAY_ENABLED to 0
+                LOGI("Switch back to display 0");
+                LOGI("sys.SECOND_DISPLAY_ENABLED Set to 0");
+                property_set("sys.SECOND_DISPLAY_ENABLED", "0");
+                memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+                //unmap the sec_disp_base
+                munmap((void *)ctx->sec_disp_base, ctx->sec_frame_size*nr_framebuffers);
+                ctx->sec_disp_base = 0;
+                //DeInit the second display
+                if(ctx->sec_fp) {
+                    int fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0); 
+                    if(fp_property >= 0) {
+                        char overlayStr[32];
+                        int blank;
+                        int fb2_fp;
+			struct fb_var_screeninfo fb0_var;
+
+                        blank = 1;
+
+                        fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
+                        if (fb2_fp < 0){
+                            LOGE("Error!Cannot open the /dev/graphics/fb2");
+                        }
+                        else{
+                            if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
+                        		LOGI("Error!BLANK FB2 failed!\n");
+                        	}
+                            close(fb2_fp);
+                        }
+
+                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB1 failed!\n");
+                    	}
+                    
+                        if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB0 failed!\n");
+                    	}
+
+                        memset(overlayStr, 0 ,32);
+                        strcpy(overlayStr, "1-layer-fb\n");
+                        LOGI("WRITE 1-layer-fb to fb1/fsl_disp_property");
+                        write(fp_property, overlayStr, strlen(overlayStr)+1);
+                        close(fp_property);
+
+                        blank = FB_BLANK_POWERDOWN;
+                    	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!BLANK FB1 failed!\n");
+                    	}
+                        blank = FB_BLANK_UNBLANK;
+                    	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+                    		LOGI("Error!UNBLANK FB0 failed!\n");
+                    	}
+
+			if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO,
+				  &fb0_var) < 0) {
+                            LOGE("Error!Cannot get var info for fb0");
+			}
+
+			if (fb0_var.bits_per_pixel == 32) {
+				struct mxcfb_loc_alpha l_alpha;
+
+				l_alpha.enable = true;
+				l_alpha.alpha_in_pixel = true;
+				if (ioctl(m->framebuffer->fd, MXCFB_SET_LOC_ALPHA,
+				            &l_alpha) < 0) {
+				    LOGE("Error!MXCFB_SET_LOC_ALPHA failed!");
+				}
+			} else {
+				struct mxcfb_gbl_alpha gbl_alpha;
+	                        struct mxcfb_color_key key;
+
+				gbl_alpha.alpha = 255;
+				gbl_alpha.enable = 1;
+				if (ioctl(m->framebuffer->fd, MXCFB_SET_GBL_ALPHA,
+					  &gbl_alpha) < 0) {
+				    LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
+				}
+
+	                        key.enable = 1;
+	                        key.color_key = 0x00000000; // Black
+	                        LOGI("MXCFB_SET_CLR_KEY");
+	                        if( ioctl(m->framebuffer->fd, MXCFB_SET_CLR_KEY,
+					  &key) < 0)
+	                        {
+	                            LOGE("Error!MXCFB_SET_CLR_KEY for fb0");
+	                        }
+			}
+                    }
+                    close(ctx->sec_fp);
+                    ctx->sec_fp = 0;
+                }
+            }
+        }
+
+        #endif
+
+        if (ioctl(m->framebuffer->fd, FBIOPAN_DISPLAY, &m->info) == -1) {
+            LOGE("FBIOPAN_DISPLAY failed");
+            m->base.unlock(&m->base, buffer); 
+            return -errno;
+        }
+
+    #ifdef SECOND_DISPLAY_SUPPORT
+        if(ctx->sec_display_inited) sem_wait(&ctx->sec_display_end);
+    #endif
+
+#ifdef FSL_EPDC_FB
+        if(ctx->rect_update) {
+            for(int i=0; i < ctx->count; i++)
+            {
+                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
+                              ctx->partial_width[i],ctx->partial_height[i],
+                              ctx->updatemode[i],m->framebuffer->fd);
+            }
+
+            ctx->rect_update = false;
+        }
+        else{
+            update_to_display(0,0,m->info.xres,m->info.yres,EINK_DEFAULT_MODE,m->framebuffer->fd);
+        }
+#endif
+
+        m->currentBuffer = buffer;
+        
+    } else {
+        // If we can't do the page_flip, just copy the buffer to the front 
+        // FIXME: use copybit HAL instead of memcpy
+        
+        void* fb_vaddr;
+        void* buffer_vaddr;
+        
+        m->base.lock(&m->base, m->framebuffer, 
+                GRALLOC_USAGE_SW_WRITE_RARELY, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
+                &fb_vaddr);
+
+        m->base.lock(&m->base, buffer, 
+                GRALLOC_USAGE_SW_READ_RARELY, 
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
+                &buffer_vaddr);
+
+        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres));
+
+#ifdef FSL_EPDC_FB
+        if(ctx->rect_update) {
+            for(int i=0; i < ctx->count; i++)
+            {
+                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
+                              ctx->partial_width[i],ctx->partial_height[i],
+                              ctx->updatemode[i],m->framebuffer->fd);
+            }
+
+            ctx->rect_update = false;
+        }
+        else{
+            update_to_display(0,0,m->info.xres,m->info.yres, EINK_DEFAULT_MODE ,m->framebuffer->fd);
+        }
+#endif
+
+        m->base.unlock(&m->base, buffer); 
+        m->base.unlock(&m->base, m->framebuffer); 
+    }
+    
+    return 0;
+}
+
+static int fb_compositionComplete(struct framebuffer_device_t* dev)
+{
+    glFinish();
+    return 0;
+}
+
+/*****************************************************************************/
+#define SINGLE_DISPLAY_CAPABILITY  (1920 * 1080 * 60)
+#define DUAL_DISPLAY_CAPABILITY    (1920 * 1080 * 30)
+
+typedef struct
+{
+	char* start;
+	char* end;
+	int width;
+	int height;
+	int freq;
+}
+disp_mode;
+
+static int str2int(char *p)
+{
+	int val = 0;
+	if(!p) return -1;
+
+	while(p[0] >= '0' && p[0] <= '9')
+	{
+		val = val * 10 + p[0] - '0';
+		p++;
+	}
+
+	return val;
+}
+
+typedef enum {
+    CHECK_NEXT_STATE,
+    FIND_WIDTH_STATE,
+    FIND_JOINT_STATE,
+    FIND_HEIGHT_STATE,
+    PREFIX_FREQ_STATE,
+    FREQUENCY_STATE,
+    FIND_NEWLINE_STATE
+}
+read_state;
+
+static disp_mode disp_mode_list[128];
+static int disp_mode_compare( const void *arg1, const void *arg2)
+{
+	disp_mode *dm1 = (disp_mode *)arg1;
+	disp_mode *dm2 = (disp_mode *)arg2;
+
+	if(dm1->width * dm1->height > dm2->width * dm2->height) return -1;
+	if(dm1->width * dm1->height == dm2->width * dm2->height)
+	{
+		return dm1->freq > dm2->freq ? -1 : 1;
+	}
+
+	return 1;
+}
+static char* find_available_mode(const char *mode_list, int dual_disp)
+{
+	int disp_threshold = 0;
+	int i,disp_mode_count = 0;
+	read_state state = CHECK_NEXT_STATE;
+	char *p = (char *)mode_list;
+
+    if(!p) return NULL;
+
+	while(p[0])
+	{
+		switch(state)
+		{
+		case CHECK_NEXT_STATE:
+			if(!strncmp(p, "D:", 2)
+				|| !strncmp(p, "S:", 2)
+				|| !strncmp(p, "U:", 2)
+				|| !strncmp(p, "V:", 2))
+			{
+				disp_mode_list[disp_mode_count].start = p;
+				state = FIND_WIDTH_STATE;
+				p+=2;
+			}
+			else p++;
+			break;
+		case FIND_WIDTH_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].width = str2int(p);
+				state = FIND_JOINT_STATE;
+			}
+			p++;
+			break;
+		case FIND_JOINT_STATE:
+			if(p[0] == 'x' || p[0] == 'X')
+			{
+				state = FIND_HEIGHT_STATE;
+			}
+			p++;
+			break;
+		case FIND_HEIGHT_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].height = str2int(p);
+				state = PREFIX_FREQ_STATE;
+			}
+			p++;
+			break;
+		case PREFIX_FREQ_STATE:
+			if(!strncmp(p, "p-", 2) || !strncmp(p, "i-", 2))
+			{
+				state = FREQUENCY_STATE;
+				p+=2;
+			}
+			else p++;
+			break;
+		case  FREQUENCY_STATE:
+			if(p[0]>='0' && p[0]<='9')
+			{
+				disp_mode_list[disp_mode_count].freq = str2int(p);
+				state = FIND_NEWLINE_STATE;
+			}
+			p++;
+			break;
+		case FIND_NEWLINE_STATE:
+			if(p[0] == '\n')
+			{
+				disp_mode_list[disp_mode_count++].end = p+1;
+				state = CHECK_NEXT_STATE;
+                if(disp_mode_count >= sizeof(disp_mode_list)/sizeof(disp_mode_list[0])) goto check_mode_end;
+			}
+			p++;
+			break;
+		default:
+			p++;
+			break;
+		}
+	}
+
+check_mode_end:
+
+	qsort(&disp_mode_list[0], disp_mode_count, sizeof(disp_mode), disp_mode_compare);
+
+	disp_threshold = dual_disp ? DUAL_DISPLAY_CAPABILITY : SINGLE_DISPLAY_CAPABILITY;
+
+	for(i=0; i<disp_mode_count; i++)
+	{
+		if(disp_mode_list[i].width * disp_mode_list[i].height * disp_mode_list[i].freq <= disp_threshold)
+			break;
+	}
+
+	if(disp_mode_list[i].end) disp_mode_list[i].end[0] = 0;
+
+    return disp_mode_list[i].start;
+}
+
+static int set_graphics_fb_mode(int fb, int dual_disp)
+{
+    int size=0;
+    int fp_cmd=0;
+    int fp_mode=0;
+    int fp_modes=0;
+    char fb_mode[256];
+    char fb_modes[1024];
+    char cmd_line[1024];
+    char temp_name[256];
+    char *disp_mode=NULL;
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.AUTO_CONFIG_DISPLAY", value, "0");
+    if (strcmp(value, "1") != 0)  return 0;
+
+    fp_cmd = open("/proc/cmdline",O_RDONLY, 0);
+    if(fp_cmd < 0) {
+        LOGI("Error! Cannot open /proc/cmdline");
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(cmd_line, 0, sizeof(cmd_line));
+    size = read(fp_cmd, cmd_line, sizeof(cmd_line));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read /proc/cmdline");
+        goto set_graphics_fb_mode_error;
+    }
+
+    close(fp_cmd); fp_cmd = 0;
+
+    if(fb==0 && strstr(cmd_line, "di1_primary")) return 0;//XGA detected
+
+    sprintf(temp_name, "/sys/class/graphics/fb%d/modes", fb);
+    fp_modes = open(temp_name,O_RDONLY, 0);
+    if(fp_modes < 0) {
+        LOGI("Error! Cannot open %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(fb_modes, 0, sizeof(fb_modes));
+    size = read(fp_modes, fb_modes, sizeof(fb_modes));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    close(fp_modes); fp_modes = 0;
+
+    if(size == sizeof(fb_modes)) fb_modes[size -1] = 0;
+
+    disp_mode = find_available_mode(fb_modes, dual_disp);
+    if(!disp_mode)
+    {
+        LOGI("Error! Cannot find available mode for fb%d", fb);
+        goto set_graphics_fb_mode_error;
+    }
+
+    LOGI("find fb%d available mode %s", fb,disp_mode);
+
+    sprintf(temp_name, "/sys/class/graphics/fb%d/mode", fb);
+    fp_mode = open(temp_name,O_RDWR, 0);
+    if(fp_mode < 0) {
+        LOGI("Error! Cannot open %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    memset(fb_mode, 0, sizeof(fb_mode));
+    size = read(fp_mode, fb_mode, sizeof(fb_mode));
+    if(size <= 0)
+    {
+        LOGI("Error! Cannot read %s", temp_name);
+        goto set_graphics_fb_mode_error;
+    }
+
+    if(strncmp(fb_mode, disp_mode, strlen(fb_mode)))
+    {
+        write(fp_mode, disp_mode, strlen(disp_mode)+1);
+    }
+
+    close(fp_mode); fp_mode = 0;
+
+    return 0;
+
+set_graphics_fb_mode_error:
+
+    if(fp_modes > 0) close(fp_modes);
+    if(fp_mode > 0) close(fp_mode);
+    if(fp_cmd > 0) close(fp_cmd);
+
+    return -1;
+
+}
+
+int mapFrameBufferLocked(struct private_module_t* module)
+{
+    // already initialized...
+    if (module->framebuffer) {
+        return 0;
+    }
+        
+    char const * const device_template[] = {
+            "/dev/graphics/fb%u",
+            "/dev/fb%u",
+            0 };
+
+    int fd = -1;
+    int i=0;
+    char name[64];
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.UI_TVOUT_DISPLAY", value, "");
+    if (strcmp(value, "1") != 0) {
+        set_graphics_fb_mode(0, 0);
+        while ((fd==-1) && device_template[i]) {
+            snprintf(name, 64, device_template[i], 0);
+            fd = open(name, O_RDWR, 0);
+            i++;
+        }
+    }
+    else{
+        set_graphics_fb_mode(1, 0);
+        while ((fd==-1) && device_template[i]) {
+            snprintf(name, 64, device_template[i], 1);
+            fd = open(name, O_RDWR, 0);
+            i++;
+        }
+    }
+
+    if (fd < 0)
+        return -errno;
+
+    struct fb_fix_screeninfo finfo;
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    struct fb_var_screeninfo info;
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+
+    if(info.bits_per_pixel == 32){
+        LOGW("32bpp setting of Framebuffer catched!");
+        /*
+         * Explicitly request BGRA 8/8/8
+         */
+        info.bits_per_pixel = 32;
+        info.red.offset     = 8;
+        info.red.length     = 8;
+        info.green.offset   = 16;
+        info.green.length   = 8;
+        info.blue.offset    = 24;
+        info.blue.length    = 8;
+        info.transp.offset  = 0;
+        info.transp.length  = 0;
+#ifndef FSL_EPDC_FB
+        /*
+         *  set the alpha in pixel
+         *  only when the fb set to 32bit
+         */
+        struct mxcfb_loc_alpha l_alpha;
+        l_alpha.enable = true;
+        l_alpha.alpha_in_pixel = true;
+        if (ioctl(fd, MXCFB_SET_LOC_ALPHA,
+                    &l_alpha) < 0) {
+            printf("Set local alpha failed\n");
+            close(fd);
+            return -errno;
+        }
+#endif
+    }
+    else{
+        /*
+         * Explicitly request 5/6/5
+         */
+        info.bits_per_pixel = 16;
+        info.red.offset     = 11;
+        info.red.length     = 5;
+        info.green.offset   = 5;
+        info.green.length   = 6;
+        info.blue.offset    = 0;
+        info.blue.length    = 5;
+        info.transp.offset  = 0;
+        info.transp.length  = 0;
+
+        if (!no_ipu) {
+            /* for the 16bit case, only involke the glb alpha */
+            struct mxcfb_gbl_alpha gbl_alpha;
+
+            gbl_alpha.alpha = 255;
+            gbl_alpha.enable = 1;
+            int ret = ioctl(fd, MXCFB_SET_GBL_ALPHA, &gbl_alpha);
+            if(ret <0) {
+	        LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
+	        return -1;
+            }
+
+            struct mxcfb_color_key key;
+            key.enable = 1;
+            key.color_key = 0x00000000; // Black
+            ret = ioctl(fd, MXCFB_SET_CLR_KEY, &key);
+            if(ret <0) {
+	        LOGE("Error!Colorkey setting failed for dev ");
+	        return -1;
+            }
+        }
+    }
+
+    /*
+     * Request nr_framebuffers screens (at lest 2 for page flipping)
+     */
+    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
+    info.xres_virtual = ALIGN_PIXEL(info.xres);
+    
+#ifdef FSL_EPDC_FB
+    info.bits_per_pixel = 16;
+    info.grayscale = 0;
+    info.yoffset = 0;
+#endif
+
+    uint32_t flags = PAGE_FLIP;
+    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
+        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
+        flags &= ~PAGE_FLIP;
+        LOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
+    }
+
+    if (info.yres_virtual < ALIGN_PIXEL_128(info.yres) * 2) {
+        // we need at least 2 for page-flipping
+        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
+        flags &= ~PAGE_FLIP;
+        LOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
+                info.yres_virtual, ALIGN_PIXEL_128(info.yres)*2);
+    }
+
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+#ifdef FSL_EPDC_FB
+    int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
+    int retval = ioctl(fd, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
+    if (retval < 0) {
+	LOGE("Error! set auto update mode error!\n");
+	return -errno;
+    }
+
+    int scheme_mode = UPDATE_SCHEME_QUEUE_AND_MERGE;
+    retval = ioctl(fd, MXCFB_SET_UPDATE_SCHEME, &scheme_mode);
+    if (retval < 0) {
+	LOGE("Error! set update scheme error!\n");
+	return -errno;
+    }
+#endif
+    int refreshRate = 1000000000000000LLU /
+    (
+            uint64_t( info.upper_margin + info.lower_margin + info.yres )
+            * ( info.left_margin  + info.right_margin + info.xres )
+            * info.pixclock
+    );
+
+    if (refreshRate == 0) {
+        // bleagh, bad info from the driver
+        refreshRate = 60*1000;  // 60 Hz
+    }
+
+    if (int(info.width) <= 0 || int(info.height) <= 0) {
+        // the driver doesn't return that information
+        // default to 160 dpi
+        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
+        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
+    }
+
+    float xdpi = (info.xres * 25.4f) / info.width;
+    float ydpi = (info.yres * 25.4f) / info.height;
+    float fps  = refreshRate / 1000.0f;
+
+    LOGI(   "using (fd=%d)\n"
+            "id           = %s\n"
+            "xres         = %d px\n"
+            "yres         = %d px\n"
+            "xres_virtual = %d px\n"
+            "yres_virtual = %d px\n"
+            "bpp          = %d\n"
+            "r            = %2u:%u\n"
+            "g            = %2u:%u\n"
+            "b            = %2u:%u\n",
+            fd,
+            finfo.id,
+            info.xres,
+            info.yres,
+            info.xres_virtual,
+            info.yres_virtual,
+            info.bits_per_pixel,
+            info.red.offset, info.red.length,
+            info.green.offset, info.green.length,
+            info.blue.offset, info.blue.length
+    );
+
+    LOGI(   "width        = %d mm (%f dpi)\n"
+            "height       = %d mm (%f dpi)\n"
+            "refresh rate = %.2f Hz\n",
+            info.width,  xdpi,
+            info.height, ydpi,
+            fps
+    );
+
+
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    if (finfo.smem_len <= 0)
+        return -errno;
+
+
+    module->flags = flags;
+    module->info = info;
+    module->finfo = finfo;
+    module->xdpi = xdpi;
+    module->ydpi = ydpi;
+    module->fps = fps;
+
+    /*
+     * map the framebuffer
+     */
+
+    int err;
+    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+    module->framebuffer = new private_handle_t(dup(fd), fbSize,
+            private_handle_t::PRIV_FLAGS_USES_PMEM);
+
+    module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
+    module->bufferMask = 0;
+
+    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (vaddr == MAP_FAILED) {
+        LOGE("Error mapping the framebuffer (%s)", strerror(errno));
+        return -errno;
+    }
+    module->framebuffer->base = intptr_t(vaddr);
+    module->framebuffer->phys = intptr_t(finfo.smem_start);
+    memset(vaddr, 0, fbSize);
+    return 0;
+}
+
+static int mapFrameBuffer(struct private_module_t* module)
+{
+    pthread_mutex_lock(&module->lock);
+    int err = mapFrameBufferLocked(module);
+    pthread_mutex_unlock(&module->lock);
+    return err;
+}
+
+#ifdef SECOND_DISPLAY_SUPPORT
+static int mapSecFrameBuffer(fb_context_t* ctx)
+{
+    int retCode = 0;
+    int sec_fp = 0,fp_property = 0;
+    size_t fbSize = 0;
+    int blank;
+    void* vaddr = NULL;
+    struct mxcfb_gbl_alpha gbl_alpha;
+    struct mxcfb_color_key key; 
+    char overlayStr[32];
+    int fb2_fp;
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            ctx->device.common.module);
+
+    set_graphics_fb_mode(1,1);
+
+    sec_fp = open("/dev/graphics/fb1",O_RDWR, 0);
+    if (sec_fp < 0){
+        LOGE("Error!Cannot open the /dev/graphics/fb1 for second display");
+        goto disp_init_error;
+    }
+
+    //Switch overlay to second display after ipu deinit
+    //echo 1-layer-fb >  /sys/class/graphics/fb0/fsl_disp_property 
+    blank = 1;
+
+    fb2_fp = open("/dev/graphics/fb2",O_RDWR, 0);
+    if (fb2_fp < 0){
+        LOGE("Error!Cannot open the /dev/graphics/fb2");
+        goto disp_init_error;
+    }
+    if(ioctl(fb2_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+    close(fb2_fp);
+
+	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB1 failed!\n");
+        goto disp_init_error;
+	}
+
+    if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+		LOGI("Error!BLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+    
+    LOGI("Open fb0/fsl_disp_property");
+    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0); 
+    if(fp_property < 0) {
+         LOGI("Error!Cannot switch the overlay to second disp");
+         goto disp_init_error;
+    }
+    
+    memset(overlayStr, 0 ,32);
+    strcpy(overlayStr, "1-layer-fb\n");
+    LOGI("WRITE 1-layer-fb to fb0/fsl_disp_property");
+    write(fp_property, overlayStr, strlen(overlayStr)+1);
+    close(fp_property);
+
+    blank = FB_BLANK_UNBLANK;
+	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
+		LOGI("Error!UNBLANK FB1 failed!\n");
+        goto disp_init_error;
+	}
+
+	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
+		LOGI("Error!UNBLANK FB0 failed!\n");
+        goto disp_init_error;
+	}
+
+    struct fb_fix_screeninfo finfo;
+    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1)
+       goto disp_init_error;
+                
+    struct fb_var_screeninfo info;
+    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1)
+        goto disp_init_error;
+                
+    LOGI("Second display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
+         info.xres,info.xres_virtual,info.yres,info.yres_virtual);
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+                
+    /*
+    * Explicitly request 5/6/5
+    */
+    info.bits_per_pixel = 16;
+    info.nonstd = 0;
+    info.red.offset     = 11;
+    info.red.length     = 5;
+    info.green.offset   = 5;
+    info.green.length   = 6;
+    info.blue.offset    = 0;
+    info.blue.length    = 5;
+    info.transp.offset  = 0;
+    info.transp.length  = 0;
+    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
+    info.xres_virtual = ALIGN_PIXEL(info.xres);
+                        
+    if (ioctl(sec_fp, FBIOPUT_VSCREENINFO, &info) == -1) {
+        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1){
+        LOGE("Error!Second display FBIOGET_VSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1){
+        LOGE("Error!Second display FBIOGET_FSCREENINFO");
+        goto disp_init_error;
+    }
+                    
+    if(finfo.smem_len <= 0)
+        goto disp_init_error;
+
+    fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  
+                   
+    vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, sec_fp, 0);
+    if (vaddr == MAP_FAILED) {
+        LOGE("Error!mapping the framebuffer (%s)", strerror(errno));
+        goto disp_init_error;
+    }
+
+    key.enable = 1;
+    key.color_key = 0x00000000; // Black
+    LOGI("MXCFB_SET_CLR_KEY");
+    if( ioctl(sec_fp, MXCFB_SET_CLR_KEY, &key) < 0)
+    {
+        LOGE("Error!MXCFB_SET_CLR_KEY");
+        goto disp_init_error;
+    }
+
+    gbl_alpha.alpha = 255;
+    gbl_alpha.enable = 1;
+    LOGI("MXCFB_SET_GBL_ALPHA");
+    if(ioctl(sec_fp, MXCFB_SET_GBL_ALPHA, &gbl_alpha) <0)
+    {
+        LOGI("Error!MXCFB_SET_GBL_ALPHA error");
+        goto disp_init_error;
+    }
+
+    ctx->sec_disp_base = intptr_t(vaddr);
+    ctx->sec_disp_phys = intptr_t(finfo.smem_start);
+    memset(vaddr, 0, fbSize);
+    ctx->sec_fp = sec_fp;
+    ctx->sec_disp_w = info.xres;
+    ctx->sec_disp_h = info.yres;
+    ctx->sec_frame_size = fbSize/nr_framebuffers;
+    ctx->sec_disp_next_buf = ((info.yoffset * nr_framebuffers / info.yres_virtual) + 1) % nr_framebuffers;
+    ctx->sec_info = info;
+    ctx->sec_finfo = finfo;
+#if 0
+    struct fb_fix_screeninfo fb0_finfo;
+    if (ioctl(m->framebuffer->fd, FBIOGET_FSCREENINFO, &fb0_finfo) == -1)
+       goto disp_init_error;
+                
+    struct fb_var_screeninfo fb0_info;
+    if (ioctl(m->framebuffer->fd, FBIOGET_VSCREENINFO, &fb0_info) == -1)
+        goto disp_init_error;
+                
+    LOGI("fb0_info display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
+         fb0_info.xres,fb0_info.xres_virtual,
+         fb0_info.yres,fb0_info.yres_virtual);
+
+    fb0_info.reserved[0] = 0;
+    fb0_info.reserved[1] = 0;
+    fb0_info.reserved[2] = 0;
+    fb0_info.xoffset = 0;
+    fb0_info.yoffset = 0;
+    fb0_info.activate = FB_ACTIVATE_NOW;
+                
+    /*
+    * Explicitly request 5/6/5
+    */
+    fb0_info.bits_per_pixel = 16;
+    fb0_info.nonstd = 0;
+    fb0_info.red.offset     = 11;
+    fb0_info.red.length     = 5;
+    fb0_info.green.offset   = 5;
+    fb0_info.green.length   = 6;
+    fb0_info.blue.offset    = 0;
+    fb0_info.blue.length    = 5;
+    fb0_info.transp.offset  = 0;
+    fb0_info.transp.length  = 0;
+    fb0_info.yres_virtual = ALIGN_PIXEL_128(fb0_info.yres) * nr_framebuffers;
+	fb0_info.xres_virtual = fb0_info.xres;
+#endif
+    if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
+        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
+        goto disp_init_error;
+    }
+
+    return 0;
+
+ disp_init_error:
+    if(sec_fp) {
+        close(sec_fp);
+        sec_fp = 0;
+        ctx->sec_fp = 0;
+    }
+    return -1;
+}
+
+static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx)
+{
+    ipu_lib_input_param_t sIPUInputParam;   
+    ipu_lib_output_param_t sIPUOutputParam; 
+    ipu_lib_handle_t            sIPUHandle;
+    int iIPURet = 0;
+    memset(&sIPUInputParam,0,sizeof(sIPUInputParam));
+    memset(&sIPUOutputParam,0,sizeof(sIPUOutputParam));
+    memset(&sIPUHandle,0,sizeof(sIPUHandle));
+
+    //Setting input format
+    sIPUInputParam.width = ctx->device.width;
+    sIPUInputParam.height = ctx->device.height;
+
+    sIPUInputParam.input_crop_win.pos.x = 0;
+    sIPUInputParam.input_crop_win.pos.y = 0;  
+    sIPUInputParam.input_crop_win.win_w = ctx->device.width;
+    sIPUInputParam.input_crop_win.win_h = ctx->device.height;
+    sIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+    sIPUInputParam.user_def_paddr[0] = phys;
+        
+    //Setting output format
+    //Should align with v4l
+    sIPUOutputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+    sIPUOutputParam.width = ctx->sec_disp_w;
+    sIPUOutputParam.height = ctx->sec_disp_h;   
+    sIPUOutputParam.show_to_fb = 0;
+    //Output param should be same as input, since no resize,crop
+    sIPUOutputParam.output_win.pos.x = 0;
+    sIPUOutputParam.output_win.pos.y = 0;
+    sIPUOutputParam.output_win.win_w = ctx->sec_disp_w;
+    sIPUOutputParam.output_win.win_h = ctx->sec_disp_h;
+    
+    int output_w = 0;
+    int output_h = 0;
+    //Make sure the output w/h proportion is align with the primary display
+    if((ctx->sec_rotation == 0x0)||(ctx->sec_rotation == 0x3))
+    {
+        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.width/ctx->device.height){
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
+        }
+        else{
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
+        }
+    }
+    else{
+        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.height/ctx->device.width){
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
+        }
+        else{
+            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
+            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
+        }
+    }
+    sIPUOutputParam.output_win.pos.x = (ctx->sec_disp_w - sIPUOutputParam.output_win.win_w)/2;
+    sIPUOutputParam.output_win.pos.y = (ctx->sec_disp_h - sIPUOutputParam.output_win.win_h)/2;
+
+
+    //sIPUOutputParam.rot = 0;
+    sIPUOutputParam.rot = ctx->sec_rotation;
+    //LOGI("Sec Rotation %d",ctx->sec_rotation);
+
+    sIPUOutputParam.user_def_paddr[0] = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    //LOGI("Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+    //sIPUOutputParam.width,
+    //sIPUOutputParam.height,
+    //sIPUOutputParam.output_win.pos.x,
+    //sIPUOutputParam.output_win.pos.y,
+    //sIPUOutputParam.output_win.win_w,
+    //sIPUOutputParam.output_win.win_h,
+    //sIPUOutputParam.rot);
+                                         
+    //LOGI("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+    //sIPUInputParam.width,
+    //sIPUInputParam.height,
+    //sIPUInputParam.fmt,
+    //sIPUInputParam.input_crop_win.pos.x,
+    //sIPUInputParam.input_crop_win.pos.y,
+    //sIPUInputParam.input_crop_win.win_w,
+    //sIPUInputParam.input_crop_win.win_h);     
+        
+    iIPURet =  mxc_ipu_lib_task_init(&sIPUInputParam,NULL,&sIPUOutputParam,OP_NORMAL_MODE|TASK_VF_MODE,&sIPUHandle);
+    if (iIPURet < 0) {
+        LOGE("Error!mxc_ipu_lib_task_init failed mIPURet %d!",iIPURet);
+        return -1;
+    }  
+    //LOGI("mxc_ipu_lib_task_init success");
+    iIPURet = mxc_ipu_lib_task_buf_update(&sIPUHandle,phys,sIPUOutputParam.user_def_paddr[0],NULL,NULL,NULL);
+    if (iIPURet < 0) {
+        LOGE("Error!mxc_ipu_lib_task_buf_update failed mIPURet %d!",iIPURet);
+        mxc_ipu_lib_task_uninit(&sIPUHandle);
+        return -1;
+    }
+    //LOGI("mxc_ipu_lib_task_buf_update success");
+    mxc_ipu_lib_task_uninit(&sIPUHandle);
+
+    return 0;
+}
+
+/** convert HAL_PIXEL_FORMAT to C2D format */
+static C2D_COLORFORMAT get_format(int format) {
+    switch (format) {
+	case HAL_PIXEL_FORMAT_BGRA_8888:   return C2D_COLOR_8888;
+    case HAL_PIXEL_FORMAT_RGB_565:     return C2D_COLOR_0565;
+    default:                           return C2D_COLOR_0565;
+    }
+}
+
+/** get  pixelbit from HAL_PIXEL_FORMAT format */
+static int get_pixelbit(int format) {
+    switch (format) {
+    case HAL_PIXEL_FORMAT_BGRA_8888:   return 32;
+    case HAL_PIXEL_FORMAT_RGB_565:     return 16;
+    default:                           return 16;
+    }
+}
+
+static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx)
+{
+    C2D_SURFACE_DEF srcSurfaceDef;
+    C2D_SURFACE_DEF dstSurfaceDef;
+    C2D_SURFACE srcSurface;
+    C2D_SURFACE dstSurface; 
+    C2D_RECT dstRect;
+
+    if(!ctx || !ctx->c2dctx) return -1;
+
+    srcSurfaceDef.format = get_format(ctx->device.format);
+    srcSurfaceDef.width =  ctx->device.width;
+    srcSurfaceDef.height = ctx->device.height;
+
+	//make sure stride is 32 pixel aligned
+    srcSurfaceDef.stride = ((ctx->device.width + 31) & ~31)*get_pixelbit(ctx->device.format)>>3;
+
+    srcSurfaceDef.buffer = (void *)phys;
+    srcSurfaceDef.host = (void *)base;
+    srcSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
+
+    if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
+    {
+        LOGE("srcSurface c2dSurfAlloc fail");
+        return -EINVAL;
+    }
+
+    dstSurfaceDef.format = get_format(HAL_PIXEL_FORMAT_RGB_565);
+    dstSurfaceDef.width =  ctx->sec_disp_w;
+    dstSurfaceDef.height = ctx->sec_disp_h;
+
+    //make sure stride is 32 pixel aligned
+    dstSurfaceDef.stride = ((ctx->sec_disp_w + 31) & ~31)*get_pixelbit(HAL_PIXEL_FORMAT_RGB_565)>>3;
+
+    dstSurfaceDef.buffer = (void *)ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    dstSurfaceDef.host = (void *)ctx->sec_disp_base + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+    dstSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
+
+    dstRect.x = dstRect.y = 0;
+    dstRect.width = dstSurfaceDef.width;
+    dstRect.height = dstSurfaceDef.height;
+                
+    if((ctx->mRotate == 0)||(ctx->mRotate == 180))
+    {
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
+            dstRect.width = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
+        }
+        else{
+            dstRect.height = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
+        }
+    }
+    else{
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
+            dstRect.width = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
+        }
+        else{
+            dstRect.height = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
+        }
+    }
+
+    dstRect.x = (ctx->sec_disp_w - dstRect.width)/2;
+    dstRect.y = (ctx->sec_disp_h - dstRect.height)/2;
+            
+    if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
+    {
+        LOGE("dstSurface c2dSurfAlloc fail");
+        c2dSurfFree(ctx->c2dctx, srcSurface);
+        return -EINVAL;
+    }
+
+    c2dSetSrcSurface(ctx->c2dctx, srcSurface);
+    c2dSetDstSurface(ctx->c2dctx, dstSurface); 
+    c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
+
+    c2dSetStretchMode(ctx->c2dctx, C2D_STRETCH_BILINEAR_SAMPLING);
+    c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);         
+    c2dSetDither(ctx->c2dctx, 0); 
+ 
+    c2dSetDstRectangle(ctx->c2dctx, &dstRect);
+    c2dDrawBlit(ctx->c2dctx); 
+        
+    c2dFinish(ctx->c2dctx);
+    c2dSurfFree(ctx->c2dctx, srcSurface);
+    c2dSurfFree(ctx->c2dctx, dstSurface);
+
+    return 0;
+}
+
+void * secDispShowFrames(void * arg)
+{
+    private_module_t* m = NULL;
+    private_handle_t const* hnd = NULL;
+    fb_context_t* ctx = (fb_context_t*)arg;
+    
+    while(1)
+    {
+        sem_wait(&ctx->sec_display_begin);
+
+        if(!ctx->sec_display_inited)
+        {
+            sem_post(&ctx->sec_display_end);
+            break;
+        }
+
+        char value[PROPERTY_VALUE_MAX];
+        property_get("ro.secfb.disable-overlay", value, "0");
+        if (!strcmp(value, "1"))
+        {
+            property_get("media.VIDEO_PLAYING", value, "0");
+        }
+
+        if (strcmp(value, "1") == 0)
+        {
+            if(ctx->cleancount)
+            {
+                sem_post(&ctx->sec_display_end);
+                continue;
+            }
+
+            ctx->cleancount++;
+            memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
+        }
+        else
+        {
+           ctx->cleancount = 0;
+        }
+
+        if(!ctx->cleancount)
+        {
+            hnd = reinterpret_cast<private_handle_t const*>(ctx->buffer);
+            m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
+
+            if(ctx->c2dctx != NULL)
+            {
+                resizeToSecFrameBuffer_c2d(hnd->base,
+                           m->framebuffer->phys + hnd->base - m->framebuffer->base,
+                           ctx);
+            }
+            else
+            {
+                resizeToSecFrameBuffer(hnd->base,
+                                   m->framebuffer->phys + hnd->base - m->framebuffer->base,
+                                   ctx);
+            }
+        }
+
+        sem_post(&ctx->sec_display_end);
+        
+        ctx->sec_info.yoffset = (ctx->sec_info.yres_virtual/nr_framebuffers) * ctx->sec_disp_next_buf;
+        ctx->sec_disp_next_buf = (ctx->sec_disp_next_buf + 1) % nr_framebuffers;
+        ctx->sec_info.activate = FB_ACTIVATE_VBL;
+
+        ioctl(ctx->sec_fp, FBIOPAN_DISPLAY, &ctx->sec_info);
+    }
+
+    return NULL;
+}
+
+#endif
+
+/*****************************************************************************/
+
+static int fb_close(struct hw_device_t *dev)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if (ctx) {
+        free(ctx);
+    }
+    return 0;
+}
+
+int fb_device_open(hw_module_t const* module, const char* name,
+        hw_device_t** device)
+{
+    int status = -EINVAL;
+    char value[PROPERTY_VALUE_MAX];
+
+    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
+        alloc_device_t* gralloc_device;
+        framebuffer_device_t *fbdev;
+
+        nr_framebuffers = NUM_BUFFERS;
+        property_get("ro.product.device", value, "");
+        if (0 == strcmp(value, "imx50_rdp")) {
+            nr_framebuffers = 2;
+            no_ipu = 1;
+        }
+
+        status = gralloc_open(module, &gralloc_device);
+        if (status < 0)
+            return status;
+
+        /* initialize our state here */
+        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = fb_close;
+        dev->device.setSwapInterval = fb_setSwapInterval;
+        dev->device.post            = fb_post;
+        #ifndef FSL_EPDC_FB
+        dev->device.setUpdateRect = 0;
+        #else
+        dev->device.setUpdateRect = fb_setUpdateRect;
+        #endif
+        dev->device.compositionComplete = fb_compositionComplete;
+        #ifdef SECOND_DISPLAY_SUPPORT
+        dev->device.setSecRotation = fb_setSecRotation;
+        #endif
+
+        private_module_t* m = (private_module_t*)module;
+        status = mapFrameBuffer(m);
+        if (status >= 0) {
+            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
+            const_cast<uint32_t&>(dev->device.flags) = 0xfb0;
+            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
+            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
+            const_cast<int&>(dev->device.stride) = stride;
+            if(m->info.bits_per_pixel != 32) {
+                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
+            }
+            else{
+                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
+            }
+            const_cast<float&>(dev->device.xdpi) = m->xdpi;
+            const_cast<float&>(dev->device.ydpi) = m->ydpi;
+            const_cast<float&>(dev->device.fps) = m->fps;
+            const_cast<int&>(dev->device.minSwapInterval) = 1;
+            const_cast<int&>(dev->device.maxSwapInterval) = 1;
+            *device = &dev->device.common;
+            fbdev = (framebuffer_device_t*) *device;
+            fbdev->reserved[0] = nr_framebuffers;
+        }
+
+	/* initialize the IPU lib IPC */
+        if (!no_ipu)
+            mxc_ipu_lib_ipc_init();
+
+    fslwatermark_sem_open();
+
+    }
+    return status;
+}
diff --git a/mx6/libgralloc/gr.h b/mx6/libgralloc/gr.h
new file mode 100755
index 0000000..1775bfa
--- /dev/null
+++ b/mx6/libgralloc/gr.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GR_H_
+#define GR_H_
+
+#include <stdint.h>
+#ifdef HAVE_ANDROID_OS      // just want PAGE_SIZE define
+# include <asm/page.h>
+#else
+# include <sys/user.h>
+#endif
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+
+#include <cutils/native_handle.h>
+
+/*****************************************************************************/
+
+struct private_module_t;
+struct private_handle_t;
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+int mapFrameBufferLocked(struct private_module_t* module);
+int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
+
+/*****************************************************************************/
+
+class Locker {
+    pthread_mutex_t mutex;
+public:
+    class Autolock {
+        Locker& locker;
+    public:
+        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
+        inline ~Autolock() { locker.unlock(); }
+    };
+    inline Locker()        { pthread_mutex_init(&mutex, 0); }
+    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
+    inline void lock()     { pthread_mutex_lock(&mutex); }
+    inline void unlock()   { pthread_mutex_unlock(&mutex); }
+};
+
+#endif /* GR_H_ */
diff --git a/mx6/libgralloc/gralloc.cpp b/mx6/libgralloc/gralloc.cpp
new file mode 100755
index 0000000..f65099e
--- /dev/null
+++ b/mx6/libgralloc/gralloc.cpp
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include <cutils/ashmem.h>
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include "gralloc_priv.h"
+#include "allocator.h"
+
+#if HAVE_ANDROID_OS
+#include <linux/android_pmem.h>
+#endif
+
+/*****************************************************************************/
+
+static SimpleBestFitAllocator sAllocator;
+
+/*****************************************************************************/
+
+struct gralloc_context_t {
+    alloc_device_t  device;
+    /* our private data here */
+};
+
+static int gralloc_alloc_buffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle);
+
+/*****************************************************************************/
+
+int fb_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device);
+
+static int gralloc_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device);
+
+extern int gralloc_lock(gralloc_module_t const* module,
+        buffer_handle_t handle, int usage,
+        int l, int t, int w, int h,
+        void** vaddr);
+
+extern int gralloc_unlock(gralloc_module_t const* module, 
+        buffer_handle_t handle);
+
+extern int gralloc_register_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle);
+
+extern int gralloc_unregister_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle);
+
+/*****************************************************************************/
+
+static struct hw_module_methods_t gralloc_module_methods = {
+        open: gralloc_device_open
+};
+
+struct private_module_t HAL_MODULE_INFO_SYM = {
+    base: {
+        common: {
+            tag: HARDWARE_MODULE_TAG,
+            version_major: 1,
+            version_minor: 0,
+            id: GRALLOC_HARDWARE_MODULE_ID,
+            name: "Graphics Memory Allocator Module",
+            author: "The Android Open Source Project",
+            methods: &gralloc_module_methods
+        },
+        registerBuffer: gralloc_register_buffer,
+        unregisterBuffer: gralloc_unregister_buffer,
+        lock: gralloc_lock,
+        unlock: gralloc_unlock,
+    },
+    framebuffer: 0,
+    flags: 0,
+    numBuffers: 0,
+    bufferMask: 0,
+    lock: PTHREAD_MUTEX_INITIALIZER,
+    currentBuffer: 0,
+    pmem_master: -1,
+    pmem_master_base: 0,
+    master_phys: 0
+};
+
+/*****************************************************************************/
+
+static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+
+    // allocate the framebuffer
+    if (m->framebuffer == NULL) {
+        // initialize the framebuffer, the framebuffer is mapped once
+        // and forever.
+        int err = mapFrameBufferLocked(m);
+        if (err < 0) {
+            return err;
+        }
+    }
+
+    const uint32_t bufferMask = m->bufferMask;
+    const uint32_t numBuffers = m->numBuffers;
+    const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
+    if (numBuffers == 1) {
+        // If we have only one buffer, we never use page-flipping. Instead,
+        // we return a regular buffer which will be memcpy'ed to the main
+        // screen when post is called.
+        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
+        pthread_mutex_unlock(&m->lock);
+        int ret = gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);
+        pthread_mutex_lock(&m->lock);
+        return ret;
+    }
+
+    if (bufferMask >= ((1LU<<numBuffers)-1)) {
+        // We ran out of buffers.
+        return -ENOMEM;
+    }
+
+    // create a "fake" handles for it
+    intptr_t vaddr = intptr_t(m->framebuffer->base);
+    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer->fd), size,
+            private_handle_t::PRIV_FLAGS_USES_PMEM |
+            private_handle_t::PRIV_FLAGS_FRAMEBUFFER);
+
+    // find a free slot
+    for (uint32_t i=0 ; i<numBuffers ; i++) {
+        if ((bufferMask & (1LU<<i)) == 0) {
+            m->bufferMask |= (1LU<<i);
+            break;
+        }
+        vaddr += bufferSize;
+    }
+    
+    hnd->base = vaddr;
+    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
+    hnd->phys = intptr_t(m->framebuffer->phys) + hnd->offset;
+    *pHandle = hnd;
+
+    return 0;
+}
+
+static int gralloc_alloc_framebuffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+    pthread_mutex_lock(&m->lock);
+    int err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
+
+static int init_pmem_area_locked(private_module_t* m)
+{
+    int err = 0;
+#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
+    int master_fd = open("/dev/pmem_gpu", O_RDWR, 0);
+    if (master_fd >= 0) {
+        
+        size_t size;
+        pmem_region region;
+        if (ioctl(master_fd, PMEM_GET_TOTAL_SIZE, &region) < 0) {
+            LOGE("PMEM_GET_TOTAL_SIZE failed, limp mode");
+            size = 8<<20;   // 8 MiB
+        } else {
+            size = region.len;
+        }
+        sAllocator.setSize(size);
+
+        void* base = mmap(0, size, 
+                PROT_READ|PROT_WRITE, MAP_SHARED, master_fd, 0);
+        if (base == MAP_FAILED) {
+            err = -errno;
+            base = 0;
+            close(master_fd);
+            master_fd = -1;
+        } else {
+            pmem_region region;
+            err = ioctl(master_fd, PMEM_GET_PHYS, &region);
+            if (err < 0) {
+                LOGE("PMEM_GET_PHYS failed (%s)", strerror(-errno));
+            } else {
+                m->master_phys = (unsigned long)region.offset;
+				LOGI("PMEM GPU enabled, size:%d, phys base:%x",size,m->master_phys);
+            }
+        }
+        m->pmem_master = master_fd;
+        m->pmem_master_base = base;
+    } else {
+        err = -errno;
+    }
+    return err;
+#else
+    return -1;
+#endif
+}
+
+static int init_pmem_area(private_module_t* m)
+{
+    pthread_mutex_lock(&m->lock);
+    int err = m->pmem_master;
+    if (err == -1) {
+        // first time, try to initialize pmem
+        err = init_pmem_area_locked(m);
+        if (err) {
+            m->pmem_master = err;
+        }
+    } else if (err < 0) {
+        // pmem couldn't be initialized, never use it
+    } else {
+        // pmem OK
+        err = 0;
+    }
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
+
+static int gralloc_alloc_buffer(alloc_device_t* dev,
+        size_t size, int usage, buffer_handle_t* pHandle)
+{
+    int err = 0;
+    int flags = 0;
+
+    int fd = -1;
+    void* base = 0;
+    int offset = 0;
+    int lockState = 0;
+
+    size = roundUpToPageSize(size);
+    
+#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
+
+    if (usage & GRALLOC_USAGE_HW_TEXTURE) {
+        // enable pmem in that case, so our software GL can fallback to
+        // the copybit module.
+        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
+    }
+    
+    if (usage & GRALLOC_USAGE_HW_2D) {
+        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
+    }
+
+    if ((flags & private_handle_t::PRIV_FLAGS_USES_PMEM) == 0) {
+try_ashmem:
+        fd = ashmem_create_region("gralloc-buffer", size);
+        if (fd < 0) {
+            LOGE("couldn't create ashmem (%s)", strerror(-errno));
+            err = -errno;
+        }
+    } else {
+        private_module_t* m = reinterpret_cast<private_module_t*>(
+                dev->common.module);
+
+        err = init_pmem_area(m);
+        if (err == 0) {
+            // PMEM buffers are always mmapped
+            base = m->pmem_master_base;
+            lockState |= private_handle_t::LOCK_STATE_MAPPED;
+
+            offset = sAllocator.allocate(size);
+            if (offset < 0) {
+                // no more pmem memory
+                err = -ENOMEM;
+            } else {
+                struct pmem_region sub = { offset, size };
+                
+                // now create the "sub-heap"
+                fd = open("/dev/pmem_gpu", O_RDWR, 0);
+                err = fd < 0 ? fd : 0;
+                
+                // and connect to it
+                if (err == 0)
+                    err = ioctl(fd, PMEM_CONNECT, m->pmem_master);
+
+                // and make it available to the client process
+                if (err == 0)
+                    err = ioctl(fd, PMEM_MAP, &sub);
+
+                if (err < 0) {
+                    err = -errno;
+                    close(fd);
+                    sAllocator.deallocate(offset);
+                    fd = -1;
+                }
+                //LOGD_IF(!err, "allocating pmem size=%d, offset=%d", size, offset);
+                memset((char*)base + offset, 0, size);
+            }
+        } else {
+            if ((usage & GRALLOC_USAGE_HW_2D) == 0) {
+                // the caller didn't request PMEM, so we can try something else
+                flags &= ~private_handle_t::PRIV_FLAGS_USES_PMEM;
+                err = 0;
+                goto try_ashmem;
+            } else {
+                LOGE("couldn't open pmem (%s)", strerror(-errno));
+            }
+        }
+    }
+
+#else // HAVE_ANDROID_OS
+    
+    fd = ashmem_create_region("Buffer", size);
+    if (fd < 0) {
+        LOGE("couldn't create ashmem (%s)", strerror(-errno));
+        err = -errno;
+    }
+
+#endif // HAVE_ANDROID_OS
+
+    if (err == 0) {
+        private_handle_t* hnd = new private_handle_t(fd, size, flags);
+        hnd->offset = offset;
+        hnd->base = int(base)+offset;
+        hnd->lockState = lockState;
+        if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
+            private_module_t* m = reinterpret_cast<private_module_t*>(
+                    dev->common.module);
+            hnd->phys = m->master_phys + offset;
+        }
+        *pHandle = hnd;
+    }
+    
+    LOGE_IF(err, "gralloc failed err=%s", strerror(-err));
+    
+    return err;
+}
+
+/*****************************************************************************/
+
+static int gralloc_alloc(alloc_device_t* dev,
+        int w, int h, int format, int usage,
+        buffer_handle_t* pHandle, int* pStride)
+{
+    if (!pHandle || !pStride)
+        return -EINVAL;
+
+    size_t size, alignedw, alignedh;
+    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || 
+            format == HAL_PIXEL_FORMAT_YCbCr_422_SP) 
+    {
+        // FIXME: there is no way to return the alignedh
+        alignedw = (w + 1) & ~1; 
+        switch (format) {
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+                size = alignedw * h * 2;
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+                alignedh = (h+1) & ~1;
+                size = (alignedw * alignedh) + (w/2 * h/2) * 2;
+                break;
+            default:
+                return -EINVAL;
+        }
+    } else {
+        alignedw = ALIGN_PIXEL(w);
+        alignedh = ALIGN_PIXEL(h);
+        int bpp = 0;
+        switch (format) {
+            case HAL_PIXEL_FORMAT_RGBA_8888:
+            case HAL_PIXEL_FORMAT_RGBX_8888:
+            case HAL_PIXEL_FORMAT_BGRA_8888:
+                bpp = 4;
+                break;
+            case HAL_PIXEL_FORMAT_RGB_888:
+                bpp = 3;
+                break;
+            case HAL_PIXEL_FORMAT_RGB_565:
+            case HAL_PIXEL_FORMAT_RGBA_5551:
+            case HAL_PIXEL_FORMAT_RGBA_4444:
+                bpp = 2;
+                break;
+            default:
+                return -EINVAL;
+        }
+        size = alignedw * alignedh * bpp;
+    }
+
+    int err;
+    if (usage & GRALLOC_USAGE_HW_FB) {
+        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);
+    } else {
+        err = gralloc_alloc_buffer(dev, size, usage, pHandle);
+    }
+
+    if (err < 0) {
+        return err;
+    }
+
+    *pStride = alignedw;
+    return 0;
+}
+
+static int gralloc_free(alloc_device_t* dev,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+        // free this buffer
+        private_module_t* m = reinterpret_cast<private_module_t*>(
+                dev->common.module);
+        const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
+        int index = (hnd->base - m->framebuffer->base) / bufferSize;
+        m->bufferMask &= ~(1<<index); 
+    } else { 
+#if HAVE_ANDROID_OS
+        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
+            if (hnd->fd >= 0) {
+                struct pmem_region sub = { hnd->offset, hnd->size };
+                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
+                LOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
+                        "fd=%d, sub.offset=%lu, sub.size=%lu",
+                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
+                if (err == 0) {
+                    // we can't deallocate the memory in case of UNMAP failure
+                    // because it would give that process access to someone else's
+                    // surfaces, which would be a security breach.
+                    sAllocator.deallocate(hnd->offset);
+                }
+            }
+        }
+#endif // HAVE_ANDROID_OS
+        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>(
+                dev->common.module);
+        terminateBuffer(module, const_cast<private_handle_t*>(hnd));
+    }
+
+    close(hnd->fd);
+    delete hnd;
+    return 0;
+}
+
+/*****************************************************************************/
+
+static int gralloc_close(struct hw_device_t *dev)
+{
+    gralloc_context_t* ctx = reinterpret_cast<gralloc_context_t*>(dev);
+    if (ctx) {
+        /* TODO: keep a list of all buffer_handle_t created, and free them
+         * all here.
+         */
+        free(ctx);
+    }
+    return 0;
+}
+
+int gralloc_device_open(const hw_module_t* module, const char* name,
+        hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
+        gralloc_context_t *dev;
+        dev = (gralloc_context_t*)malloc(sizeof(*dev));
+
+        /* initialize our state here */
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag = HARDWARE_DEVICE_TAG;
+        dev->device.common.version = 0;
+        dev->device.common.module = const_cast<hw_module_t*>(module);
+        dev->device.common.close = gralloc_close;
+
+        dev->device.alloc   = gralloc_alloc;
+        dev->device.free    = gralloc_free;
+
+        *device = &dev->device.common;
+        status = 0;
+    } else {
+        status = fb_device_open(module, name, device);
+    }
+    return status;
+}
diff --git a/mx6/libgralloc/gralloc_priv.h b/mx6/libgralloc/gralloc_priv.h
new file mode 100755
index 0000000..35c2bce
--- /dev/null
+++ b/mx6/libgralloc/gralloc_priv.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GRALLOC_PRIV_H_
+#define GRALLOC_PRIV_H_
+
+#include <stdint.h>
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <cutils/native_handle.h>
+
+#include <linux/fb.h>
+
+#define  ALIGN_PIXEL(x)  ((x+ 31) & ~31)
+/** z430 core need 4k aligned memory, since xres has been 32 aligned, make yres
+    to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
+#define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
+/*****************************************************************************/
+
+struct private_module_t;
+struct private_handle_t;
+
+struct private_module_t {
+    gralloc_module_t base;
+
+    private_handle_t* framebuffer;
+    uint32_t flags;
+    uint32_t numBuffers;
+    uint32_t bufferMask;
+    pthread_mutex_t lock;
+    buffer_handle_t currentBuffer;
+    int pmem_master;
+    void* pmem_master_base;
+    unsigned long master_phys;
+
+    struct fb_var_screeninfo info;
+    struct fb_fix_screeninfo finfo;
+    float xdpi;
+    float ydpi;
+    float fps;
+
+    enum {
+        // flag to indicate we'll post this buffer
+        PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
+    };
+};
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+struct private_handle_t : public native_handle {
+#else
+struct private_handle_t {
+    struct native_handle nativeHandle;
+#endif
+
+    enum {
+        PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
+        PRIV_FLAGS_USES_PMEM   = 0x00000002,
+    };
+
+    enum {
+        LOCK_STATE_WRITE     =   1<<31,
+        LOCK_STATE_MAPPED    =   1<<30,
+        LOCK_STATE_READ_MASK =   0x3FFFFFFF
+    };
+
+    // file-descriptors
+    int     magic;
+    int     flags;
+    int     size;
+    int     offset;
+    int     base;
+
+    int     pid;
+
+    int     vidNode;
+    int     adjustedSize;
+    int     pool;
+    int     surface;
+    int     width;
+    int     height;
+    int     format;
+#if !defined(gcdHARDWARE_2D_COMPOSITION)
+    /* 3D composition. */
+    int     resolveVidNode;
+    int     resolveAdjustedSize;
+    int     resolvePool;
+    int     resolveSurface;
+    int     resolveDoneSignal;
+    int     resolveOutstanding;
+    int     usage;
+    int     private0; /* Padding */
+#endif
+    /* Out of band */
+    int     phys;
+    int     fd;
+
+#ifdef __cplusplus
+
+#if !defined(gcdHARDWARE_2D_COMPOSITION)
+    /* 3D composition. */
+    static const int sNumInts = 23;
+    static const int sNumFds  = 0;
+#else
+    /* 2D hardware composition. */
+    static const int sNumInts = 13;
+    static const int sNumFds  = 0;
+#endif
+    static const int sMagic   = 0x3141592;
+
+    private_handle_t(int fd, int size, int flags) :
+        magic(sMagic),
+        flags(flags),
+        size(size),
+        offset(0),
+        base(0),
+        pid(getpid()),
+        vidNode(0),
+        adjustedSize(0),
+        pool(0),
+        surface(0),
+        width(0),
+        height(0),
+        format(0),
+#if !defined(gcdHARDWARE_2D_COMPOSITION)
+        /* 3D composition. */
+        resolveVidNode(0),
+        resolveAdjustedSize(0),
+        resolvePool(0),
+        resolveSurface(0),
+        resolveDoneSignal(0),
+        resolveOutstanding(0),
+        usage(0),
+#endif
+        /* Out of band */
+        phys(0),
+        fd(fd)
+
+    {
+        version = sizeof(native_handle);
+        numInts = sNumInts;
+        numFds = sNumFds;
+    }
+    ~private_handle_t() {
+        magic = 0;
+    }
+
+    bool usesPhysicallyContiguousMemory() {
+        return (flags & PRIV_FLAGS_USES_PMEM) != 0;
+    }
+
+    static int validate(const native_handle* h) {
+        const private_handle_t* hnd = (const private_handle_t*)h;
+        if (!h || h->version != sizeof(native_handle) ||
+                h->numInts != sNumInts || h->numFds != sNumFds ||
+                hnd->magic != sMagic)
+        {
+            //LOGE("invalid gralloc handle (at %p)", h);
+            //LOGE("------------------h=%x", (int)h);
+	    if(h != NULL)
+	        LOGE("h->version=%d, h->numInts=%d, h->numFds=%d, hnd->magic=%x", h->version, h->numInts, h->numFds, hnd->magic);
+            return -EINVAL;
+        }
+        return 0;
+    }
+
+    static private_handle_t* dynamicCast(const native_handle* in) {
+        if (validate(in) == 0) {
+            return (private_handle_t*) in;
+        }
+        return NULL;
+    }
+#endif
+};
+
+#endif /* GRALLOC_PRIV_H_ */
diff --git a/mx6/libgralloc/mapper.cpp b/mx6/libgralloc/mapper.cpp
new file mode 100755
index 0000000..e2caf79
--- /dev/null
+++ b/mx6/libgralloc/mapper.cpp
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include "gralloc_priv.h"
+
+
+// we need this for now because pmem cannot mmap at an offset
+#define PMEM_HACK   1
+
+/* desktop Linux needs a little help with gettid() */
+#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
+#define __KERNEL__
+# include <linux/unistd.h>
+pid_t gettid() { return syscall(__NR_gettid);}
+#undef __KERNEL__
+#endif
+
+/*****************************************************************************/
+
+static int gralloc_map(gralloc_module_t const* module,
+        buffer_handle_t handle,
+        void** vaddr)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        size_t size = hnd->size;
+#if PMEM_HACK
+        size += hnd->offset;
+#endif
+        void* mappedAddress = mmap(0, size,
+                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
+        if (mappedAddress == MAP_FAILED) {
+            LOGE("Could not mmap %s", strerror(errno));
+            return -errno;
+        }
+        hnd->base = intptr_t(mappedAddress) + hnd->offset;
+        //LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", 
+        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
+    }
+    *vaddr = (void*)hnd->base;
+    return 0;
+}
+
+static int gralloc_unmap(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        void* base = (void*)hnd->base;
+        size_t size = hnd->size;
+#if PMEM_HACK
+        base = (void*)(intptr_t(base) - hnd->offset);
+        size += hnd->offset;
+#endif
+        //LOGD("unmapping from %p, size=%d", base, size);
+        if (munmap(base, size) < 0) {
+            LOGE("Could not unmap %s", strerror(errno));
+        }
+    }
+    hnd->base = 0;
+    return 0;
+}
+
+/*****************************************************************************/
+
+static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER; 
+
+/*****************************************************************************/
+
+int gralloc_register_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    // In this implementation, we don't need to do anything here
+
+    /* NOTE: we need to initialize the buffer as not mapped/not locked
+     * because it shouldn't when this function is called the first time
+     * in a new process. Ideally these flags shouldn't be part of the
+     * handle, but instead maintained in the kernel or at least 
+     * out-of-line
+     */ 
+
+    // if this handle was created in this process, then we keep it as is.
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (hnd->pid != getpid()) {
+        hnd->base = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+int gralloc_unregister_buffer(gralloc_module_t const* module,
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     * NOTE: the framebuffer is handled differently and is never unmapped.
+     */
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+    
+    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
+            "[unregister] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+
+    // never unmap buffers that were created in this process
+    if (hnd->pid != getpid()) {
+        if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
+            gralloc_unmap(module, handle);
+        }
+        hnd->base = 0;
+        hnd->lockState  = 0;
+        hnd->writeOwner = 0;
+    }
+    return 0;
+}
+
+int terminateBuffer(gralloc_module_t const* module,
+        private_handle_t* hnd)
+{
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     */
+
+    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
+            "[terminate] handle %p still locked (state=%08x)",
+            hnd, hnd->lockState);
+    
+    if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
+        // this buffer was mapped, unmap it now
+        if ((hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) && 
+            (hnd->pid == getpid())) {
+            // ... unless it's a "master" pmem buffer, that is a buffer
+            // mapped in the process it's been allocated.
+            // (see gralloc_alloc_buffer())
+        } else {
+            gralloc_unmap(module, hnd);
+        }
+    }
+
+    return 0;
+}
+
+int gralloc_lock(gralloc_module_t const* module,
+        buffer_handle_t handle, int usage,
+        int l, int t, int w, int h,
+        void** vaddr)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    int err = 0;
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int32_t current_value, new_value;
+    int retry;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
+            // already locked for write 
+            LOGE("handle %p already locked for write", handle);
+            return -EBUSY;
+        } else if (current_value & private_handle_t::LOCK_STATE_READ_MASK) {
+            // already locked for read
+            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+                LOGE("handle %p already locked for read", handle);
+                return -EBUSY;
+            } else {
+                // this is not an error
+                //LOGD("%p already locked for read... count = %d", 
+                //        handle, (current_value & ~(1<<31)));
+            }
+        }
+
+        // not currently locked
+        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
+            // locking for write
+            new_value |= private_handle_t::LOCK_STATE_WRITE;
+        }
+        new_value++;
+
+        retry = android_atomic_cmpxchg(current_value, new_value, 
+                (volatile int32_t*)&hnd->lockState);
+    } while (retry);
+
+    if (new_value & private_handle_t::LOCK_STATE_WRITE) {
+        // locking for write, store the tid
+        hnd->writeOwner = gettid();
+    }
+
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
+        if (!(current_value & private_handle_t::LOCK_STATE_MAPPED)) {
+            // we need to map for real
+            pthread_mutex_t* const lock = &sMapLock;
+            pthread_mutex_lock(lock);
+            if (!(hnd->lockState & private_handle_t::LOCK_STATE_MAPPED)) {
+                err = gralloc_map(module, handle, vaddr);
+                if (err == 0) {
+                    android_atomic_or(private_handle_t::LOCK_STATE_MAPPED,
+                            (volatile int32_t*)&(hnd->lockState));
+                }
+            }
+            pthread_mutex_unlock(lock);
+        }
+        *vaddr = (void*)hnd->base;
+    }
+
+    return err;
+}
+
+int gralloc_unlock(gralloc_module_t const* module, 
+        buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int32_t current_value, new_value;
+
+    do {
+        current_value = hnd->lockState;
+        new_value = current_value;
+
+        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
+            // locked for write
+            if (hnd->writeOwner == gettid()) {
+                hnd->writeOwner = 0;
+                new_value &= ~private_handle_t::LOCK_STATE_WRITE;
+            }
+        }
+
+        if ((new_value & private_handle_t::LOCK_STATE_READ_MASK) == 0) {
+            LOGE("handle %p not locked", handle);
+            return -EINVAL;
+        }
+
+        new_value--;
+
+    } while (android_atomic_cmpxchg(current_value, new_value, 
+            (volatile int32_t*)&hnd->lockState));
+
+    return 0;
+}
-- 
1.8.0

