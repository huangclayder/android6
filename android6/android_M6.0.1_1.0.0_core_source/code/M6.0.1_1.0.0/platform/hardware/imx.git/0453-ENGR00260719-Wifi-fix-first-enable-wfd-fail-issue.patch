From b0fcb1b757eda82a2160f81ac1fdaf3349e14ec2 Mon Sep 17 00:00:00 2001
From: Jianzheng Zhou <jianzheng.zhou@freescale.com>
Date: Tue, 14 May 2013 10:12:43 +0800
Subject: [PATCH 453/635] ENGR00260719 Wifi: fix first enable wfd fail issue

This is caused by p2p_go and wlan0 concurrent.Using old driver and firmware
it will fail for operate wlan0 while p2p0 is forming group.Atheros has update
this issue in this new driver and firmware.

Signed-off-by: Jianzheng Zhou <jianzheng.zhou@freescale.com>
---
 .../drivers/net/wireless/ath/ath6kl/btc.h          |    3 +
 .../drivers/net/wireless/ath/ath6kl/cfg80211.c     |  483 ++-
 .../net/wireless/ath/ath6kl/cfg80211.c.orig        | 3882 --------------------
 .../drivers/net/wireless/ath/ath6kl/cfg80211.h     |    5 +-
 .../drivers/net/wireless/ath/ath6kl/core.h         |  219 +-
 .../drivers/net/wireless/ath/ath6kl/debug.c        |   49 +-
 .../drivers/net/wireless/ath/ath6kl/debug.c.orig   | 1804 ---------
 .../drivers/net/wireless/ath/ath6kl/debug.h        |   10 +-
 .../drivers/net/wireless/ath/ath6kl/debugfs_pri.c  |  234 +-
 .../drivers/net/wireless/ath/ath6kl/debugfs_pri.h  |    5 +-
 .../drivers/net/wireless/ath/ath6kl/hif.c          |    9 +-
 .../drivers/net/wireless/ath/ath6kl/htc.c          |   71 +-
 .../drivers/net/wireless/ath/ath6kl/htc.h          |    7 +
 .../drivers/net/wireless/ath/ath6kl/init.c         |  246 +-
 .../drivers/net/wireless/ath/ath6kl/init.c.orig    | 2079 -----------
 .../drivers/net/wireless/ath/ath6kl/main.c         |  386 +-
 .../drivers/net/wireless/ath/ath6kl/main.c.orig    | 1372 -------
 .../drivers/net/wireless/ath/ath6kl/platform.c     |   29 +-
 .../drivers/net/wireless/ath/ath6kl/recovery.c     |   30 +-
 .../drivers/net/wireless/ath/ath6kl/sdio.c         |   16 +-
 .../drivers/net/wireless/ath/ath6kl/sdio.c.orig    | 1455 --------
 .../drivers/net/wireless/ath/ath6kl/softmac.c      |    2 +-
 .../drivers/net/wireless/ath/ath6kl/target.h       |    5 +
 .../drivers/net/wireless/ath/ath6kl/txrx.c         |  165 +-
 .../drivers/net/wireless/ath/ath6kl/wmi.c          |  555 ++-
 .../drivers/net/wireless/ath/ath6kl/wmi.h          |  137 +-
 .../compat-wireless/include/linux/nl80211.h        |    3 +
 27 files changed, 2308 insertions(+), 10953 deletions(-)
 delete mode 100644 wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c.orig
 delete mode 100644 wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c.orig
 delete mode 100644 wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c.orig
 delete mode 100644 wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c.orig
 delete mode 100644 wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c.orig

diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/btc.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/btc.h
index 71075a8..99d46a8 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/btc.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/btc.h
@@ -55,6 +55,9 @@ void cfg80211_send_event_to_app(struct net_device *dev,
 	u16 size;
 	union iwreq_data wrqu;
 
+	if (!dev)
+		return;
+
 	size = len + EVENT_ID_LEN;
 
 	if (size > IW_CUSTOM_MAX)
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c
index b6a48f4..a8d4a52 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -145,6 +145,8 @@ static struct ieee80211_supported_band ath6kl_band_5ghz = {
 
 #define CCKM_KRK_CIPHER_SUITE 0x004096ff /* use for KRK */
 
+#define SSCAN_WAKELOCK_IN_SECOND 35
+
 /* returns true if scheduled scan was stopped */
 static bool __ath6kl_cfg80211_sscan_stop(struct ath6kl_vif *vif)
 {
@@ -711,8 +713,8 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
 				   u8 *bssid, u16 listen_intvl,
 				   u16 beacon_intvl,
 				   enum network_type nw_type,
-				   u8 beacon_ie_len, u8 assoc_req_len,
-				   u8 assoc_resp_len, u8 *assoc_info)
+				   u16 beacon_ie_len, u16 assoc_req_len,
+				   u16 assoc_resp_len, u8 *assoc_info)
 {
 	struct ieee80211_channel *chan;
 	struct ath6kl *ar = vif->ar;
@@ -832,9 +834,15 @@ void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 {
 	struct ath6kl *ar = vif->ar;
 
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
+	struct cfg80211_scan_request *scan_req;
+
+	spin_lock_bh(&vif->if_lock);
+	scan_req = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
+
+	if (scan_req) {
+		cfg80211_scan_done(scan_req, true);
 	}
 
 	if (vif->nw_type & ADHOC_NETWORK) {
@@ -1028,7 +1036,22 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 	if (test_bit(CONNECTED, &vif->flags))
 		force_fg_scan = 1;
 
+	WARN_ON_ONCE(vif->scan_req);
+	spin_lock_bh(&vif->if_lock);
 	vif->scan_req = request;
+	spin_unlock_bh(&vif->if_lock);
+
+	if (test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,
+		     ar->fw_capabilities)) {
+
+		if (request->no_cck) {
+#ifdef CONFIG_HAS_WAKELOCK
+			ath6kl_p2p_release_wakelock(ar);
+			ath6kl_p2p_acquire_wakelock(ar , n_channels *
+						    msecs_to_jiffies(110));
+#endif
+		}
+	}
 
 	ret = ath6kl_wmi_beginscan_cmd(ar->wmi, vif->fw_vif_idx,
 				       WMI_LONG_SCAN, force_fg_scan,
@@ -1040,7 +1063,9 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 
 	if (ret) {
 		ath6kl_err("failed to start scan: %d\n", ret);
+		spin_lock_bh(&vif->if_lock);
 		vif->scan_req = NULL;
+		spin_unlock_bh(&vif->if_lock);
 	}
 
 	kfree(channels);
@@ -1051,19 +1076,28 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 void ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)
 {
 	struct ath6kl *ar = vif->ar;
+	struct cfg80211_scan_request *request = NULL;
 	int i;
 
 	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: status%s\n", __func__,
 		   aborted ? " aborted" : "");
 
-	if (!vif->scan_req)
+	spin_lock_bh(&vif->if_lock);
+	if (!vif->scan_req) {
+		spin_unlock_bh(&vif->if_lock);
 		return;
+	}
+
+	request = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
 
 	if (aborted)
 		goto out;
 
-	if (vif->scan_req->n_ssids && vif->scan_req->ssids[0].ssid_len) {
-		for (i = 0; i < vif->scan_req->n_ssids; i++) {
+	if (request->n_ssids && request->ssids &&
+	    request->ssids[0].ssid_len) {
+		for (i = 0; i < request->n_ssids; i++) {
 			ath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx,
 						  i + 1, DISABLE_SSID_FLAG,
 						  0, NULL);
@@ -1071,8 +1105,7 @@ void ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)
 	}
 
 out:
-	cfg80211_scan_done(vif->scan_req, aborted);
-	vif->scan_req = NULL;
+	cfg80211_scan_done(request, aborted);
 }
 
 void ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,
@@ -2209,7 +2242,7 @@ static int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
 	struct ath6kl_vif *first_vif, *vif;
 	int ret = 0;
 	u32 filter = 0;
-	bool connected = false;
+	bool connected = false, sscan = false;
 
 	/* enter / leave wow suspend on first vif always */
 	first_vif = ath6kl_vif_first(ar);
@@ -2224,17 +2257,28 @@ static int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
 	spin_lock_bh(&ar->list_lock);
 	list_for_each_entry(vif, &ar->vif_list, list) {
 		if (!test_bit(CONNECTED, &vif->flags) ||
-		    !ath6kl_cfg80211_ready(vif))
+		    !ath6kl_cfg80211_ready(vif)) {
+			/* if a sscan is going on, do not clear
+			   WOW_FILTER_SSID later */
+			if (test_bit(SCHED_SCANNING, &vif->flags)) {
+				filter |= WOW_FILTER_SSID;
+				sscan = true;
+			}
 			continue;
+		}
+
 		connected = true;
 
+		spin_unlock_bh(&ar->list_lock);
 		ret = ath6kl_wow_suspend_vif(vif, wow, &filter);
+		spin_lock_bh(&ar->list_lock);
 		if (ret)
 			break;
 	}
 	spin_unlock_bh(&ar->list_lock);
 
-	if (!connected)
+	/* to enable pno, goes into wow while sscan */
+	if (!connected && !sscan)
 		return -ENOTCONN;
 	else if (ret)
 		return ret;
@@ -2286,8 +2330,9 @@ static int ath6kl_wow_resume_vif(struct ath6kl_vif *vif)
 
 static int ath6kl_wow_resume(struct ath6kl *ar)
 {
-	struct ath6kl_vif *vif;
+	struct ath6kl_vif *vif, *vif_p;
 	int ret;
+	bool sscan = false;
 
 	vif = ath6kl_vif_first(ar);
 	if (WARN_ON(unlikely(!vif)) ||
@@ -2295,7 +2340,23 @@ static int ath6kl_wow_resume(struct ath6kl *ar)
 		return -EIO;
 
 #ifdef CONFIG_HAS_WAKELOCK
-	wake_lock_timeout(&ar->wake_lock, 5);
+	spin_lock_bh(&ar->list_lock);
+	list_for_each_entry(vif_p, &ar->vif_list, list) {
+		if (test_bit(SCHED_SCANNING, &vif_p->flags)) {
+			sscan = true;
+			break;
+		}
+	}
+	spin_unlock_bh(&ar->list_lock);
+
+	if (sscan) {
+		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "sched scan %ds(%d jiffies) wake lock\n",
+			SSCAN_WAKELOCK_IN_SECOND, SSCAN_WAKELOCK_IN_SECOND*HZ);
+		wake_lock_timeout(&ar->wake_lock,
+			SSCAN_WAKELOCK_IN_SECOND * HZ);
+	} else {
+		wake_lock_timeout(&ar->wake_lock, 5);
+	}
 #endif
 
 	ar->state = ATH6KL_STATE_RESUMING;
@@ -2313,7 +2374,9 @@ static int ath6kl_wow_resume(struct ath6kl *ar)
 		if (!test_bit(CONNECTED, &vif->flags) ||
 		    !ath6kl_cfg80211_ready(vif))
 			continue;
+		spin_unlock_bh(&ar->list_lock);
 		ret = ath6kl_wow_resume_vif(vif);
+		spin_lock_bh(&ar->list_lock);
 		if (ret)
 			break;
 	}
@@ -2582,19 +2645,21 @@ void ath6kl_check_wow_status(struct ath6kl *ar, struct sk_buff *skb,
 #endif
 
 static int ath6kl_set_htcap(struct ath6kl_vif *vif, enum ieee80211_band band,
-			    bool ht_enable)
+			    bool ht_enable, bool ht40_support)
 {
 	struct ath6kl_htcap *htcap = &vif->htcap[band];
 
-	if (htcap->ht_enable == ht_enable)
-		return 0;
-
 	if (ht_enable) {
 		/* Set default ht capabilities */
 		htcap->ht_enable = true;
 		htcap->cap_info = (band == IEEE80211_BAND_2GHZ) ?
 				   ath6kl_g_htcap : ath6kl_a_htcap;
 		htcap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;
+		/*disable ht40*/
+		if (!ht40_support) {
+			htcap->cap_info &= ~(IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+					     IEEE80211_HT_CAP_SGI_40);
+		}
 	} else /* Disable ht */
 		memset(htcap, 0, sizeof(*htcap));
 
@@ -2679,9 +2744,10 @@ static int ath6kl_ap_beacon(struct wiphy *wiphy, struct net_device *dev,
 {
 	struct ath6kl *ar = ath6kl_priv(dev);
 	struct ath6kl_vif *vif = netdev_priv(dev);
+	struct ath6kl_vif_bcn_info *bcn_info = &vif->bcn_info;
 	struct ieee80211_mgmt *mgmt;
 	enum wmi_phy_mode phy_mode;
-	bool hidden = false;
+	bool hidden = false, is_ht40;
 	u8 *ies;
 	int ies_len;
 	struct wmi_connect_cmd p;
@@ -2747,6 +2813,8 @@ static int ath6kl_ap_beacon(struct wiphy *wiphy, struct net_device *dev,
 	if (info->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE)
 		hidden = true;
 
+	bcn_info->hidden_ssid = hidden;
+
 	res = ath6kl_wmi_ap_hidden_ssid(ar->wmi, vif->fw_vif_idx, hidden);
 	if (res)
 		return res;
@@ -2896,8 +2964,10 @@ static int ath6kl_ap_beacon(struct wiphy *wiphy, struct net_device *dev,
 		p.nw_subtype = SUBTYPE_NONE;
 	}
 
+	is_ht40 = (vif->next_ch_type == NL80211_CHAN_HT40MINUS ||
+		   vif->next_ch_type == NL80211_CHAN_HT40PLUS);
 	if (ath6kl_set_htcap(vif, vif->next_ch_band,
-			     vif->next_ch_type != NL80211_CHAN_NO_HT))
+			     vif->next_ch_type != NL80211_CHAN_NO_HT, is_ht40))
 		return -EIO;
 
 	if (test_bit(ATH6KL_FW_CAPABILITY_MAC_ACL, ar->fw_capabilities)) {
@@ -2923,6 +2993,9 @@ static int ath6kl_ap_beacon(struct wiphy *wiphy, struct net_device *dev,
 		return -ENOTSUPP;
 	}
 
+	bcn_info->phy_mode = phy_mode;
+	bcn_info->sta_cap_req = info->sta_cap_req;
+
 	res = ath6kl_wmi_set_ch_params(ar->wmi, vif->fw_vif_idx, phy_mode);
 	if (res)
 		return res;
@@ -2933,6 +3006,65 @@ ap_commit:
 	if (res < 0)
 		return res;
 
+	if (info->beacon_ies_len) {
+		if (bcn_info->beacon_ies)
+			bcn_info->beacon_ies = krealloc(bcn_info->beacon_ies,
+							info->beacon_ies_len,
+							GFP_KERNEL);
+		else
+			bcn_info->beacon_ies = kmalloc(info->beacon_ies_len,
+						       GFP_KERNEL);
+
+		if (!bcn_info->beacon_ies) {
+			ath6kl_warn("Failed to allocate memory to store beacon ies\n");
+			return 0;
+		}
+
+		memcpy(bcn_info->beacon_ies, info->beacon_ies,
+		       info->beacon_ies_len);
+		bcn_info->beacon_ies_len = info->beacon_ies_len;
+	}
+
+	if (info->proberesp_ies_len) {
+		if (bcn_info->proberesp_ies)
+			bcn_info->proberesp_ies =
+					krealloc(bcn_info->proberesp_ies,
+						 info->proberesp_ies_len,
+						 GFP_KERNEL);
+		else
+			bcn_info->proberesp_ies =
+					kmalloc(info->proberesp_ies_len,
+						GFP_KERNEL);
+		if (!bcn_info->proberesp_ies) {
+			ath6kl_warn("Failed to allocate memory to store probe resp ies\n");
+			return 0;
+		}
+
+		memcpy(bcn_info->proberesp_ies, info->proberesp_ies,
+		       info->proberesp_ies_len);
+		bcn_info->proberesp_ies_len = info->proberesp_ies_len;
+	}
+
+	if (info->assocresp_ies_len) {
+		if (bcn_info->assocresp_ies)
+			bcn_info->assocresp_ies =
+					krealloc(bcn_info->assocresp_ies,
+						 info->assocresp_ies_len,
+						 GFP_KERNEL);
+		else
+			bcn_info->assocresp_ies =
+					kmalloc(info->assocresp_ies_len,
+						GFP_KERNEL);
+		if (!bcn_info->assocresp_ies) {
+			ath6kl_warn("Failed to allocate memory to store assoc resp ies\n");
+			return 0;
+		}
+
+		memcpy(bcn_info->assocresp_ies, info->assocresp_ies,
+		       info->assocresp_ies_len);
+		bcn_info->assocresp_ies_len = info->assocresp_ies_len;
+	}
+
 	return 0;
 }
 
@@ -2976,6 +3108,14 @@ static int ath6kl_del_beacon(struct wiphy *wiphy, struct net_device *dev)
 {
 	struct ath6kl *ar = ath6kl_priv(dev);
 	struct ath6kl_vif *vif = netdev_priv(dev);
+	struct ath6kl_vif_bcn_info *bcn_info = &vif->bcn_info;
+
+	kfree(bcn_info->beacon_ies);
+	kfree(bcn_info->proberesp_ies);
+	kfree(bcn_info->assocresp_ies);
+	bcn_info->beacon_ies = NULL;
+	bcn_info->proberesp_ies = NULL;
+	bcn_info->assocresp_ies = NULL;
 
 	if (vif->nw_type != AP_NETWORK)
 		return -EOPNOTSUPP;
@@ -2986,15 +3126,89 @@ static int ath6kl_del_beacon(struct wiphy *wiphy, struct net_device *dev)
 	clear_bit(CONNECTED, &vif->flags);
 
 	/* Restore ht setting in firmware */
-	if (ath6kl_set_htcap(vif, IEEE80211_BAND_2GHZ, true))
+	if (ath6kl_set_htcap(vif, IEEE80211_BAND_2GHZ, true, true))
 		return -EIO;
 
-	if (ath6kl_set_htcap(vif, IEEE80211_BAND_5GHZ, true))
+	if (ath6kl_set_htcap(vif, IEEE80211_BAND_5GHZ, true, true))
 		return -EIO;
 
 	return 0;
 }
 
+void ath6kl_cfg80211_start_ap(struct ath6kl_vif *vif)
+{
+	struct ath6kl_vif_bcn_info *info = &vif->bcn_info;
+	struct ath6kl *ar = vif->ar;
+	bool is_ht40;
+
+
+	if (!ath6kl_cfg80211_ready(vif))
+		return;
+
+	/* this also clears IE in fw if it's not set */
+	if (ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
+				     WMI_FRAME_BEACON, info->beacon_ies,
+				     info->beacon_ies_len))
+		return;
+
+	/* this also clears IE in fw if it's not set */
+	if (ath6kl_set_ap_probe_resp_ies(vif, info->proberesp_ies,
+					 info->proberesp_ies_len))
+		return;
+
+	/* this also clears IE in fw if it's not set */
+	if (ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
+				     WMI_FRAME_ASSOC_RESP, info->assocresp_ies,
+				     info->assocresp_ies_len))
+		return;
+
+	if (ath6kl_wmi_ap_hidden_ssid(ar->wmi, vif->fw_vif_idx,
+				      info->hidden_ssid))
+		return;
+
+	if ((vif->profile.auth_mode & (WPA2_AUTH | WPA2_PSK_AUTH)) &&
+	    test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,
+		     ar->fw_capabilities)) {
+		if (ath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,
+					  WLAN_EID_RSN, WMI_RSN_IE_CAPB,
+					  (const u8 *) &vif->rsn_capab,
+					  sizeof(vif->rsn_capab)))
+			return;
+	}
+
+	/* Enable uAPSD support by default */
+	if (ath6kl_wmi_ap_set_apsd(ar->wmi, vif->fw_vif_idx, true))
+		return;
+
+	is_ht40 = (vif->next_ch_type == NL80211_CHAN_HT40MINUS ||
+		   vif->next_ch_type == NL80211_CHAN_HT40PLUS);
+	if (ath6kl_set_htcap(vif, vif->next_ch_band,
+			     vif->next_ch_type != NL80211_CHAN_NO_HT, is_ht40))
+		return;
+
+
+	if (info->sta_cap_req) {
+		if (ath6kl_wmi_set_ch_params(ar->wmi, vif->fw_vif_idx,
+					     info->phy_mode))
+			return;
+	}
+
+	ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx, &vif->profile);
+
+	/* TODO: Configure ACL MAC list */
+}
+
+void ath6kl_cfg80211_start_all(struct ath6kl *ar)
+{
+	struct ath6kl_vif *vif;
+
+	list_for_each_entry(vif, &ar->vif_list, list) {
+		if (vif->next_mode == AP_NETWORK &&
+		    vif->wdev.iftype != NL80211_IFTYPE_P2P_GO)
+			ath6kl_cfg80211_start_ap(vif);
+	}
+}
+
 static const u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 static int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,
@@ -3004,6 +3218,8 @@ static int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,
 	struct ath6kl_vif *vif = netdev_priv(dev);
 	const u8 *addr = mac ? mac : bcast_addr;
 
+	if (!ath6kl_cfg80211_ready(vif))
+		return -EIO;
 	return ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx, WMI_AP_DEAUTH,
 				      addr, WLAN_REASON_PREV_AUTH_NOT_VALID);
 }
@@ -3204,6 +3420,9 @@ static int ath6kl_mgmt_tx(struct wiphy *wiphy, struct net_device *dev,
 	const struct ieee80211_mgmt *mgmt;
 	bool more_data, queued;
 
+	if (!ath6kl_cfg80211_ready(vif))
+		return -EIO;
+
 	mgmt = (const struct ieee80211_mgmt *) buf;
 	if (vif->nw_type == AP_NETWORK && test_bit(CONNECTED, &vif->flags) &&
 	    ieee80211_is_probe_resp(mgmt->frame_control) &&
@@ -3499,6 +3718,10 @@ static struct cfg80211_ops ath6kl_cfg80211_ops = {
 
 void ath6kl_cfg80211_stop(struct ath6kl_vif *vif)
 {
+	struct ath6kl* ar = vif->ar;
+	u8 mac[ETH_ALEN];
+	int i;
+
 	ath6kl_cfg80211_sscan_disable(vif);
 
 	switch (vif->sme_state) {
@@ -3515,6 +3738,20 @@ void ath6kl_cfg80211_stop(struct ath6kl_vif *vif)
 		break;
 	}
 
+	if (vif->ar->state == ATH6KL_STATE_RECOVERY &&
+	    vif->nw_type == AP_NETWORK) {
+		for (i = 0; i < AP_MAX_NUM_STA; i++) {
+			if (is_zero_ether_addr(ar->sta_list[i].mac))
+				continue;
+			memcpy(mac, ar->sta_list[i].mac, ETH_ALEN);
+			if (!ath6kl_remove_sta(ar, mac,
+					       WMI_AP_REASON_FROM_HOST))
+				continue;
+			cfg80211_del_sta(vif->ndev, (const u8 *) mac,
+					 GFP_KERNEL);
+		}
+	}
+
 	if (vif->ar->state != ATH6KL_STATE_RECOVERY &&
 	    (test_bit(CONNECTED, &vif->flags) ||
 	    test_bit(CONNECT_PEND, &vif->flags)))
@@ -3526,7 +3763,6 @@ void ath6kl_cfg80211_stop(struct ath6kl_vif *vif)
 
 	/* Stop netdev queues, needed during recovery */
 	netif_stop_queue(vif->ndev);
-	netif_carrier_off(vif->ndev);
 
 	/* disable scanning */
 	if (vif->ar->state != ATH6KL_STATE_RECOVERY &&
@@ -3582,6 +3818,9 @@ static int ath6kl_cfg80211_reg_notify(struct wiphy *wiphy,
 		return ret;
 	}
 
+	if (test_bit(ATH6KL_FW_CAPABILITY_REGDOMAIN_V2, ar->fw_capabilities))
+		return 0;
+
 	/*
 	 * Firmware will apply the regdomain change only after a scan is
 	 * issued and it will send a WMI_REGDOMAIN_EVENTID when it has been
@@ -3658,6 +3897,8 @@ struct ath6kl *ath6kl_core_alloc(struct device *dev)
 		skb_queue_head_init(&ar->sta_list[ctr].psq);
 		skb_queue_head_init(&ar->sta_list[ctr].apsdq);
 		ar->sta_list[ctr].mgmt_psq_len = 0;
+		ar->sta_list[ctr].apsdq_depth = 0;
+		ar->sta_list[ctr].psq_depth = 0;
 		INIT_LIST_HEAD(&ar->sta_list[ctr].mgmt_psq);
 		ar->sta_list[ctr].aggr_conn =
 			kzalloc(sizeof(struct aggr_info_conn), GFP_KERNEL);
@@ -3678,6 +3919,7 @@ struct ath6kl *ath6kl_core_alloc(struct device *dev)
 int ath6kl_register_ieee80211_hw(struct ath6kl *ar)
 {
 	struct wiphy *wiphy = ar->wiphy;
+	bool band_2gig = false, band_5gig = false, ht = false;
 	int ret;
 
 	wiphy->mgmt_stypes = ath6kl_mgmt_stypes;
@@ -3719,8 +3961,39 @@ int ath6kl_register_ieee80211_hw(struct ath6kl *ar)
 		ath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;
 	}
 
-	wiphy->bands[IEEE80211_BAND_2GHZ] = &ath6kl_band_2ghz;
-	wiphy->bands[IEEE80211_BAND_5GHZ] = &ath6kl_band_5ghz;
+	switch (ar->hw.cap) {
+	case WMI_11AN_CAP:
+		ht = true;
+	case WMI_11A_CAP:
+		band_5gig = true;
+		break;
+	case WMI_11GN_CAP:
+		ht = true;
+	case WMI_11G_CAP:
+		band_2gig = true;
+		break;
+	case WMI_11AGN_CAP:
+		ht = true;
+	case WMI_11AG_CAP:
+		band_2gig = true;
+		band_5gig = true;
+		break;
+	default:
+		ath6kl_err("invalid phy capability!\n");
+		return -EINVAL;
+	}
+
+	if (!ht) {
+		ath6kl_band_2ghz.ht_cap.cap = 0;
+		ath6kl_band_2ghz.ht_cap.ht_supported = false;
+		ath6kl_band_5ghz.ht_cap.cap = 0;
+		ath6kl_band_5ghz.ht_cap.ht_supported = false;
+	}
+	if (band_2gig)
+		wiphy->bands[IEEE80211_BAND_2GHZ] = &ath6kl_band_2ghz;
+	if (band_5gig)
+		wiphy->bands[IEEE80211_BAND_5GHZ] = &ath6kl_band_5ghz;
+
 	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 
 	wiphy->cipher_suites = cipher_suites;
@@ -3738,6 +4011,20 @@ int ath6kl_register_ieee80211_hw(struct ath6kl *ar)
 
 	wiphy->max_sched_scan_ssids = MAX_PROBED_SSIDS;
 
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM |
+			WIPHY_FLAG_HAVE_AP_SME |
+			WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |
+			WIPHY_FLAG_SUPPORTS_ACS;
+
+	if (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, ar->fw_capabilities))
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+
+	wiphy->probe_resp_offload =
+		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |
+		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |
+		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P |
+		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U;
+
 	ath6kl_setup_android_resource(ar);
 
 	if (test_bit(ATH6KL_FW_CAPABILITY_MAC_ACL, ar->fw_capabilities)) {
@@ -3866,6 +4153,150 @@ err:
 	return NULL;
 }
 
+static unsigned long ath6kl_get_tp_cur_value(struct ath6kl_vif *vif,
+					     enum ath6kl_tp_type type)
+{
+	unsigned long value = 0;
+
+	if (type == ATH6KL_TP_TYPE_PACKETS)
+		value = vif->net_stats.tx_packets + vif->net_stats.rx_packets;
+	else if (type == ATH6KL_TP_TYPE_BYTES)
+		value = vif->net_stats.tx_bytes + vif->net_stats.rx_bytes;
+
+	return value;
+}
+
+static unsigned int ath6kl_get_tp_level(unsigned long cur_tp,
+					unsigned long thr_a,
+					unsigned long thr_b,
+					unsigned long thr_c)
+{
+	unsigned int level = ATH6KL_TP_LOW;
+
+	if (cur_tp >= thr_c)
+		level = ATH6KL_TP_SUPER_C;
+	else if (cur_tp >= thr_b)
+		level = ATH6KL_TP_HIGH_B;
+	else if (cur_tp >= thr_a)
+		level = ATH6KL_TP_NORMAL_A;
+
+	return level;
+}
+static void ath6kl_tp_changed_notify(struct ath6kl_vif *vif,
+				     unsigned int old_level,
+				     unsigned int new_level,
+				     unsigned long cur_tp)
+{
+	ath6kl_dbg(ATH6KL_DBG_WLAN_TX, "tp changed: %s old:%d, new:%d, tp:%ld\n",
+		   vif->ndev->name, old_level, new_level, cur_tp);
+
+	/* do the control if needed */
+	return;
+}
+
+void ath6kl_tp_cfg(struct ath6kl *ar, unsigned int interval_s,
+		   unsigned int type, unsigned long thr_a,
+		   unsigned long thr_b, unsigned long thr_c)
+{
+	struct ath6kl_vif *vif, *tmp_vif;
+	struct ath6kl_vif_tp_status *vif_tp_status;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
+		   "cfg tp interval:%d, type:%d a:%ld, b:%ld, c:%ld\n",
+		   interval_s, type, thr_a, thr_b, thr_c);
+
+	/* use default setting if all threshold are zero */
+	if (thr_a == 0 && thr_b == 0 && thr_c == 0) {
+		if (type == ATH6KL_TP_TYPE_BYTES) {
+			thr_a = TP_THR_BYTES_A_DEFAULT;
+			thr_b = TP_THR_BYTES_B_DEFAULT;
+			thr_c = TP_THR_BYTES_C_DEFAULT;
+		} else {
+			thr_a = TP_THR_PKS_A_DEFAULT;
+			thr_b = TP_THR_PKS_B_DEFAULT;
+			thr_c = TP_THR_PKS_C_DEFAULT;
+		}
+	}
+
+	if (!(thr_a < thr_b && thr_b < thr_c)) {
+		ath6kl_err("threshold error, a < b < c, a:%ld, b:%ld, c:%ld\n",
+			   thr_a, thr_b, thr_c);
+		return;
+	}
+
+	if (interval_s == 0 ||
+	    interval_s > TP_MONITOR_MAX_INTERVEL_S ||
+	    type >= ATH6KL_TP_TYPE_MAX ||
+	    thr_a < TP_THR_MIN ||
+	    thr_c > TP_THR_MAX) {
+		ath6kl_err("parameter out of range, interval:%d, type:%d, a:%ld, c:%ld\n",
+			   interval_s, type, thr_a, thr_c);
+		return;
+	}
+
+	del_timer_sync(&ar->tp_ctl.tp_monitor_timer);
+
+	/* clear the previous status */
+	spin_lock_bh(&ar->list_lock);
+	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
+		vif_tp_status = &vif->vif_tp_status;
+		vif_tp_status->cur_level = 0;
+		vif_tp_status->cur_tp = 0;
+		vif_tp_status->cur_txrx = ath6kl_get_tp_cur_value(vif, type);
+	}
+	spin_unlock_bh(&ar->list_lock);
+
+	ar->tp_ctl.interval_s = interval_s;
+	ar->tp_ctl.thr_type = type;
+	ar->tp_ctl.thr_a = thr_a;
+	ar->tp_ctl.thr_b = thr_b;
+	ar->tp_ctl.thr_c = thr_c;
+
+	if (type != ATH6KL_TP_TYPE_DISABLED)
+		mod_timer(&ar->tp_ctl.tp_monitor_timer, jiffies +
+			  msecs_to_jiffies(ar->tp_ctl.interval_s*1000));
+}
+
+void ath6kl_tp_monitor_timer(unsigned long data)
+{
+	struct ath6kl *ar = (struct ath6kl *) data;
+	struct ath6kl_vif_tp_status *vif_tp_sts;
+	struct ath6kl_vif *vif, *tmp_vif;
+	struct ath6kl_tp_ctl *tp_ctl = &ar->tp_ctl;
+	unsigned long cur_txrx, cur_tp;
+	unsigned int cur_level;
+
+	if (!tp_ctl->interval_s ||
+	    tp_ctl->thr_type == ATH6KL_TP_TYPE_DISABLED)
+		return;
+
+	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
+		vif_tp_sts = &vif->vif_tp_status;
+		cur_txrx = ath6kl_get_tp_cur_value(vif, tp_ctl->thr_type);
+
+		/* Avoid override */
+		if (cur_txrx >= vif_tp_sts->cur_txrx) {
+			cur_tp = cur_txrx - vif_tp_sts->cur_txrx;
+			cur_tp = cur_tp/(tp_ctl->interval_s);
+			cur_level = ath6kl_get_tp_level(cur_tp,
+							tp_ctl->thr_a,
+							tp_ctl->thr_b,
+							tp_ctl->thr_c);
+			if (cur_level != vif_tp_sts->cur_level)
+				ath6kl_tp_changed_notify(vif,
+							 vif_tp_sts->cur_level,
+							 cur_level, cur_tp);
+
+			vif_tp_sts->cur_level = cur_level;
+			vif_tp_sts->cur_tp = cur_tp;
+		}
+		vif_tp_sts->cur_txrx = cur_txrx;
+	}
+
+	mod_timer(&tp_ctl->tp_monitor_timer, jiffies +
+		  msecs_to_jiffies(tp_ctl->interval_s*1000));
+}
+
 void ath6kl_deinit_ieee80211_hw(struct ath6kl *ar)
 {
 	int i;
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c.orig b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c.orig
deleted file mode 100644
index 45cbe66..0000000
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.c.orig
+++ /dev/null
@@ -1,3882 +0,0 @@
-/*
- * Copyright (c) 2004-2011 Atheros Communications Inc.
- * Copyright (c) 2011-2012 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include <linux/moduleparam.h>
-#include <linux/inetdevice.h>
-
-#include "core.h"
-#include "cfg80211.h"
-#include "debug.h"
-#include "hif-ops.h"
-#include "testmode.h"
-#include "cfg80211_btcoex.h"
-#include "pm.h"
-
-static unsigned int ath6kl_p2p = 1;
-
-module_param(ath6kl_p2p, uint, 0644);
-
-#define RATETAB_ENT(_rate, _rateid, _flags) {   \
-	.bitrate    = (_rate),                  \
-	.flags      = (_flags),                 \
-	.hw_value   = (_rateid),                \
-}
-
-#define CHAN2G(_channel, _freq, _flags) {   \
-	.band           = IEEE80211_BAND_2GHZ,  \
-	.hw_value       = (_channel),           \
-	.center_freq    = (_freq),              \
-	.flags          = (_flags),             \
-	.max_antenna_gain   = 0,                \
-	.max_power      = 30,                   \
-}
-
-#define CHAN5G(_channel, _flags) {		    \
-	.band           = IEEE80211_BAND_5GHZ,      \
-	.hw_value       = (_channel),               \
-	.center_freq    = 5000 + (5 * (_channel)),  \
-	.flags          = (_flags),                 \
-	.max_antenna_gain   = 0,                    \
-	.max_power      = 30,                       \
-}
-
-#define DEFAULT_BG_SCAN_PERIOD 60
-
-struct ath6kl_cfg80211_match_probe_ssid {
-	struct cfg80211_ssid ssid;
-	u8 flag;
-};
-
-static struct ieee80211_rate ath6kl_rates[] = {
-	RATETAB_ENT(10, 0x1, 0),
-	RATETAB_ENT(20, 0x2, 0),
-	RATETAB_ENT(55, 0x4, 0),
-	RATETAB_ENT(110, 0x8, 0),
-	RATETAB_ENT(60, 0x10, 0),
-	RATETAB_ENT(90, 0x20, 0),
-	RATETAB_ENT(120, 0x40, 0),
-	RATETAB_ENT(180, 0x80, 0),
-	RATETAB_ENT(240, 0x100, 0),
-	RATETAB_ENT(360, 0x200, 0),
-	RATETAB_ENT(480, 0x400, 0),
-	RATETAB_ENT(540, 0x800, 0),
-};
-
-#define ath6kl_a_rates     (ath6kl_rates + 4)
-#define ath6kl_a_rates_size    8
-#define ath6kl_g_rates     (ath6kl_rates + 0)
-#define ath6kl_g_rates_size    12
-
-#define ath6kl_g_htcap IEEE80211_HT_CAP_SGI_20
-#define ath6kl_a_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \
-			IEEE80211_HT_CAP_SGI_20		 | \
-			IEEE80211_HT_CAP_SGI_40)
-
-static struct ieee80211_channel ath6kl_2ghz_channels[] = {
-	CHAN2G(1, 2412, 0),
-	CHAN2G(2, 2417, 0),
-	CHAN2G(3, 2422, 0),
-	CHAN2G(4, 2427, 0),
-	CHAN2G(5, 2432, 0),
-	CHAN2G(6, 2437, 0),
-	CHAN2G(7, 2442, 0),
-	CHAN2G(8, 2447, 0),
-	CHAN2G(9, 2452, 0),
-	CHAN2G(10, 2457, 0),
-	CHAN2G(11, 2462, 0),
-	CHAN2G(12, 2467, 0),
-	CHAN2G(13, 2472, 0),
-	CHAN2G(14, 2484, 0),
-};
-
-static struct ieee80211_channel ath6kl_5ghz_a_channels[] = {
-	CHAN5G(34, 0), CHAN5G(36, 0),
-	CHAN5G(38, 0), CHAN5G(40, 0),
-	CHAN5G(42, 0), CHAN5G(44, 0),
-	CHAN5G(46, 0), CHAN5G(48, 0),
-	CHAN5G(52, 0), CHAN5G(56, 0),
-	CHAN5G(60, 0), CHAN5G(64, 0),
-	CHAN5G(100, 0), CHAN5G(104, 0),
-	CHAN5G(108, 0), CHAN5G(112, 0),
-	CHAN5G(116, 0), CHAN5G(120, 0),
-	CHAN5G(124, 0), CHAN5G(128, 0),
-	CHAN5G(132, 0), CHAN5G(136, 0),
-	CHAN5G(140, 0), CHAN5G(149, 0),
-	CHAN5G(153, 0), CHAN5G(157, 0),
-	CHAN5G(161, 0), CHAN5G(165, 0),
-	CHAN5G(184, 0), CHAN5G(188, 0),
-	CHAN5G(192, 0), CHAN5G(196, 0),
-	CHAN5G(200, 0), CHAN5G(204, 0),
-	CHAN5G(208, 0), CHAN5G(212, 0),
-	CHAN5G(216, 0),
-};
-
-static struct ieee80211_supported_band ath6kl_band_2ghz = {
-	.n_channels = ARRAY_SIZE(ath6kl_2ghz_channels),
-	.channels = ath6kl_2ghz_channels,
-	.n_bitrates = ath6kl_g_rates_size,
-	.bitrates = ath6kl_g_rates,
-	.ht_cap.cap = ath6kl_g_htcap,
-	.ht_cap.ht_supported = true,
-};
-
-static struct ieee80211_supported_band ath6kl_band_5ghz = {
-	.n_channels = ARRAY_SIZE(ath6kl_5ghz_a_channels),
-	.channels = ath6kl_5ghz_a_channels,
-	.n_bitrates = ath6kl_a_rates_size,
-	.bitrates = ath6kl_a_rates,
-	.ht_cap.cap = ath6kl_a_htcap,
-	.ht_cap.ht_supported = true,
-};
-
-#define CCKM_KRK_CIPHER_SUITE 0x004096ff /* use for KRK */
-
-/* returns true if scheduled scan was stopped */
-static bool __ath6kl_cfg80211_sscan_stop(struct ath6kl_vif *vif)
-{
-	struct ath6kl *ar = vif->ar;
-
-	if (!test_and_clear_bit(SCHED_SCANNING, &vif->flags))
-		return false;
-
-	del_timer_sync(&vif->sched_scan_timer);
-
-	if (ar->state == ATH6KL_STATE_RECOVERY)
-		return true;
-
-	ath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, false);
-
-	return true;
-}
-
-static void ath6kl_cfg80211_sscan_disable(struct ath6kl_vif *vif)
-{
-	struct ath6kl *ar = vif->ar;
-	bool stopped;
-
-	stopped = __ath6kl_cfg80211_sscan_stop(vif);
-
-	if (!stopped)
-		return;
-
-	cfg80211_sched_scan_stopped(ar->wiphy);
-}
-
-static int ath6kl_set_wpa_version(struct ath6kl_vif *vif,
-				  enum nl80211_wpa_versions wpa_version)
-{
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: %u\n", __func__, wpa_version);
-
-	if (!wpa_version) {
-		vif->auth_mode = NONE_AUTH;
-	} else if (wpa_version & NL80211_WPA_VERSION_2) {
-		vif->auth_mode = WPA2_AUTH;
-	} else if (wpa_version & NL80211_WPA_VERSION_1) {
-		vif->auth_mode = WPA_AUTH;
-	} else {
-		ath6kl_err("%s: %u not supported\n", __func__, wpa_version);
-		return -ENOTSUPP;
-	}
-
-	return 0;
-}
-
-static int ath6kl_set_auth_type(struct ath6kl_vif *vif,
-				enum nl80211_auth_type auth_type)
-{
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: 0x%x\n", __func__, auth_type);
-
-	switch (auth_type) {
-	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-		vif->dot11_auth_mode = OPEN_AUTH;
-		break;
-	case NL80211_AUTHTYPE_SHARED_KEY:
-		vif->dot11_auth_mode = SHARED_AUTH;
-		break;
-	case NL80211_AUTHTYPE_NETWORK_EAP:
-		vif->dot11_auth_mode = LEAP_AUTH;
-		break;
-
-	case NL80211_AUTHTYPE_AUTOMATIC:
-		vif->dot11_auth_mode = OPEN_AUTH | SHARED_AUTH;
-		break;
-
-	default:
-		ath6kl_err("%s: 0x%x not spported\n", __func__, auth_type);
-		return -ENOTSUPP;
-	}
-
-	return 0;
-}
-
-static int ath6kl_set_cipher(struct ath6kl_vif *vif, u32 cipher, bool ucast)
-{
-	u8 *ar_cipher = ucast ? &vif->prwise_crypto : &vif->grp_crypto;
-	u8 *ar_cipher_len = ucast ? &vif->prwise_crypto_len :
-		&vif->grp_crypto_len;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: cipher 0x%x, ucast %u\n",
-		   __func__, cipher, ucast);
-
-	switch (cipher) {
-	case 0:
-		/* our own hack to use value 0 as no crypto used */
-		*ar_cipher = NONE_CRYPT;
-		*ar_cipher_len = 0;
-		break;
-	case WLAN_CIPHER_SUITE_WEP40:
-		*ar_cipher = WEP_CRYPT;
-		*ar_cipher_len = 5;
-		break;
-	case WLAN_CIPHER_SUITE_WEP104:
-		*ar_cipher = WEP_CRYPT;
-		*ar_cipher_len = 13;
-		break;
-	case WLAN_CIPHER_SUITE_TKIP:
-		*ar_cipher = TKIP_CRYPT;
-		*ar_cipher_len = 0;
-		break;
-	case WLAN_CIPHER_SUITE_CCMP:
-		*ar_cipher = AES_CRYPT;
-		*ar_cipher_len = 0;
-		break;
-	case WLAN_CIPHER_SUITE_SMS4:
-		*ar_cipher = WAPI_CRYPT;
-		*ar_cipher_len = 0;
-		break;
-	default:
-		ath6kl_err("cipher 0x%x not supported\n", cipher);
-		return -ENOTSUPP;
-	}
-
-	return 0;
-}
-
-static void ath6kl_set_key_mgmt(struct ath6kl_vif *vif, u32 key_mgmt)
-{
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: 0x%x\n", __func__, key_mgmt);
-
-	if (key_mgmt == WLAN_AKM_SUITE_PSK) {
-		if (vif->auth_mode == WPA_AUTH)
-			vif->auth_mode = WPA_PSK_AUTH;
-		else if (vif->auth_mode == WPA2_AUTH)
-			vif->auth_mode = WPA2_PSK_AUTH;
-	} else if (key_mgmt == 0x00409600) {
-		if (vif->auth_mode == WPA_AUTH)
-			vif->auth_mode = WPA_AUTH_CCKM;
-		else if (vif->auth_mode == WPA2_AUTH)
-			vif->auth_mode = WPA2_AUTH_CCKM;
-	} else if (key_mgmt != WLAN_AKM_SUITE_8021X) {
-		vif->auth_mode = NONE_AUTH;
-	}
-}
-
-bool ath6kl_cfg80211_ready(struct ath6kl_vif *vif)
-{
-	struct ath6kl *ar = vif->ar;
-
-	if (!test_bit(WMI_READY, &ar->flag)) {
-		ath6kl_err("wmi is not ready\n");
-		return false;
-	}
-
-	if (!test_bit(WLAN_ENABLED, &vif->flags)) {
-		ath6kl_err("wlan disabled\n");
-		return false;
-	}
-
-	return true;
-}
-
-static bool ath6kl_is_wpa_ie(const u8 *pos)
-{
-	return pos[0] == WLAN_EID_WPA && pos[1] >= 4 &&
-		pos[2] == 0x00 && pos[3] == 0x50 &&
-		pos[4] == 0xf2 && pos[5] == 0x01;
-}
-
-static bool ath6kl_is_rsn_ie(const u8 *pos)
-{
-	return pos[0] == WLAN_EID_RSN;
-}
-
-static bool ath6kl_is_wps_ie(const u8 *pos)
-{
-	return (pos[0] == WLAN_EID_VENDOR_SPECIFIC &&
-		pos[1] >= 4 &&
-		pos[2] == 0x00 && pos[3] == 0x50 && pos[4] == 0xf2 &&
-		pos[5] == 0x04);
-}
-
-static int ath6kl_set_assoc_req_ies(struct ath6kl_vif *vif, const u8 *ies,
-				    size_t ies_len)
-{
-	struct ath6kl *ar = vif->ar;
-	const u8 *pos;
-	u8 *buf = NULL;
-	size_t len = 0;
-	int ret;
-
-	/*
-	 * Clear previously set flag
-	 */
-
-	ar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;
-
-	/*
-	 * Filter out RSN/WPA IE(s)
-	 */
-
-	if (ies && ies_len) {
-		buf = kmalloc(ies_len, GFP_KERNEL);
-		if (buf == NULL)
-			return -ENOMEM;
-		pos = ies;
-
-		while (pos + 1 < ies + ies_len) {
-			if (pos + 2 + pos[1] > ies + ies_len)
-				break;
-			if (!(ath6kl_is_wpa_ie(pos) || ath6kl_is_rsn_ie(pos))) {
-				memcpy(buf + len, pos, 2 + pos[1]);
-				len += 2 + pos[1];
-			}
-
-			if (ath6kl_is_wps_ie(pos))
-				ar->connect_ctrl_flags |= CONNECT_WPS_FLAG;
-
-			pos += 2 + pos[1];
-		}
-	}
-
-	ret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_ASSOC_REQ, buf, len);
-	kfree(buf);
-	return ret;
-}
-
-static int ath6kl_nliftype_to_drv_iftype(enum nl80211_iftype type, u8 *nw_type)
-{
-	switch (type) {
-	case NL80211_IFTYPE_STATION:
-		*nw_type = INFRA_NETWORK;
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		*nw_type = ADHOC_NETWORK;
-		break;
-	case NL80211_IFTYPE_AP:
-		*nw_type = AP_NETWORK;
-		break;
-	case NL80211_IFTYPE_P2P_CLIENT:
-		*nw_type = INFRA_NETWORK;
-		break;
-	case NL80211_IFTYPE_P2P_GO:
-		*nw_type = AP_NETWORK;
-		break;
-	default:
-		ath6kl_err("invalid interface type %u\n", type);
-		return -ENOTSUPP;
-	}
-
-	return 0;
-}
-
-static bool ath6kl_is_valid_iftype(struct ath6kl *ar, enum nl80211_iftype type,
-				   u8 *if_idx, u8 *nw_type)
-{
-	int i;
-
-	if (ath6kl_nliftype_to_drv_iftype(type, nw_type))
-		return false;
-
-	if (ar->ibss_if_active || ((type == NL80211_IFTYPE_ADHOC) &&
-	    ar->num_vif))
-		return false;
-
-	if (type == NL80211_IFTYPE_STATION ||
-	    type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_ADHOC) {
-		for (i = 0; i < ar->vif_max; i++) {
-			if ((ar->avail_idx_map >> i) & BIT(0)) {
-				*if_idx = i;
-				return true;
-			}
-		}
-	}
-
-	if (type == NL80211_IFTYPE_P2P_CLIENT ||
-	    type == NL80211_IFTYPE_P2P_GO) {
-		for (i = ar->max_norm_iface; i < ar->vif_max; i++) {
-			if ((ar->avail_idx_map >> i) & BIT(0)) {
-				*if_idx = i;
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
-
-static int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
-				   struct cfg80211_connect_params *sme)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	int status;
-	u8 nw_subtype = (ar->p2p) ? SUBTYPE_P2PDEV : SUBTYPE_NONE;
-	u16 interval;
-
-	ath6kl_cfg80211_sscan_disable(vif);
-
-	vif->sme_state = SME_CONNECTING;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {
-		ath6kl_err("destroy in progress\n");
-		return -EBUSY;
-	}
-
-	if (test_bit(SKIP_SCAN, &ar->flag) &&
-	    ((sme->channel && sme->channel->center_freq == 0) ||
-	     (sme->bssid && is_zero_ether_addr(sme->bssid)))) {
-		ath6kl_err("SkipScan: channel or bssid invalid\n");
-		return -EINVAL;
-	}
-
-	if (down_interruptible(&ar->sem)) {
-		ath6kl_err("busy, couldn't get access\n");
-		return -ERESTARTSYS;
-	}
-
-	if (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {
-		ath6kl_err("busy, destroy in progress\n");
-		up(&ar->sem);
-		return -EBUSY;
-	}
-
-	if (ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)]) {
-		/*
-		 * sleep until the command queue drains
-		 */
-		wait_event_interruptible_timeout(ar->event_wq,
-			ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)] == 0,
-			WMI_TIMEOUT);
-		if (signal_pending(current)) {
-			ath6kl_err("cmd queue drain timeout\n");
-			up(&ar->sem);
-			return -EINTR;
-		}
-	}
-
-	status = ath6kl_set_assoc_req_ies(vif, sme->ie, sme->ie_len);
-	if (status) {
-		up(&ar->sem);
-		return status;
-	}
-
-	if (sme->ie == NULL || sme->ie_len == 0)
-		ar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;
-
-	if (test_bit(CONNECTED, &vif->flags) &&
-	    vif->ssid_len == sme->ssid_len &&
-	    !memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {
-		vif->reconnect_flag = true;
-		status = ath6kl_wmi_reconnect_cmd(ar->wmi, vif->fw_vif_idx,
-						  vif->req_bssid,
-						  vif->ch_hint);
-
-		up(&ar->sem);
-		if (status) {
-			ath6kl_err("wmi_reconnect_cmd failed\n");
-			return -EIO;
-		}
-		return 0;
-	} else if (vif->ssid_len == sme->ssid_len &&
-		   !memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {
-		ath6kl_disconnect(vif);
-	}
-
-	memset(vif->ssid, 0, sizeof(vif->ssid));
-	vif->ssid_len = sme->ssid_len;
-	memcpy(vif->ssid, sme->ssid, sme->ssid_len);
-
-	if (sme->channel)
-		vif->ch_hint = sme->channel->center_freq;
-
-	memset(vif->req_bssid, 0, sizeof(vif->req_bssid));
-	if (sme->bssid && !is_broadcast_ether_addr(sme->bssid))
-		memcpy(vif->req_bssid, sme->bssid, sizeof(vif->req_bssid));
-
-	ath6kl_set_wpa_version(vif, sme->crypto.wpa_versions);
-
-	status = ath6kl_set_auth_type(vif, sme->auth_type);
-	if (status) {
-		up(&ar->sem);
-		return status;
-	}
-
-	if (sme->crypto.n_ciphers_pairwise)
-		ath6kl_set_cipher(vif, sme->crypto.ciphers_pairwise[0], true);
-	else
-		ath6kl_set_cipher(vif, 0, true);
-
-	ath6kl_set_cipher(vif, sme->crypto.cipher_group, false);
-
-	if (sme->crypto.n_akm_suites)
-		ath6kl_set_key_mgmt(vif, sme->crypto.akm_suites[0]);
-
-	if ((sme->key_len) &&
-	    (vif->auth_mode == NONE_AUTH) &&
-	    (vif->prwise_crypto == WEP_CRYPT)) {
-		struct ath6kl_key *key = NULL;
-
-		if (sme->key_idx > WMI_MAX_KEY_INDEX) {
-			ath6kl_err("key index %d out of bounds\n",
-				   sme->key_idx);
-			up(&ar->sem);
-			return -ENOENT;
-		}
-
-		key = &vif->keys[sme->key_idx];
-		key->key_len = sme->key_len;
-		memcpy(key->key, sme->key, key->key_len);
-		key->cipher = vif->prwise_crypto;
-		vif->def_txkey_index = sme->key_idx;
-
-		ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, sme->key_idx,
-				      vif->prwise_crypto,
-				      GROUP_USAGE | TX_USAGE,
-				      key->key_len,
-				      NULL, 0,
-				      key->key, KEY_OP_INIT_VAL, NULL,
-				      NO_SYNC_WMIFLAG);
-	}
-
-	if (!ar->usr_bss_filter) {
-		clear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);
-		if (ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-		    ALL_BSS_FILTER, 0) != 0) {
-			ath6kl_err("couldn't set bss filtering\n");
-			up(&ar->sem);
-			return -EIO;
-		}
-	}
-
-	vif->nw_type = vif->next_mode;
-
-	/* enable enhanced bmiss detection if applicable */
-	ath6kl_cfg80211_sta_bmiss_enhance(vif, true);
-
-	if (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
-		nw_subtype = SUBTYPE_P2PCLIENT;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "%s: connect called with authmode %d dot11 auth %d"
-		   " PW crypto %d PW crypto len %d GRP crypto %d"
-		   " GRP crypto len %d channel hint %u\n",
-		   __func__,
-		   vif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,
-		   vif->prwise_crypto_len, vif->grp_crypto,
-		   vif->grp_crypto_len, vif->ch_hint);
-
-	vif->reconnect_flag = 0;
-
-	if (vif->nw_type == INFRA_NETWORK) {
-		interval = max(vif->listen_intvl_t,
-			       (u16) ATH6KL_MAX_WOW_LISTEN_INTL);
-		status = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,
-						       interval,
-						       0);
-		if (status) {
-			ath6kl_err("couldn't set listen intervel\n");
-			up(&ar->sem);
-			return status;
-		}
-	}
-
-	status = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,
-					vif->dot11_auth_mode, vif->auth_mode,
-					vif->prwise_crypto,
-					vif->prwise_crypto_len,
-					vif->grp_crypto, vif->grp_crypto_len,
-					vif->ssid_len, vif->ssid,
-					vif->req_bssid, vif->ch_hint,
-					ar->connect_ctrl_flags, nw_subtype);
-
-	/* disable background scan if period is 0 */
-	if (sme->bg_scan_period == 0)
-		sme->bg_scan_period = 0xffff;
-
-	/* configure default value if not specified */
-	if (sme->bg_scan_period == -1)
-		sme->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;
-
-	ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx, 0, 0,
-				  sme->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);
-
-	up(&ar->sem);
-
-	if (status == -EINVAL) {
-		memset(vif->ssid, 0, sizeof(vif->ssid));
-		vif->ssid_len = 0;
-		ath6kl_err("invalid request\n");
-		return -ENOENT;
-	} else if (status) {
-		ath6kl_err("ath6kl_wmi_connect_cmd failed\n");
-		return -EIO;
-	}
-
-	if ((!(ar->connect_ctrl_flags & CONNECT_DO_WPA_OFFLOAD)) &&
-	    ((vif->auth_mode == WPA_PSK_AUTH)
-	     || (vif->auth_mode == WPA2_PSK_AUTH))) {
-		mod_timer(&vif->disconnect_timer,
-			  jiffies + msecs_to_jiffies(DISCON_TIMER_INTVAL));
-	}
-
-	ar->connect_ctrl_flags &= ~CONNECT_DO_WPA_OFFLOAD;
-	set_bit(CONNECT_PEND, &vif->flags);
-
-	return 0;
-}
-
-static struct cfg80211_bss *
-ath6kl_add_bss_if_needed(struct ath6kl_vif *vif,
-			 enum network_type nw_type,
-			 const u8 *bssid,
-			 struct ieee80211_channel *chan,
-			 const u8 *beacon_ie,
-			 size_t beacon_ie_len)
-{
-	struct ath6kl *ar = vif->ar;
-	struct cfg80211_bss *bss;
-	u16 cap_mask, cap_val;
-	u8 *ie;
-
-	if (nw_type & ADHOC_NETWORK) {
-		cap_mask = WLAN_CAPABILITY_IBSS;
-		cap_val = WLAN_CAPABILITY_IBSS;
-	} else {
-		cap_mask = WLAN_CAPABILITY_ESS;
-		cap_val = WLAN_CAPABILITY_ESS;
-	}
-
-	bss = cfg80211_get_bss(ar->wiphy, chan, bssid,
-			       vif->ssid, vif->ssid_len,
-			       cap_mask, cap_val);
-	if (bss == NULL) {
-		/*
-		 * Since cfg80211 may not yet know about the BSS,
-		 * generate a partial entry until the first BSS info
-		 * event becomes available.
-		 *
-		 * Prepend SSID element since it is not included in the Beacon
-		 * IEs from the target.
-		 */
-		ie = kmalloc(2 + vif->ssid_len + beacon_ie_len, GFP_KERNEL);
-		if (ie == NULL)
-			return NULL;
-		ie[0] = WLAN_EID_SSID;
-		ie[1] = vif->ssid_len;
-		memcpy(ie + 2, vif->ssid, vif->ssid_len);
-		memcpy(ie + 2 + vif->ssid_len, beacon_ie, beacon_ie_len);
-		bss = cfg80211_inform_bss(ar->wiphy, chan,
-					  bssid, 0, cap_val, 100,
-					  ie, 2 + vif->ssid_len + beacon_ie_len,
-					  0, GFP_KERNEL);
-		if (bss)
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "added bss %pM to "
-				   "cfg80211\n", bssid);
-		kfree(ie);
-	} else
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "cfg80211 already has a bss\n");
-
-	return bss;
-}
-
-void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
-				   u8 *bssid, u16 listen_intvl,
-				   u16 beacon_intvl,
-				   enum network_type nw_type,
-				   u8 beacon_ie_len, u8 assoc_req_len,
-				   u8 assoc_resp_len, u8 *assoc_info)
-{
-	struct ieee80211_channel *chan;
-	struct ath6kl *ar = vif->ar;
-	struct cfg80211_bss *bss;
-
-	/* capinfo + listen interval */
-	u8 assoc_req_ie_offset = sizeof(u16) + sizeof(u16);
-
-	/* capinfo + status code +  associd */
-	u8 assoc_resp_ie_offset = sizeof(u16) + sizeof(u16) + sizeof(u16);
-
-	u8 *assoc_req_ie = assoc_info + beacon_ie_len + assoc_req_ie_offset;
-	u8 *assoc_resp_ie = assoc_info + beacon_ie_len + assoc_req_len +
-	    assoc_resp_ie_offset;
-
-	assoc_req_len -= assoc_req_ie_offset;
-	assoc_resp_len -= assoc_resp_ie_offset;
-
-	/*
-	 * Store Beacon interval here; DTIM period will be available only once
-	 * a Beacon frame from the AP is seen.
-	 */
-	vif->assoc_bss_beacon_int = beacon_intvl;
-	clear_bit(DTIM_PERIOD_AVAIL, &vif->flags);
-
-	if (nw_type & ADHOC_NETWORK) {
-		if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-				   "%s: ath6k not in ibss mode\n", __func__);
-			return;
-		}
-	}
-
-	if (nw_type & INFRA_NETWORK) {
-		if (vif->wdev.iftype != NL80211_IFTYPE_STATION &&
-		    vif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-				   "%s: ath6k not in station mode\n", __func__);
-			return;
-		}
-	}
-
-	chan = ieee80211_get_channel(ar->wiphy, (int) channel);
-
-	bss = ath6kl_add_bss_if_needed(vif, nw_type, bssid, chan,
-				       assoc_info, beacon_ie_len);
-	if (!bss) {
-		ath6kl_err("could not add cfg80211 bss entry\n");
-		return;
-	}
-
-	if (nw_type & ADHOC_NETWORK) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "ad-hoc %s selected\n",
-			   nw_type & ADHOC_CREATOR ? "creator" : "joiner");
-		cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
-		cfg80211_put_bss(bss);
-		return;
-	}
-
-	if (vif->sme_state == SME_CONNECTING) {
-		/* inform connect result to cfg80211 */
-		vif->sme_state = SME_CONNECTED;
-		cfg80211_connect_result(vif->ndev, bssid,
-					assoc_req_ie, assoc_req_len,
-					assoc_resp_ie, assoc_resp_len,
-					WLAN_STATUS_SUCCESS, GFP_KERNEL);
-		cfg80211_put_bss(bss);
-	} else if (vif->sme_state == SME_CONNECTED) {
-		/* inform roam event to cfg80211 */
-		cfg80211_roamed_bss(vif->ndev, bss, assoc_req_ie, assoc_req_len,
-				    assoc_resp_ie, assoc_resp_len, GFP_KERNEL);
-	}
-}
-
-static int ath6kl_cfg80211_disconnect(struct wiphy *wiphy,
-				      struct net_device *dev, u16 reason_code)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: reason=%u\n", __func__,
-		   reason_code);
-
-	ath6kl_cfg80211_sscan_disable(vif);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {
-		ath6kl_err("busy, destroy in progress\n");
-		return -EBUSY;
-	}
-
-	if (down_interruptible(&ar->sem)) {
-		ath6kl_err("busy, couldn't get access\n");
-		return -ERESTARTSYS;
-	}
-
-	vif->reconnect_flag = 0;
-	ath6kl_disconnect(vif);
-	memset(vif->ssid, 0, sizeof(vif->ssid));
-	vif->ssid_len = 0;
-
-	if (!test_bit(SKIP_SCAN, &ar->flag))
-		memset(vif->req_bssid, 0, sizeof(vif->req_bssid));
-
-	up(&ar->sem);
-
-	vif->sme_state = SME_DISCONNECTED;
-
-	return 0;
-}
-
-void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
-				      u8 *bssid, u8 assoc_resp_len,
-				      u8 *assoc_info, u16 proto_reason)
-{
-	struct ath6kl *ar = vif->ar;
-
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
-	}
-
-	if (vif->nw_type & ADHOC_NETWORK) {
-		if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-				   "%s: ath6k not in ibss mode\n", __func__);
-			return;
-		}
-		memset(bssid, 0, ETH_ALEN);
-		cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
-		return;
-	}
-
-	if (vif->nw_type & INFRA_NETWORK) {
-		if (vif->wdev.iftype != NL80211_IFTYPE_STATION &&
-		    vif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-				   "%s: ath6k not in station mode\n", __func__);
-			return;
-		}
-	}
-
-	clear_bit(CONNECT_PEND, &vif->flags);
-
-	if (vif->sme_state == SME_CONNECTING) {
-		cfg80211_connect_result(vif->ndev,
-				bssid, NULL, 0,
-				NULL, 0,
-				WLAN_STATUS_UNSPECIFIED_FAILURE,
-				GFP_KERNEL);
-	} else if (vif->sme_state == SME_CONNECTED) {
-		cfg80211_disconnected(vif->ndev, proto_reason,
-				      NULL, 0, GFP_KERNEL);
-	}
-
-	vif->sme_state = SME_DISCONNECTED;
-
-	/*
-	 * Send a disconnect command to target when a disconnect event is
-	 * received with reason code other than 3 (DISCONNECT_CMD - disconnect
-	 * request from host) to make the firmware stop trying to connect even
-	 * after giving disconnect event. There will be one more disconnect
-	 * event for this disconnect command with reason code DISCONNECT_CMD
-	 * which won't be notified to cfg80211.
-	 */
-	if (reason != DISCONNECT_CMD)
-		ath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);
-}
-
-static int ath6kl_set_probed_ssids(struct ath6kl *ar,
-				   struct ath6kl_vif *vif,
-				   struct cfg80211_ssid *ssids, int n_ssids,
-				   struct cfg80211_match_set *match_set,
-				   int n_match_ssid)
-{
-	u8 i, j, index_to_add, ssid_found = false;
-	struct ath6kl_cfg80211_match_probe_ssid ssid_list[MAX_PROBED_SSIDS];
-
-	memset(ssid_list, 0, sizeof(ssid_list));
-
-	if (n_ssids > MAX_PROBED_SSIDS ||
-	    n_match_ssid > MAX_PROBED_SSIDS)
-		return -EINVAL;
-
-	for (i = 0; i < n_ssids; i++) {
-		memcpy(ssid_list[i].ssid.ssid,
-		       ssids[i].ssid,
-		       ssids[i].ssid_len);
-		ssid_list[i].ssid.ssid_len = ssids[i].ssid_len;
-
-		if (ssids[i].ssid_len)
-			ssid_list[i].flag = SPECIFIC_SSID_FLAG;
-		else
-			ssid_list[i].flag = ANY_SSID_FLAG;
-
-		if (n_match_ssid == 0)
-			ssid_list[i].flag |= MATCH_SSID_FLAG;
-	}
-
-	index_to_add = i;
-
-	for (i = 0; i < n_match_ssid; i++) {
-		ssid_found = false;
-
-		for (j = 0; j < n_ssids; j++) {
-			if ((match_set[i].ssid.ssid_len ==
-			     ssid_list[j].ssid.ssid_len) &&
-			    (!memcmp(ssid_list[j].ssid.ssid,
-				     match_set[i].ssid.ssid,
-				     match_set[i].ssid.ssid_len))) {
-				ssid_list[j].flag |= MATCH_SSID_FLAG;
-				ssid_found = true;
-				break;
-			}
-		}
-
-		if (ssid_found)
-			continue;
-
-		if (index_to_add >= MAX_PROBED_SSIDS)
-			continue;
-
-		ssid_list[index_to_add].ssid.ssid_len =
-			match_set[i].ssid.ssid_len;
-		memcpy(ssid_list[index_to_add].ssid.ssid,
-		       match_set[i].ssid.ssid,
-		       match_set[i].ssid.ssid_len);
-		ssid_list[index_to_add].flag |= MATCH_SSID_FLAG;
-		index_to_add++;
-	}
-
-	for (i = 0; i < index_to_add; i++) {
-		ath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,
-					  ssid_list[i].flag,
-					  ssid_list[i].ssid.ssid_len,
-					  ssid_list[i].ssid.ssid);
-
-	}
-
-	/* Make sure no old entries are left behind */
-	for (i = index_to_add; i < MAX_PROBED_SSIDS; i++) {
-		ath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,
-					  DISABLE_SSID_FLAG, 0, NULL);
-	}
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
-				struct cfg80211_scan_request *request)
-{
-	struct ath6kl *ar = ath6kl_priv(ndev);
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	s8 n_channels = 0;
-	u16 *channels = NULL;
-	int ret = 0;
-	u32 force_fg_scan = 0;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	ath6kl_cfg80211_sscan_disable(vif);
-
-	if (!ar->usr_bss_filter) {
-		clear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);
-		ret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-					       ALL_BSS_FILTER, 0);
-		if (ret) {
-			ath6kl_err("couldn't set bss filtering\n");
-			return ret;
-		}
-	}
-
-	ret = ath6kl_set_probed_ssids(ar, vif, request->ssids,
-				      request->n_ssids, NULL, 0);
-	if (ret < 0)
-		return ret;
-
-	/* this also clears IE in fw if it's not set */
-	ret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_PROBE_REQ,
-				       request->ie, request->ie_len);
-	if (ret) {
-		ath6kl_err("failed to set Probe Request appie for "
-			   "scan");
-		return ret;
-	}
-
-	/*
-	 * Scan only the requested channels if the request specifies a set of
-	 * channels. If the list is longer than the target supports, do not
-	 * configure the list and instead, scan all available channels.
-	 */
-	if (request->n_channels > 0 &&
-	    request->n_channels <= WMI_MAX_CHANNELS) {
-		u8 i;
-
-		n_channels = request->n_channels;
-
-		channels = kzalloc(n_channels * sizeof(u16), GFP_KERNEL);
-		if (channels == NULL) {
-			ath6kl_warn("failed to set scan channels, "
-				    "scan all channels");
-			n_channels = 0;
-		}
-
-		for (i = 0; i < n_channels; i++)
-			channels[i] = request->channels[i]->center_freq;
-	}
-
-	if (test_bit(CONNECTED, &vif->flags))
-		force_fg_scan = 1;
-
-	vif->scan_req = request;
-
-	ret = ath6kl_wmi_beginscan_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_LONG_SCAN, force_fg_scan,
-				       false, 0,
-				       ATH6KL_FG_SCAN_INTERVAL,
-				       n_channels, channels,
-				       request->no_cck,
-				       request->rates);
-
-	if (ret) {
-		ath6kl_err("failed to start scan: %d\n", ret);
-		vif->scan_req = NULL;
-	}
-
-	kfree(channels);
-
-	return ret;
-}
-
-void ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)
-{
-	struct ath6kl *ar = vif->ar;
-	int i;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: status%s\n", __func__,
-		   aborted ? " aborted" : "");
-
-	if (!vif->scan_req)
-		return;
-
-	if (aborted)
-		goto out;
-
-	if (vif->scan_req->n_ssids && vif->scan_req->ssids[0].ssid_len) {
-		for (i = 0; i < vif->scan_req->n_ssids; i++) {
-			ath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx,
-						  i + 1, DISABLE_SSID_FLAG,
-						  0, NULL);
-		}
-	}
-
-out:
-	cfg80211_scan_done(vif->scan_req, aborted);
-	vif->scan_req = NULL;
-}
-
-void ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,
-				      enum wmi_phy_mode mode)
-{
-	enum nl80211_channel_type type;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "channel switch notify nw_type %d freq %d mode %d\n",
-		   vif->nw_type, freq, mode);
-
-	type = (mode == WMI_11G_HT20) ? NL80211_CHAN_HT20 : NL80211_CHAN_NO_HT;
-
-	cfg80211_ch_switch_notify(vif->ndev, freq, type);
-}
-
-static int ath6kl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
-				   u8 key_index, bool pairwise,
-				   const u8 *mac_addr,
-				   struct key_params *params)
-{
-	struct ath6kl *ar = ath6kl_priv(ndev);
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	struct ath6kl_key *key = NULL;
-	int seq_len;
-	u8 key_usage;
-	u8 key_type;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (params->cipher == CCKM_KRK_CIPHER_SUITE) {
-		if (params->key_len != WMI_KRK_LEN)
-			return -EINVAL;
-		return ath6kl_wmi_add_krk_cmd(ar->wmi, vif->fw_vif_idx,
-					      params->key);
-	}
-
-	if (key_index > WMI_MAX_KEY_INDEX) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "%s: key index %d out of bounds\n", __func__,
-			   key_index);
-		return -ENOENT;
-	}
-
-	key = &vif->keys[key_index];
-	memset(key, 0, sizeof(struct ath6kl_key));
-
-	if (pairwise)
-		key_usage = PAIRWISE_USAGE;
-	else
-		key_usage = GROUP_USAGE;
-
-	seq_len = params->seq_len;
-	if (params->cipher == WLAN_CIPHER_SUITE_SMS4 &&
-	    seq_len > ATH6KL_KEY_SEQ_LEN) {
-		/* Only first half of the WPI PN is configured */
-		seq_len = ATH6KL_KEY_SEQ_LEN;
-	}
-	if (params->key_len > WLAN_MAX_KEY_LEN ||
-	    seq_len > sizeof(key->seq))
-		return -EINVAL;
-
-	key->key_len = params->key_len;
-	memcpy(key->key, params->key, key->key_len);
-	key->seq_len = seq_len;
-	memcpy(key->seq, params->seq, key->seq_len);
-	key->cipher = params->cipher;
-
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		key_type = WEP_CRYPT;
-		break;
-
-	case WLAN_CIPHER_SUITE_TKIP:
-		key_type = TKIP_CRYPT;
-		break;
-
-	case WLAN_CIPHER_SUITE_CCMP:
-		key_type = AES_CRYPT;
-		break;
-	case WLAN_CIPHER_SUITE_SMS4:
-		key_type = WAPI_CRYPT;
-		break;
-
-	default:
-		return -ENOTSUPP;
-	}
-
-	if (((vif->auth_mode == WPA_PSK_AUTH)
-	     || (vif->auth_mode == WPA2_PSK_AUTH))
-	    && (key_usage & GROUP_USAGE))
-		del_timer(&vif->disconnect_timer);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "%s: index %d, key_len %d, key_type 0x%x, key_usage 0x%x, seq_len %d\n",
-		   __func__, key_index, key->key_len, key_type,
-		   key_usage, key->seq_len);
-
-	if (vif->nw_type == AP_NETWORK && !pairwise &&
-	    (key_type == TKIP_CRYPT || key_type == AES_CRYPT ||
-	     key_type == WAPI_CRYPT)) {
-		ar->ap_mode_bkey.valid = true;
-		ar->ap_mode_bkey.key_index = key_index;
-		ar->ap_mode_bkey.key_type = key_type;
-		ar->ap_mode_bkey.key_len = key->key_len;
-		memcpy(ar->ap_mode_bkey.key, key->key, key->key_len);
-		if (!test_bit(CONNECTED, &vif->flags)) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "Delay initial group "
-				   "key configuration until AP mode has been "
-				   "started\n");
-			/*
-			 * The key will be set in ath6kl_connect_ap_mode() once
-			 * the connected event is received from the target.
-			 */
-			return 0;
-		}
-	}
-
-	if (vif->next_mode == AP_NETWORK && key_type == WEP_CRYPT &&
-	    !test_bit(CONNECTED, &vif->flags)) {
-		/*
-		 * Store the key locally so that it can be re-configured after
-		 * the AP mode has properly started
-		 * (ath6kl_install_statioc_wep_keys).
-		 */
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "Delay WEP key configuration "
-			   "until AP mode has been started\n");
-		vif->wep_key_list[key_index].key_len = key->key_len;
-		memcpy(vif->wep_key_list[key_index].key, key->key,
-		       key->key_len);
-		return 0;
-	}
-
-	return ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, key_index,
-				     key_type, key_usage, key->key_len,
-				     key->seq, key->seq_len, key->key,
-				     KEY_OP_INIT_VAL,
-				     (u8 *) mac_addr, SYNC_BOTH_WMIFLAG);
-}
-
-static int ath6kl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
-				   u8 key_index, bool pairwise,
-				   const u8 *mac_addr)
-{
-	struct ath6kl *ar = ath6kl_priv(ndev);
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (key_index > WMI_MAX_KEY_INDEX) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "%s: key index %d out of bounds\n", __func__,
-			   key_index);
-		return -ENOENT;
-	}
-
-	if (!vif->keys[key_index].key_len) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "%s: index %d is empty\n", __func__, key_index);
-		return 0;
-	}
-
-	vif->keys[key_index].key_len = 0;
-
-	return ath6kl_wmi_deletekey_cmd(ar->wmi, vif->fw_vif_idx, key_index);
-}
-
-static int ath6kl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,
-				   u8 key_index, bool pairwise,
-				   const u8 *mac_addr, void *cookie,
-				   void (*callback) (void *cookie,
-						     struct key_params *))
-{
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	struct ath6kl_key *key = NULL;
-	struct key_params params;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (key_index > WMI_MAX_KEY_INDEX) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "%s: key index %d out of bounds\n", __func__,
-			   key_index);
-		return -ENOENT;
-	}
-
-	key = &vif->keys[key_index];
-	memset(&params, 0, sizeof(params));
-	params.cipher = key->cipher;
-	params.key_len = key->key_len;
-	params.seq_len = key->seq_len;
-	params.seq = key->seq;
-	params.key = key->key;
-
-	callback(cookie, &params);
-
-	return key->key_len ? 0 : -ENOENT;
-}
-
-static int ath6kl_cfg80211_set_default_key(struct wiphy *wiphy,
-					   struct net_device *ndev,
-					   u8 key_index, bool unicast,
-					   bool multicast)
-{
-	struct ath6kl *ar = ath6kl_priv(ndev);
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	struct ath6kl_key *key = NULL;
-	u8 key_usage;
-	enum crypto_type key_type = NONE_CRYPT;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (key_index > WMI_MAX_KEY_INDEX) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "%s: key index %d out of bounds\n",
-			   __func__, key_index);
-		return -ENOENT;
-	}
-
-	if (!vif->keys[key_index].key_len) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: invalid key index %d\n",
-			   __func__, key_index);
-		return -EINVAL;
-	}
-
-	vif->def_txkey_index = key_index;
-	key = &vif->keys[vif->def_txkey_index];
-	key_usage = GROUP_USAGE;
-	if (vif->prwise_crypto == WEP_CRYPT)
-		key_usage |= TX_USAGE;
-	if (unicast)
-		key_type = vif->prwise_crypto;
-	if (multicast)
-		key_type = vif->grp_crypto;
-
-	if (vif->next_mode == AP_NETWORK && !test_bit(CONNECTED, &vif->flags))
-		return 0; /* Delay until AP mode has been started */
-
-	return ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx,
-				     vif->def_txkey_index,
-				     key_type, key_usage,
-				     key->key_len, key->seq, key->seq_len,
-				     key->key,
-				     KEY_OP_INIT_VAL, NULL,
-				     SYNC_BOTH_WMIFLAG);
-}
-
-void ath6kl_cfg80211_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid,
-				       bool ismcast)
-{
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "%s: keyid %d, ismcast %d\n", __func__, keyid, ismcast);
-
-	cfg80211_michael_mic_failure(vif->ndev, vif->bssid,
-				     (ismcast ? NL80211_KEYTYPE_GROUP :
-				      NL80211_KEYTYPE_PAIRWISE), keyid, NULL,
-				     GFP_KERNEL);
-}
-
-static int ath6kl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
-{
-	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
-	struct ath6kl_vif *vif;
-	int ret;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: changed 0x%x\n", __func__,
-		   changed);
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
-		ret = ath6kl_wmi_set_rts_cmd(ar->wmi, wiphy->rts_threshold);
-		if (ret != 0) {
-			ath6kl_err("ath6kl_wmi_set_rts_cmd failed\n");
-			return -EIO;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * The type nl80211_tx_power_setting replaces the following
- * data type from 2.6.36 onwards
-*/
-static int ath6kl_cfg80211_set_txpower(struct wiphy *wiphy,
-				       enum nl80211_tx_power_setting type,
-				       int mbm)
-{
-	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
-	struct ath6kl_vif *vif;
-	u8 ath6kl_dbm;
-	int dbm = MBM_TO_DBM(mbm);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type 0x%x, dbm %d\n", __func__,
-		   type, dbm);
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	switch (type) {
-	case NL80211_TX_POWER_AUTOMATIC:
-		return 0;
-	case NL80211_TX_POWER_LIMITED:
-		ar->tx_pwr = ath6kl_dbm = dbm;
-		break;
-	default:
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type 0x%x not supported\n",
-			   __func__, type);
-		return -EOPNOTSUPP;
-	}
-
-	ath6kl_wmi_set_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx, ath6kl_dbm);
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_get_txpower(struct wiphy *wiphy, int *dbm)
-{
-	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
-	struct ath6kl_vif *vif;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (test_bit(CONNECTED, &vif->flags)) {
-		ar->tx_pwr = 0;
-
-		if (ath6kl_wmi_get_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx) != 0) {
-			ath6kl_err("ath6kl_wmi_get_tx_pwr_cmd failed\n");
-			return -EIO;
-		}
-
-		wait_event_interruptible_timeout(ar->event_wq, ar->tx_pwr != 0,
-						 5 * HZ);
-
-		if (signal_pending(current)) {
-			ath6kl_err("target did not respond\n");
-			return -EINTR;
-		}
-	}
-
-	*dbm = ar->tx_pwr;
-	return 0;
-}
-
-static int ath6kl_cfg80211_set_power_mgmt(struct wiphy *wiphy,
-					  struct net_device *dev,
-					  bool pmgmt, int timeout)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct wmi_power_mode_cmd mode;
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: pmgmt %d, timeout %d\n",
-		   __func__, pmgmt, timeout);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (pmgmt) {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: max perf\n", __func__);
-		mode.pwr_mode = REC_POWER;
-	} else {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: rec power\n", __func__);
-		mode.pwr_mode = MAX_PERF_POWER;
-	}
-
-	if (ath6kl_wmi_powermode_cmd(ar->wmi, vif->fw_vif_idx,
-	     mode.pwr_mode) != 0) {
-		ath6kl_err("wmi_powermode_cmd failed\n");
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static struct net_device *ath6kl_cfg80211_add_iface(struct wiphy *wiphy,
-						    char *name,
-						    enum nl80211_iftype type,
-						    u32 *flags,
-						    struct vif_params *params)
-{
-	struct ath6kl *ar = wiphy_priv(wiphy);
-	struct net_device *ndev;
-	u8 if_idx, nw_type;
-
-	if (ar->num_vif == ar->vif_max) {
-		ath6kl_err("Reached maximum number of supported vif\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	if (!ath6kl_is_valid_iftype(ar, type, &if_idx, &nw_type)) {
-		ath6kl_err("Not a supported interface type\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	ndev = ath6kl_interface_add(ar, name, type, if_idx, nw_type);
-	if (!ndev)
-		return ERR_PTR(-ENOMEM);
-
-	ar->num_vif++;
-
-	return ndev;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-struct net_device *ath6kl_cfg80211_add_p2p0_iface(struct ath6kl *ar)
-{
-	return ath6kl_cfg80211_add_iface(ar->wiphy, "p2p0",
-					 NL80211_IFTYPE_P2P_CLIENT,
-					 NULL, NULL);
-}
-#endif
-
-static int ath6kl_cfg80211_del_iface(struct wiphy *wiphy,
-				     struct net_device *ndev)
-{
-	struct ath6kl *ar = wiphy_priv(wiphy);
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-
-	spin_lock_bh(&ar->list_lock);
-	list_del(&vif->list);
-	spin_unlock_bh(&ar->list_lock);
-
-	ath6kl_cleanup_vif(vif, test_bit(WMI_READY, &ar->flag));
-
-	ath6kl_deinit_if_data(vif);
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_change_iface(struct wiphy *wiphy,
-					struct net_device *ndev,
-					enum nl80211_iftype type, u32 *flags,
-					struct vif_params *params)
-{
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	int i;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type %u\n", __func__, type);
-
-	/*
-	 * Don't bring up p2p on an interface which is not initialized
-	 * for p2p operation where fw does not have capability to switch
-	 * dynamically between non-p2p and p2p type interface.
-	 */
-	if (!test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,
-		      vif->ar->fw_capabilities) &&
-	    (type == NL80211_IFTYPE_P2P_CLIENT ||
-	     type == NL80211_IFTYPE_P2P_GO)) {
-		if (vif->ar->vif_max == 1) {
-			if (vif->fw_vif_idx != 0)
-				return -EINVAL;
-			else
-				goto set_iface_type;
-		}
-
-		for (i = vif->ar->max_norm_iface; i < vif->ar->vif_max; i++) {
-			if (i == vif->fw_vif_idx)
-				break;
-		}
-
-		if (i == vif->ar->vif_max) {
-			ath6kl_err("Invalid interface to bring up P2P\n");
-			return -EINVAL;
-		}
-	}
-
-	/* need to clean up enhanced bmiss detection fw state */
-	ath6kl_cfg80211_sta_bmiss_enhance(vif, false);
-
-set_iface_type:
-	switch (type) {
-	case NL80211_IFTYPE_STATION:
-		vif->next_mode = INFRA_NETWORK;
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		vif->next_mode = ADHOC_NETWORK;
-		break;
-	case NL80211_IFTYPE_AP:
-		vif->next_mode = AP_NETWORK;
-		break;
-	case NL80211_IFTYPE_P2P_CLIENT:
-		vif->next_mode = INFRA_NETWORK;
-		break;
-	case NL80211_IFTYPE_P2P_GO:
-		vif->next_mode = AP_NETWORK;
-		break;
-	default:
-		ath6kl_err("invalid interface type %u\n", type);
-		return -EOPNOTSUPP;
-	}
-
-	vif->wdev.iftype = type;
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_join_ibss(struct wiphy *wiphy,
-				     struct net_device *dev,
-				     struct cfg80211_ibss_params *ibss_param)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	int status;
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	vif->ssid_len = ibss_param->ssid_len;
-	memcpy(vif->ssid, ibss_param->ssid, vif->ssid_len);
-
-	if (ibss_param->channel)
-		vif->ch_hint = ibss_param->channel->center_freq;
-
-	if (ibss_param->channel_fixed) {
-		/*
-		 * TODO: channel_fixed: The channel should be fixed, do not
-		 * search for IBSSs to join on other channels. Target
-		 * firmware does not support this feature, needs to be
-		 * updated.
-		 */
-		return -EOPNOTSUPP;
-	}
-
-	memset(vif->req_bssid, 0, sizeof(vif->req_bssid));
-	if (ibss_param->bssid && !is_broadcast_ether_addr(ibss_param->bssid))
-		memcpy(vif->req_bssid, ibss_param->bssid,
-		       sizeof(vif->req_bssid));
-
-	ath6kl_set_wpa_version(vif, 0);
-
-	status = ath6kl_set_auth_type(vif, NL80211_AUTHTYPE_OPEN_SYSTEM);
-	if (status)
-		return status;
-
-	if (ibss_param->privacy) {
-		ath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, true);
-		ath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, false);
-	} else {
-		ath6kl_set_cipher(vif, 0, true);
-		ath6kl_set_cipher(vif, 0, false);
-	}
-
-	vif->nw_type = vif->next_mode;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "%s: connect called with authmode %d dot11 auth %d"
-		   " PW crypto %d PW crypto len %d GRP crypto %d"
-		   " GRP crypto len %d channel hint %u\n",
-		   __func__,
-		   vif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,
-		   vif->prwise_crypto_len, vif->grp_crypto,
-		   vif->grp_crypto_len, vif->ch_hint);
-
-	status = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,
-					vif->dot11_auth_mode, vif->auth_mode,
-					vif->prwise_crypto,
-					vif->prwise_crypto_len,
-					vif->grp_crypto, vif->grp_crypto_len,
-					vif->ssid_len, vif->ssid,
-					vif->req_bssid, vif->ch_hint,
-					ar->connect_ctrl_flags, SUBTYPE_NONE);
-	set_bit(CONNECT_PEND, &vif->flags);
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_leave_ibss(struct wiphy *wiphy,
-				      struct net_device *dev)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	ath6kl_disconnect(vif);
-	memset(vif->ssid, 0, sizeof(vif->ssid));
-	vif->ssid_len = 0;
-
-	return 0;
-}
-
-static const u32 cipher_suites[] = {
-	WLAN_CIPHER_SUITE_WEP40,
-	WLAN_CIPHER_SUITE_WEP104,
-	WLAN_CIPHER_SUITE_TKIP,
-	WLAN_CIPHER_SUITE_CCMP,
-	CCKM_KRK_CIPHER_SUITE,
-	WLAN_CIPHER_SUITE_SMS4,
-};
-
-static bool is_rate_legacy(s32 rate)
-{
-	static const s32 legacy[] = { 1000, 2000, 5500, 11000,
-		6000, 9000, 12000, 18000, 24000,
-		36000, 48000, 54000
-	};
-	u8 i;
-
-	for (i = 0; i < ARRAY_SIZE(legacy); i++)
-		if (rate == legacy[i])
-			return true;
-
-	return false;
-}
-
-static bool is_rate_ht20(s32 rate, u8 *mcs, bool *sgi)
-{
-	static const s32 ht20[] = { 6500, 13000, 19500, 26000, 39000,
-		52000, 58500, 65000, 72200
-	};
-	u8 i;
-
-	for (i = 0; i < ARRAY_SIZE(ht20); i++) {
-		if (rate == ht20[i]) {
-			if (i == ARRAY_SIZE(ht20) - 1)
-				/* last rate uses sgi */
-				*sgi = true;
-			else
-				*sgi = false;
-
-			*mcs = i;
-			return true;
-		}
-	}
-	return false;
-}
-
-static bool is_rate_ht40(s32 rate, u8 *mcs, bool *sgi)
-{
-	static const s32 ht40[] = { 13500, 27000, 40500, 54000,
-		81000, 108000, 121500, 135000,
-		150000
-	};
-	u8 i;
-
-	for (i = 0; i < ARRAY_SIZE(ht40); i++) {
-		if (rate == ht40[i]) {
-			if (i == ARRAY_SIZE(ht40) - 1)
-				/* last rate uses sgi */
-				*sgi = true;
-			else
-				*sgi = false;
-
-			*mcs = i;
-			return true;
-		}
-	}
-
-	return false;
-}
-
-static int ath6kl_get_station(struct wiphy *wiphy, struct net_device *dev,
-			      u8 *mac, struct station_info *sinfo)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	long left;
-	bool sgi;
-	s32 rate;
-	int ret;
-	u8 mcs;
-
-	if (memcmp(mac, vif->bssid, ETH_ALEN) != 0)
-		return -ENOENT;
-
-	if (down_interruptible(&ar->sem))
-		return -EBUSY;
-
-	set_bit(STATS_UPDATE_PEND, &vif->flags);
-
-	ret = ath6kl_wmi_get_stats_cmd(ar->wmi, vif->fw_vif_idx);
-
-	if (ret != 0) {
-		up(&ar->sem);
-		return -EIO;
-	}
-
-	left = wait_event_interruptible_timeout(ar->event_wq,
-						!test_bit(STATS_UPDATE_PEND,
-							  &vif->flags),
-						WMI_TIMEOUT);
-
-	up(&ar->sem);
-
-	if (left == 0)
-		return -ETIMEDOUT;
-	else if (left < 0)
-		return left;
-
-	if (vif->target_stats.rx_byte) {
-		sinfo->rx_bytes = vif->target_stats.rx_byte;
-		sinfo->filled |= STATION_INFO_RX_BYTES;
-		sinfo->rx_packets = vif->target_stats.rx_pkt;
-		sinfo->filled |= STATION_INFO_RX_PACKETS;
-	}
-
-	if (vif->target_stats.tx_byte) {
-		sinfo->tx_bytes = vif->target_stats.tx_byte;
-		sinfo->filled |= STATION_INFO_TX_BYTES;
-		sinfo->tx_packets = vif->target_stats.tx_pkt;
-		sinfo->filled |= STATION_INFO_TX_PACKETS;
-	}
-
-	sinfo->signal = vif->target_stats.cs_rssi;
-	sinfo->filled |= STATION_INFO_SIGNAL;
-
-	rate = vif->target_stats.tx_ucast_rate;
-
-	if (is_rate_legacy(rate)) {
-		sinfo->txrate.legacy = rate / 100;
-	} else if (is_rate_ht20(rate, &mcs, &sgi)) {
-		if (sgi) {
-			sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
-			sinfo->txrate.mcs = mcs - 1;
-		} else {
-			sinfo->txrate.mcs = mcs;
-		}
-
-		sinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;
-	} else if (is_rate_ht40(rate, &mcs, &sgi)) {
-		if (sgi) {
-			sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
-			sinfo->txrate.mcs = mcs - 1;
-		} else {
-			sinfo->txrate.mcs = mcs;
-		}
-
-		sinfo->txrate.flags |= RATE_INFO_FLAGS_40_MHZ_WIDTH;
-		sinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;
-	} else {
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-			   "invalid rate from stats: %d\n", rate);
-		ath6kl_debug_war(ar, ATH6KL_WAR_INVALID_RATE);
-		return 0;
-	}
-
-	sinfo->filled |= STATION_INFO_TX_BITRATE;
-
-	if (test_bit(CONNECTED, &vif->flags) &&
-	    test_bit(DTIM_PERIOD_AVAIL, &vif->flags) &&
-	    vif->nw_type == INFRA_NETWORK) {
-		sinfo->filled |= STATION_INFO_BSS_PARAM;
-		sinfo->bss_param.flags = 0;
-		sinfo->bss_param.dtim_period = vif->assoc_bss_dtim_period;
-		sinfo->bss_param.beacon_interval = vif->assoc_bss_beacon_int;
-	}
-
-	return 0;
-}
-
-static int ath6kl_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
-			    struct cfg80211_pmksa *pmksa)
-{
-	struct ath6kl *ar = ath6kl_priv(netdev);
-	struct ath6kl_vif *vif = netdev_priv(netdev);
-
-	return ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,
-				       pmksa->pmkid, true);
-}
-
-static int ath6kl_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
-			    struct cfg80211_pmksa *pmksa)
-{
-	struct ath6kl *ar = ath6kl_priv(netdev);
-	struct ath6kl_vif *vif = netdev_priv(netdev);
-
-	return ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,
-				       pmksa->pmkid, false);
-}
-
-static int ath6kl_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
-{
-	struct ath6kl *ar = ath6kl_priv(netdev);
-	struct ath6kl_vif *vif = netdev_priv(netdev);
-
-	if (test_bit(CONNECTED, &vif->flags))
-		return ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx,
-					       vif->bssid, NULL, false);
-	return 0;
-}
-
-static int ath6kl_wow_usr(struct ath6kl *ar, struct ath6kl_vif *vif,
-			  struct cfg80211_wowlan *wow, u32 *filter)
-{
-	int ret, pos;
-	u8 mask[WOW_MASK_SIZE];
-	u16 i;
-
-	/* Configure the patterns that we received from the user. */
-	for (i = 0; i < wow->n_patterns; i++) {
-
-		/*
-		 * Convert given nl80211 specific mask value to equivalent
-		 * driver specific mask value and send it to the chip along
-		 * with patterns. For example, If the mask value defined in
-		 * struct cfg80211_wowlan is 0xA (equivalent binary is 1010),
-		 * then equivalent driver specific mask value is
-		 * "0xFF 0x00 0xFF 0x00".
-		 */
-		memset(&mask, 0, sizeof(mask));
-		for (pos = 0; pos < wow->patterns[i].pattern_len; pos++) {
-			if (wow->patterns[i].mask[pos / 8] & (0x1 << (pos % 8)))
-				mask[pos] = 0xFF;
-		}
-		/*
-		 * Note: Pattern's offset is not passed as part of wowlan
-		 * parameter from CFG layer. So it's always passed as ZERO
-		 * to the firmware. It means, given WOW patterns are always
-		 * matched from the first byte of received pkt in the firmware.
-		 */
-		ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-				vif->fw_vif_idx, WOW_LIST_ID,
-				wow->patterns[i].pattern_len,
-				0 /* pattern offset */,
-				wow->patterns[i].pattern, mask);
-		if (ret)
-			return ret;
-	}
-
-	if (wow->disconnect)
-		*filter |= WOW_FILTER_OPTION_NWK_DISASSOC;
-
-	if (wow->magic_pkt)
-		*filter |= WOW_FILTER_OPTION_MAGIC_PACKET;
-
-	if (wow->gtk_rekey_failure)
-		*filter |= WOW_FILTER_OPTION_GTK_ERROR;
-
-	if (wow->eap_identity_req)
-		*filter |= WOW_FILTER_OPTION_EAP_REQ;
-
-	if (wow->four_way_handshake)
-		*filter |= WOW_FILTER_OPTION_8021X_4WAYHS;
-
-	return 0;
-}
-
-static int ath6kl_wow_ap(struct ath6kl *ar, struct ath6kl_vif *vif)
-{
-	static const u8 unicst_pattern[] = { 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x08 };
-	static const u8 unicst_mask[] = { 0x01, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x7f };
-	u8 unicst_offset = 0;
-	static const u8 arp_pattern[] = { 0x08, 0x06 };
-	static const u8 arp_mask[] = { 0xff, 0xff };
-	u8 arp_offset = 20;
-	static const u8 discvr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };
-	static const u8 discvr_mask[] = { 0xf0, 0x00, 0x00, 0xf8 };
-	u8 discvr_offset = 38;
-	static const u8 dhcp_pattern[] = { 0xff, 0xff, 0xff, 0xff,
-		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x43 /* port 67 */ };
-	static const u8 dhcp_mask[] = { 0xff, 0xff, 0xff, 0xff,
-		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0xff, 0xff /* port 67 */ };
-	u8 dhcp_offset = 0;
-	int ret;
-
-	/* Setup unicast IP, EAPOL-like and ARP pkt pattern */
-	ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-			vif->fw_vif_idx, WOW_LIST_ID,
-			sizeof(unicst_pattern), unicst_offset,
-			unicst_pattern, unicst_mask);
-	if (ret) {
-		ath6kl_err("failed to add WOW unicast IP pattern\n");
-		return ret;
-	}
-
-	/* Setup all ARP pkt pattern */
-	ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-			vif->fw_vif_idx, WOW_LIST_ID,
-			sizeof(arp_pattern), arp_offset,
-			arp_pattern, arp_mask);
-	if (ret) {
-		ath6kl_err("failed to add WOW ARP pattern\n");
-		return ret;
-	}
-
-	/*
-	 * Setup multicast pattern for mDNS 224.0.0.251,
-	 * SSDP 239.255.255.250 and LLMNR  224.0.0.252
-	 */
-	ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-			vif->fw_vif_idx, WOW_LIST_ID,
-			sizeof(discvr_pattern), discvr_offset,
-			discvr_pattern, discvr_mask);
-	if (ret) {
-		ath6kl_err("failed to add WOW mDNS/SSDP/LLMNR pattern\n");
-		return ret;
-	}
-
-	/* Setup all DHCP broadcast pkt pattern */
-	ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-			vif->fw_vif_idx, WOW_LIST_ID,
-			sizeof(dhcp_pattern), dhcp_offset,
-			dhcp_pattern, dhcp_mask);
-	if (ret) {
-		ath6kl_err("failed to add WOW DHCP broadcast pattern\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_wow_sta(struct ath6kl *ar, struct ath6kl_vif *vif)
-{
-	struct net_device *ndev = vif->ndev;
-	static const u8 discvr_lmnr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };
-	static const u8 discvr_lmnr_mask[] = { 0xff, 0xff, 0xff, 0xf8 };
-	static const u8 discvr_ssdp_pattern[] = { 0xef, 0xff, 0xff, 0xfa };
-	static const u8 discvr_ssdp_mask[] = { 0xff, 0xff, 0xff, 0xff };
-	u8 discvr_offset = 38;
-	u8 mac_mask[ETH_ALEN];
-	int ret;
-
-	/* Setup unicast pkt pattern */
-	memset(mac_mask, 0xff, ETH_ALEN);
-	ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-				vif->fw_vif_idx, WOW_LIST_ID,
-				ETH_ALEN, 0, ndev->dev_addr,
-				mac_mask);
-	if (ret) {
-		ath6kl_err("failed to add WOW unicast pattern\n");
-		return ret;
-	}
-
-	/*
-	 * Setup multicast pattern for mDNS 224.0.0.251,
-	 * SSDP 239.255.255.250 and LLMNR 224.0.0.252
-	 */
-	if ((ndev->flags & IFF_ALLMULTI) ||
-	    (ndev->flags & IFF_MULTICAST && netdev_mc_count(ndev) > 0)) {
-		ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-				vif->fw_vif_idx, WOW_LIST_ID,
-				sizeof(discvr_lmnr_pattern), discvr_offset,
-				discvr_lmnr_pattern, discvr_lmnr_mask);
-		if (ret) {
-			ath6kl_err("failed to add WOW mDNS/LMNR pattern\n");
-			return ret;
-		}
-		ret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,
-				vif->fw_vif_idx, WOW_LIST_ID,
-				sizeof(discvr_ssdp_pattern), discvr_offset,
-				discvr_ssdp_pattern, discvr_ssdp_mask);
-		if (ret) {
-			ath6kl_err("failed to add WOW SSDP pattern\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int is_hsleep_mode_procsed(struct ath6kl_vif *vif)
-{
-	return test_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);
-}
-
-static bool is_ctrl_ep_empty(struct ath6kl *ar)
-{
-	return !ar->tx_pending[ar->ctrl_ep];
-}
-
-static int ath6kl_cfg80211_host_sleep(struct ath6kl *ar, struct ath6kl_vif *vif)
-{
-	int ret, left;
-
-	clear_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);
-
-	ret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,
-						 ATH6KL_HOST_MODE_ASLEEP);
-	if (ret)
-		return ret;
-
-	left = wait_event_interruptible_timeout(ar->event_wq,
-						is_hsleep_mode_procsed(vif),
-						WMI_TIMEOUT);
-	if (left == 0) {
-		ath6kl_warn("timeout, didn't get host sleep cmd processed event\n");
-		ret = -ETIMEDOUT;
-	} else if (left < 0) {
-		ath6kl_warn("error while waiting for host sleep cmd processed event %d\n",
-			    left);
-		ret = left;
-	}
-
-	if (ar->tx_pending[ar->ctrl_ep]) {
-		left = wait_event_interruptible_timeout(ar->event_wq,
-							is_ctrl_ep_empty(ar),
-							WMI_TIMEOUT);
-		if (left == 0) {
-			ath6kl_warn("clear wmi ctrl data timeout\n");
-			ret = -ETIMEDOUT;
-		} else if (left < 0) {
-			ath6kl_warn("clear wmi ctrl data failed: %d\n", left);
-			ret = left;
-		}
-	}
-
-	return ret;
-}
-
-static int ath6kl_wow_suspend_vif(struct ath6kl_vif *vif,
-				  struct cfg80211_wowlan *wow, u32 *filter)
-{
-	struct ath6kl *ar = vif->ar;
-	struct in_device *in_dev;
-	struct in_ifaddr *ifa;
-	int ret;
-	u16 i, bmiss_time;
-	__be32 ips[MAX_IP_ADDRS];
-	u8 index = 0;
-
-	if (!test_bit(NETDEV_MCAST_ALL_ON, &vif->flags)) {
-		ret = ath6kl_wmi_mcast_filter_cmd(ar->wmi,
-						  vif->fw_vif_idx, false);
-		if (ret)
-			return ret;
-	}
-
-	/* Clear existing WOW patterns */
-	for (i = 0; i < WOW_MAX_FILTERS_PER_LIST; i++)
-		ath6kl_wmi_del_wow_pattern_cmd(ar->wmi, vif->fw_vif_idx,
-					       WOW_LIST_ID, i);
-
-	/*
-	 * Skip the default WOW pattern configuration
-	 * if the driver receives any WOW patterns from
-	 * the user.
-	 */
-	if (wow)
-		ret = ath6kl_wow_usr(ar, vif, wow, filter);
-	else if (vif->nw_type == AP_NETWORK)
-		ret = ath6kl_wow_ap(ar, vif);
-	else
-		ret = ath6kl_wow_sta(ar, vif);
-
-	if (ret)
-		return ret;
-
-	netif_stop_queue(vif->ndev);
-
-	if (vif->nw_type != AP_NETWORK) {
-		ret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,
-						    ATH6KL_MAX_WOW_LISTEN_INTL,
-						    0);
-		if (ret)
-			return ret;
-
-		/* Set listen interval x 15 times as bmiss time */
-		bmiss_time = ATH6KL_MAX_WOW_LISTEN_INTL * 15;
-		if (bmiss_time > ATH6KL_MAX_BMISS_TIME)
-			bmiss_time = ATH6KL_MAX_BMISS_TIME;
-
-		ret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,
-					       bmiss_time, 0);
-		if (ret)
-			return ret;
-
-		ret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,
-						0xFFFF, 0, 0xFFFF, 0, 0, 0,
-						0, 0, 0, 0);
-		if (ret)
-			return ret;
-	}
-
-	/* Setup own IP addr for ARP agent. */
-	in_dev = __in_dev_get_rtnl(vif->ndev);
-	if (!in_dev)
-		return 0;
-
-	ifa = in_dev->ifa_list;
-	memset(&ips, 0, sizeof(ips));
-
-	/* Configure IP addr only if IP address count < MAX_IP_ADDRS */
-	while (index < MAX_IP_ADDRS && ifa) {
-		ips[index] = ifa->ifa_local;
-		ifa = ifa->ifa_next;
-		index++;
-	}
-
-	if (ifa) {
-		ath6kl_err("total IP addr count is exceeding fw limit\n");
-		return -EINVAL;
-	}
-
-	ret = ath6kl_wmi_set_ip_cmd(ar->wmi, vif->fw_vif_idx, ips[0], ips[1]);
-	if (ret) {
-		ath6kl_err("fail to setup ip for arp agent\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
-{
-	struct ath6kl_vif *first_vif, *vif;
-	int ret = 0;
-	u32 filter = 0;
-	bool connected = false;
-
-	/* enter / leave wow suspend on first vif always */
-	first_vif = ath6kl_vif_first(ar);
-	if (WARN_ON(unlikely(!first_vif)) ||
-	    !ath6kl_cfg80211_ready(first_vif))
-		return -EIO;
-
-	if (wow && (wow->n_patterns > WOW_MAX_FILTERS_PER_LIST))
-		return -EINVAL;
-
-	/* install filters for each connected vif */
-	spin_lock_bh(&ar->list_lock);
-	list_for_each_entry(vif, &ar->vif_list, list) {
-		if (!test_bit(CONNECTED, &vif->flags) ||
-		    !ath6kl_cfg80211_ready(vif))
-			continue;
-		connected = true;
-
-		ret = ath6kl_wow_suspend_vif(vif, wow, &filter);
-		if (ret)
-			break;
-	}
-	spin_unlock_bh(&ar->list_lock);
-
-	if (!connected)
-		return -ENOTCONN;
-	else if (ret)
-		return ret;
-
-	ar->state = ATH6KL_STATE_SUSPENDING;
-
-	ret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, first_vif->fw_vif_idx,
-					  ATH6KL_WOW_MODE_ENABLE,
-					  filter,
-					  WOW_HOST_REQ_DELAY);
-	if (ret)
-		return ret;
-
-	return ath6kl_cfg80211_host_sleep(ar, first_vif);
-}
-
-static int ath6kl_wow_resume_vif(struct ath6kl_vif *vif)
-{
-	struct ath6kl *ar = vif->ar;
-	int ret;
-
-	if (vif->nw_type != AP_NETWORK) {
-		ret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,
-						0, 0, 0, 0, 0, 0, 3, 0, 0, 0);
-		if (ret)
-			return ret;
-
-		ret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,
-						    vif->listen_intvl_t, 0);
-		if (ret)
-			return ret;
-
-		ret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,
-					       vif->bmiss_time_t, 0);
-		if (ret)
-			return ret;
-	}
-	if (!test_bit(NETDEV_MCAST_ALL_OFF, &vif->flags)) {
-		ret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi,
-						  vif->fw_vif_idx, true);
-		if (ret)
-			return ret;
-	}
-
-	netif_wake_queue(vif->ndev);
-
-	return 0;
-}
-
-static int ath6kl_wow_resume(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif;
-	int ret;
-
-	vif = ath6kl_vif_first(ar);
-	if (WARN_ON(unlikely(!vif)) ||
-	    !ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-#ifdef CONFIG_HAS_WAKELOCK
-	wake_lock_timeout(&ar->wake_lock, 5);
-#endif
-
-	ar->state = ATH6KL_STATE_RESUMING;
-
-	ret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,
-						 ATH6KL_HOST_MODE_AWAKE);
-	if (ret) {
-		ath6kl_warn("Failed to configure host sleep mode for "
-			    "wow resume: %d\n", ret);
-		goto cleanup;
-	}
-
-	spin_lock_bh(&ar->list_lock);
-	list_for_each_entry(vif, &ar->vif_list, list) {
-		if (!test_bit(CONNECTED, &vif->flags) ||
-		    !ath6kl_cfg80211_ready(vif))
-			continue;
-		ret = ath6kl_wow_resume_vif(vif);
-		if (ret)
-			break;
-	}
-	spin_unlock_bh(&ar->list_lock);
-
-	if (ret)
-		goto cleanup;
-
-	ar->state = ATH6KL_STATE_ON;
-	return 0;
-
-cleanup:
-	ar->state = ATH6KL_STATE_WOW;
-	return ret;
-}
-
-static int ath6kl_cfg80211_deepsleep_suspend(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif;
-	int ret;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	if (!test_bit(WMI_READY, &ar->flag)) {
-		ath6kl_err("deepsleep failed as wmi is not ready\n");
-		return -EIO;
-	}
-
-	ath6kl_cfg80211_stop_all(ar);
-
-	/* Save the current power mode before enabling power save */
-	ar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;
-
-	ret = ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER);
-	if (ret)
-		return ret;
-
-	/* Disable WOW mode */
-	ret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, vif->fw_vif_idx,
-					  ATH6KL_WOW_MODE_DISABLE,
-					  0, 0);
-	if (ret)
-		return ret;
-
-	/* Flush all non control pkts in TX path */
-	ath6kl_tx_data_cleanup(ar);
-
-	ret = ath6kl_cfg80211_host_sleep(ar, vif);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_deepsleep_resume(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif;
-	int ret;
-
-	vif = ath6kl_vif_first(ar);
-
-	if (!vif)
-		return -EIO;
-
-	if (ar->wmi->pwr_mode != ar->wmi->saved_pwr_mode) {
-		ret = ath6kl_wmi_powermode_cmd(ar->wmi, 0,
-					       ar->wmi->saved_pwr_mode);
-		if (ret)
-			return ret;
-	}
-
-	ret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,
-						 ATH6KL_HOST_MODE_AWAKE);
-	if (ret)
-		return ret;
-
-	ar->state = ATH6KL_STATE_ON;
-
-	/* Reset scan parameter to default values */
-	ret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,
-					0, 0, 0, 0, 0, 0, 3, 0, 0, 0);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-int ath6kl_cfg80211_suspend(struct ath6kl *ar,
-			    enum ath6kl_cfg_suspend_mode mode,
-			    struct cfg80211_wowlan *wow)
-{
-	struct ath6kl_vif *vif;
-	enum ath6kl_state prev_state;
-	int ret;
-
-	switch (mode) {
-	case ATH6KL_CFG_SUSPEND_WOW:
-
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "wow mode suspend\n");
-
-		/* Flush all non control pkts in TX path */
-		ath6kl_tx_data_cleanup(ar);
-
-		prev_state = ar->state;
-		ret = ath6kl_wow_suspend(ar, wow);
-		if (ret) {
-			ar->state = prev_state;
-			return ret;
-		}
-
-		ar->state = ATH6KL_STATE_WOW;
-		break;
-
-	case ATH6KL_CFG_SUSPEND_DEEPSLEEP:
-
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "deep sleep suspend\n");
-
-		ret = ath6kl_cfg80211_deepsleep_suspend(ar);
-		if (ret) {
-			ath6kl_err("deepsleep suspend failed: %d\n", ret);
-			return ret;
-		}
-
-		ar->state = ATH6KL_STATE_DEEPSLEEP;
-
-		break;
-
-	case ATH6KL_CFG_SUSPEND_CUTPOWER:
-
-		ath6kl_cfg80211_stop_all(ar);
-
-		if (ar->state == ATH6KL_STATE_OFF) {
-			ath6kl_dbg(ATH6KL_DBG_SUSPEND,
-				   "suspend hw off, no action for cutpower\n");
-			break;
-		}
-
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "suspend cutting power\n");
-
-		ret = ath6kl_init_hw_stop(ar);
-		if (ret) {
-			ath6kl_warn("failed to stop hw during suspend: %d\n",
-				    ret);
-		}
-
-		ar->state = ATH6KL_STATE_CUTPOWER;
-
-		break;
-
-	default:
-		break;
-	}
-
-	list_for_each_entry(vif, &ar->vif_list, list)
-		ath6kl_cfg80211_scan_complete_event(vif, true);
-
-	return 0;
-}
-
-int ath6kl_cfg80211_resume(struct ath6kl *ar)
-{
-	int ret;
-
-	switch (ar->state) {
-	case  ATH6KL_STATE_WOW:
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "wow mode resume\n");
-
-		ret = ath6kl_wow_resume(ar);
-		if (ret) {
-			ath6kl_warn("wow mode resume failed: %d\n", ret);
-			return ret;
-		}
-
-		break;
-
-	case ATH6KL_STATE_DEEPSLEEP:
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "deep sleep resume\n");
-
-		ret = ath6kl_cfg80211_deepsleep_resume(ar);
-		if (ret) {
-			ath6kl_warn("deep sleep resume failed: %d\n", ret);
-			return ret;
-		}
-		break;
-
-	case ATH6KL_STATE_CUTPOWER:
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "resume restoring power\n");
-
-		ret = ath6kl_init_hw_start(ar);
-		if (ret) {
-			ath6kl_warn("Failed to boot hw in resume: %d\n", ret);
-			return ret;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-
-/* hif layer decides what suspend mode to use */
-static int __ath6kl_cfg80211_suspend(struct wiphy *wiphy,
-				 struct cfg80211_wowlan *wow)
-{
-	struct ath6kl *ar = wiphy_priv(wiphy);
-
-	ath6kl_recovery_suspend(ar);
-
-	return ath6kl_hif_suspend(ar, wow);
-}
-
-static int __ath6kl_cfg80211_resume(struct wiphy *wiphy)
-{
-	struct ath6kl *ar = wiphy_priv(wiphy);
-	int err;
-
-	err = ath6kl_hif_resume(ar);
-	if (err)
-		return err;
-
-	ath6kl_recovery_resume(ar);
-
-	return 0;
-}
-
-/*
- * FIXME: WOW suspend mode is selected if the host sdio controller supports
- * both sdio irq wake up and keep power. The target pulls sdio data line to
- * wake up the host when WOW pattern matches. This causes sdio irq handler
- * is being called in the host side which internally hits ath6kl's RX path.
- *
- * Since sdio interrupt is not disabled, RX path executes even before
- * the host executes the actual resume operation from PM module.
- *
- * In the current scenario, WOW resume should happen before start processing
- * any data from the target. So It's required to perform WOW resume in RX path.
- * Ideally we should perform WOW resume only in the actual platform
- * resume path. This area needs bit rework to avoid WOW resume in RX path.
- *
- * ath6kl_check_wow_status() is called from ath6kl_rx().
- */
-void ath6kl_check_wow_status(struct ath6kl *ar, struct sk_buff *skb,
-			     bool is_event_pkt)
-{
-	if (ar->state == ATH6KL_STATE_SUSPENDING)
-		return;
-
-	if (ar->state == ATH6KL_STATE_WOW)
-		ath6kl_cfg80211_resume(ar);
-	else
-		ath6kl_config_suspend_wake_lock(ar, skb, is_event_pkt);
-}
-
-#else
-
-void ath6kl_check_wow_status(struct ath6kl *ar, struct sk_buff *skb,
-			     bool is_event_pkt)
-{
-}
-#endif
-
-static int ath6kl_set_htcap(struct ath6kl_vif *vif, enum ieee80211_band band,
-			    bool ht_enable)
-{
-	struct ath6kl_htcap *htcap = &vif->htcap[band];
-
-	if (htcap->ht_enable == ht_enable)
-		return 0;
-
-	if (ht_enable) {
-		/* Set default ht capabilities */
-		htcap->ht_enable = true;
-		htcap->cap_info = (band == IEEE80211_BAND_2GHZ) ?
-				   ath6kl_g_htcap : ath6kl_a_htcap;
-		htcap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;
-	} else /* Disable ht */
-		memset(htcap, 0, sizeof(*htcap));
-
-	return ath6kl_wmi_set_htcap_cmd(vif->ar->wmi, vif->fw_vif_idx,
-					band, htcap);
-}
-
-static int ath6kl_set_channel(struct wiphy *wiphy, struct net_device *dev,
-			      struct ieee80211_channel *chan,
-			      enum nl80211_channel_type channel_type)
-{
-	struct ath6kl_vif *vif;
-
-	/*
-	 * 'dev' could be NULL if a channel change is required for the hardware
-	 * device itself, instead of a particular VIF.
-	 *
-	 * FIXME: To be handled properly when monitor mode is supported.
-	 */
-	if (!dev)
-		return -EBUSY;
-
-	vif = netdev_priv(dev);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: center_freq=%u hw_value=%u\n",
-		   __func__, chan->center_freq, chan->hw_value);
-	vif->next_chan = chan->center_freq;
-	vif->next_ch_type = channel_type;
-	vif->next_ch_band = chan->band;
-
-	return 0;
-}
-
-static bool ath6kl_is_p2p_ie(const u8 *pos)
-{
-	return pos[0] == WLAN_EID_VENDOR_SPECIFIC && pos[1] >= 4 &&
-		pos[2] == 0x50 && pos[3] == 0x6f &&
-		pos[4] == 0x9a && pos[5] == 0x09;
-}
-
-static int ath6kl_set_ap_probe_resp_ies(struct ath6kl_vif *vif,
-					const u8 *ies, size_t ies_len)
-{
-	struct ath6kl *ar = vif->ar;
-	const u8 *pos;
-	u8 *buf = NULL;
-	size_t len = 0;
-	int ret;
-
-	/*
-	 * Filter out P2P IE(s) since they will be included depending on
-	 * the Probe Request frame in ath6kl_send_go_probe_resp().
-	 */
-
-	if (ies && ies_len) {
-		buf = kmalloc(ies_len, GFP_KERNEL);
-		if (buf == NULL)
-			return -ENOMEM;
-		pos = ies;
-		while (pos + 1 < ies + ies_len) {
-			if (pos + 2 + pos[1] > ies + ies_len)
-				break;
-			if (!ath6kl_is_p2p_ie(pos)) {
-				memcpy(buf + len, pos, 2 + pos[1]);
-				len += 2 + pos[1];
-			}
-			pos += 2 + pos[1];
-		}
-	}
-
-	ret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_PROBE_RESP, buf, len);
-	kfree(buf);
-	return ret;
-}
-
-static int ath6kl_ap_beacon(struct wiphy *wiphy, struct net_device *dev,
-			    struct beacon_parameters *info, bool add)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	struct ieee80211_mgmt *mgmt;
-	enum wmi_phy_mode phy_mode;
-	bool hidden = false;
-	u8 *ies;
-	int ies_len;
-	struct wmi_connect_cmd p;
-	int res;
-	int i, ret;
-	u8 *rsn_ie;
-	int rsn_ie_len;
-	u16 cnt;
-	u16 rsn_capb;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: add=%d\n", __func__, add);
-
-	if (!ath6kl_cfg80211_ready(vif))
-		return -EIO;
-
-	if (vif->next_mode != AP_NETWORK)
-		return -EOPNOTSUPP;
-
-	/* this also clears IE in fw if it's not set */
-	res = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_BEACON,
-				       info->beacon_ies,
-				       info->beacon_ies_len);
-	if (res)
-		return res;
-
-	/* this also clears IE in fw if it's not set */
-	res = ath6kl_set_ap_probe_resp_ies(vif, info->proberesp_ies,
-					   info->proberesp_ies_len);
-	if (res)
-		return res;
-
-	/* this also clears IE in fw if it's not set */
-	res = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_ASSOC_RESP,
-				       info->assocresp_ies,
-				       info->assocresp_ies_len);
-	if (res)
-		return res;
-
-	if (!add)
-		return 0;
-
-	ar->ap_mode_bkey.valid = false;
-
-	/* TODO:
-	 * info->interval
-	 * info->dtim_period
-	 */
-
-	if (info->head == NULL)
-		return -EINVAL;
-	mgmt = (struct ieee80211_mgmt *) info->head;
-	ies = mgmt->u.beacon.variable;
-	if (ies > info->head + info->head_len)
-		return -EINVAL;
-	ies_len = info->head + info->head_len - ies;
-
-	if (info->ssid == NULL)
-		return -EINVAL;
-	memcpy(vif->ssid, info->ssid, info->ssid_len);
-	vif->ssid_len = info->ssid_len;
-	if (info->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE)
-		hidden = true;
-
-	res = ath6kl_wmi_ap_hidden_ssid(ar->wmi, vif->fw_vif_idx, hidden);
-	if (res)
-		return res;
-
-	ret = ath6kl_set_auth_type(vif, info->auth_type);
-	if (ret)
-		return ret;
-
-	memset(&p, 0, sizeof(p));
-
-	for (i = 0; i < info->crypto.n_akm_suites; i++) {
-		switch (info->crypto.akm_suites[i]) {
-		case WLAN_AKM_SUITE_8021X:
-			if (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)
-				p.auth_mode |= WPA_AUTH;
-			if (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)
-				p.auth_mode |= WPA2_AUTH;
-			break;
-		case WLAN_AKM_SUITE_PSK:
-			if (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)
-				p.auth_mode |= WPA_PSK_AUTH;
-			if (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)
-				p.auth_mode |= WPA2_PSK_AUTH;
-			break;
-		}
-	}
-	if (p.auth_mode == 0)
-		p.auth_mode = NONE_AUTH;
-	vif->auth_mode = p.auth_mode;
-
-	for (i = 0; i < info->crypto.n_ciphers_pairwise; i++) {
-		switch (info->crypto.ciphers_pairwise[i]) {
-		case WLAN_CIPHER_SUITE_WEP40:
-		case WLAN_CIPHER_SUITE_WEP104:
-			p.prwise_crypto_type |= WEP_CRYPT;
-			break;
-		case WLAN_CIPHER_SUITE_TKIP:
-			p.prwise_crypto_type |= TKIP_CRYPT;
-			break;
-		case WLAN_CIPHER_SUITE_CCMP:
-			p.prwise_crypto_type |= AES_CRYPT;
-			break;
-		case WLAN_CIPHER_SUITE_SMS4:
-			p.prwise_crypto_type |= WAPI_CRYPT;
-			break;
-		}
-	}
-	if (p.prwise_crypto_type == 0) {
-		p.prwise_crypto_type = NONE_CRYPT;
-		ath6kl_set_cipher(vif, 0, true);
-	} else if (info->crypto.n_ciphers_pairwise == 1)
-		ath6kl_set_cipher(vif, info->crypto.ciphers_pairwise[0], true);
-
-	switch (info->crypto.cipher_group) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		p.grp_crypto_type = WEP_CRYPT;
-		break;
-	case WLAN_CIPHER_SUITE_TKIP:
-		p.grp_crypto_type = TKIP_CRYPT;
-		break;
-	case WLAN_CIPHER_SUITE_CCMP:
-		p.grp_crypto_type = AES_CRYPT;
-		break;
-	case WLAN_CIPHER_SUITE_SMS4:
-		p.grp_crypto_type = WAPI_CRYPT;
-		break;
-	default:
-		p.grp_crypto_type = NONE_CRYPT;
-		break;
-	}
-	ath6kl_set_cipher(vif, info->crypto.cipher_group, false);
-
-	p.nw_type = AP_NETWORK;
-	vif->nw_type = vif->next_mode;
-
-	p.ssid_len = vif->ssid_len;
-	memcpy(p.ssid, vif->ssid, vif->ssid_len);
-	p.dot11_auth_mode = vif->dot11_auth_mode;
-
-	if (info->auto_channel_select) {
-		ar->want_ch_switch |= 1 << vif->fw_vif_idx;
-		vif->next_chan = info->auto_channel_select - 1;
-	}
-
-	p.ch = cpu_to_le16(vif->next_chan);
-
-	/*
-	 * Get the PTKSA replay counter in the RSN IE. Supplicant
-	 * will use the RSN IE in M3 message and firmware has to
-	 * advertise the same in beacon/probe response. Send
-	 * the complete RSN IE capability field to firmware
-	 */
-	if ((p.auth_mode & (WPA2_AUTH | WPA2_PSK_AUTH)) && (info->tail) &&
-	    test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,
-		     ar->fw_capabilities)) {
-		rsn_capb = 0;
-		rsn_ie = (u8 *)cfg80211_find_ie(WLAN_EID_RSN, info->tail,
-							info->tail_len);
-		if (rsn_ie) {
-			rsn_ie_len = *(rsn_ie + 1);
-			rsn_ie += 2;	/* skip element id and length */
-			do {
-				/* skip version, group cipher */
-				if (rsn_ie_len < 6)
-					break;
-				rsn_ie +=  6;
-				rsn_ie_len -= 6;
-				/* skip pairwise cipher suite */
-				if (rsn_ie_len < 2)
-					break;
-				cnt = *((u16 *)rsn_ie);
-				rsn_ie += (2 + cnt * 4);
-				rsn_ie_len -= (2 + cnt * 4);
-				/* skip akm suite */
-				if (rsn_ie_len < 2)
-					break;
-				cnt = *((u16 *)rsn_ie);
-				rsn_ie += (2 + cnt * 4);
-				rsn_ie_len -= (2 + cnt * 4);
-				if (rsn_ie_len < 2)
-					break;
-				rsn_capb = *((u16 *)rsn_ie);
-			} while (0);
-			rsn_capb = cpu_to_le16(rsn_capb);
-			res = ath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,
-				WLAN_EID_RSN, WMI_RSN_IE_CAPB,
-				(const u8 *)&rsn_capb, sizeof(rsn_capb));
-		vif->rsn_capab = rsn_capb;
-			if (res < 0)
-				return res;
-		}
-	}
-
-	/* Enable uAPSD support by default */
-	res = ath6kl_wmi_ap_set_apsd(ar->wmi, vif->fw_vif_idx, true);
-	if (res < 0)
-		return res;
-
-	if (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
-		p.nw_subtype = SUBTYPE_P2PGO;
-	} else {
-		/*
-		 * Due to firmware limitation, it is not possible to
-		 * do P2P mgmt operations in AP mode
-		 */
-		p.nw_subtype = SUBTYPE_NONE;
-	}
-
-	if (ath6kl_set_htcap(vif, vif->next_ch_band,
-			     vif->next_ch_type != NL80211_CHAN_NO_HT))
-		return -EIO;
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_MAC_ACL, ar->fw_capabilities)) {
-		res = ath6kl_wmi_set_acl_policy(ar->wmi, vif->fw_vif_idx,
-						info->acl_mac);
-		if (res < 0)
-			return res;
-	}
-
-	if (!info->sta_cap_req)
-		goto ap_commit;
-
-	switch (info->sta_cap_req) {
-	case NL80211_STA_CAP_REQ_11BONLY:
-		phy_mode = WMI_11B_MODE;
-		break;
-	case NL80211_STA_CAP_REQ_11GONLY:
-		phy_mode = WMI_11GONLY_MODE;
-		break;
-	default:
-		ath6kl_err("STA capability requirement %d is not supported in AP mode\n",
-			   info->sta_cap_req);
-		return -ENOTSUPP;
-	}
-
-	res = ath6kl_wmi_set_ch_params(ar->wmi, vif->fw_vif_idx, phy_mode);
-	if (res)
-		return res;
-
-ap_commit:
-	memcpy(&vif->profile, &p, sizeof(p));
-	res = ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx, &p);
-	if (res < 0)
-		return res;
-
-	return 0;
-}
-
-void ath6kl_cfg80211_sta_bmiss_enhance(struct ath6kl_vif *vif, bool enable)
-{
-	int err;
-
-	if (!test_bit(ATH6KL_FW_CAPABILITY_BMISS_ENHANCE,
-		      vif->ar->fw_capabilities))
-		return;
-
-	if (WARN_ON(!test_bit(WMI_READY, &vif->ar->flag)))
-		return;
-
-	if (vif->nw_type != INFRA_NETWORK)
-		return;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s fw bmiss enhance\n",
-		   enable ? "enable" : "disable");
-
-	err = ath6kl_wmi_sta_bmiss_enhance_cmd(vif->ar->wmi,
-					       vif->fw_vif_idx, enable);
-	if (err)
-		ath6kl_err("failed to %s enhanced bmiss detection: %d\n",
-			   enable ? "enable" : "disable", err);
-}
-
-static int ath6kl_add_beacon(struct wiphy *wiphy, struct net_device *dev,
-			     struct beacon_parameters *info)
-{
-	return ath6kl_ap_beacon(wiphy, dev, info, true);
-}
-
-static int ath6kl_set_beacon(struct wiphy *wiphy, struct net_device *dev,
-			     struct beacon_parameters *info)
-{
-	return ath6kl_ap_beacon(wiphy, dev, info, false);
-}
-
-static int ath6kl_del_beacon(struct wiphy *wiphy, struct net_device *dev)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	if (vif->nw_type != AP_NETWORK)
-		return -EOPNOTSUPP;
-	if (!test_bit(CONNECTED, &vif->flags))
-		return -ENOTCONN;
-
-	ath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);
-	clear_bit(CONNECTED, &vif->flags);
-
-	/* Restore ht setting in firmware */
-	if (ath6kl_set_htcap(vif, IEEE80211_BAND_2GHZ, true))
-		return -EIO;
-
-	if (ath6kl_set_htcap(vif, IEEE80211_BAND_5GHZ, true))
-		return -EIO;
-
-	return 0;
-}
-
-static const u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-static int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,
-			      u8 *mac)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	const u8 *addr = mac ? mac : bcast_addr;
-
-	return ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx, WMI_AP_DEAUTH,
-				      addr, WLAN_REASON_PREV_AUTH_NOT_VALID);
-}
-
-static int ath6kl_change_station(struct wiphy *wiphy, struct net_device *dev,
-				 u8 *mac, struct station_parameters *params)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	if (vif->nw_type != AP_NETWORK)
-		return -EOPNOTSUPP;
-
-	/* Use this only for authorizing/unauthorizing a station */
-	if (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))
-		return -EOPNOTSUPP;
-
-	if (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))
-		return ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,
-					      WMI_AP_MLME_AUTHORIZE, mac, 0);
-	return ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,
-				      WMI_AP_MLME_UNAUTHORIZE, mac, 0);
-}
-
-static int ath6kl_remain_on_channel(struct wiphy *wiphy,
-				    struct net_device *dev,
-				    struct ieee80211_channel *chan,
-				    enum nl80211_channel_type channel_type,
-				    unsigned int duration,
-				    u64 *cookie)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	u32 id;
-#ifdef CONFIG_HAS_WAKELOCK
-	ath6kl_p2p_release_wakelock(ar);
-	ath6kl_p2p_acquire_wakelock(ar , duration + 100);
-#endif
-	/* TODO: if already pending or ongoing remain-on-channel,
-	 * return -EBUSY */
-	id = ++vif->last_roc_id;
-	if (id == 0) {
-		/* Do not use 0 as the cookie value */
-		id = ++vif->last_roc_id;
-	}
-	*cookie = id;
-
-	return ath6kl_wmi_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx,
-					     chan->center_freq, duration);
-}
-
-static int ath6kl_cancel_remain_on_channel(struct wiphy *wiphy,
-					   struct net_device *dev,
-					   u64 cookie)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	if (cookie != vif->last_roc_id)
-		return -ENOENT;
-	vif->last_cancel_roc_id = cookie;
-
-	return ath6kl_wmi_cancel_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx);
-}
-
-static int ath6kl_send_go_probe_resp(struct ath6kl_vif *vif,
-				     const u8 *buf, size_t len,
-				     unsigned int freq)
-{
-	struct ath6kl *ar = vif->ar;
-	const u8 *pos;
-	u8 *p2p;
-	int p2p_len;
-	int ret;
-	const struct ieee80211_mgmt *mgmt;
-
-	mgmt = (const struct ieee80211_mgmt *) buf;
-
-	/* Include P2P IE(s) from the frame generated in user space. */
-
-	p2p = kmalloc(len, GFP_KERNEL);
-	if (p2p == NULL)
-		return -ENOMEM;
-	p2p_len = 0;
-
-	pos = mgmt->u.probe_resp.variable;
-	while (pos + 1 < buf + len) {
-		if (pos + 2 + pos[1] > buf + len)
-			break;
-		if (ath6kl_is_p2p_ie(pos)) {
-			memcpy(p2p + p2p_len, pos, 2 + pos[1]);
-			p2p_len += 2 + pos[1];
-		}
-		pos += 2 + pos[1];
-	}
-
-	ret = ath6kl_wmi_send_probe_response_cmd(ar->wmi, vif->fw_vif_idx, freq,
-						 mgmt->da, p2p, p2p_len);
-	kfree(p2p);
-	return ret;
-}
-
-static bool ath6kl_mgmt_powersave_ap(struct ath6kl_vif *vif,
-				     u32 id,
-				     u32 freq,
-				     u32 wait,
-				     const u8 *buf,
-				     size_t len,
-				     bool *more_data,
-				     bool no_cck)
-{
-	struct ieee80211_mgmt *mgmt;
-	struct ath6kl_sta *conn;
-	bool is_psq_empty = false;
-	struct ath6kl_mgmt_buff *mgmt_buf;
-	size_t mgmt_buf_size;
-	struct ath6kl *ar = vif->ar;
-
-	mgmt = (struct ieee80211_mgmt *) buf;
-	if (is_multicast_ether_addr(mgmt->da))
-		return false;
-
-	conn = ath6kl_find_sta(vif, mgmt->da);
-	if (!conn)
-		return false;
-
-	if (conn->sta_flags & STA_PS_SLEEP) {
-		if (!(conn->sta_flags & STA_PS_POLLED)) {
-			/* Queue the frames if the STA is sleeping */
-			mgmt_buf_size = len + sizeof(struct ath6kl_mgmt_buff);
-			mgmt_buf = kmalloc(mgmt_buf_size, GFP_KERNEL);
-			if (!mgmt_buf)
-				return false;
-
-			INIT_LIST_HEAD(&mgmt_buf->list);
-			mgmt_buf->id = id;
-			mgmt_buf->freq = freq;
-			mgmt_buf->wait = wait;
-			mgmt_buf->len = len;
-			mgmt_buf->no_cck = no_cck;
-			memcpy(mgmt_buf->buf, buf, len);
-			spin_lock_bh(&conn->psq_lock);
-			is_psq_empty = skb_queue_empty(&conn->psq) &&
-					(conn->mgmt_psq_len == 0);
-			list_add_tail(&mgmt_buf->list, &conn->mgmt_psq);
-			conn->mgmt_psq_len++;
-			spin_unlock_bh(&conn->psq_lock);
-
-			/*
-			 * If this is the first pkt getting queued
-			 * for this STA, update the PVB for this
-			 * STA.
-			 */
-			if (is_psq_empty)
-				ath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,
-						       conn->aid, 1);
-			return true;
-		}
-
-		/*
-		 * This tx is because of a PsPoll.
-		 * Determine if MoreData bit has to be set.
-		 */
-		spin_lock_bh(&conn->psq_lock);
-		if (!skb_queue_empty(&conn->psq) || (conn->mgmt_psq_len != 0))
-			*more_data = true;
-		spin_unlock_bh(&conn->psq_lock);
-	}
-
-	return false;
-}
-
-/* Check if SSID length is greater than DIRECT- */
-static bool ath6kl_is_p2p_go_ssid(const u8 *buf, size_t len)
-{
-	const struct ieee80211_mgmt *mgmt;
-	mgmt = (const struct ieee80211_mgmt *) buf;
-
-	/* variable[1] contains the SSID tag length */
-	if (buf + len >= &mgmt->u.probe_resp.variable[1] &&
-	    (mgmt->u.probe_resp.variable[1] > P2P_WILDCARD_SSID_LEN)) {
-		return true;
-	}
-
-	return false;
-}
-
-static int ath6kl_mgmt_tx(struct wiphy *wiphy, struct net_device *dev,
-			  struct ieee80211_channel *chan, bool offchan,
-			  enum nl80211_channel_type channel_type,
-			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, bool no_cck,
-			  bool dont_wait_for_ack, u64 *cookie)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	u32 id;
-	const struct ieee80211_mgmt *mgmt;
-	bool more_data, queued;
-
-	mgmt = (const struct ieee80211_mgmt *) buf;
-	if (vif->nw_type == AP_NETWORK && test_bit(CONNECTED, &vif->flags) &&
-	    ieee80211_is_probe_resp(mgmt->frame_control) &&
-	    ath6kl_is_p2p_go_ssid(buf, len)) {
-		/*
-		 * Send Probe Response frame in GO mode using a separate WMI
-		 * command to allow the target to fill in the generic IEs.
-		 */
-		*cookie = 0; /* TX status not supported */
-		return ath6kl_send_go_probe_resp(vif, buf, len,
-						 chan->center_freq);
-	}
-
-	id = vif->send_action_id++;
-	if (id == 0) {
-		/*
-		 * 0 is a reserved value in the WMI command and shall not be
-		 * used for the command.
-		 */
-		id = vif->send_action_id++;
-	}
-
-	*cookie = id;
-
-	/* AP mode Power saving processing */
-	if (vif->nw_type == AP_NETWORK) {
-		queued = ath6kl_mgmt_powersave_ap(vif,
-					id, chan->center_freq,
-					wait, buf,
-					len, &more_data, no_cck);
-		if (queued)
-			return 0;
-	}
-
-	return ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx, id,
-					chan->center_freq, wait,
-					buf, len, no_cck);
-}
-
-static void ath6kl_mgmt_frame_register(struct wiphy *wiphy,
-				       struct net_device *dev,
-				       u16 frame_type, bool reg)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: frame_type=0x%x reg=%d\n",
-		   __func__, frame_type, reg);
-	if (frame_type == IEEE80211_STYPE_PROBE_REQ) {
-		/*
-		 * Note: This notification callback is not allowed to sleep, so
-		 * we cannot send WMI_PROBE_REQ_REPORT_CMD here. Instead, we
-		 * hardcode target to report Probe Request frames all the time.
-		 */
-		vif->probe_req_report = reg;
-	}
-}
-
-static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,
-			struct net_device *dev,
-			struct cfg80211_sched_scan_request *request)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	u16 interval;
-	int ret, rssi_thold;
-
-	if (ar->state != ATH6KL_STATE_ON)
-		return -EIO;
-
-	if (vif->sme_state != SME_DISCONNECTED)
-		return -EBUSY;
-
-	ath6kl_cfg80211_scan_complete_event(vif, true);
-
-	ret = ath6kl_set_probed_ssids(ar, vif, request->ssids,
-				      request->n_ssids,
-				      request->match_sets,
-				      request->n_match_sets);
-	if (ret < 0)
-		return ret;
-
-	if (!request->n_match_sets) {
-		ret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-					       ALL_BSS_FILTER, 0);
-		if (ret < 0)
-			return ret;
-	} else {
-		 ret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-						MATCHED_SSID_FILTER, 0);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD,
-		     ar->fw_capabilities)) {
-		if (request->rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
-			rssi_thold = 0;
-		else if (request->rssi_thold < -127)
-			rssi_thold = -127;
-		else
-			rssi_thold = request->rssi_thold;
-
-		ret = ath6kl_wmi_set_rssi_filter_cmd(ar->wmi, vif->fw_vif_idx,
-						     rssi_thold);
-		if (ret) {
-			ath6kl_err("failed to set RSSI threshold for scan\n");
-			return ret;
-		}
-	}
-
-	/* fw uses seconds, also make sure that it's >0 */
-	interval = max_t(u16, 1, request->interval / 1000);
-
-	ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,
-				  interval, interval,
-				  vif->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);
-
-	/* this also clears IE in fw if it's not set */
-	ret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,
-				       WMI_FRAME_PROBE_REQ,
-				       request->ie, request->ie_len);
-	if (ret) {
-		ath6kl_warn("Failed to set probe request IE for scheduled scan: %d",
-			    ret);
-		return ret;
-	}
-
-	ret = ath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, true);
-	if (ret)
-		return ret;
-
-	set_bit(SCHED_SCANNING, &vif->flags);
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_sscan_stop(struct wiphy *wiphy,
-				      struct net_device *dev)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	bool stopped;
-
-	stopped = __ath6kl_cfg80211_sscan_stop(vif);
-
-	if (!stopped)
-		return -EIO;
-
-	return 0;
-}
-
-static int ath6kl_cfg80211_set_bitrate(struct wiphy *wiphy,
-				       struct net_device *dev,
-				       const u8 *addr,
-				       const struct cfg80211_bitrate_mask *mask)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	return ath6kl_wmi_set_bitrate_mask(ar->wmi, vif->fw_vif_idx,
-					   mask);
-}
-
-static int ath6kl_set_mac_acl(struct wiphy *wiphy,
-			      struct net_device *dev,
-			      struct cfg80211_acl_params *acl_info)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	int i, err;
-	static const u8 zero_mac[ETH_ALEN] = { 0 };
-
-	/* Reset the acl list */
-	err = ath6kl_wmi_set_acl_list(ar->wmi, vif->fw_vif_idx, 0, zero_mac,
-				      acl_info->acl_policy, true);
-	if (err)
-		return err;
-
-	for (i = 0; i < acl_info->n_acl_entries; i++) {
-		err = ath6kl_wmi_set_acl_list(ar->wmi, vif->fw_vif_idx, i,
-					      acl_info->mac_addrs[i].addr,
-					      acl_info->acl_policy, false);
-		if (err)
-			return err;
-	}
-
-	/*
-	 * Notify fw of the state that the host is done with setting
-	 * the acl list. This is done with a special configuration
-	 * where the index of the mac address is passed as 0xff and
-	 * the mac address is zero mac. Firmware would carry out
-	 * certain operations based on the newly set acl list after
-	 * this notification.
-	 */
-	err = ath6kl_wmi_set_acl_list(ar->wmi, vif->fw_vif_idx,
-				      MAC_ACL_INDEX_EOL, zero_mac,
-				      acl_info->acl_policy, false);
-
-	return err;
-}
-
-static int ath6kl_cfg80211_set_txe_config(struct wiphy *wiphy,
-					  struct net_device *dev,
-					  u32 rate, u32 pkts, u32 intvl)
-{
-	struct ath6kl *ar = ath6kl_priv(dev);
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	if (vif->nw_type != INFRA_NETWORK ||
-	    !test_bit(ATH6KL_FW_CAPABILITY_TX_ERR_NOTIFY, ar->fw_capabilities))
-		return -EOPNOTSUPP;
-
-	if (vif->sme_state != SME_CONNECTED)
-		return -ENOTCONN;
-
-	/* save this since the firmware won't report the interval */
-	vif->txe_intvl = intvl;
-
-	return ath6kl_wmi_set_txe_notify(ar->wmi, vif->fw_vif_idx,
-					 rate, pkts, intvl);
-}
-
-static const struct ieee80211_txrx_stypes
-ath6kl_mgmt_stypes[NUM_NL80211_IFTYPES] = {
-	[NL80211_IFTYPE_STATION] = {
-		.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_RESP >> 4),
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
-	},
-	[NL80211_IFTYPE_AP] = {
-		.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_RESP >> 4),
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
-	},
-	[NL80211_IFTYPE_P2P_CLIENT] = {
-		.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_RESP >> 4),
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
-	},
-	[NL80211_IFTYPE_P2P_GO] = {
-		.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_RESP >> 4),
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
-	},
-};
-
-static struct cfg80211_ops ath6kl_cfg80211_ops = {
-	.add_virtual_intf = ath6kl_cfg80211_add_iface,
-	.del_virtual_intf = ath6kl_cfg80211_del_iface,
-	.change_virtual_intf = ath6kl_cfg80211_change_iface,
-	.scan = ath6kl_cfg80211_scan,
-	.connect = ath6kl_cfg80211_connect,
-	.disconnect = ath6kl_cfg80211_disconnect,
-	.add_key = ath6kl_cfg80211_add_key,
-	.get_key = ath6kl_cfg80211_get_key,
-	.del_key = ath6kl_cfg80211_del_key,
-	.set_default_key = ath6kl_cfg80211_set_default_key,
-	.set_wiphy_params = ath6kl_cfg80211_set_wiphy_params,
-	.set_tx_power = ath6kl_cfg80211_set_txpower,
-	.get_tx_power = ath6kl_cfg80211_get_txpower,
-	.set_power_mgmt = ath6kl_cfg80211_set_power_mgmt,
-	.join_ibss = ath6kl_cfg80211_join_ibss,
-	.leave_ibss = ath6kl_cfg80211_leave_ibss,
-	.get_station = ath6kl_get_station,
-	.set_pmksa = ath6kl_set_pmksa,
-	.del_pmksa = ath6kl_del_pmksa,
-	.flush_pmksa = ath6kl_flush_pmksa,
-	CFG80211_TESTMODE_CMD(ath6kl_tm_cmd)
-#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	.suspend = __ath6kl_cfg80211_suspend,
-	.resume = __ath6kl_cfg80211_resume,
-#endif
-	.set_channel = ath6kl_set_channel,
-	.add_beacon = ath6kl_add_beacon,
-	.set_beacon = ath6kl_set_beacon,
-	.del_beacon = ath6kl_del_beacon,
-	.del_station = ath6kl_del_station,
-	.change_station = ath6kl_change_station,
-	.remain_on_channel = ath6kl_remain_on_channel,
-	.cancel_remain_on_channel = ath6kl_cancel_remain_on_channel,
-	.mgmt_tx = ath6kl_mgmt_tx,
-	.mgmt_frame_register = ath6kl_mgmt_frame_register,
-	.notify_btcoex = ath6kl_notify_btcoex,
-	.sched_scan_start = ath6kl_cfg80211_sscan_start,
-	.sched_scan_stop = ath6kl_cfg80211_sscan_stop,
-	.set_bitrate_mask = ath6kl_cfg80211_set_bitrate,
-	.set_mac_acl = ath6kl_set_mac_acl,
-	.set_cqm_txe_config = ath6kl_cfg80211_set_txe_config,
-};
-
-void ath6kl_cfg80211_stop(struct ath6kl_vif *vif)
-{
-	ath6kl_cfg80211_sscan_disable(vif);
-
-	switch (vif->sme_state) {
-	case SME_DISCONNECTED:
-		break;
-	case SME_CONNECTING:
-		cfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0,
-					NULL, 0,
-					WLAN_STATUS_UNSPECIFIED_FAILURE,
-					GFP_KERNEL);
-		break;
-	case SME_CONNECTED:
-		cfg80211_disconnected(vif->ndev, 0, NULL, 0, GFP_KERNEL);
-		break;
-	}
-
-	if (vif->ar->state != ATH6KL_STATE_RECOVERY &&
-	    (test_bit(CONNECTED, &vif->flags) ||
-	    test_bit(CONNECT_PEND, &vif->flags)))
-		ath6kl_wmi_disconnect_cmd(vif->ar->wmi, vif->fw_vif_idx);
-
-	vif->sme_state = SME_DISCONNECTED;
-	clear_bit(CONNECTED, &vif->flags);
-	clear_bit(CONNECT_PEND, &vif->flags);
-
-	/* Stop netdev queues, needed during recovery */
-	netif_stop_queue(vif->ndev);
-	netif_carrier_off(vif->ndev);
-
-	/* disable scanning */
-	if (vif->ar->state != ATH6KL_STATE_RECOVERY &&
-	    ath6kl_wmi_scanparams_cmd(vif->ar->wmi, vif->fw_vif_idx, 0xFFFF,
-				      0, 0, 0, 0, 0, 0, 0, 0, 0) != 0)
-		ath6kl_warn("failed to disable scan during stop\n");
-
-	ath6kl_cfg80211_scan_complete_event(vif, true);
-}
-
-void ath6kl_cfg80211_stop_all(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif && ar->state != ATH6KL_STATE_RECOVERY) {
-		/* save the current power mode before enabling power save */
-		ar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;
-
-		if (ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER) != 0)
-			ath6kl_warn("ath6kl_deep_sleep_enable: "
-				    "wmi_powermode_cmd failed\n");
-		return;
-	}
-
-	/*
-	 * FIXME: we should take ar->list_lock to protect changes in the
-	 * vif_list, but that's not trivial to do as ath6kl_cfg80211_stop()
-	 * sleeps.
-	 */
-	list_for_each_entry(vif, &ar->vif_list, list)
-		ath6kl_cfg80211_stop(vif);
-}
-
-#ifdef CONFIG_ATH6KL_REGDOMAIN
-static int ath6kl_cfg80211_reg_notify(struct wiphy *wiphy,
-				      struct regulatory_request *request)
-{
-	struct ath6kl *ar = wiphy_priv(wiphy);
-	u32 rates[IEEE80211_NUM_BANDS];
-	int ret, i;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
-		   "cfg reg_notify %c%c%s%s initiator %d\n",
-		   request->alpha2[0], request->alpha2[1],
-		   request->intersect ? " intersect" : "",
-		   request->processed ? " processed" : "",
-		   request->initiator);
-
-	ret = ath6kl_wmi_set_regdomain_cmd(ar->wmi, request->alpha2);
-	if (ret) {
-		ath6kl_err("failed to set regdomain: %d\n", ret);
-		return ret;
-	}
-
-	/*
-	 * Firmware will apply the regdomain change only after a scan is
-	 * issued and it will send a WMI_REGDOMAIN_EVENTID when it has been
-	 * changed.
-	 */
-
-	for (i = 0; i < IEEE80211_NUM_BANDS; i++)
-		if (wiphy->bands[i])
-			rates[i] = (1 << wiphy->bands[i]->n_bitrates) - 1;
-
-
-	ret = ath6kl_wmi_beginscan_cmd(ar->wmi, 0, WMI_LONG_SCAN, false,
-				       false, 0, ATH6KL_FG_SCAN_INTERVAL,
-				       0, NULL, false, rates);
-	if (ret) {
-		ath6kl_err("failed to start scan for a regdomain change: %d\n",
-			   ret);
-		return ret;
-	}
-
-	return 0;
-}
-#endif
-
-struct ath6kl *ath6kl_core_alloc(struct device *dev)
-{
-	struct ath6kl *ar;
-	struct wiphy *wiphy;
-	u8 ctr;
-
-	/* create a new wiphy for use with cfg80211 */
-	wiphy = wiphy_new(&ath6kl_cfg80211_ops, sizeof(struct ath6kl));
-
-	if (!wiphy) {
-		ath6kl_err("couldn't allocate wiphy device\n");
-		return NULL;
-	}
-
-	ar = wiphy_priv(wiphy);
-	ar->p2p = !!ath6kl_p2p;
-	ar->wiphy = wiphy;
-	ar->dev = dev;
-
-	ar->vif_max = 1;
-
-	ar->max_norm_iface = 1;
-
-	spin_lock_init(&ar->lock);
-	spin_lock_init(&ar->mcastpsq_lock);
-	spin_lock_init(&ar->list_lock);
-
-	init_waitqueue_head(&ar->event_wq);
-	sema_init(&ar->sem, 1);
-
-	INIT_LIST_HEAD(&ar->amsdu_rx_buffer_queue);
-	INIT_LIST_HEAD(&ar->vif_list);
-
-	clear_bit(WMI_ENABLED, &ar->flag);
-	clear_bit(SKIP_SCAN, &ar->flag);
-	clear_bit(DESTROY_IN_PROGRESS, &ar->flag);
-
-	ar->tx_pwr = 0;
-	ar->intra_bss = 1;
-	ar->lrssi_roam_threshold = DEF_LRSSI_ROAM_THRESHOLD;
-
-	ar->state = ATH6KL_STATE_OFF;
-
-	memset((u8 *)ar->sta_list, 0,
-	       AP_MAX_NUM_STA * sizeof(struct ath6kl_sta));
-
-	/* Init the PS queues */
-	for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {
-		spin_lock_init(&ar->sta_list[ctr].psq_lock);
-		skb_queue_head_init(&ar->sta_list[ctr].psq);
-		skb_queue_head_init(&ar->sta_list[ctr].apsdq);
-		ar->sta_list[ctr].mgmt_psq_len = 0;
-		INIT_LIST_HEAD(&ar->sta_list[ctr].mgmt_psq);
-		ar->sta_list[ctr].aggr_conn =
-			kzalloc(sizeof(struct aggr_info_conn), GFP_KERNEL);
-		if (!ar->sta_list[ctr].aggr_conn) {
-			ath6kl_err("Failed to allocate memory for sta aggregation information\n");
-			ath6kl_core_cleanup(ar);
-			return NULL;
-		}
-	}
-
-	skb_queue_head_init(&ar->mcastpsq);
-
-	memcpy(ar->ap_country_code, DEF_AP_COUNTRY_CODE, 3);
-
-	return ar;
-}
-
-int ath6kl_register_ieee80211_hw(struct ath6kl *ar)
-{
-	struct wiphy *wiphy = ar->wiphy;
-	int ret;
-
-	wiphy->mgmt_stypes = ath6kl_mgmt_stypes;
-
-	wiphy->max_remain_on_channel_duration = 5000;
-
-	/* set device pointer for wiphy */
-	set_wiphy_dev(wiphy, ar->dev);
-
-	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
-				 BIT(NL80211_IFTYPE_ADHOC) |
-				 BIT(NL80211_IFTYPE_AP);
-	if (ar->p2p) {
-		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_GO) |
-					  BIT(NL80211_IFTYPE_P2P_CLIENT);
-	}
-
-#ifdef CONFIG_ATH6KL_REGDOMAIN
-	/* FIXME: add firmware capability */
-	wiphy->reg_notifier = ath6kl_cfg80211_reg_notify;
-#endif
-
-	/* max num of ssids that can be probed during scanning */
-	wiphy->max_scan_ssids = MAX_PROBED_SSIDS;
-
-	/* max num of ssids that can be matched after scan */
-	if (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_MATCH_LIST,
-		     ar->fw_capabilities))
-		wiphy->max_match_sets = MAX_PROBED_SSIDS;
-
-	wiphy->max_scan_ie_len = 1000; /* FIX: what is correct limit? */
-	if (ar->hw.flags & ATH6KL_HW_FLAG_64BIT_RATES) {
-		ath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-		ath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-		ath6kl_band_2ghz.ht_cap.mcs.rx_mask[1] = 0xff;
-		ath6kl_band_5ghz.ht_cap.mcs.rx_mask[1] = 0xff;
-	} else {
-		ath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-		ath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-	}
-
-	wiphy->bands[IEEE80211_BAND_2GHZ] = &ath6kl_band_2ghz;
-	wiphy->bands[IEEE80211_BAND_5GHZ] = &ath6kl_band_5ghz;
-	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
-
-	wiphy->cipher_suites = cipher_suites;
-	wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
-
-	wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-			      WIPHY_WOWLAN_DISCONNECT |
-			      WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
-			      WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
-			      WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
-			      WIPHY_WOWLAN_4WAY_HANDSHAKE;
-	wiphy->wowlan.n_patterns = WOW_MAX_FILTERS_PER_LIST;
-	wiphy->wowlan.pattern_min_len = 1;
-	wiphy->wowlan.pattern_max_len = WOW_PATTERN_SIZE;
-
-	wiphy->max_sched_scan_ssids = MAX_PROBED_SSIDS;
-
-	ath6kl_setup_android_resource(ar);
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_MAC_ACL, ar->fw_capabilities)) {
-		ar->wiphy->features |= NL80211_FEATURE_MAC_ACL;
-		ar->wiphy->max_acl_mac_addrs = MAX_ACL_MAC_ADDRS;
-	}
-
-	ret = wiphy_register(wiphy);
-	if (ret < 0) {
-		ath6kl_err("couldn't register wiphy device\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_init_if_data(struct ath6kl_vif *vif)
-{
-	vif->aggr_cntxt = aggr_init(vif);
-	if (!vif->aggr_cntxt) {
-		ath6kl_err("failed to initialize aggr\n");
-		return -ENOMEM;
-	}
-
-	setup_timer(&vif->disconnect_timer, disconnect_timer_handler,
-		    (unsigned long) vif->ndev);
-	setup_timer(&vif->sched_scan_timer, ath6kl_wmi_sscan_timer,
-		    (unsigned long) vif);
-
-	set_bit(WMM_ENABLED, &vif->flags);
-	spin_lock_init(&vif->if_lock);
-
-	INIT_LIST_HEAD(&vif->mc_filter);
-
-	return 0;
-}
-
-void ath6kl_deinit_if_data(struct ath6kl_vif *vif)
-{
-	struct ath6kl *ar = vif->ar;
-	struct ath6kl_mc_filter *mc_filter, *tmp;
-
-	aggr_module_destroy(vif->aggr_cntxt);
-
-	ar->avail_idx_map |= BIT(vif->fw_vif_idx);
-
-	if (vif->nw_type == ADHOC_NETWORK)
-		ar->ibss_if_active = false;
-
-	list_for_each_entry_safe(mc_filter, tmp, &vif->mc_filter, list) {
-		list_del(&mc_filter->list);
-		kfree(mc_filter);
-	}
-
-	unregister_netdevice(vif->ndev);
-
-	ar->num_vif--;
-}
-
-struct net_device *ath6kl_interface_add(struct ath6kl *ar, char *name,
-					enum nl80211_iftype type, u8 fw_vif_idx,
-					u8 nw_type)
-{
-	struct net_device *ndev;
-	struct ath6kl_vif *vif;
-
-	ndev = alloc_netdev(sizeof(*vif), name, ether_setup);
-	if (!ndev)
-		return NULL;
-
-	vif = netdev_priv(ndev);
-	ndev->ieee80211_ptr = &vif->wdev;
-	vif->wdev.wiphy = ar->wiphy;
-	vif->ar = ar;
-	vif->ndev = ndev;
-	SET_NETDEV_DEV(ndev, wiphy_dev(vif->wdev.wiphy));
-	vif->wdev.netdev = ndev;
-	vif->wdev.iftype = type;
-	vif->fw_vif_idx = fw_vif_idx;
-	vif->nw_type = vif->next_mode = nw_type;
-	vif->scan_ctrl_flag = 0;
-	vif->listen_intvl_t = ATH6KL_DEFAULT_LISTEN_INTVAL;
-	vif->bmiss_time_t = ATH6KL_DEFAULT_BMISS_TIME;
-	vif->bg_scan_period = 0;
-	vif->htcap[IEEE80211_BAND_2GHZ].ht_enable = true;
-	vif->htcap[IEEE80211_BAND_5GHZ].ht_enable = true;
-
-	memcpy(ndev->dev_addr, ar->mac_addr, ETH_ALEN);
-	if (fw_vif_idx != 0) {
-		ndev->dev_addr[0] = (ndev->dev_addr[0] ^ (1 << fw_vif_idx)) |
-				     0x2;
-		if (test_bit(ATH6KL_FW_CAPABILITY_CUSTOM_MAC_ADDR,
-			     ar->fw_capabilities))
-			ndev->dev_addr[4] ^= 0x80;
-	}
-
-	init_netdev(ndev);
-
-	ath6kl_init_control_info(vif);
-
-	/* TODO: Pass interface specific pointer instead of ar */
-	if (ath6kl_init_if_data(vif))
-		goto err;
-
-	if (register_netdevice(ndev))
-		goto err;
-
-	ar->avail_idx_map &= ~BIT(fw_vif_idx);
-	vif->sme_state = SME_DISCONNECTED;
-	set_bit(WLAN_ENABLED, &vif->flags);
-	ar->wlan_pwr_state = WLAN_POWER_STATE_ON;
-	set_bit(NETDEV_REGISTERED, &vif->flags);
-
-	if (type == NL80211_IFTYPE_ADHOC)
-		ar->ibss_if_active = true;
-
-	spin_lock_bh(&ar->list_lock);
-	list_add_tail(&vif->list, &ar->vif_list);
-	spin_unlock_bh(&ar->list_lock);
-
-	return ndev;
-
-err:
-	aggr_module_destroy(vif->aggr_cntxt);
-	free_netdev(ndev);
-	return NULL;
-}
-
-void ath6kl_deinit_ieee80211_hw(struct ath6kl *ar)
-{
-	int i;
-
-	ath6kl_cleanup_android_resource(ar);
-
-	for (i = 0; i < AP_MAX_NUM_STA; i++)
-		kfree(ar->sta_list[i].aggr_conn);
-
-	wiphy_unregister(ar->wiphy);
-	wiphy_free(ar->wiphy);
-}
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.h
index 7fedc98..34456fa 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/cfg80211.h
@@ -38,8 +38,8 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
 				   u8 *bssid, u16 listen_intvl,
 				   u16 beacon_intvl,
 				   enum network_type nw_type,
-				   u8 beacon_ie_len, u8 assoc_req_len,
-				   u8 assoc_resp_len, u8 *assoc_info);
+				   u16 beacon_ie_len, u16 assoc_req_len,
+				   u16 assoc_resp_len, u8 *assoc_info);
 
 void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 				      u8 *bssid, u8 assoc_resp_len,
@@ -54,6 +54,7 @@ int ath6kl_cfg80211_suspend(struct ath6kl *ar,
 
 int ath6kl_cfg80211_resume(struct ath6kl *ar);
 
+void ath6kl_cfg80211_start_all(struct ath6kl *ar);
 void ath6kl_cfg80211_stop(struct ath6kl_vif *vif);
 void ath6kl_cfg80211_stop_all(struct ath6kl *ar);
 bool ath6kl_cfg80211_ready(struct ath6kl_vif *vif);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/core.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/core.h
index 6fd5172..3f45655 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/core.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/core.h
@@ -18,12 +18,15 @@
 #ifndef CORE_H
 #define CORE_H
 
+#include <linux/ip.h>
+#include <linux/udp.h>
 #include <linux/etherdevice.h>
 #include <linux/rtnetlink.h>
 #include <linux/firmware.h>
 #include <linux/sched.h>
 #include <linux/circ_buf.h>
 #include <net/cfg80211.h>
+#include <linux/wireless.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 #endif
@@ -61,7 +64,10 @@
 
 /* MAX_HI_COOKIE_NUM are reserved for high priority traffic */
 #define MAX_DEF_COOKIE_NUM                180
-#define MAX_HI_COOKIE_NUM                 18	/* 10% of MAX_COOKIE_NUM */
+/* Reserved for data sync cmd to avoid htc dead lock */
+#define DATA_SYNC_RESERVED                10
+/* 10% of MAX_COOKIE_NUM(18) + DATA_SYNC_RESERVED(10) */
+#define MAX_HI_COOKIE_NUM                 28
 #define MAX_COOKIE_NUM                 (MAX_DEF_COOKIE_NUM + MAX_HI_COOKIE_NUM)
 #define WMI_MAX_COOKIE_NUM                80
 
@@ -69,12 +75,18 @@
 
 #define DISCON_TIMER_INTVAL               10000  /* in msec */
 
+#define MAX_APSD_DEPTH_FOR_EACH_CONN	  50	/*limit it to avoid exhausting system's memory*/
+#define MAX_PSQ_DEPTH_FOR_EACH_CONN       50 /*limit it to avoid exhausting system's memory*/
+
 /* Channel dwell time in fg scan */
 #define ATH6KL_FG_SCAN_INTERVAL         50 /* in ms */
 
 /* Channel dwell time in fg scan */
 #define ATH6KL_FG_SCAN_INTERVAL		50 /* in ms */
 
+/* number of sending ps-poll before switch to send null data */
+#define WLAN_CONFIG_PSPOLL_NUM		0
+
 /* includes also the null byte */
 #define ATH6KL_FIRMWARE_MAGIC               "QCA-ATH6KL"
 
@@ -153,6 +165,20 @@ enum ath6kl_fw_capability {
 	 */
 	ATH6KL_FW_CAPABILITY_MAC_ACL,
 
+	/*
+	* Firmware with capability regdomain-v2 can support
+	* set regdomain immediately. The firmware without this
+	* capability need start scan for new regdomain take effect
+	*/
+	ATH6KL_FW_CAPABILITY_REGDOMAIN_V2,
+
+	/*
+	 * Firmware capable to send more than 255 byte in IE
+	 * (assoc req ie, assoc resp ie, beacon ie) present in
+	 * connect event.
+	 */
+	ATH6KL_FW_CAPABILITY_LARGE_CONNECT_IE,
+
 	/* this needs to be last */
 	ATH6KL_FW_CAPABILITY_MAX,
 };
@@ -385,6 +411,8 @@ struct ath6kl_sta {
 	size_t mgmt_psq_len;
 	u8 apsd_info;
 	struct sk_buff_head apsdq;
+	size_t apsdq_depth;
+	size_t psq_depth;
 	struct aggr_info_conn *aggr_conn;
 };
 
@@ -402,6 +430,40 @@ struct ath6kl_bmi {
 	u32 max_cmd_size;
 };
 
+/* Same as struct target_stats, expect it trackes only few
+   stats in u32 variable. */
+struct target_stats_dup {
+	u32 tx_retry_cnt[4];
+	u32 tx_mult_retry_cnt[4];
+	u32 tx_pkt_per_ac[4];
+	u32 rx_pkt;
+	u32 rx_dupl_frame;
+	u32 tx_fail_cnt[4];
+	u32 tx_rts_fail_cnt;
+	u32 tx_err;
+	u32 tx_rts_success_cnt;
+	u32 rx_err;
+	u32 tx_byte;
+};
+
+enum ath6kl_wlan_stats {
+	WLAN_STATS_INVALID,
+	WLAN_STATS_RETRY_CNT,
+	WLAN_STATS_MUL_RETRY_CNT,
+	WLAN_STATS_TX_FRM_CNT,
+	WLAN_STATS_RX_FRM_CNT,
+	WLAN_STATS_FRM_DUP_CNT,
+	WLAN_STATS_FAIL_CNT,
+	WLAN_STATS_RTS_FAIL_CNT,
+	WLAN_STATS_ACK_FAIL_CNT,
+	WLAN_STATS_RTS_SUC_CNT,
+	WLAN_STATS_RX_DISCARD_CNT,
+	WLAN_STATS_RX_ERROR_CNT,
+	WLAN_STATS_TX_BYTE_CNT,
+};
+
+#define ATH6KL_PRI_IOCTL_REPLY_BUF_MAX 1024
+
 struct target_stats {
 	u64 tx_pkt;
 	u64 tx_byte;
@@ -561,12 +623,37 @@ enum ath6kl_vif_state {
 	SCHED_SCANNING,
 };
 
+struct ath6kl_vif_bcn_info {
+	bool hidden_ssid;
+	enum wmi_phy_mode phy_mode;
+	u8 *beacon_ies;
+	size_t beacon_ies_len;
+	u8 *proberesp_ies;
+	size_t proberesp_ies_len;
+	u8 *assocresp_ies;
+	size_t assocresp_ies_len;
+	u8 sta_cap_req;
+};
+
+struct ath6kl_vif_tp_status {
+	unsigned int cur_level;
+	unsigned long cur_tp;
+	unsigned long cur_txrx; /* net_device_stats */
+};
+
+struct ath6kl_vif_cookie_cfg {
+	bool load_balance;
+	int min_cookies; /* the min cookies reserved for vif */
+	int mid_cookies; /* middle of cookies */
+	int max_cookies; /* max number assigned for vif */
+};
+
 struct ath6kl_vif {
 	struct list_head list;
 	struct wireless_dev wdev;
 	struct net_device *ndev;
 	struct ath6kl *ar;
-	/* Lock to protect vif specific net_stats and flags */
+	/* Lock to protect vif specific net_stats, scan_req and flags */
 	spinlock_t if_lock;
 	u8 fw_vif_idx;
 	unsigned long flags;
@@ -612,10 +699,15 @@ struct ath6kl_vif {
 	u8 assoc_bss_dtim_period;
 	struct net_device_stats net_stats;
 	struct target_stats target_stats;
+	struct target_stats_dup target_stats_dup;
 	struct wmi_connect_cmd profile;
 	u16 rsn_capab;
 
 	struct list_head mc_filter;
+	struct ath6kl_vif_bcn_info bcn_info;
+
+	struct ath6kl_vif_tp_status vif_tp_status;
+	unsigned int cur_data_cookies; /* current cookies used */
 };
 
 #define WOW_LIST_ID		0
@@ -623,6 +715,26 @@ struct ath6kl_vif {
 
 #define ATH6KL_SCHED_SCAN_RESULT_DELAY 5000 /* ms */
 
+#define ATH6KL_PRIV_GET_WLAN_STATS	(SIOCIWFIRSTPRIV + 21)
+
+/* ATH6KL_IOCTL_EXTENDED - extended ioctl */
+#define ATH6KL_IOCTL_WEXT_PRIV26        (SIOCIWFIRSTPRIV+26)
+
+
+struct ath6kl_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+};
+
+/* TBD: ioctl number is aligned to olca branch
+ * will refine one the loopback tool is ready for native ath6kl
+ */
+enum ath6kl_xioctl {
+	ATH6KL_XIOCTL_TRAFFIC_ACTIVITY_CHANGE	= 80,
+	ATH6KL_XIOCTL_PKT_FILTER_ADD_DEL	= 81,
+};
+
 /* Flag info */
 enum ath6kl_dev_state {
 	WMI_ENABLED,
@@ -633,6 +745,8 @@ enum ath6kl_dev_state {
 	SKIP_SCAN,
 	ROAM_TBL_PEND,
 	FIRST_BOOT,
+	RECOVERY_CLEANUP,
+	REG_DOMAIN_HINT_PEND
 };
 
 enum ath6kl_state {
@@ -653,6 +767,42 @@ enum ath6kl_fw_err {
 	ATH6KL_FW_ASSERT,
 	ATH6KL_FW_HB_RESP_FAILURE,
 	ATH6KL_FW_EP_FULL,
+	ATH6KL_FW_TX_OVERFLOW,
+};
+
+#define TP_MONITOR_TIMER_INTERVAL_S	3
+#define TP_THR_PKS_A_DEFAULT		500
+#define TP_THR_PKS_B_DEFAULT		1500
+#define TP_THR_PKS_C_DEFAULT		5000
+#define TP_THR_BYTES_A_DEFAULT		500000
+#define TP_THR_BYTES_B_DEFAULT		1500000
+#define TP_THR_BYTES_C_DEFAULT		5000000
+
+#define TP_MONITOR_MAX_INTERVEL_S	20 /* max interval seconds */
+#define TP_THR_MIN			100 /* min thr setting */
+#define TP_THR_MAX			100000000 /* max thr setting */
+
+enum ath6kl_tp_level {
+	ATH6KL_TP_LOW,			/* throughput range:[0, a) */
+	ATH6KL_TP_NORMAL_A,		/* throughput range:[a, b) */
+	ATH6KL_TP_HIGH_B,		/* throughput range:[b, c) */
+	ATH6KL_TP_SUPER_C,		/* throughput range:[c, ...) */
+};
+
+enum ath6kl_tp_type {
+	ATH6KL_TP_TYPE_DISABLED,
+	ATH6KL_TP_TYPE_PACKETS,
+	ATH6KL_TP_TYPE_BYTES,
+	ATH6KL_TP_TYPE_MAX,
+};
+
+struct ath6kl_tp_ctl {
+	unsigned int interval_s; /* tp control interval */
+	struct timer_list tp_monitor_timer;
+	enum ath6kl_tp_type thr_type; /* type for monitor throughput */
+	unsigned long thr_a; /* threshold for monitor throughput */
+	unsigned long thr_b;
+	unsigned long thr_c;
 };
 
 struct ath6kl {
@@ -734,6 +884,7 @@ struct ath6kl {
 		u32 uarttx_pin;
 		u32 testscript_addr;
 		u32 flags;
+		enum wmi_phy_cap cap;
 
 		struct ath6kl_hw_fw {
 			const char *dir;
@@ -786,7 +937,6 @@ struct ath6kl {
 	struct ath6kl_btcoex btcoex_info;
 
 	struct ath6kl_fw_recovery {
-		bool enable;
 		struct work_struct recovery_work;
 		unsigned long err_reason;
 		unsigned long hb_poll;
@@ -794,8 +944,12 @@ struct ath6kl {
 		u32 seq_num;
 		bool hb_pending;
 		u8 hb_misscnt;
+		bool enable;
 	} fw_recovery;
 
+	struct ath6kl_tp_ctl tp_ctl;
+	struct ath6kl_vif_cookie_cfg vif_cookie_cfg;
+
 #ifdef CONFIG_ATH6KL_DEBUG
 	struct {
 		struct sk_buff_head fwlog_queue;
@@ -830,8 +984,40 @@ struct ath6kl {
 	struct wake_lock p2p_wake_lock;
 #endif /* CONFIG_HAS_WAKELOCK */
 
+	u8 *ready_data;
+	size_t ready_len;
+
+	u8 alpha2[2];
 };
 
+#define ATH6KL_DHCP_OPCODE_MSG_TYPE      53
+#define ATH6KL_DHCP_MSG_TYPE_LEN         1
+
+struct bootp_pkt {		/* BOOTP packet format */
+	struct iphdr iph;	/* IP header */
+	struct udphdr udph;	/* UDP header */
+	u8 op;			/* 1=request, 2=reply */
+	u8 htype;		/* HW address type */
+	u8 hlen;		/* HW address length */
+	u8 hops;		/* Used only by gateways */
+	__be32 xid;		/* Transaction ID */
+	__be16 secs;		/* Seconds since we started */
+	__be16 flags;		/* Just what it says */
+	__be32 client_ip;	/* Client's IP address if known */
+	__be32 your_ip;		/* Assigned IP address */
+	__be32 server_ip;	/* Server's IP address */
+	__be32 relay_ip;	/* IP address of BOOTP relay */
+	u8 hw_addr[16];		/* Client's HW address */
+	u8 serv_name[64];	/* Server host name */
+	u8 boot_file[128];	/* Name of boot file */
+	u8 exten[312];		/* DHCP options / BOOTP vendor extensions */
+};
+
+struct dhcp_packet {
+	struct ethhdr  eth_hdr;
+	struct bootp_pkt bootp_hdr;
+} __packed;
+
 static inline struct ath6kl *ath6kl_priv(struct net_device *dev)
 {
 	return ((struct ath6kl_vif *) netdev_priv(dev))->ar;
@@ -890,18 +1076,20 @@ void aggr_reset_state(struct aggr_info_conn *aggr_conn);
 struct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 * node_addr);
 struct ath6kl_sta *ath6kl_find_sta_by_aid(struct ath6kl *ar, u8 aid);
 
-void ath6kl_ready_event(void *devt, u8 * datap, u32 sw_ver, u32 abi_ver);
+void ath6kl_ready_event(void *devt, u8 * datap, u32 sw_ver, u32 abi_ver,
+			enum wmi_phy_cap cap);
 int ath6kl_control_tx(void *devt, struct sk_buff *skb,
 		      enum htc_endpoint_id eid);
 void ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel,
 			  u8 *bssid, u16 listen_int,
 			  u16 beacon_int, enum network_type net_type,
-			  u8 beacon_ie_len, u8 assoc_req_len,
-			  u8 assoc_resp_len, u8 *assoc_info);
+			  u16 beacon_ie_len, u16 assoc_req_len,
+			  u16 assoc_resp_len, u8 *assoc_info);
 void ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel);
 void ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,
 				u8 keymgmt, u8 ucipher, u8 auth,
-				u8 assoc_req_len, u8 *assoc_info, u8 apsd_info);
+				u16 assoc_req_len, u8 *assoc_info,
+				u8 apsd_info);
 void ath6kl_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 			     u8 *bssid, u8 assoc_resp_len,
 			     u8 *assoc_info, u16 prot_reason_status);
@@ -932,13 +1120,28 @@ int ath6kl_init_hw_start(struct ath6kl *ar);
 int ath6kl_init_hw_stop(struct ath6kl *ar);
 void ath6kl_check_wow_status(struct ath6kl *ar, struct sk_buff *skb,
 			     bool is_event_pkt);
-void ath6kl_sdio_init_platform(void);
+int ath6kl_sdio_init_platform(void);
 void ath6kl_sdio_exit_platform(void);
 void ath6kl_mangle_mac_address(struct ath6kl *ar, u8 locally_administered_bit);
 
 int ath6kl_wait_for_init_comp(void);
 void ath6kl_notify_init_done(void);
 
+u8 ath6kl_remove_sta(struct ath6kl *ar, u8 *mac, u16 reason);
+
+void ath6kl_tp_monitor_timer(unsigned long data);
+void ath6kl_tp_cfg(struct ath6kl *ar, unsigned int interval_s,
+		   unsigned int type, unsigned long thr_a,
+		   unsigned long thr_b, unsigned long thr_c);
+void ath6kl_cookie_vif_balance_init(struct ath6kl *ar);
+bool ath6kl_is_other_vif_cookie_busy(struct ath6kl *ar,
+				    struct ath6kl_vif *cur_vif);
+bool ath6kl_is_other_vif_connected(struct ath6kl *ar,
+				   struct ath6kl_vif *cur_vif);
+
+int ath6kl_ioctl_pkt_filter_set(struct ath6kl_vif *vif,
+				char *buf,
+				int len);
 /* Fw error recovery */
 void ath6kl_init_hw_restart(struct ath6kl *ar);
 void ath6kl_recovery_err_notify(struct ath6kl *ar, enum ath6kl_fw_err reason);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c
index b7e4ad1..682abf6 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c
@@ -454,6 +454,9 @@ static ssize_t ath6kl_fwlog_mask_write(struct file *file,
 	struct ath6kl *ar = file->private_data;
 	int ret;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	ret = kstrtou32_from_user(user_buf, count, 0, &ar->debug.fwlog_mask);
 	if (ret)
 		return ret;
@@ -487,6 +490,9 @@ static ssize_t read_file_tgt_stats(struct file *file, char __user *user_buf,
 	long left;
 	ssize_t ret_cnt;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -965,6 +971,9 @@ static ssize_t ath6kl_lrssi_roam_write(struct file *file,
 	char buf[32];
 	ssize_t len;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	len = min(count, sizeof(buf) - 1);
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;
@@ -1109,6 +1118,9 @@ static ssize_t ath6kl_roam_table_read(struct file *file, char __user *user_buf,
 	unsigned int len, buf_len;
 	ssize_t ret_cnt;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	if (down_interruptible(&ar->sem))
 		return -EBUSY;
 
@@ -1180,6 +1192,9 @@ static ssize_t ath6kl_force_roam_write(struct file *file,
 	int i;
 	int addr[ETH_ALEN];
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	len = min(count, sizeof(buf) - 1);
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;
@@ -1216,6 +1231,9 @@ static ssize_t ath6kl_roam_mode_write(struct file *file,
 	size_t len;
 	enum wmi_roam_mode mode;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	len = min(count, sizeof(buf) - 1);
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;
@@ -1271,6 +1289,9 @@ static ssize_t ath6kl_keepalive_write(struct file *file,
 	int ret;
 	u8 val;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	ret = kstrtou8_from_user(user_buf, count, 0, &val);
 	if (ret)
 		return ret;
@@ -1316,6 +1337,9 @@ static ssize_t ath6kl_disconnect_timeout_write(struct file *file,
 	int ret;
 	u8 val;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	ret = kstrtou8_from_user(user_buf, count, 0, &val);
 	if (ret)
 		return ret;
@@ -1349,6 +1373,9 @@ static ssize_t ath6kl_create_qos_write(struct file *file,
 	u32 val32;
 	u16 val16;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -1527,6 +1554,9 @@ static ssize_t ath6kl_delete_qos_write(struct file *file,
 	u8 traffic_class;
 	u8 tsid;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -1572,6 +1602,9 @@ static ssize_t ath6kl_bgscan_int_write(struct file *file,
 	char buf[32];
 	ssize_t len;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -1612,6 +1645,9 @@ static ssize_t ath6kl_listen_int_write(struct file *file,
 	char buf[32];
 	ssize_t len;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -1671,6 +1707,9 @@ static ssize_t ath6kl_power_params_write(struct file *file,
 	u16 idle_period, ps_poll_num, dtim,
 		tx_wakeup, num_tx;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	len = min(count, sizeof(buf) - 1);
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;
@@ -1720,7 +1759,7 @@ static const struct file_operations fops_power_params = {
 	.llseek = default_llseek,
 };
 
-int ath6kl_debug_init(struct ath6kl *ar)
+void ath6kl_debug_init(struct ath6kl *ar)
 {
 	skb_queue_head_init(&ar->debug.fwlog_queue);
 	init_completion(&ar->debug.fwlog_completion);
@@ -1730,7 +1769,15 @@ int ath6kl_debug_init(struct ath6kl *ar)
 	 * value from the firmware.
 	 */
 	ar->debug.fwlog_mask = 0;
+}
 
+/*
+ * Initialisation needs to happen in two stages as fwlog events can come
+ * before cfg80211 is initialised, and debugfs depends on cfg80211
+ * initialisation.
+ */
+int ath6kl_debug_init_fs(struct ath6kl *ar)
+{
 	ar->debugfs_phy = debugfs_create_dir("ath6kl",
 					     ar->wiphy->debugfsdir);
 	if (!ar->debugfs_phy)
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c.orig b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c.orig
deleted file mode 100644
index c211dab..0000000
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.c.orig
+++ /dev/null
@@ -1,1804 +0,0 @@
-/*
- * Copyright (c) 2004-2011 Atheros Communications Inc.
- * Copyright (c) 2011-2012 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "core.h"
-
-#include <linux/skbuff.h>
-#include <linux/fs.h>
-#include <linux/vmalloc.h>
-#include <linux/export.h>
-
-#include "debug.h"
-#include "debugfs_pri.h"
-#include "target.h"
-
-struct ath6kl_fwlog_slot {
-	__le32 timestamp;
-	__le32 length;
-
-	/* max ATH6KL_FWLOG_PAYLOAD_SIZE bytes */
-	u8 payload[0];
-};
-
-#define ATH6KL_FWLOG_MAX_ENTRIES 20
-
-#define ATH6KL_FWLOG_VALID_MASK 0x1ffff
-
-int ath6kl_printk(const char *level, const char *fmt, ...)
-{
-	struct va_format vaf;
-	va_list args;
-	int rtn;
-
-	va_start(args, fmt);
-
-	vaf.fmt = fmt;
-	vaf.va = &args;
-
-	rtn = printk("%sath6kl: %pV", level, &vaf);
-
-	va_end(args);
-
-	return rtn;
-}
-
-#ifdef CONFIG_ATH6KL_DEBUG
-
-#define REG_OUTPUT_LEN_PER_LINE	25
-#define REGTYPE_STR_LEN		100
-
-struct ath6kl_diag_reg_info {
-	u32 reg_start;
-	u32 reg_end;
-	const char *reg_info;
-};
-
-static const struct ath6kl_diag_reg_info diag_reg[] = {
-	{ 0x20000, 0x200fc, "General DMA and Rx registers" },
-	{ 0x28000, 0x28900, "MAC PCU register & keycache" },
-	{ 0x20800, 0x20a40, "QCU" },
-	{ 0x21000, 0x212f0, "DCU" },
-	{ 0x4000,  0x42e4, "RTC" },
-	{ 0x540000, 0x540000 + (256 * 1024), "RAM" },
-	{ 0x29800, 0x2B210, "Base Band" },
-	{ 0x1C000, 0x1C748, "Analog" },
-};
-
-void ath6kl_dump_registers(struct ath6kl_device *dev,
-			   struct ath6kl_irq_proc_registers *irq_proc_reg,
-			   struct ath6kl_irq_enable_reg *irq_enable_reg)
-{
-
-	ath6kl_dbg(ATH6KL_DBG_ANY, ("<------- Register Table -------->\n"));
-
-	if (irq_proc_reg != NULL) {
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			"Host Int status:           0x%x\n",
-			irq_proc_reg->host_int_status);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "CPU Int status:            0x%x\n",
-			irq_proc_reg->cpu_int_status);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Error Int status:          0x%x\n",
-			irq_proc_reg->error_int_status);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Counter Int status:        0x%x\n",
-			irq_proc_reg->counter_int_status);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Mbox Frame:                0x%x\n",
-			irq_proc_reg->mbox_frame);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Rx Lookahead Valid:        0x%x\n",
-			irq_proc_reg->rx_lkahd_valid);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Rx Lookahead 0:            0x%x\n",
-			irq_proc_reg->rx_lkahd[0]);
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			   "Rx Lookahead 1:            0x%x\n",
-			irq_proc_reg->rx_lkahd[1]);
-
-		if (dev->ar->mbox_info.gmbox_addr != 0) {
-			/*
-			 * If the target supports GMBOX hardware, dump some
-			 * additional state.
-			 */
-			ath6kl_dbg(ATH6KL_DBG_ANY,
-				"GMBOX Host Int status 2:   0x%x\n",
-				irq_proc_reg->host_int_status2);
-			ath6kl_dbg(ATH6KL_DBG_ANY,
-				"GMBOX RX Avail:            0x%x\n",
-				irq_proc_reg->gmbox_rx_avail);
-			ath6kl_dbg(ATH6KL_DBG_ANY,
-				"GMBOX lookahead alias 0:   0x%x\n",
-				irq_proc_reg->rx_gmbox_lkahd_alias[0]);
-			ath6kl_dbg(ATH6KL_DBG_ANY,
-				"GMBOX lookahead alias 1:   0x%x\n",
-				irq_proc_reg->rx_gmbox_lkahd_alias[1]);
-		}
-
-	}
-
-	if (irq_enable_reg != NULL) {
-		ath6kl_dbg(ATH6KL_DBG_ANY,
-			"Int status Enable:         0x%x\n",
-			irq_enable_reg->int_status_en);
-		ath6kl_dbg(ATH6KL_DBG_ANY, "Counter Int status Enable: 0x%x\n",
-			irq_enable_reg->cntr_int_status_en);
-	}
-	ath6kl_dbg(ATH6KL_DBG_ANY, "<------------------------------->\n");
-}
-
-static void dump_cred_dist(struct htc_endpoint_credit_dist *ep_dist)
-{
-	ath6kl_dbg(ATH6KL_DBG_CREDIT,
-		   "--- endpoint: %d  svc_id: 0x%X ---\n",
-		   ep_dist->endpoint, ep_dist->svc_id);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " dist_flags     : 0x%X\n",
-		   ep_dist->dist_flags);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_norm      : %d\n",
-		   ep_dist->cred_norm);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_min       : %d\n",
-		   ep_dist->cred_min);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " credits        : %d\n",
-		   ep_dist->credits);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_assngd    : %d\n",
-		   ep_dist->cred_assngd);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " seek_cred      : %d\n",
-		   ep_dist->seek_cred);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_sz        : %d\n",
-		   ep_dist->cred_sz);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_per_msg   : %d\n",
-		   ep_dist->cred_per_msg);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " cred_to_dist   : %d\n",
-		   ep_dist->cred_to_dist);
-	ath6kl_dbg(ATH6KL_DBG_CREDIT, " txq_depth      : %d\n",
-		   get_queue_depth(&ep_dist->htc_ep->txq));
-	ath6kl_dbg(ATH6KL_DBG_CREDIT,
-		   "----------------------------------\n");
-}
-
-/* FIXME: move to htc.c */
-void dump_cred_dist_stats(struct htc_target *target)
-{
-	struct htc_endpoint_credit_dist *ep_list;
-
-	if (!AR_DBG_LVL_CHECK(ATH6KL_DBG_CREDIT))
-		return;
-
-	list_for_each_entry(ep_list, &target->cred_dist_list, list)
-		dump_cred_dist(ep_list);
-
-	ath6kl_dbg(ATH6KL_DBG_CREDIT,
-		   "credit distribution total %d free %d\n",
-		   target->credit_info->total_avail_credits,
-		   target->credit_info->cur_free_credits);
-}
-
-static int ath6kl_debugfs_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-void ath6kl_debug_war(struct ath6kl *ar, enum ath6kl_war war)
-{
-	switch (war) {
-	case ATH6KL_WAR_INVALID_RATE:
-		ar->debug.war_stats.invalid_rate++;
-		break;
-	}
-}
-
-static ssize_t read_file_war_stats(struct file *file, char __user *user_buf,
-				   size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char *buf;
-	unsigned int len = 0, buf_len = 1500;
-	ssize_t ret_cnt;
-
-	buf = kzalloc(buf_len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	len += scnprintf(buf + len, buf_len - len, "\n");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "Workaround stats");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n\n",
-			 "=================");
-	len += scnprintf(buf + len, buf_len - len, "%20s %10u\n",
-			 "Invalid rates", ar->debug.war_stats.invalid_rate);
-
-	if (WARN_ON(len > buf_len))
-		len = buf_len;
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-
-	kfree(buf);
-	return ret_cnt;
-}
-
-static const struct file_operations fops_war_stats = {
-	.read = read_file_war_stats,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-void ath6kl_debug_fwlog_event(struct ath6kl *ar, const void *buf, size_t len)
-{
-	struct ath6kl_fwlog_slot *slot;
-	struct sk_buff *skb;
-	size_t slot_len;
-
-	if (WARN_ON(len > ATH6KL_FWLOG_PAYLOAD_SIZE))
-		return;
-
-	slot_len = sizeof(*slot) + ATH6KL_FWLOG_PAYLOAD_SIZE;
-
-	skb = alloc_skb(slot_len, GFP_KERNEL);
-	if (!skb)
-		return;
-
-	slot = (struct ath6kl_fwlog_slot *) skb_put(skb, slot_len);
-	slot->timestamp = cpu_to_le32(jiffies);
-	slot->length = cpu_to_le32(len);
-	memcpy(slot->payload, buf, len);
-
-	/* Need to pad each record to fixed length ATH6KL_FWLOG_PAYLOAD_SIZE */
-	memset(slot->payload + len, 0, ATH6KL_FWLOG_PAYLOAD_SIZE - len);
-
-	spin_lock(&ar->debug.fwlog_queue.lock);
-
-	__skb_queue_tail(&ar->debug.fwlog_queue, skb);
-	complete(&ar->debug.fwlog_completion);
-
-	/* drop oldest entries */
-	while (skb_queue_len(&ar->debug.fwlog_queue) >
-	       ATH6KL_FWLOG_MAX_ENTRIES) {
-		skb = __skb_dequeue(&ar->debug.fwlog_queue);
-		kfree_skb(skb);
-	}
-
-	spin_unlock(&ar->debug.fwlog_queue.lock);
-
-	return;
-}
-
-static int ath6kl_fwlog_open(struct inode *inode, struct file *file)
-{
-	struct ath6kl *ar = inode->i_private;
-
-	if (ar->debug.fwlog_open)
-		return -EBUSY;
-
-	ar->debug.fwlog_open = true;
-
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static int ath6kl_fwlog_release(struct inode *inode, struct file *file)
-{
-	struct ath6kl *ar = inode->i_private;
-
-	ar->debug.fwlog_open = false;
-
-	return 0;
-}
-
-static ssize_t ath6kl_fwlog_read(struct file *file, char __user *user_buf,
-				 size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct sk_buff *skb;
-	ssize_t ret_cnt;
-	size_t len = 0;
-	char *buf;
-
-	buf = vmalloc(count);
-	if (!buf)
-		return -ENOMEM;
-
-	/* read undelivered logs from firmware */
-	ath6kl_read_fwlogs(ar);
-
-	spin_lock(&ar->debug.fwlog_queue.lock);
-
-	while ((skb = __skb_dequeue(&ar->debug.fwlog_queue))) {
-		if (skb->len > count - len) {
-			/* not enough space, put skb back and leave */
-			__skb_queue_head(&ar->debug.fwlog_queue, skb);
-			break;
-		}
-
-
-		memcpy(buf + len, skb->data, skb->len);
-		len += skb->len;
-
-		kfree_skb(skb);
-	}
-
-	spin_unlock(&ar->debug.fwlog_queue.lock);
-
-	/* FIXME: what to do if len == 0? */
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-
-	vfree(buf);
-
-	return ret_cnt;
-}
-
-static const struct file_operations fops_fwlog = {
-	.open = ath6kl_fwlog_open,
-	.release = ath6kl_fwlog_release,
-	.read = ath6kl_fwlog_read,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_fwlog_block_read(struct file *file,
-				       char __user *user_buf,
-				       size_t count,
-				       loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct sk_buff *skb;
-	ssize_t ret_cnt;
-	size_t len = 0, not_copied;
-	char *buf;
-	int ret;
-
-	buf = vmalloc(count);
-	if (!buf)
-		return -ENOMEM;
-
-	spin_lock(&ar->debug.fwlog_queue.lock);
-
-	if (skb_queue_len(&ar->debug.fwlog_queue) == 0) {
-		/* we must init under queue lock */
-		init_completion(&ar->debug.fwlog_completion);
-
-		spin_unlock(&ar->debug.fwlog_queue.lock);
-
-		ret = wait_for_completion_interruptible(
-			&ar->debug.fwlog_completion);
-		if (ret == -ERESTARTSYS) {
-			vfree(buf);
-			return ret;
-		}
-
-		spin_lock(&ar->debug.fwlog_queue.lock);
-	}
-
-	while ((skb = __skb_dequeue(&ar->debug.fwlog_queue))) {
-		if (skb->len > count - len) {
-			/* not enough space, put skb back and leave */
-			__skb_queue_head(&ar->debug.fwlog_queue, skb);
-			break;
-		}
-
-
-		memcpy(buf + len, skb->data, skb->len);
-		len += skb->len;
-
-		kfree_skb(skb);
-	}
-
-	spin_unlock(&ar->debug.fwlog_queue.lock);
-
-	/* FIXME: what to do if len == 0? */
-
-	not_copied = copy_to_user(user_buf, buf, len);
-	if (not_copied != 0) {
-		ret_cnt = -EFAULT;
-		goto out;
-	}
-
-	*ppos = *ppos + len;
-
-	ret_cnt = len;
-
-out:
-	vfree(buf);
-
-	return ret_cnt;
-}
-
-static const struct file_operations fops_fwlog_block = {
-	.open = ath6kl_fwlog_open,
-	.release = ath6kl_fwlog_release,
-	.read = ath6kl_fwlog_block_read,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_fwlog_mask_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[16];
-	int len;
-
-	len = snprintf(buf, sizeof(buf), "0x%x\n", ar->debug.fwlog_mask);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_fwlog_mask_write(struct file *file,
-				       const char __user *user_buf,
-				       size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-
-	ret = kstrtou32_from_user(user_buf, count, 0, &ar->debug.fwlog_mask);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_wmi_config_debug_module_cmd(ar->wmi,
-						 ATH6KL_FWLOG_VALID_MASK,
-						 ar->debug.fwlog_mask);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static const struct file_operations fops_fwlog_mask = {
-	.open = ath6kl_debugfs_open,
-	.read = ath6kl_fwlog_mask_read,
-	.write = ath6kl_fwlog_mask_write,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t read_file_tgt_stats(struct file *file, char __user *user_buf,
-				   size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	struct target_stats *tgt_stats;
-	char *buf;
-	unsigned int len = 0, buf_len = 1500;
-	int i;
-	long left;
-	ssize_t ret_cnt;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	tgt_stats = &vif->target_stats;
-
-	buf = kzalloc(buf_len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (down_interruptible(&ar->sem)) {
-		kfree(buf);
-		return -EBUSY;
-	}
-
-	set_bit(STATS_UPDATE_PEND, &vif->flags);
-
-	if (ath6kl_wmi_get_stats_cmd(ar->wmi, 0)) {
-		up(&ar->sem);
-		kfree(buf);
-		return -EIO;
-	}
-
-	left = wait_event_interruptible_timeout(ar->event_wq,
-						!test_bit(STATS_UPDATE_PEND,
-						&vif->flags), WMI_TIMEOUT);
-
-	up(&ar->sem);
-
-	if (left <= 0) {
-		kfree(buf);
-		return -ETIMEDOUT;
-	}
-
-	len += scnprintf(buf + len, buf_len - len, "\n");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "Target Tx stats");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n\n",
-			 "=================");
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Ucast packets", tgt_stats->tx_ucast_pkt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Bcast packets", tgt_stats->tx_bcast_pkt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Ucast byte", tgt_stats->tx_ucast_byte);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Bcast byte", tgt_stats->tx_bcast_byte);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Rts success cnt", tgt_stats->tx_rts_success_cnt);
-	for (i = 0; i < 4; i++)
-		len += scnprintf(buf + len, buf_len - len,
-				 "%18s %d %10llu\n", "PER on ac",
-				 i, tgt_stats->tx_pkt_per_ac[i]);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Error", tgt_stats->tx_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Fail count", tgt_stats->tx_fail_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Retry count", tgt_stats->tx_retry_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Multi retry cnt", tgt_stats->tx_mult_retry_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Rts fail cnt", tgt_stats->tx_rts_fail_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%25s %10llu\n\n",
-			 "TKIP counter measure used",
-			 tgt_stats->tkip_cnter_measures_invoked);
-
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "Target Rx stats");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "=================");
-
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Ucast packets", tgt_stats->rx_ucast_pkt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10d\n",
-			 "Ucast Rate", tgt_stats->rx_ucast_rate);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Bcast packets", tgt_stats->rx_bcast_pkt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Ucast byte", tgt_stats->rx_ucast_byte);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Bcast byte", tgt_stats->rx_bcast_byte);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Fragmented pkt", tgt_stats->rx_frgment_pkt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Error", tgt_stats->rx_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "CRC Err", tgt_stats->rx_crc_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Key chache miss", tgt_stats->rx_key_cache_miss);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Decrypt Err", tgt_stats->rx_decrypt_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Duplicate frame", tgt_stats->rx_dupl_frame);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Tkip Mic failure", tgt_stats->tkip_local_mic_fail);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "TKIP format err", tgt_stats->tkip_fmt_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "CCMP format Err", tgt_stats->ccmp_fmt_err);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n\n",
-			 "CCMP Replay Err", tgt_stats->ccmp_replays);
-
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "Misc Target stats");
-	len += scnprintf(buf + len, buf_len - len, "%25s\n",
-			 "=================");
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Beacon Miss count", tgt_stats->cs_bmiss_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Num Connects", tgt_stats->cs_connect_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10llu\n",
-			 "Num disconnects", tgt_stats->cs_discon_cnt);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10d\n",
-			 "Beacon avg rssi", tgt_stats->cs_ave_beacon_rssi);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10d\n",
-			 "ARP pkt received", tgt_stats->arp_received);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10d\n",
-			 "ARP pkt matched", tgt_stats->arp_matched);
-	len += scnprintf(buf + len, buf_len - len, "%20s %10d\n",
-			 "ARP pkt replied", tgt_stats->arp_replied);
-
-	if (len > buf_len)
-		len = buf_len;
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-
-	kfree(buf);
-	return ret_cnt;
-}
-
-static const struct file_operations fops_tgt_stats = {
-	.read = read_file_tgt_stats,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-#define print_credit_info(fmt_str, ep_list_field)		\
-	(len += scnprintf(buf + len, buf_len - len, fmt_str,	\
-			 ep_list->ep_list_field))
-#define CREDIT_INFO_DISPLAY_STRING_LEN	200
-#define CREDIT_INFO_LEN	128
-
-static ssize_t read_file_credit_dist_stats(struct file *file,
-					   char __user *user_buf,
-					   size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct htc_target *target = ar->htc_target;
-	struct htc_endpoint_credit_dist *ep_list;
-	char *buf;
-	unsigned int buf_len, len = 0;
-	ssize_t ret_cnt;
-
-	buf_len = CREDIT_INFO_DISPLAY_STRING_LEN +
-		  get_queue_depth(&target->cred_dist_list) * CREDIT_INFO_LEN;
-	buf = kzalloc(buf_len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	len += scnprintf(buf + len, buf_len - len, "%25s%5d\n",
-			 "Total Avail Credits: ",
-			 target->credit_info->total_avail_credits);
-	len += scnprintf(buf + len, buf_len - len, "%25s%5d\n",
-			 "Free credits :",
-			 target->credit_info->cur_free_credits);
-
-	len += scnprintf(buf + len, buf_len - len,
-			 " Epid  Flags    Cred_norm  Cred_min  Credits  Cred_assngd"
-			 "  Seek_cred  Cred_sz  Cred_per_msg  Cred_to_dist"
-			 "  qdepth\n");
-
-	list_for_each_entry(ep_list, &target->cred_dist_list, list) {
-		print_credit_info("  %2d", endpoint);
-		print_credit_info("%10x", dist_flags);
-		print_credit_info("%8d", cred_norm);
-		print_credit_info("%9d", cred_min);
-		print_credit_info("%9d", credits);
-		print_credit_info("%10d", cred_assngd);
-		print_credit_info("%13d", seek_cred);
-		print_credit_info("%12d", cred_sz);
-		print_credit_info("%9d", cred_per_msg);
-		print_credit_info("%14d", cred_to_dist);
-		len += scnprintf(buf + len, buf_len - len, "%12d\n",
-				 get_queue_depth(&ep_list->htc_ep->txq));
-	}
-
-	if (len > buf_len)
-		len = buf_len;
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-	kfree(buf);
-	return ret_cnt;
-}
-
-static const struct file_operations fops_credit_dist_stats = {
-	.read = read_file_credit_dist_stats,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static unsigned int print_endpoint_stat(struct htc_target *target, char *buf,
-					unsigned int buf_len, unsigned int len,
-					int offset, const char *name)
-{
-	int i;
-	struct htc_endpoint_stats *ep_st;
-	u32 *counter;
-
-	len += scnprintf(buf + len, buf_len - len, "%s:", name);
-	for (i = 0; i < ENDPOINT_MAX; i++) {
-		ep_st = &target->endpoint[i].ep_st;
-		counter = ((u32 *) ep_st) + (offset / 4);
-		len += scnprintf(buf + len, buf_len - len, " %u", *counter);
-	}
-	len += scnprintf(buf + len, buf_len - len, "\n");
-
-	return len;
-}
-
-static ssize_t ath6kl_endpoint_stats_read(struct file *file,
-					  char __user *user_buf,
-					  size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct htc_target *target = ar->htc_target;
-	char *buf;
-	unsigned int buf_len, len = 0;
-	ssize_t ret_cnt;
-
-	buf_len = sizeof(struct htc_endpoint_stats) / sizeof(u32) *
-		(25 + ENDPOINT_MAX * 11);
-	buf = kmalloc(buf_len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-#define EPSTAT(name)							\
-	len = print_endpoint_stat(target, buf, buf_len, len,		\
-				  offsetof(struct htc_endpoint_stats, name), \
-				  #name)
-	EPSTAT(cred_low_indicate);
-	EPSTAT(tx_issued);
-	EPSTAT(tx_pkt_bundled);
-	EPSTAT(tx_bundles);
-	EPSTAT(tx_dropped);
-	EPSTAT(tx_cred_rpt);
-	EPSTAT(cred_rpt_from_rx);
-	EPSTAT(cred_rpt_from_other);
-	EPSTAT(cred_rpt_ep0);
-	EPSTAT(cred_from_rx);
-	EPSTAT(cred_from_other);
-	EPSTAT(cred_from_ep0);
-	EPSTAT(cred_cosumd);
-	EPSTAT(cred_retnd);
-	EPSTAT(rx_pkts);
-	EPSTAT(rx_lkahds);
-	EPSTAT(rx_bundl);
-	EPSTAT(rx_bundle_lkahd);
-	EPSTAT(rx_bundle_from_hdr);
-	EPSTAT(rx_alloc_thresh_hit);
-	EPSTAT(rxalloc_thresh_byte);
-#undef EPSTAT
-
-	if (len > buf_len)
-		len = buf_len;
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-	kfree(buf);
-	return ret_cnt;
-}
-
-static ssize_t ath6kl_endpoint_stats_write(struct file *file,
-					   const char __user *user_buf,
-					   size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct htc_target *target = ar->htc_target;
-	int ret, i;
-	u32 val;
-	struct htc_endpoint_stats *ep_st;
-
-	ret = kstrtou32_from_user(user_buf, count, 0, &val);
-	if (ret)
-		return ret;
-	if (val == 0) {
-		for (i = 0; i < ENDPOINT_MAX; i++) {
-			ep_st = &target->endpoint[i].ep_st;
-			memset(ep_st, 0, sizeof(*ep_st));
-		}
-	}
-
-	return count;
-}
-
-static const struct file_operations fops_endpoint_stats = {
-	.open = ath6kl_debugfs_open,
-	.read = ath6kl_endpoint_stats_read,
-	.write = ath6kl_endpoint_stats_write,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static unsigned long ath6kl_get_num_reg(void)
-{
-	int i;
-	unsigned long n_reg = 0;
-
-	for (i = 0; i < ARRAY_SIZE(diag_reg); i++)
-		n_reg = n_reg +
-		     (diag_reg[i].reg_end - diag_reg[i].reg_start) / 4 + 1;
-
-	return n_reg;
-}
-
-static bool ath6kl_dbg_is_diag_reg_valid(u32 reg_addr)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(diag_reg); i++) {
-		if (reg_addr >= diag_reg[i].reg_start &&
-		    reg_addr <= diag_reg[i].reg_end)
-			return true;
-	}
-
-	return false;
-}
-
-static ssize_t ath6kl_regread_read(struct file *file, char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u8 buf[50];
-	unsigned int len = 0;
-
-	if (ar->debug.dbgfs_diag_reg)
-		len += scnprintf(buf + len, sizeof(buf) - len, "0x%x\n",
-				ar->debug.dbgfs_diag_reg);
-	else
-		len += scnprintf(buf + len, sizeof(buf) - len,
-				 "All diag registers\n");
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_regread_write(struct file *file,
-				    const char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u8 buf[50];
-	unsigned int len;
-	unsigned long reg_addr;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	buf[len] = '\0';
-
-	if (strict_strtoul(buf, 0, &reg_addr))
-		return -EINVAL;
-
-	if ((reg_addr % 4) != 0)
-		return -EINVAL;
-
-	if (reg_addr && !ath6kl_dbg_is_diag_reg_valid(reg_addr))
-		return -EINVAL;
-
-	ar->debug.dbgfs_diag_reg = reg_addr;
-
-	return count;
-}
-
-static const struct file_operations fops_diag_reg_read = {
-	.read = ath6kl_regread_read,
-	.write = ath6kl_regread_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static int ath6kl_regdump_open(struct inode *inode, struct file *file)
-{
-	struct ath6kl *ar = inode->i_private;
-	u8 *buf;
-	unsigned long int reg_len;
-	unsigned int len = 0, n_reg;
-	u32 addr;
-	__le32 reg_val;
-	int i, status;
-
-	/* Dump all the registers if no register is specified */
-	if (!ar->debug.dbgfs_diag_reg)
-		n_reg = ath6kl_get_num_reg();
-	else
-		n_reg = 1;
-
-	reg_len = n_reg * REG_OUTPUT_LEN_PER_LINE;
-	if (n_reg > 1)
-		reg_len += REGTYPE_STR_LEN;
-
-	buf = vmalloc(reg_len);
-	if (!buf)
-		return -ENOMEM;
-
-	if (n_reg == 1) {
-		addr = ar->debug.dbgfs_diag_reg;
-
-		status = ath6kl_diag_read32(ar,
-				TARG_VTOP(ar->target_type, addr),
-				(u32 *)&reg_val);
-		if (status)
-			goto fail_reg_read;
-
-		len += scnprintf(buf + len, reg_len - len,
-				 "0x%06x 0x%08x\n", addr, le32_to_cpu(reg_val));
-		goto done;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(diag_reg); i++) {
-		len += scnprintf(buf + len, reg_len - len,
-				"%s\n", diag_reg[i].reg_info);
-		for (addr = diag_reg[i].reg_start;
-		     addr <= diag_reg[i].reg_end; addr += 4) {
-			status = ath6kl_diag_read32(ar,
-					TARG_VTOP(ar->target_type, addr),
-					(u32 *)&reg_val);
-			if (status)
-				goto fail_reg_read;
-
-			len += scnprintf(buf + len, reg_len - len,
-					"0x%06x 0x%08x\n",
-					addr, le32_to_cpu(reg_val));
-		}
-	}
-
-done:
-	file->private_data = buf;
-	return 0;
-
-fail_reg_read:
-	ath6kl_warn("Unable to read memory:%u\n", addr);
-	vfree(buf);
-	return -EIO;
-}
-
-static ssize_t ath6kl_regdump_read(struct file *file, char __user *user_buf,
-				  size_t count, loff_t *ppos)
-{
-	u8 *buf = file->private_data;
-	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
-}
-
-static int ath6kl_regdump_release(struct inode *inode, struct file *file)
-{
-	vfree(file->private_data);
-	return 0;
-}
-
-static const struct file_operations fops_reg_dump = {
-	.open = ath6kl_regdump_open,
-	.read = ath6kl_regdump_read,
-	.release = ath6kl_regdump_release,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_lrssi_roam_write(struct file *file,
-				       const char __user *user_buf,
-				       size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	unsigned long lrssi_roam_threshold;
-	char buf[32];
-	ssize_t len;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	buf[len] = '\0';
-	if (strict_strtoul(buf, 0, &lrssi_roam_threshold))
-		return -EINVAL;
-
-	ar->lrssi_roam_threshold = lrssi_roam_threshold;
-
-	ath6kl_wmi_set_roam_lrssi_cmd(ar->wmi, ar->lrssi_roam_threshold);
-
-	return count;
-}
-
-static ssize_t ath6kl_lrssi_roam_read(struct file *file,
-				      char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[32];
-	unsigned int len;
-
-	len = snprintf(buf, sizeof(buf), "%u\n", ar->lrssi_roam_threshold);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static const struct file_operations fops_lrssi_roam_threshold = {
-	.read = ath6kl_lrssi_roam_read,
-	.write = ath6kl_lrssi_roam_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_regwrite_read(struct file *file,
-				    char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u8 buf[32];
-	unsigned int len = 0;
-
-	len = scnprintf(buf, sizeof(buf), "Addr: 0x%x Val: 0x%x\n",
-			ar->debug.diag_reg_addr_wr, ar->debug.diag_reg_val_wr);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_regwrite_write(struct file *file,
-				     const char __user *user_buf,
-				     size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[32];
-	char *sptr, *token;
-	unsigned int len = 0;
-	u32 reg_addr, reg_val;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	buf[len] = '\0';
-	sptr = buf;
-
-	token = strsep(&sptr, "=");
-	if (!token)
-		return -EINVAL;
-
-	if (kstrtou32(token, 0, &reg_addr))
-		return -EINVAL;
-
-	if (!ath6kl_dbg_is_diag_reg_valid(reg_addr))
-		return -EINVAL;
-
-	if (kstrtou32(sptr, 0, &reg_val))
-		return -EINVAL;
-
-	ar->debug.diag_reg_addr_wr = reg_addr;
-	ar->debug.diag_reg_val_wr = reg_val;
-
-	if (ath6kl_diag_write32(ar, ar->debug.diag_reg_addr_wr,
-				cpu_to_le32(ar->debug.diag_reg_val_wr)))
-		return -EIO;
-
-	return count;
-}
-
-static const struct file_operations fops_diag_reg_write = {
-	.read = ath6kl_regwrite_read,
-	.write = ath6kl_regwrite_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-int ath6kl_debug_roam_tbl_event(struct ath6kl *ar, const void *buf,
-				size_t len)
-{
-	const struct wmi_target_roam_tbl *tbl;
-	u16 num_entries;
-
-	if (len < sizeof(*tbl))
-		return -EINVAL;
-
-	tbl = (const struct wmi_target_roam_tbl *) buf;
-	num_entries = le16_to_cpu(tbl->num_entries);
-	if (sizeof(*tbl) + num_entries * sizeof(struct wmi_bss_roam_info) >
-	    len)
-		return -EINVAL;
-
-	if (ar->debug.roam_tbl == NULL ||
-	    ar->debug.roam_tbl_len < (unsigned int) len) {
-		kfree(ar->debug.roam_tbl);
-		ar->debug.roam_tbl = kmalloc(len, GFP_ATOMIC);
-		if (ar->debug.roam_tbl == NULL)
-			return -ENOMEM;
-	}
-
-	memcpy(ar->debug.roam_tbl, buf, len);
-	ar->debug.roam_tbl_len = len;
-
-	if (test_bit(ROAM_TBL_PEND, &ar->flag)) {
-		clear_bit(ROAM_TBL_PEND, &ar->flag);
-		wake_up(&ar->event_wq);
-	}
-
-	return 0;
-}
-
-static ssize_t ath6kl_roam_table_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-	long left;
-	struct wmi_target_roam_tbl *tbl;
-	u16 num_entries, i;
-	char *buf;
-	unsigned int len, buf_len;
-	ssize_t ret_cnt;
-
-	if (down_interruptible(&ar->sem))
-		return -EBUSY;
-
-	set_bit(ROAM_TBL_PEND, &ar->flag);
-
-	ret = ath6kl_wmi_get_roam_tbl_cmd(ar->wmi);
-	if (ret) {
-		up(&ar->sem);
-		return ret;
-	}
-
-	left = wait_event_interruptible_timeout(
-		ar->event_wq, !test_bit(ROAM_TBL_PEND, &ar->flag), WMI_TIMEOUT);
-	up(&ar->sem);
-
-	if (left <= 0)
-		return -ETIMEDOUT;
-
-	if (ar->debug.roam_tbl == NULL)
-		return -ENOMEM;
-
-	tbl = (struct wmi_target_roam_tbl *) ar->debug.roam_tbl;
-	num_entries = le16_to_cpu(tbl->num_entries);
-
-	buf_len = 100 + num_entries * 100;
-	buf = kzalloc(buf_len, GFP_KERNEL);
-	if (buf == NULL)
-		return -ENOMEM;
-	len = 0;
-	len += scnprintf(buf + len, buf_len - len,
-			 "roam_mode=%u\n\n"
-			 "# roam_util bssid rssi rssidt last_rssi util bias\n",
-			 le16_to_cpu(tbl->roam_mode));
-
-	for (i = 0; i < num_entries; i++) {
-		struct wmi_bss_roam_info *info = &tbl->info[i];
-		len += scnprintf(buf + len, buf_len - len,
-				 "%d %pM %d %d %d %d %d\n",
-				 a_sle32_to_cpu(info->roam_util), info->bssid,
-				 info->rssi, info->rssidt, info->last_rssi,
-				 info->util, info->bias);
-	}
-
-	if (len > buf_len)
-		len = buf_len;
-
-	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-
-	kfree(buf);
-	return ret_cnt;
-}
-
-static const struct file_operations fops_roam_table = {
-	.read = ath6kl_roam_table_read,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_force_roam_write(struct file *file,
-				       const char __user *user_buf,
-				       size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-	char buf[20];
-	size_t len;
-	u8 bssid[ETH_ALEN];
-	int i;
-	int addr[ETH_ALEN];
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-
-	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
-		   &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5])
-	    != ETH_ALEN)
-		return -EINVAL;
-	for (i = 0; i < ETH_ALEN; i++)
-		bssid[i] = addr[i];
-
-	ret = ath6kl_wmi_force_roam_cmd(ar->wmi, bssid);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static const struct file_operations fops_force_roam = {
-	.write = ath6kl_force_roam_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_roam_mode_write(struct file *file,
-				      const char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-	char buf[20];
-	size_t len;
-	enum wmi_roam_mode mode;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-	if (len > 0 && buf[len - 1] == '\n')
-		buf[len - 1] = '\0';
-
-	if (strcasecmp(buf, "default") == 0)
-		mode = WMI_DEFAULT_ROAM_MODE;
-	else if (strcasecmp(buf, "bssbias") == 0)
-		mode = WMI_HOST_BIAS_ROAM_MODE;
-	else if (strcasecmp(buf, "lock") == 0)
-		mode = WMI_LOCK_BSS_MODE;
-	else
-		return -EINVAL;
-
-	ret = ath6kl_wmi_set_roam_mode_cmd(ar->wmi, mode);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static const struct file_operations fops_roam_mode = {
-	.write = ath6kl_roam_mode_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-void ath6kl_debug_set_keepalive(struct ath6kl *ar, u8 keepalive)
-{
-	ar->debug.keepalive = keepalive;
-}
-
-static ssize_t ath6kl_keepalive_read(struct file *file, char __user *user_buf,
-				     size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[16];
-	int len;
-
-	len = snprintf(buf, sizeof(buf), "%u\n", ar->debug.keepalive);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_keepalive_write(struct file *file,
-				      const char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-	u8 val;
-
-	ret = kstrtou8_from_user(user_buf, count, 0, &val);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_wmi_set_keepalive_cmd(ar->wmi, 0, val);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static const struct file_operations fops_keepalive = {
-	.open = ath6kl_debugfs_open,
-	.read = ath6kl_keepalive_read,
-	.write = ath6kl_keepalive_write,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-void ath6kl_debug_set_disconnect_timeout(struct ath6kl *ar, u8 timeout)
-{
-	ar->debug.disc_timeout = timeout;
-}
-
-static ssize_t ath6kl_disconnect_timeout_read(struct file *file,
-					      char __user *user_buf,
-					      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[16];
-	int len;
-
-	len = snprintf(buf, sizeof(buf), "%u\n", ar->debug.disc_timeout);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_disconnect_timeout_write(struct file *file,
-					       const char __user *user_buf,
-					       size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	int ret;
-	u8 val;
-
-	ret = kstrtou8_from_user(user_buf, count, 0, &val);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_wmi_disctimeout_cmd(ar->wmi, 0, val);
-	if (ret)
-		return ret;
-
-	return count;
-}
-
-static const struct file_operations fops_disconnect_timeout = {
-	.open = ath6kl_debugfs_open,
-	.read = ath6kl_disconnect_timeout_read,
-	.write = ath6kl_disconnect_timeout_write,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_create_qos_write(struct file *file,
-						const char __user *user_buf,
-						size_t count, loff_t *ppos)
-{
-
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	char buf[200];
-	ssize_t len;
-	char *sptr, *token;
-	struct wmi_create_pstream_cmd pstream;
-	u32 val32;
-	u16 val16;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-	sptr = buf;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.user_pri))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.traffic_direc))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.traffic_class))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.traffic_type))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.voice_psc_cap))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.min_service_int = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.max_service_int = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.inactivity_int = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.suspension_int = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.service_start_time = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &pstream.tsid))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &val16))
-		return -EINVAL;
-	pstream.nominal_msdu = cpu_to_le16(val16);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &val16))
-		return -EINVAL;
-	pstream.max_msdu = cpu_to_le16(val16);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.min_data_rate = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.mean_data_rate = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.peak_data_rate = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.max_burst_size = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.delay_bound = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.min_phy_rate = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.sba = cpu_to_le32(val32);
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou32(token, 0, &val32))
-		return -EINVAL;
-	pstream.medium_time = cpu_to_le32(val32);
-
-	pstream.nominal_phy = ((le32_to_cpu(pstream.min_phy_rate) / 1000) / 1000);
-
-	ath6kl_wmi_create_pstream_cmd(ar->wmi, vif->fw_vif_idx, &pstream);
-
-	return count;
-}
-
-static const struct file_operations fops_create_qos = {
-	.write = ath6kl_create_qos_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_delete_qos_write(struct file *file,
-				const char __user *user_buf,
-				size_t count, loff_t *ppos)
-{
-
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	char buf[100];
-	ssize_t len;
-	char *sptr, *token;
-	u8 traffic_class;
-	u8 tsid;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-	sptr = buf;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &traffic_class))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou8(token, 0, &tsid))
-		return -EINVAL;
-
-	ath6kl_wmi_delete_pstream_cmd(ar->wmi, vif->fw_vif_idx,
-				      traffic_class, tsid);
-
-	return count;
-}
-
-static const struct file_operations fops_delete_qos = {
-	.write = ath6kl_delete_qos_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_bgscan_int_write(struct file *file,
-				const char __user *user_buf,
-				size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	u16 bgscan_int;
-	char buf[32];
-	ssize_t len;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	buf[len] = '\0';
-	if (kstrtou16(buf, 0, &bgscan_int))
-		return -EINVAL;
-
-	if (bgscan_int == 0)
-		bgscan_int = 0xffff;
-
-	vif->bg_scan_period = bgscan_int;
-
-	ath6kl_wmi_scanparams_cmd(ar->wmi, 0, 0, 0, bgscan_int, 0, 0, 0, 3,
-				  vif->scan_ctrl_flag, 0, 0);
-
-	return count;
-}
-
-static const struct file_operations fops_bgscan_int = {
-	.write = ath6kl_bgscan_int_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_listen_int_write(struct file *file,
-				       const char __user *user_buf,
-				       size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	u16 listen_interval;
-	char buf[32];
-	ssize_t len;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	buf[len] = '\0';
-	if (kstrtou16(buf, 0, &listen_interval))
-		return -EINVAL;
-
-	if ((listen_interval < 15) || (listen_interval > 3000))
-		return -EINVAL;
-
-	vif->listen_intvl_t = listen_interval;
-	ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,
-				      vif->listen_intvl_t, 0);
-
-	return count;
-}
-
-static ssize_t ath6kl_listen_int_read(struct file *file,
-				      char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	char buf[32];
-	int len;
-
-	vif = ath6kl_vif_first(ar);
-	if (!vif)
-		return -EIO;
-
-	len = scnprintf(buf, sizeof(buf), "%u\n", vif->listen_intvl_t);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static const struct file_operations fops_listen_int = {
-	.read = ath6kl_listen_int_read,
-	.write = ath6kl_listen_int_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_power_params_write(struct file *file,
-						const char __user *user_buf,
-						size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u8 buf[100];
-	unsigned int len = 0;
-	char *sptr, *token;
-	u16 idle_period, ps_poll_num, dtim,
-		tx_wakeup, num_tx;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-	sptr = buf;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &idle_period))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &ps_poll_num))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &dtim))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &tx_wakeup))
-		return -EINVAL;
-
-	token = strsep(&sptr, " ");
-	if (!token)
-		return -EINVAL;
-	if (kstrtou16(token, 0, &num_tx))
-		return -EINVAL;
-
-	ath6kl_wmi_pmparams_cmd(ar->wmi, 0, idle_period, ps_poll_num,
-				dtim, tx_wakeup, num_tx, 0);
-
-	return count;
-}
-
-static const struct file_operations fops_power_params = {
-	.write = ath6kl_power_params_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-int ath6kl_debug_init(struct ath6kl *ar)
-{
-	skb_queue_head_init(&ar->debug.fwlog_queue);
-	init_completion(&ar->debug.fwlog_completion);
-
-	/*
-	 * Actually we are lying here but don't know how to read the mask
-	 * value from the firmware.
-	 */
-	ar->debug.fwlog_mask = 0;
-
-	ar->debugfs_phy = debugfs_create_dir("ath6kl",
-					     ar->wiphy->debugfsdir);
-	if (!ar->debugfs_phy)
-		return -ENOMEM;
-
-	debugfs_create_file("tgt_stats", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_tgt_stats);
-
-	debugfs_create_file("credit_dist_stats", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_credit_dist_stats);
-
-	debugfs_create_file("endpoint_stats", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_endpoint_stats);
-
-	debugfs_create_file("fwlog", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_fwlog);
-
-	debugfs_create_file("fwlog_block", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_fwlog_block);
-
-	debugfs_create_file("fwlog_mask", S_IRUSR | S_IWUSR, ar->debugfs_phy,
-			    ar, &fops_fwlog_mask);
-
-	debugfs_create_file("reg_addr", S_IRUSR | S_IWUSR, ar->debugfs_phy, ar,
-			    &fops_diag_reg_read);
-
-	debugfs_create_file("reg_dump", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_reg_dump);
-
-	debugfs_create_file("lrssi_roam_threshold", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_lrssi_roam_threshold);
-
-	debugfs_create_file("reg_write", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_diag_reg_write);
-
-	debugfs_create_file("war_stats", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_war_stats);
-
-	debugfs_create_file("roam_table", S_IRUSR, ar->debugfs_phy, ar,
-			    &fops_roam_table);
-
-	debugfs_create_file("force_roam", S_IWUSR, ar->debugfs_phy, ar,
-			    &fops_force_roam);
-
-	debugfs_create_file("roam_mode", S_IWUSR, ar->debugfs_phy, ar,
-			    &fops_roam_mode);
-
-	debugfs_create_file("keepalive", S_IRUSR | S_IWUSR, ar->debugfs_phy, ar,
-			    &fops_keepalive);
-
-	debugfs_create_file("disconnect_timeout", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_disconnect_timeout);
-
-	debugfs_create_file("create_qos", S_IWUSR, ar->debugfs_phy, ar,
-				&fops_create_qos);
-
-	debugfs_create_file("delete_qos", S_IWUSR, ar->debugfs_phy, ar,
-				&fops_delete_qos);
-
-	debugfs_create_file("bgscan_interval", S_IWUSR,
-				ar->debugfs_phy, ar, &fops_bgscan_int);
-
-	debugfs_create_file("listen_interval", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_listen_int);
-
-	debugfs_create_file("power_params", S_IWUSR, ar->debugfs_phy, ar,
-						&fops_power_params);
-
-	return ath6kl_init_debugfs_pri(ar);
-}
-
-void ath6kl_debug_cleanup(struct ath6kl *ar)
-{
-	skb_queue_purge(&ar->debug.fwlog_queue);
-	kfree(ar->debug.roam_tbl);
-}
-
-#endif
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.h
index 65f2a33..670dbe8 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debug.h
@@ -44,7 +44,6 @@ enum ATH6K_DEBUG_MASK {
 	ATH6KL_DBG_SUSPEND	= BIT(20),
 	ATH6KL_DBG_USB		= BIT(21),
 	ATH6KL_DBG_RECOVERY	= BIT(22),
-	ATH6KL_DBG_STACK_DUMP	= BIT(23),
 	ATH6KL_DBG_ANY	        = 0xffffffff  /* enable all logs */
 };
 
@@ -99,7 +98,8 @@ int ath6kl_debug_roam_tbl_event(struct ath6kl *ar, const void *buf,
 				size_t len);
 void ath6kl_debug_set_keepalive(struct ath6kl *ar, u8 keepalive);
 void ath6kl_debug_set_disconnect_timeout(struct ath6kl *ar, u8 timeout);
-int ath6kl_debug_init(struct ath6kl *ar);
+void ath6kl_debug_init(struct ath6kl *ar);
+int ath6kl_debug_init_fs(struct ath6kl *ar);
 void ath6kl_debug_cleanup(struct ath6kl *ar);
 
 #else
@@ -149,7 +149,11 @@ static inline void ath6kl_debug_set_disconnect_timeout(struct ath6kl *ar,
 {
 }
 
-static inline int ath6kl_debug_init(struct ath6kl *ar)
+static inline void ath6kl_debug_init(struct ath6kl *ar)
+{
+}
+
+static inline int ath6kl_debug_init_fs(struct ath6kl *ar)
 {
 	return 0;
 }
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.c
index 79a4746..2912c64 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.c
@@ -14,8 +14,6 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#ifdef CONFIG_ATH6KL_DEBUG
-
 #include <linux/skbuff.h>
 #include <linux/export.h>
 #include "core.h"
@@ -23,6 +21,8 @@
 #include "debug.h"
 #include "debugfs_pri.h"
 
+#ifdef CONFIG_ATH6KL_DEBUG
+
 struct wmi_set_inact_period_cmd {
 	__le32 inact_period;
 	u8 num_null_func;
@@ -113,6 +113,9 @@ static ssize_t ath6kl_inact_period_write(struct file *file,
 	u32 inact_period;
 	size_t len;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	len = min(count, sizeof(buf) - 1);
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;
@@ -146,6 +149,9 @@ static ssize_t ath6kl_bmisstime_write(struct file *file,
 	char buf[32];
 	ssize_t len;
 
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
 	vif = ath6kl_vif_first(ar);
 	if (!vif)
 		return -EIO;
@@ -195,6 +201,208 @@ static const struct file_operations fops_bmisstime = {
 	.llseek = default_llseek,
 };
 
+static ssize_t ath6kl_max_num_sta_write(struct file *file,
+				      const char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ath6kl *ar = file->private_data;
+	int ret;
+	u8 val;
+
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
+	ret = kstrtou8_from_user(user_buf, count, 0, &val);
+	if (ret)
+		return ret;
+
+	ret = ath6kl_wmi_ap_set_num_sta(ar->wmi, 0, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static const struct file_operations fops_max_num_sta = {
+	.open = ath6kl_debugfs_open_pri,
+	.write = ath6kl_max_num_sta_write,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath6kl_tp_track_write(struct file *file,
+				      const char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ath6kl_tp_ctl tp_ctl;
+	struct ath6kl *ar = file->private_data;
+	char *sptr, *token;
+	char buf[200];
+	ssize_t len;
+	u32 val32;
+
+	len = min(count, sizeof(buf) - 1);
+
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+	sptr = buf;
+
+	token = strsep(&sptr, " ");
+	if (!token)
+		return -EINVAL;
+
+	if (kstrtou32(token, 0, &val32))
+		return -EINVAL;
+	tp_ctl.thr_type = (unsigned int)(val32);
+
+	token = strsep(&sptr, " ");
+	if (!token)
+		return -EINVAL;
+	if (kstrtou32(token, 0, &val32))
+		return -EINVAL;
+	tp_ctl.thr_a = (unsigned long)(val32);
+
+	token = strsep(&sptr, " ");
+	if (!token)
+		return -EINVAL;
+	if (kstrtou32(token, 0, &val32))
+		return -EINVAL;
+	tp_ctl.thr_b = (unsigned long)(val32);
+
+	token = strsep(&sptr, " ");
+	if (!token)
+		return -EINVAL;
+	if (kstrtou32(token, 0, &val32))
+		return -EINVAL;
+	tp_ctl.thr_c = (unsigned long)(val32);
+
+	ath6kl_tp_cfg(ar, ar->tp_ctl.interval_s, tp_ctl.thr_type,
+		      tp_ctl.thr_a, tp_ctl.thr_b, tp_ctl.thr_c);
+
+	return len;
+}
+
+static ssize_t ath6kl_tp_track_read(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ath6kl *ar = file->private_data;
+	struct ath6kl_tp_ctl *tp_ctl = &ar->tp_ctl;
+	char buf[200];
+	unsigned int len = 0, buf_len = 0;
+	ssize_t ret_cnt;
+
+	buf_len = sizeof(buf)-1;
+	len += scnprintf(buf + len, buf_len - len, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "%d %ld %ld %ld\n",
+			 tp_ctl->thr_type, tp_ctl->thr_a,
+			 tp_ctl->thr_b, tp_ctl->thr_c);
+
+	if (WARN_ON(len > buf_len))
+		len = buf_len;
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	return ret_cnt;
+}
+
+static const struct file_operations fops_throughput_track = {
+	.read = ath6kl_tp_track_read,
+	.write = ath6kl_tp_track_write,
+	.open = ath6kl_debugfs_open_pri,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath6kl_tp_current_read(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ath6kl *ar = file->private_data;
+	struct ath6kl_vif *vif, *tmp_vif;
+	struct ath6kl_vif_tp_status *vif_tp_status;
+	char buf[200];
+	unsigned int len = 0, buf_len = 0;
+	ssize_t ret_cnt;
+
+	buf_len = sizeof(buf)-1;
+	len += scnprintf(buf + len, buf_len - len, "\n");
+
+	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
+		vif_tp_status = &vif->vif_tp_status;
+		len += scnprintf(buf + len, buf_len - len, "%s %d %ld\n",
+			vif->ndev->name, vif_tp_status->cur_level,
+				vif_tp_status->cur_tp);
+	}
+
+	if (WARN_ON(len > buf_len))
+		len = buf_len;
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	return ret_cnt;
+}
+
+static const struct file_operations fops_throughput_current = {
+	.read = ath6kl_tp_current_read,
+	.open = ath6kl_debugfs_open_pri,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath6kl_packet_filter_write(struct file *file,
+					  const char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct ath6kl *ar = file->private_data;
+	struct ath6kl_vif *vif;
+	char buf[512];
+	ssize_t len;
+	int ret;
+
+	if (WARN_ON(!test_bit(WMI_READY, &ar->flag)))
+		return -EIO;
+
+	vif = ath6kl_vif_first(ar);
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	ret = ath6kl_ioctl_pkt_filter_set(vif, buf, len);
+	if (ret) {
+		ath6kl_err("failed to set pkt filter:%d\n", ret);
+		return ret;
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_packet_filter = {
+	.open = ath6kl_debugfs_open_pri,
+	.write = ath6kl_packet_filter_write,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath6kl_hw_info_read(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ath6kl *ar = file->private_data;
+	char buf[48];
+	int len;
+
+	len = snprintf(buf, sizeof(buf), "hw_info: %s, 0x%x\n",
+		       ar->hw.name, ar->version.target_ver);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_hw_info = {
+	.open = ath6kl_debugfs_open_pri,
+	.read = ath6kl_hw_info_read,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 int ath6kl_init_debugfs_pri(struct ath6kl *ar)
 {
 	debugfs_create_file("inactivity_period", S_IWUSR, ar->debugfs_phy, ar,
@@ -203,6 +411,28 @@ int ath6kl_init_debugfs_pri(struct ath6kl *ar)
 	debugfs_create_file("bmiss_time", S_IRUSR | S_IWUSR, ar->debugfs_phy,
 			    ar, &fops_bmisstime);
 
+	debugfs_create_file("max_num_sta", S_IWUSR, ar->debugfs_phy,
+			    ar, &fops_max_num_sta);
+
+	debugfs_create_file("throughput_track", S_IRUSR | S_IWUSR,
+			    ar->debugfs_phy, ar, &fops_throughput_track);
+
+	debugfs_create_file("throughput_current", S_IRUSR,
+			    ar->debugfs_phy, ar, &fops_throughput_current);
+
+	debugfs_create_file("packet_filter", S_IWUSR, ar->debugfs_phy, ar,
+			    &fops_packet_filter);
+
+	debugfs_create_file("hw_info", S_IRUSR, ar->debugfs_phy, ar,
+			    &fops_hw_info);
+
+	return 0;
+}
+
+#else
+
+int ath6kl_wmi_error_report_event(struct wmi *wmi, u8 *data, int len)
+{
 	return 0;
 }
 
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.h
index f29df30..412aaf9 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/debugfs_pri.h
@@ -29,7 +29,10 @@ struct wmi_tgt_err_report_evt {
 	__le32 err_val;
 } __packed;
 
-int ath6kl_wmi_error_report_event(struct wmi *wmi, u8 *data, int len);
 int ath6kl_init_debugfs_pri(struct ath6kl *ar);
+
 #endif
+
+int ath6kl_wmi_error_report_event(struct wmi *wmi, u8 *data, int len);
+
 #endif
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/hif.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/hif.c
index b2f65f7..8b513d1 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/hif.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/hif.c
@@ -218,9 +218,8 @@ static int ath6kl_hif_proc_dbg_intr(struct ath6kl_device *dev)
 		ath6kl_warn("Failed to clear debug interrupt: %d\n", ret);
 
 	ath6kl_hif_dump_fw_crash(dev->ar);
-	if (debug_mask & ATH6KL_DBG_STACK_DUMP)
-		ath6kl_hif_dump_fw_more(dev->ar, DUMP_MASK_FULL_STACK |
-					DUMP_MASK_DBGLOG);
+	ath6kl_hif_dump_fw_more(dev->ar, DUMP_MASK_FULL_STACK |
+				DUMP_MASK_DBGLOG);
 	ath6kl_read_fwlogs(dev->ar);
 	ath6kl_recovery_err_notify(dev->ar, ATH6KL_FW_ASSERT);
 
@@ -410,8 +409,10 @@ static int ath6kl_hif_proc_err_intr(struct ath6kl_device *dev)
 	if (MS(ERROR_INT_STATUS_RX_UNDERFLOW, error_int_status))
 		ath6kl_err("rx underflow\n");
 
-	if (MS(ERROR_INT_STATUS_TX_OVERFLOW, error_int_status))
+	if (MS(ERROR_INT_STATUS_TX_OVERFLOW, error_int_status)) {
 		ath6kl_err("tx overflow\n");
+		ath6kl_recovery_err_notify(dev->ar, ATH6KL_FW_TX_OVERFLOW);
+	}
 
 	/* Clear the interrupt */
 	dev->irq_proc_reg.error_int_status &= ~error_int_status;
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.c
index 8ac60f4..399a227 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.c
@@ -1881,13 +1881,55 @@ fail_rx:
 	return status;
 }
 
+static void ath6kl_htc_rx_work(struct work_struct *work)
+{
+	struct htc_target *target;
+	struct htc_packet *packet, *tmp_pkt;
+	struct htc_endpoint *endpoint;
+	struct list_head temp_rx_bufq;
+
+	target = container_of(work, struct htc_target, rx_work);
+
+	INIT_LIST_HEAD(&temp_rx_bufq);
+
+	spin_lock_bh(&target->rx_bufq_lock);
+	list_for_each_entry_safe(packet, tmp_pkt, &target->rx_bufq, list) {
+		list_del(&packet->list);
+		list_add_tail(&packet->list, &temp_rx_bufq);
+	}
+	spin_unlock_bh(&target->rx_bufq_lock);
+
+	list_for_each_entry_safe(packet, tmp_pkt, &temp_rx_bufq, list) {
+		list_del(&packet->list);
+		endpoint = &target->endpoint[packet->endpoint];
+
+		ath6kl_dbg(ATH6KL_DBG_HTC,
+			   "htc rx complete ep %d packet 0x%p\n",
+			   endpoint->eid, packet);
+
+		endpoint->ep_cb.rx(endpoint->target, packet);
+	}
+}
+
 static void ath6kl_htc_rx_complete(struct htc_endpoint *endpoint,
 				   struct htc_packet *packet)
 {
+	struct htc_target *target;
+
+	if (endpoint->eid == ENDPOINT_0) {
 		ath6kl_dbg(ATH6KL_DBG_HTC,
 			   "htc rx complete ep %d packet 0x%p\n",
 			   endpoint->eid, packet);
 		endpoint->ep_cb.rx(endpoint->target, packet);
+	} else {
+		target = endpoint->target;
+
+		spin_lock_bh(&target->rx_bufq_lock);
+		list_add_tail(&packet->list, &target->rx_bufq);
+		spin_unlock_bh(&target->rx_bufq_lock);
+
+		queue_work(target->rx_wq, &target->rx_work);
+	}
 }
 
 static int ath6kl_htc_rx_bundle(struct htc_target *target,
@@ -2474,7 +2516,8 @@ int ath6kl_htc_conn_service(struct htc_target *target,
 		max_msg_sz = le16_to_cpu(resp_msg->max_msg_sz);
 	}
 
-	if (assigned_ep >= ENDPOINT_MAX || !max_msg_sz) {
+	if (WARN_ON_ONCE(assigned_ep == ENDPOINT_UNUSED ||
+			 assigned_ep >= ENDPOINT_MAX || !max_msg_sz)) {
 		status = -ENOMEM;
 		goto fail_tx;
 	}
@@ -2507,6 +2550,9 @@ int ath6kl_htc_conn_service(struct htc_target *target,
 	case WMI_DATA_BK_SVC:
 		endpoint->tx_drop_packet_threshold = MAX_DEF_COOKIE_NUM / 3;
 		break;
+	case WMI_DATA_VO_SVC:
+		endpoint->tx_drop_packet_threshold = DATA_SYNC_RESERVED;
+		break;
 	default:
 		endpoint->tx_drop_packet_threshold = MAX_HI_COOKIE_NUM;
 		break;
@@ -2839,13 +2885,24 @@ void *ath6kl_htc_create(struct ath6kl *ar)
 		goto err_htc_cleanup;
 	}
 
+        target->rx_wq = create_singlethread_workqueue("htc_rx");
+        if (!target->rx_wq) {
+		ath6kl_err("unable to create rx_wq workqueue\n");
+		status = -ENOMEM;
+		goto err_htc_cleanup;
+	}
+
 	spin_lock_init(&target->htc_lock);
 	spin_lock_init(&target->rx_lock);
 	spin_lock_init(&target->tx_lock);
+	spin_lock_init(&target->rx_bufq_lock);
 
 	INIT_LIST_HEAD(&target->free_ctrl_txbuf);
 	INIT_LIST_HEAD(&target->free_ctrl_rxbuf);
 	INIT_LIST_HEAD(&target->cred_dist_list);
+	INIT_LIST_HEAD(&target->rx_bufq);
+
+	INIT_WORK(&target->rx_work, ath6kl_htc_rx_work);
 
 	target->dev->ar = ar;
 	target->dev->htc_cnxt = target;
@@ -2872,6 +2929,18 @@ void ath6kl_htc_cleanup(struct htc_target *target)
 {
 	struct htc_packet *packet, *tmp_packet;
 
+	destroy_workqueue(target->rx_wq);
+
+	if (!list_empty(&target->rx_bufq)) {
+		spin_lock_bh(&target->rx_bufq_lock);
+		list_for_each_entry_safe(packet, tmp_packet,
+					 &target->rx_bufq, list) {
+			list_del(&packet->list);
+			dev_kfree_skb(packet->pkt_cntxt);
+		}
+		spin_unlock_bh(&target->rx_bufq_lock);
+	}
+
 	/* FIXME: remove check once USB support is implemented */
 	if (target->dev->ar->hif_type != ATH6KL_HIF_TYPE_USB)
 		ath6kl_hif_cleanup_scatter(target->dev->ar);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.h
index 59f0599..5e6ff8b 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/htc.h
@@ -550,6 +550,13 @@ struct htc_target {
 
 	/* counts the number of Tx without bundling continously per AC */
 	u32 ac_tx_count[WMM_NUM_AC];
+
+	struct workqueue_struct *rx_wq;
+	struct work_struct rx_work;
+
+	struct list_head rx_bufq;
+	spinlock_t rx_bufq_lock;
+
 };
 
 void *ath6kl_htc_create(struct ath6kl *ar);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c
index 9e3499a..bb66ec2 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c
@@ -36,7 +36,10 @@ static unsigned int wow_mode;
 static unsigned int uart_debug;
 static unsigned int ar6k_clock = 19200000;
 static unsigned short locally_administered_bit;
+static unsigned int recovery_enable;
 static unsigned int heart_beat_poll = 2000;
+static unsigned short reg_domain = 0xffff;
+static unsigned int load_balance = 1;
 
 module_param(debug_mask, uint, 0644);
 module_param(testmode, uint, 0644);
@@ -45,9 +48,16 @@ module_param(wow_mode, uint, 0644);
 module_param(uart_debug, uint, 0644);
 module_param(ar6k_clock, uint, 0644);
 module_param(locally_administered_bit, ushort, 0644);
+module_param(reg_domain, ushort, 0644);
+module_param(recovery_enable, uint, 0644);
 module_param(heart_beat_poll, uint, 0644);
+module_param(load_balance, uint, 0644);
 MODULE_PARM_DESC(heart_beat_poll, "Enable fw error detection periodic" \
 		 "polling. This also specifies the polling interval in msecs");
+MODULE_PARM_DESC(recovery_enable, "Enable recovery from firmware error");
+MODULE_PARM_DESC(load_balance, "Enable driver load balance for each vif," \
+		"it is only useful for multi vif interface");
+
 
 static const struct ath6kl_hw hw_list[] = {
 	{
@@ -143,6 +153,62 @@ static const struct ath6kl_hw hw_list[] = {
 };
 
 /*
+ * Number of bytes in board data that we are interested
+ * in while setting regulatory domain from host
+ */
+#define REG_DMN_BOARD_DATA_LEN	16
+
+/* Modifies regulatory domain in board data in target RAM */
+static int ath6kl_set_reg_dmn(struct ath6kl *ar)
+{
+	u8 buf[REG_DMN_BOARD_DATA_LEN];
+	__le16 old_sum, old_ver, old_rd, old_rd_next;
+	__le32 brd_dat_addr = 0, new_sum, new_rd;
+	int ret;
+
+	ret = ath6kl_bmi_read(ar, AR6003_BOARD_DATA_ADDR,
+			      (u8 *)&brd_dat_addr, 4);
+	if (ret)
+		return ret;
+
+	memset(buf, 0, sizeof(buf));
+	ret = ath6kl_bmi_read(ar, brd_dat_addr, buf, sizeof(buf));
+	if (ret)
+		return ret;
+
+	memcpy((u8 *)&old_sum, buf + AR6003_BOARD_DATA_OFFSET, 2);
+	memcpy((u8 *)&old_ver, buf + AR6003_BOARD_DATA_OFFSET + 2, 2);
+	memcpy((u8 *)&old_rd, buf + AR6003_RD_OFFSET, 2);
+	memcpy((u8 *)&old_rd_next, buf + AR6003_RD_OFFSET + 2, 2);
+
+	/*
+	 * Overwrite the new regulatory domain and preserve the
+	 * MAC addr which is in the same word.
+	 */
+	new_rd = cpu_to_le32((le32_to_cpu(old_rd_next) << 16) + reg_domain);
+	ret = ath6kl_bmi_write(ar,
+		cpu_to_le32(le32_to_cpu(brd_dat_addr) + AR6003_RD_OFFSET),
+		(u8 *)&new_rd, 4);
+	if (ret)
+		return ret;
+
+	/*
+	 * Recompute the board data checksum with the new regulatory
+	 * domain, preserve the version information which is in the
+	 * same word.
+	 */
+	new_sum = cpu_to_le32((le32_to_cpu(old_ver) << 16) +
+			      (le32_to_cpu(old_sum) ^ le32_to_cpu(old_rd) ^
+			       reg_domain));
+	ret = ath6kl_bmi_write(ar,
+		cpu_to_le32(le32_to_cpu(brd_dat_addr) +
+		AR6003_BOARD_DATA_OFFSET),
+		(u8 *)&new_sum, 4);
+
+	return ret;
+}
+
+/*
  * Include definitions here that can be used to tune the WLAN module
  * behavior. Different customers can tune the behavior as per their needs,
  * here.
@@ -412,6 +478,8 @@ static int ath6kl_target_config_wlan_params(struct ath6kl *ar, int idx)
 {
 	int status = 0;
 	int ret;
+	u16 ps_fail_policy;
+	u16 pspoll_num = WLAN_CONFIG_PSPOLL_NUM;
 
 	/*
 	 * Configure the device for rx dot11 header rules. "0,0" are the
@@ -425,11 +493,15 @@ static int ath6kl_target_config_wlan_params(struct ath6kl *ar, int idx)
 	}
 
 	if (ar->conf_flags & ATH6KL_CONF_IGNORE_PS_FAIL_EVT_IN_SCAN)
-		if ((ath6kl_wmi_pmparams_cmd(ar->wmi, idx, 0, 1, 0, 0, 1,
-		     IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN)) != 0) {
-			ath6kl_err("unable to set power save fail event policy\n");
-			status = -EIO;
-		}
+		ps_fail_policy = IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN;
+	else
+		ps_fail_policy = SEND_POWER_SAVE_FAIL_EVENT_ALWAYS;
+
+	if ((ath6kl_wmi_pmparams_cmd(ar->wmi, idx, 0, pspoll_num, 0, 0, 1,
+				     ps_fail_policy)) != 0) {
+		ath6kl_err("unable to set power save parameter\n");
+		status = -EIO;
+	}
 
 	if (!(ar->conf_flags & ATH6KL_CONF_IGNORE_ERP_BARKER))
 		if ((ath6kl_wmi_set_lpreamble_cmd(ar->wmi, idx, 0,
@@ -635,6 +707,8 @@ void ath6kl_core_cleanup(struct ath6kl *ar)
 
 	ath6kl_recovery_cleanup(ar);
 
+	del_timer_sync(&ar->tp_ctl.tp_monitor_timer);
+
 	destroy_workqueue(ar->ath6kl_wq);
 
 	if (ar->htc_target)
@@ -650,7 +724,12 @@ void ath6kl_core_cleanup(struct ath6kl *ar)
 
 	kfree(ar->fw_board);
 	kfree(ar->fw_otp);
-	vfree(ar->fw);
+
+	if (test_bit(TESTMODE, &ar->flag))
+		kfree(ar->fw);
+	else
+		vfree(ar->fw);
+
 	kfree(ar->fw_patch);
 	kfree(ar->fw_testscript);
 
@@ -1638,6 +1717,12 @@ static int __ath6kl_init_hw_start(struct ath6kl *ar)
 	if (ret)
 		goto err_power_off;
 
+	if (reg_domain != 0xffff) {
+		ret = ath6kl_set_reg_dmn(ar);
+		if (ret)
+			goto err_power_off;
+	}
+
 	/* Do we need to finish the BMI phase */
 	/* FIXME: return error from ath6kl_bmi_done() */
 	if (ath6kl_bmi_done(ar)) {
@@ -1676,10 +1761,16 @@ static int __ath6kl_init_hw_start(struct ath6kl *ar)
 						    test_bit(WMI_READY,
 							     &ar->flag),
 						    WMI_TIMEOUT);
+	if (timeleft <= 0) {
+		clear_bit(WMI_READY, &ar->flag);
+		ath6kl_err("wmi is not ready or wait was interrupted: %ld\n",
+			   timeleft);
+		ret = -EIO;
+		goto err_htc_stop;
+	}
 
 	ath6kl_dbg(ATH6KL_DBG_BOOT, "firmware booted\n");
 
-
 	if (test_and_clear_bit(FIRST_BOOT, &ar->flag)) {
 		ath6kl_info("%s %s fw %s api %d%s\n",
 			    ar->hw.name,
@@ -1696,13 +1787,6 @@ static int __ath6kl_init_hw_start(struct ath6kl *ar)
 		goto err_htc_stop;
 	}
 
-	if (!timeleft || signal_pending(current)) {
-		clear_bit(WMI_READY, &ar->flag);
-		ath6kl_err("wmi is not ready or wait was interrupted\n");
-		ret = -EIO;
-		goto err_htc_stop;
-	}
-
 	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: wmi is ready\n", __func__);
 
 	/* communicate the wmi protocol verision to the target */
@@ -1829,38 +1913,6 @@ int ath6kl_core_init(struct ath6kl *ar)
 
 	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: got wmi @ 0x%p.\n", __func__, ar->wmi);
 
-	ret = ath6kl_register_ieee80211_hw(ar);
-	if (ret)
-		goto err_node_cleanup;
-
-	ret = ath6kl_debug_init(ar);
-	if (ret) {
-		wiphy_unregister(ar->wiphy);
-		goto err_node_cleanup;
-	}
-
-	for (i = 0; i < ar->vif_max; i++)
-		ar->avail_idx_map |= BIT(i);
-
-	rtnl_lock();
-
-	/* Add an initial station interface */
-	ndev = ath6kl_interface_add(ar, "wlan%d", NL80211_IFTYPE_STATION, 0,
-				    INFRA_NETWORK);
-
-	rtnl_unlock();
-
-	if (!ndev) {
-		ath6kl_err("Failed to instantiate a network device\n");
-		ret = -ENOMEM;
-		wiphy_unregister(ar->wiphy);
-		goto err_debug_init;
-	}
-
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: name=%s dev=0x%p, ar=0x%p\n",
-			__func__, ndev->name, ndev, ar);
-
 	/* setup access class priority mappings */
 	ar->ac_stream_pri_map[WMM_AC_BK] = 0; /* lowest  */
 	ar->ac_stream_pri_map[WMM_AC_BE] = 1;
@@ -1889,25 +1941,9 @@ int ath6kl_core_init(struct ath6kl *ar)
 	else
 		ar->wow_suspend_mode = 0;
 
-	ar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM |
-			    WIPHY_FLAG_HAVE_AP_SME |
-			    WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |
-			    WIPHY_FLAG_SUPPORTS_ACS;
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, ar->fw_capabilities))
-		ar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
-
-	ar->wiphy->probe_resp_offload =
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U;
-
 	set_bit(FIRST_BOOT, &ar->flag);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
-	ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
-#endif
+	ath6kl_debug_init(ar);
 
 	ret = ath6kl_init_hw_start(ar);
 	if (ret) {
@@ -1919,11 +1955,38 @@ int ath6kl_core_init(struct ath6kl *ar)
 	ath6kl_rx_refill(ar->htc_target, ar->ctrl_ep);
 	ath6kl_rx_refill(ar->htc_target, ar->ac2ep_map[WMM_AC_BE]);
 
-	/*
-	 * Set mac address which is received in ready event
-	 * FIXME: Move to ath6kl_interface_add()
-	 */
-	memcpy(ndev->dev_addr, ar->mac_addr, ETH_ALEN);
+	ret = ath6kl_register_ieee80211_hw(ar);
+	if (ret)
+		goto err_rxbuf_cleanup;
+
+	ret = ath6kl_debug_init_fs(ar);
+	if (ret)
+		goto err_rxbuf_cleanup;
+
+	for (i = 0; i < ar->vif_max; i++)
+		ar->avail_idx_map |= BIT(i);
+
+	rtnl_lock();
+
+	/* Add an initial station interface */
+	ndev = ath6kl_interface_add(ar, "wlan%d", NL80211_IFTYPE_STATION, 0,
+				    INFRA_NETWORK);
+
+	rtnl_unlock();
+
+	if (!ndev) {
+		ath6kl_err("Failed to instantiate a network device\n");
+		ret = -ENOMEM;
+		goto err_rxbuf_cleanup;
+	}
+
+	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: name=%s dev=0x%p, ar=0x%p\n",
+		   __func__, ndev->name, ndev, ar);
+
+	ath6kl_wmi_send_rdy_evt_to_app(ndev, ar);
+
+	if (test_and_clear_bit(REG_DOMAIN_HINT_PEND, &ar->flag))
+		regulatory_hint(ar->wiphy, ar->alpha2);
 
 	rtnl_lock();
 	ndev_p2p0 = ath6kl_cfg80211_add_p2p0_iface(ar);
@@ -1932,8 +1995,25 @@ int ath6kl_core_init(struct ath6kl *ar)
 	if (!ndev_p2p0) {
 		ath6kl_err("Failed to create p2p0 iface\n");
 		ret = -ENOMEM;
-		goto err_rxbuf_cleanup;
+		goto err_ndev_cleanup;
 	}
+	ar->tp_ctl.tp_monitor_timer.function = ath6kl_tp_monitor_timer;
+	ar->tp_ctl.tp_monitor_timer.data = (unsigned long) ar;
+	init_timer_deferrable(&ar->tp_ctl.tp_monitor_timer);
+
+	ath6kl_tp_cfg(ar, TP_MONITOR_TIMER_INTERVAL_S, ATH6KL_TP_TYPE_DISABLED,
+		      0, 0, 0);
+
+	if (ar->vif_max <= 1)
+		ar->vif_cookie_cfg.load_balance = false;
+	else {
+		ar->vif_cookie_cfg.load_balance = !!load_balance;
+		ath6kl_cookie_vif_balance_init(ar);
+	}
+
+	ar->fw_recovery.enable = !!recovery_enable;
+	if (!ar->fw_recovery.enable)
+		return ret;
 
 	if (heart_beat_poll &&
 	    test_bit(ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL,
@@ -1944,16 +2024,15 @@ int ath6kl_core_init(struct ath6kl *ar)
 
 	return ret;
 
-err_rxbuf_cleanup:
-	ath6kl_htc_flush_rx_buf(ar->htc_target);
-	ath6kl_cleanup_amsdu_rxbufs(ar);
+err_ndev_cleanup:
 	rtnl_lock();
 	ath6kl_deinit_if_data(netdev_priv(ndev));
 	rtnl_unlock();
-	wiphy_unregister(ar->wiphy);
-err_debug_init:
+err_rxbuf_cleanup:
 	ath6kl_debug_cleanup(ar);
-err_node_cleanup:
+	ath6kl_htc_flush_rx_buf(ar->htc_target);
+	ath6kl_cleanup_amsdu_rxbufs(ar);
+	wiphy_unregister(ar->wiphy);
 	ath6kl_cleanup_android_resource(ar);
 	ath6kl_wmi_shutdown(ar->wmi);
 	clear_bit(WMI_ENABLED, &ar->flag);
@@ -1966,6 +2045,7 @@ err_bmi_cleanup:
 	ath6kl_bmi_cleanup(ar);
 err_wq:
 	destroy_workqueue(ar->ath6kl_wq);
+	kfree(ar->ready_data);
 
 	return ret;
 }
@@ -1985,12 +2065,15 @@ void ath6kl_init_hw_restart(struct ath6kl *ar)
 		ath6kl_dbg(ATH6KL_DBG_RECOVERY, "Failed to restart during fw error recovery\n");
 		return;
 	}
+
+	ath6kl_cfg80211_start_all(ar);
 }
 
 void ath6kl_cleanup_vif(struct ath6kl_vif *vif, bool wmi_ready)
 {
 	static u8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 	bool discon_issued;
+	struct cfg80211_scan_request *scan_req;
 
 	netif_stop_queue(vif->ndev);
 
@@ -2009,10 +2092,13 @@ void ath6kl_cleanup_vif(struct ath6kl_vif *vif, bool wmi_ready)
 						0, NULL, 0);
 	}
 
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
-	}
+	spin_lock_bh(&vif->if_lock);
+	scan_req = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
+
+	if (scan_req)
+		cfg80211_scan_done(scan_req, true);
 
 	/* need to clean up enhanced bmiss detection fw state */
 	ath6kl_cfg80211_sta_bmiss_enhance(vif, false);
@@ -2047,8 +2133,6 @@ void ath6kl_stop_txrx(struct ath6kl *ar)
 
 	clear_bit(WMI_READY, &ar->flag);
 
-	del_timer_sync(&ar->fw_recovery.hb_timer);
-
 	/*
 	 * After wmi_shudown all WMI events will be dropped. We
 	 * need to cleanup the buffers allocated in AP mode and
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c.orig b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c.orig
deleted file mode 100644
index ea5582a..0000000
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/init.c.orig
+++ /dev/null
@@ -1,2079 +0,0 @@
-
-/*
- * Copyright (c) 2011 Atheros Communications Inc.
- * Copyright (c) 2011-2012 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include <linux/moduleparam.h>
-#include <linux/errno.h>
-//#include <linux/of.h>
-#include <linux/mmc/sdio_func.h>
-#include <linux/vmalloc.h>
-#include "core.h"
-#include "cfg80211.h"
-#include "target.h"
-#include "debug.h"
-#include "hif-ops.h"
-#include "pm.h"
-
-unsigned int debug_mask;
-static unsigned int testmode;
-/* Set WOW mode as default suspend mode */
-static unsigned int suspend_mode = 3;
-static unsigned int wow_mode;
-static unsigned int uart_debug;
-static unsigned int ar6k_clock = 19200000;
-static unsigned short locally_administered_bit;
-static unsigned int heart_beat_poll = 2000;
-
-module_param(debug_mask, uint, 0644);
-module_param(testmode, uint, 0644);
-module_param(suspend_mode, uint, 0644);
-module_param(wow_mode, uint, 0644);
-module_param(uart_debug, uint, 0644);
-module_param(ar6k_clock, uint, 0644);
-module_param(locally_administered_bit, ushort, 0644);
-module_param(heart_beat_poll, uint, 0644);
-MODULE_PARM_DESC(heart_beat_poll, "Enable fw error detection periodic" \
-		 "polling. This also specifies the polling interval in msecs");
-
-static const struct ath6kl_hw hw_list[] = {
-	{
-		.id				= AR6003_HW_2_0_VERSION,
-		.name				= "ar6003 hw 2.0",
-		.dataset_patch_addr		= 0x57e884,
-		.app_load_addr			= 0x543180,
-		.board_ext_data_addr		= 0x57e500,
-		.reserved_ram_size		= 6912,
-		.refclk_hz			= 26000000,
-		.uarttx_pin			= 8,
-
-		/* hw2.0 needs override address hardcoded */
-		.app_start_override_addr	= 0x944C00,
-		.flags				= 0,
-
-		.fw = {
-			.dir		= AR6003_HW_2_0_FW_DIR,
-			.otp		= AR6003_HW_2_0_OTP_FILE,
-			.fw		= AR6003_HW_2_0_FIRMWARE_FILE,
-			.tcmd		= AR6003_HW_2_0_TCMD_FIRMWARE_FILE,
-			.patch		= AR6003_HW_2_0_PATCH_FILE,
-		},
-
-		.fw_board		= AR6003_HW_2_0_BOARD_DATA_FILE,
-		.fw_default_board	= AR6003_HW_2_0_DEFAULT_BOARD_DATA_FILE,
-	},
-	{
-		.id				= AR6003_HW_2_1_1_VERSION,
-		.name				= "ar6003 hw 2.1.1",
-		.dataset_patch_addr		= 0x57ff74,
-		.app_load_addr			= 0x1234,
-		.board_ext_data_addr		= 0x542330,
-		.reserved_ram_size		= 512,
-		.refclk_hz			= 26000000,
-		.uarttx_pin			= 8,
-		.testscript_addr		= 0x57ef74,
-		.flags				= 0,
-
-		.fw = {
-			.dir		= AR6003_HW_2_1_1_FW_DIR,
-			.otp		= AR6003_HW_2_1_1_OTP_FILE,
-			.fw		= AR6003_HW_2_1_1_FIRMWARE_FILE,
-			.tcmd		= AR6003_HW_2_1_1_TCMD_FIRMWARE_FILE,
-			.patch		= AR6003_HW_2_1_1_PATCH_FILE,
-			.utf		= AR6003_HW_2_1_1_UTF_FIRMWARE_FILE,
-			.testscript	= AR6003_HW_2_1_1_TESTSCRIPT_FILE,
-		},
-
-		.fw_board		= AR6003_HW_2_1_1_BOARD_DATA_FILE,
-		.fw_default_board	= AR6003_HW_2_1_1_DEFAULT_BOARD_DATA_FILE,
-	},
-	{
-		.id				= AR6004_HW_1_0_VERSION,
-		.name				= "ar6004 hw 1.0",
-		.dataset_patch_addr		= 0x57e884,
-		.app_load_addr			= 0x1234,
-		.board_ext_data_addr		= 0x437000,
-		.reserved_ram_size		= 19456,
-		.board_addr			= 0x433900,
-		.refclk_hz			= 26000000,
-		.uarttx_pin			= 11,
-		.flags				= ATH6KL_HW_FLAG_64BIT_RATES,
-
-		.fw = {
-			.dir		= AR6004_HW_1_0_FW_DIR,
-			.fw		= AR6004_HW_1_0_FIRMWARE_FILE,
-		},
-
-		.fw_board		= AR6004_HW_1_0_BOARD_DATA_FILE,
-		.fw_default_board	= AR6004_HW_1_0_DEFAULT_BOARD_DATA_FILE,
-	},
-	{
-		.id				= AR6004_HW_1_1_VERSION,
-		.name				= "ar6004 hw 1.1",
-		.dataset_patch_addr		= 0x57e884,
-		.app_load_addr			= 0x1234,
-		.board_ext_data_addr		= 0x437000,
-		.reserved_ram_size		= 11264,
-		.board_addr			= 0x43d400,
-		.refclk_hz			= 40000000,
-		.uarttx_pin			= 11,
-		.flags				= ATH6KL_HW_FLAG_64BIT_RATES,
-
-		.fw = {
-			.dir		= AR6004_HW_1_1_FW_DIR,
-			.fw		= AR6004_HW_1_1_FIRMWARE_FILE,
-		},
-
-		.fw_board		= AR6004_HW_1_1_BOARD_DATA_FILE,
-		.fw_default_board	= AR6004_HW_1_1_DEFAULT_BOARD_DATA_FILE,
-	},
-};
-
-/*
- * Include definitions here that can be used to tune the WLAN module
- * behavior. Different customers can tune the behavior as per their needs,
- * here.
- */
-
-/*
- * This configuration item enable/disable keepalive support.
- * Keepalive support: In the absence of any data traffic to AP, null
- * frames will be sent to the AP at periodic interval, to keep the association
- * active. This configuration item defines the periodic interval.
- * Use value of zero to disable keepalive support
- * Default: 60 seconds
- */
-#define WLAN_CONFIG_KEEP_ALIVE_INTERVAL 60
-
-/*
- * This configuration item sets the value of disconnect timeout
- * Firmware delays sending the disconnec event to the host for this
- * timeout after is gets disconnected from the current AP.
- * If the firmware successly roams within the disconnect timeout
- * it sends a new connect event
- */
-#define WLAN_CONFIG_DISCONNECT_TIMEOUT 10
-
-
-#define ATH6KL_DATA_OFFSET    64
-struct sk_buff *ath6kl_buf_alloc(int size)
-{
-	struct sk_buff *skb;
-	u16 reserved;
-
-	/* Add chacheline space at front and back of buffer */
-	reserved = (2 * L1_CACHE_BYTES) + ATH6KL_DATA_OFFSET +
-		   sizeof(struct htc_packet) + ATH6KL_HTC_ALIGN_BYTES;
-	skb = dev_alloc_skb(size + reserved);
-
-	if (skb)
-		skb_reserve(skb, reserved - L1_CACHE_BYTES);
-	return skb;
-}
-
-void ath6kl_init_profile_info(struct ath6kl_vif *vif)
-{
-	vif->ssid_len = 0;
-	memset(vif->ssid, 0, sizeof(vif->ssid));
-
-	vif->dot11_auth_mode = OPEN_AUTH;
-	vif->auth_mode = NONE_AUTH;
-	vif->prwise_crypto = NONE_CRYPT;
-	vif->prwise_crypto_len = 0;
-	vif->grp_crypto = NONE_CRYPT;
-	vif->grp_crypto_len = 0;
-	memset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));
-	memset(vif->req_bssid, 0, sizeof(vif->req_bssid));
-	memset(vif->bssid, 0, sizeof(vif->bssid));
-	vif->bss_ch = 0;
-}
-
-static int ath6kl_set_host_app_area(struct ath6kl *ar)
-{
-	u32 address, data;
-	struct host_app_area host_app_area;
-
-	/* Fetch the address of the host_app_area_s
-	 * instance in the host interest area */
-	address = ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_app_host_interest));
-	address = TARG_VTOP(ar->target_type, address);
-
-	if (ath6kl_diag_read32(ar, address, &data))
-		return -EIO;
-
-	address = TARG_VTOP(ar->target_type, data);
-	host_app_area.wmi_protocol_ver = cpu_to_le32(WMI_PROTOCOL_VERSION);
-	if (ath6kl_diag_write(ar, address, (u8 *) &host_app_area,
-			      sizeof(struct host_app_area)))
-		return -EIO;
-
-	return 0;
-}
-
-static inline void set_ac2_ep_map(struct ath6kl *ar,
-				  u8 ac,
-				  enum htc_endpoint_id ep)
-{
-	ar->ac2ep_map[ac] = ep;
-	ar->ep2ac_map[ep] = ac;
-}
-
-/* connect to a service */
-static int ath6kl_connectservice(struct ath6kl *ar,
-				 struct htc_service_connect_req  *con_req,
-				 char *desc)
-{
-	int status;
-	struct htc_service_connect_resp response;
-
-	memset(&response, 0, sizeof(response));
-
-	status = ath6kl_htc_conn_service(ar->htc_target, con_req, &response);
-	if (status) {
-		ath6kl_err("failed to connect to %s service status:%d\n",
-			   desc, status);
-		return status;
-	}
-
-	switch (con_req->svc_id) {
-	case WMI_CONTROL_SVC:
-		if (test_bit(WMI_ENABLED, &ar->flag))
-			ath6kl_wmi_set_control_ep(ar->wmi, response.endpoint);
-		ar->ctrl_ep = response.endpoint;
-		break;
-	case WMI_DATA_BE_SVC:
-		set_ac2_ep_map(ar, WMM_AC_BE, response.endpoint);
-		break;
-	case WMI_DATA_BK_SVC:
-		set_ac2_ep_map(ar, WMM_AC_BK, response.endpoint);
-		break;
-	case WMI_DATA_VI_SVC:
-		set_ac2_ep_map(ar, WMM_AC_VI, response.endpoint);
-		break;
-	case WMI_DATA_VO_SVC:
-		set_ac2_ep_map(ar, WMM_AC_VO, response.endpoint);
-		break;
-	default:
-		ath6kl_err("service id is not mapped %d\n", con_req->svc_id);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int ath6kl_init_service_ep(struct ath6kl *ar)
-{
-	struct htc_service_connect_req connect;
-
-	memset(&connect, 0, sizeof(connect));
-
-	/* these fields are the same for all service endpoints */
-	connect.ep_cb.rx = ath6kl_rx;
-	connect.ep_cb.rx_refill = ath6kl_rx_refill;
-	connect.ep_cb.tx_full = ath6kl_tx_queue_full;
-
-	/*
-	 * Set the max queue depth so that our ath6kl_tx_queue_full handler
-	 * gets called.
-	*/
-	connect.max_txq_depth = MAX_DEFAULT_SEND_QUEUE_DEPTH;
-	connect.ep_cb.rx_refill_thresh = ATH6KL_MAX_RX_BUFFERS / 4;
-	if (!connect.ep_cb.rx_refill_thresh)
-		connect.ep_cb.rx_refill_thresh++;
-
-	/* connect to control service */
-	connect.svc_id = WMI_CONTROL_SVC;
-	if (ath6kl_connectservice(ar, &connect, "WMI CONTROL"))
-		return -EIO;
-
-	connect.flags |= HTC_FLGS_TX_BNDL_PAD_EN;
-
-	/*
-	 * Limit the HTC message size on the send path, although e can
-	 * receive A-MSDU frames of 4K, we will only send ethernet-sized
-	 * (802.3) frames on the send path.
-	 */
-	connect.max_rxmsg_sz = WMI_MAX_TX_DATA_FRAME_LENGTH;
-
-	/*
-	 * To reduce the amount of committed memory for larger A_MSDU
-	 * frames, use the recv-alloc threshold mechanism for larger
-	 * packets.
-	 */
-	connect.ep_cb.rx_alloc_thresh = ATH6KL_BUFFER_SIZE;
-	connect.ep_cb.rx_allocthresh = ath6kl_alloc_amsdu_rxbuf;
-
-	/*
-	 * For the remaining data services set the connection flag to
-	 * reduce dribbling, if configured to do so.
-	 */
-	connect.conn_flags |= HTC_CONN_FLGS_REDUCE_CRED_DRIB;
-	connect.conn_flags &= ~HTC_CONN_FLGS_THRESH_MASK;
-	connect.conn_flags |= HTC_CONN_FLGS_THRESH_LVL_QUAT;
-
-	connect.svc_id = WMI_DATA_BE_SVC;
-
-	if (ath6kl_connectservice(ar, &connect, "WMI DATA BE"))
-		return -EIO;
-
-	/* connect to back-ground map this to WMI LOW_PRI */
-	connect.svc_id = WMI_DATA_BK_SVC;
-	if (ath6kl_connectservice(ar, &connect, "WMI DATA BK"))
-		return -EIO;
-
-	/* connect to Video service, map this to to HI PRI */
-	connect.svc_id = WMI_DATA_VI_SVC;
-	if (ath6kl_connectservice(ar, &connect, "WMI DATA VI"))
-		return -EIO;
-
-	/*
-	 * Connect to VO service, this is currently not mapped to a WMI
-	 * priority stream due to historical reasons. WMI originally
-	 * defined 3 priorities over 3 mailboxes We can change this when
-	 * WMI is reworked so that priorities are not dependent on
-	 * mailboxes.
-	 */
-	connect.svc_id = WMI_DATA_VO_SVC;
-	if (ath6kl_connectservice(ar, &connect, "WMI DATA VO"))
-		return -EIO;
-
-	return 0;
-}
-
-void ath6kl_init_control_info(struct ath6kl_vif *vif)
-{
-	ath6kl_init_profile_info(vif);
-	vif->def_txkey_index = 0;
-	memset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));
-	vif->ch_hint = 0;
-}
-
-/*
- * Set HTC/Mbox operational parameters, this can only be called when the
- * target is in the BMI phase.
- */
-static int ath6kl_set_htc_params(struct ath6kl *ar, u32 mbox_isr_yield_val,
-				 u8 htc_ctrl_buf)
-{
-	int status;
-	u32 blk_size;
-
-	blk_size = ar->mbox_info.block_size;
-
-	if (htc_ctrl_buf)
-		blk_size |=  ((u32)htc_ctrl_buf) << 16;
-
-	/* set the host interest area for the block size */
-	status = ath6kl_bmi_write(ar,
-			ath6kl_get_hi_item_addr(ar,
-			HI_ITEM(hi_mbox_io_block_sz)),
-			(u8 *)&blk_size,
-			4);
-	if (status) {
-		ath6kl_err("bmi_write_memory for IO block size failed\n");
-		goto out;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "block size set: %d (target addr:0x%X)\n",
-		   blk_size,
-		   ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_mbox_io_block_sz)));
-
-	if (mbox_isr_yield_val) {
-		/* set the host interest area for the mbox ISR yield limit */
-		status = ath6kl_bmi_write(ar,
-				ath6kl_get_hi_item_addr(ar,
-				HI_ITEM(hi_mbox_isr_yield_limit)),
-				(u8 *)&mbox_isr_yield_val,
-				4);
-		if (status) {
-			ath6kl_err("bmi_write_memory for yield limit failed\n");
-			goto out;
-		}
-	}
-
-out:
-	return status;
-}
-
-static int ath6kl_target_config_wlan_params(struct ath6kl *ar, int idx)
-{
-	int status = 0;
-	int ret;
-
-	/*
-	 * Configure the device for rx dot11 header rules. "0,0" are the
-	 * default values. Required if checksum offload is needed. Set
-	 * RxMetaVersion to 2.
-	 */
-	if (ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi, idx,
-					       ar->rx_meta_ver, 0, 0)) {
-		ath6kl_err("unable to set the rx frame format\n");
-		status = -EIO;
-	}
-
-	if (ar->conf_flags & ATH6KL_CONF_IGNORE_PS_FAIL_EVT_IN_SCAN)
-		if ((ath6kl_wmi_pmparams_cmd(ar->wmi, idx, 0, 1, 0, 0, 1,
-		     IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN)) != 0) {
-			ath6kl_err("unable to set power save fail event policy\n");
-			status = -EIO;
-		}
-
-	if (!(ar->conf_flags & ATH6KL_CONF_IGNORE_ERP_BARKER))
-		if ((ath6kl_wmi_set_lpreamble_cmd(ar->wmi, idx, 0,
-		     WMI_DONOT_IGNORE_BARKER_IN_ERP)) != 0) {
-			ath6kl_err("unable to set barker preamble policy\n");
-			status = -EIO;
-		}
-
-	if (ath6kl_wmi_set_keepalive_cmd(ar->wmi, idx,
-			WLAN_CONFIG_KEEP_ALIVE_INTERVAL)) {
-		ath6kl_err("unable to set keep alive interval\n");
-		status = -EIO;
-	}
-
-	if (ath6kl_wmi_disctimeout_cmd(ar->wmi, idx,
-			WLAN_CONFIG_DISCONNECT_TIMEOUT)) {
-		ath6kl_err("unable to set disconnect timeout\n");
-		status = -EIO;
-	}
-
-	if (!(ar->conf_flags & ATH6KL_CONF_ENABLE_TX_BURST))
-		if (ath6kl_wmi_set_wmm_txop(ar->wmi, idx, WMI_TXOP_DISABLED)) {
-			ath6kl_err("unable to set txop bursting\n");
-			status = -EIO;
-		}
-
-	if (ar->p2p && (ar->vif_max == 1 || idx)) {
-		ret = ath6kl_wmi_info_req_cmd(ar->wmi, idx,
-					      P2P_FLAG_CAPABILITIES_REQ |
-					      P2P_FLAG_MACADDR_REQ |
-					      P2P_FLAG_HMODEL_REQ);
-		if (ret) {
-			ath6kl_dbg(ATH6KL_DBG_TRC, "failed to request P2P "
-				   "capabilities (%d) - assuming P2P not "
-				   "supported\n", ret);
-			ar->p2p = 0;
-		}
-	}
-
-	if (ar->p2p && (ar->vif_max == 1 || idx)) {
-		/* Enable Probe Request reporting for P2P */
-		ret = ath6kl_wmi_probe_report_req_cmd(ar->wmi, idx, true);
-		if (ret) {
-			ath6kl_dbg(ATH6KL_DBG_TRC, "failed to enable Probe "
-				   "Request reporting (%d)\n", ret);
-		}
-	}
-
-	return status;
-}
-
-int ath6kl_configure_target(struct ath6kl *ar)
-{
-	u32 param, ram_reserved_size;
-	u8 fw_iftype, fw_mode = 0, fw_submode = 0;
-	int i, status;
-
-	param = uart_debug;
-	if (ath6kl_bmi_write(ar, ath6kl_get_hi_item_addr(ar,
-			     HI_ITEM(hi_serial_enable)), (u8 *)&param, 4)) {
-		ath6kl_err("bmi_write_memory for uart debug failed\n");
-		return -EIO;
-	}
-
-	/*
-	 * Note: Even though the firmware interface type is
-	 * chosen as BSS_STA for all three interfaces, can
-	 * be configured to IBSS/AP as long as the fw submode
-	 * remains normal mode (0 - AP, STA and IBSS). But
-	 * due to an target assert in firmware only one interface is
-	 * configured for now.
-	 */
-	fw_iftype = HI_OPTION_FW_MODE_BSS_STA;
-
-	for (i = 0; i < ar->vif_max; i++)
-		fw_mode |= fw_iftype << (i * HI_OPTION_FW_MODE_BITS);
-
-	/*
-	 * Submodes when fw does not support dynamic interface
-	 * switching:
-	 *		vif[0] - AP/STA/IBSS
-	 *		vif[1] - "P2P dev"/"P2P GO"/"P2P Client"
-	 *		vif[2] - "P2P dev"/"P2P GO"/"P2P Client"
-	 * Otherwise, All the interface are initialized to p2p dev.
-	 */
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,
-		     ar->fw_capabilities)) {
-		for (i = 0; i < ar->vif_max; i++)
-			fw_submode |= HI_OPTION_FW_SUBMODE_P2PDEV <<
-				(i * HI_OPTION_FW_SUBMODE_BITS);
-	} else {
-		for (i = 0; i < ar->max_norm_iface; i++)
-			fw_submode |= HI_OPTION_FW_SUBMODE_NONE <<
-				(i * HI_OPTION_FW_SUBMODE_BITS);
-
-		for (i = ar->max_norm_iface; i < ar->vif_max; i++)
-			fw_submode |= HI_OPTION_FW_SUBMODE_P2PDEV <<
-				(i * HI_OPTION_FW_SUBMODE_BITS);
-
-		if (ar->p2p && ar->vif_max == 1)
-			fw_submode = HI_OPTION_FW_SUBMODE_P2PDEV;
-	}
-
-	param = HTC_PROTOCOL_VERSION;
-	if (ath6kl_bmi_write(ar,
-			     ath6kl_get_hi_item_addr(ar,
-			     HI_ITEM(hi_app_host_interest)),
-			     (u8 *)&param, 4) != 0) {
-		ath6kl_err("bmi_write_memory for htc version failed\n");
-		return -EIO;
-	}
-
-	/* set the firmware mode to STA/IBSS/AP */
-	param = 0;
-
-	if (ath6kl_bmi_read(ar,
-			    ath6kl_get_hi_item_addr(ar,
-			    HI_ITEM(hi_option_flag)),
-			    (u8 *)&param, 4) != 0) {
-		ath6kl_err("bmi_read_memory for setting fwmode failed\n");
-		return -EIO;
-	}
-
-	param |= (ar->vif_max << HI_OPTION_NUM_DEV_SHIFT);
-	param |= fw_mode << HI_OPTION_FW_MODE_SHIFT;
-	param |= fw_submode << HI_OPTION_FW_SUBMODE_SHIFT;
-
-	param |= (0 << HI_OPTION_MAC_ADDR_METHOD_SHIFT);
-	param |= (0 << HI_OPTION_FW_BRIDGE_SHIFT);
-
-	if (ath6kl_bmi_write(ar,
-			     ath6kl_get_hi_item_addr(ar,
-			     HI_ITEM(hi_option_flag)),
-			     (u8 *)&param,
-			     4) != 0) {
-		ath6kl_err("bmi_write_memory for setting fwmode failed\n");
-		return -EIO;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "firmware mode set\n");
-
-	/*
-	 * Hardcode the address use for the extended board data
-	 * Ideally this should be pre-allocate by the OS at boot time
-	 * But since it is a new feature and board data is loaded
-	 * at init time, we have to workaround this from host.
-	 * It is difficult to patch the firmware boot code,
-	 * but possible in theory.
-	 */
-
-	param = ar->hw.board_ext_data_addr;
-	ram_reserved_size = ar->hw.reserved_ram_size;
-
-	if (ath6kl_bmi_write(ar, ath6kl_get_hi_item_addr(ar,
-					HI_ITEM(hi_board_ext_data)),
-			     (u8 *)&param, 4) != 0) {
-		ath6kl_err("bmi_write_memory for hi_board_ext_data failed\n");
-		return -EIO;
-	}
-
-	if (ath6kl_bmi_write(ar, ath6kl_get_hi_item_addr(ar,
-					HI_ITEM(hi_end_ram_reserve_sz)),
-			     (u8 *)&ram_reserved_size, 4) != 0) {
-		ath6kl_err("bmi_write_memory for hi_end_ram_reserve_sz failed\n");
-		return -EIO;
-	}
-
-	/* set the block size for the target */
-	if (ath6kl_set_htc_params(ar, MBOX_YIELD_LIMIT, 0))
-		/* use default number of control buffers */
-		return -EIO;
-
-	/* Configure GPIO AR600x UART */
-	param = ar->hw.uarttx_pin;
-	status = ath6kl_bmi_write(ar,
-				ath6kl_get_hi_item_addr(ar,
-				HI_ITEM(hi_dbg_uart_txpin)),
-				(u8 *)&param, 4);
-	if (status)
-		return status;
-
-	/* Configure target refclk_hz */
-	param =  ar->hw.refclk_hz;
-	status = ath6kl_bmi_write(ar,
-				ath6kl_get_hi_item_addr(ar,
-				HI_ITEM(hi_refclk_hz)),
-				(u8 *)&param, 4);
-	if (status)
-		return status;
-
-	return 0;
-}
-
-void ath6kl_core_free(struct ath6kl *ar)
-{
-	wiphy_free(ar->wiphy);
-}
-
-void ath6kl_core_cleanup(struct ath6kl *ar)
-{
-	ath6kl_hif_power_off(ar);
-
-	ath6kl_recovery_cleanup(ar);
-
-	destroy_workqueue(ar->ath6kl_wq);
-
-	if (ar->htc_target)
-		ath6kl_htc_cleanup(ar->htc_target);
-
-	ath6kl_cookie_cleanup(ar);
-
-	ath6kl_cleanup_amsdu_rxbufs(ar);
-
-	ath6kl_bmi_cleanup(ar);
-
-	ath6kl_debug_cleanup(ar);
-
-	kfree(ar->fw_board);
-	kfree(ar->fw_otp);
-	vfree(ar->fw);
-	kfree(ar->fw_patch);
-	kfree(ar->fw_testscript);
-
-	ath6kl_deinit_ieee80211_hw(ar);
-}
-
-/* firmware upload */
-static int ath6kl_get_fw(struct ath6kl *ar, const char *filename,
-			 u8 **fw, size_t *fw_len)
-{
-	const struct firmware *fw_entry;
-	int ret;
-
-	ret = request_firmware(&fw_entry, filename, ar->dev);
-	if (ret)
-		return ret;
-
-	*fw_len = fw_entry->size;
-	*fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
-
-	if (*fw == NULL)
-		ret = -ENOMEM;
-
-	release_firmware(fw_entry);
-
-	return ret;
-}
-
-#if 0
-#ifdef CONFIG_OF
-/*
- * Check the device tree for a board-id and use it to construct
- * the pathname to the firmware file.  Used (for now) to find a
- * fallback to the "bdata.bin" file--typically a symlink to the
- * appropriate board-specific file.
- */
-static bool check_device_tree(struct ath6kl *ar)
-{
-	static const char *board_id_prop = "atheros,board-id";
-	struct device_node *node;
-	char board_filename[64];
-	const char *board_id;
-	int ret;
-
-	for_each_compatible_node(node, NULL, "atheros,ath6kl") {
-		board_id = of_get_property(node, board_id_prop, NULL);
-		if (board_id == NULL) {
-			ath6kl_warn("No \"%s\" property on %s node.\n",
-				    board_id_prop, node->name);
-			continue;
-		}
-		snprintf(board_filename, sizeof(board_filename),
-			 "%s/bdata.%s.bin", ar->hw.fw.dir, board_id);
-
-		ret = ath6kl_get_fw(ar, board_filename, &ar->fw_board,
-				    &ar->fw_board_len);
-		if (ret) {
-			ath6kl_err("Failed to get DT board file %s: %d\n",
-				   board_filename, ret);
-			continue;
-		}
-		return true;
-	}
-	return false;
-}
-#else
-static bool check_device_tree(struct ath6kl *ar)
-{
-	return false;
-}
-#endif /* CONFIG_OF */
-#endif
-static int ath6kl_fetch_board_file(struct ath6kl *ar)
-{
-	const char *filename;
-	int ret;
-
-	if (ar->fw_board != NULL)
-		return 0;
-
-	if (WARN_ON(ar->hw.fw_board == NULL))
-		return -EINVAL;
-
-	filename = ar->hw.fw_board;
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw_board,
-			    &ar->fw_board_len);
-	if (ret == 0) {
-		/* managed to get proper board file */
-		return 0;
-	}
-#if 0
-	if (check_device_tree(ar)) {
-		/* got board file from device tree */
-		return 0;
-	}
-#endif
-	/* there was no proper board file, try to use default instead */
-	ath6kl_warn("Failed to get board file %s (%d), trying to find default board file.\n",
-		    filename, ret);
-
-	filename = ar->hw.fw_default_board;
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw_board,
-			    &ar->fw_board_len);
-	if (ret) {
-		ath6kl_err("Failed to get default board file %s: %d\n",
-			   filename, ret);
-		return ret;
-	}
-
-	ath6kl_warn("WARNING! No proper board file was not found, instead using a default board file.\n");
-	ath6kl_warn("Most likely your hardware won't work as specified. Install correct board file!\n");
-
-	return 0;
-}
-
-static int ath6kl_fetch_otp_file(struct ath6kl *ar)
-{
-	char filename[100];
-	int ret;
-
-	if (ar->fw_otp != NULL)
-		return 0;
-
-	if (ar->hw.fw.otp == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_BOOT,
-			   "no OTP file configured for this hw\n");
-		return 0;
-	}
-
-	snprintf(filename, sizeof(filename), "%s/%s",
-		 ar->hw.fw.dir, ar->hw.fw.otp);
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw_otp,
-			    &ar->fw_otp_len);
-	if (ret) {
-		ath6kl_err("Failed to get OTP file %s: %d\n",
-			   filename, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_fetch_testmode_file(struct ath6kl *ar)
-{
-	char filename[100];
-	int ret;
-
-	if (testmode == 0)
-		return 0;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "testmode %d\n", testmode);
-
-	if (testmode == 2) {
-		if (ar->hw.fw.utf == NULL) {
-			ath6kl_warn("testmode 2 not supported\n");
-			return -EOPNOTSUPP;
-		}
-
-		snprintf(filename, sizeof(filename), "%s/%s",
-			 ar->hw.fw.dir, ar->hw.fw.utf);
-	} else {
-		if (ar->hw.fw.tcmd == NULL) {
-			ath6kl_warn("testmode 1 not supported\n");
-			return -EOPNOTSUPP;
-		}
-
-		snprintf(filename, sizeof(filename), "%s/%s",
-			 ar->hw.fw.dir, ar->hw.fw.tcmd);
-	}
-
-	set_bit(TESTMODE, &ar->flag);
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw, &ar->fw_len);
-	if (ret) {
-		ath6kl_err("Failed to get testmode %d firmware file %s: %d\n",
-			   testmode, filename, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_fetch_fw_file(struct ath6kl *ar)
-{
-	char filename[100];
-	int ret;
-
-	if (ar->fw != NULL)
-		return 0;
-
-	/* FIXME: remove WARN_ON() as we won't support FW API 1 for long */
-	if (WARN_ON(ar->hw.fw.fw == NULL))
-		return -EINVAL;
-
-	snprintf(filename, sizeof(filename), "%s/%s",
-		 ar->hw.fw.dir, ar->hw.fw.fw);
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw, &ar->fw_len);
-	if (ret) {
-		ath6kl_err("Failed to get firmware file %s: %d\n",
-			   filename, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_fetch_patch_file(struct ath6kl *ar)
-{
-	char filename[100];
-	int ret;
-
-	if (ar->fw_patch != NULL)
-		return 0;
-
-	if (ar->hw.fw.patch == NULL)
-		return 0;
-
-	snprintf(filename, sizeof(filename), "%s/%s",
-		 ar->hw.fw.dir, ar->hw.fw.patch);
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw_patch,
-			    &ar->fw_patch_len);
-	if (ret) {
-		ath6kl_err("Failed to get patch file %s: %d\n",
-			   filename, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_fetch_testscript_file(struct ath6kl *ar)
-{
-	char filename[100];
-	int ret;
-
-	if (testmode != 2)
-		return 0;
-
-	if (ar->fw_testscript != NULL)
-		return 0;
-
-	if (ar->hw.fw.testscript == NULL)
-		return 0;
-
-	snprintf(filename, sizeof(filename), "%s/%s",
-		ar->hw.fw.dir, ar->hw.fw.testscript);
-
-	ret = ath6kl_get_fw(ar, filename, &ar->fw_testscript,
-				&ar->fw_testscript_len);
-	if (ret) {
-		ath6kl_err("Failed to get testscript file %s: %d\n",
-			filename, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ath6kl_fetch_fw_api1(struct ath6kl *ar)
-{
-	int ret;
-
-	ret = ath6kl_fetch_otp_file(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_fetch_fw_file(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_fetch_patch_file(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_fetch_testscript_file(ar);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int ath6kl_fetch_fw_apin(struct ath6kl *ar, const char *name)
-{
-	size_t magic_len, len, ie_len;
-	const struct firmware *fw;
-	struct ath6kl_fw_ie *hdr;
-	char filename[100];
-	const u8 *data;
-	int ret, ie_id, i, index, bit;
-	__le32 *val;
-
-	snprintf(filename, sizeof(filename), "%s/%s", ar->hw.fw.dir, name);
-
-	ret = request_firmware(&fw, filename, ar->dev);
-	if (ret)
-		return ret;
-
-	data = fw->data;
-	len = fw->size;
-
-	/* magic also includes the null byte, check that as well */
-	magic_len = strlen(ATH6KL_FIRMWARE_MAGIC) + 1;
-
-	if (len < magic_len) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (memcmp(data, ATH6KL_FIRMWARE_MAGIC, magic_len) != 0) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	len -= magic_len;
-	data += magic_len;
-
-	/* loop elements */
-	while (len > sizeof(struct ath6kl_fw_ie)) {
-		/* hdr is unaligned! */
-		hdr = (struct ath6kl_fw_ie *) data;
-
-		ie_id = le32_to_cpup(&hdr->id);
-		ie_len = le32_to_cpup(&hdr->len);
-
-		len -= sizeof(*hdr);
-		data += sizeof(*hdr);
-
-		if (len < ie_len) {
-			ret = -EINVAL;
-			goto out;
-		}
-
-		switch (ie_id) {
-		case ATH6KL_FW_IE_FW_VERSION:
-			strlcpy(ar->wiphy->fw_version, data,
-				sizeof(ar->wiphy->fw_version));
-
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found fw version %s\n",
-				    ar->wiphy->fw_version);
-			break;
-		case ATH6KL_FW_IE_OTP_IMAGE:
-			ath6kl_dbg(ATH6KL_DBG_BOOT, "found otp image ie (%zd B)\n",
-				ie_len);
-
-			ar->fw_otp = kmemdup(data, ie_len, GFP_KERNEL);
-
-			if (ar->fw_otp == NULL) {
-				ret = -ENOMEM;
-				goto out;
-			}
-
-			ar->fw_otp_len = ie_len;
-			break;
-		case ATH6KL_FW_IE_FW_IMAGE:
-			ath6kl_dbg(ATH6KL_DBG_BOOT, "found fw image ie (%zd B)\n",
-				ie_len);
-
-			/* in testmode we already might have a fw file */
-			if (ar->fw != NULL)
-				break;
-
-			ar->fw = vmalloc(ie_len);
-
-			if (ar->fw == NULL) {
-				ret = -ENOMEM;
-				goto out;
-			}
-
-			memcpy(ar->fw, data, ie_len);
-			ar->fw_len = ie_len;
-			break;
-		case ATH6KL_FW_IE_PATCH_IMAGE:
-			ath6kl_dbg(ATH6KL_DBG_BOOT, "found patch image ie (%zd B)\n",
-				ie_len);
-
-			ar->fw_patch = kmemdup(data, ie_len, GFP_KERNEL);
-
-			if (ar->fw_patch == NULL) {
-				ret = -ENOMEM;
-				goto out;
-			}
-
-			ar->fw_patch_len = ie_len;
-			break;
-		case ATH6KL_FW_IE_RESERVED_RAM_SIZE:
-			val = (__le32 *) data;
-			ar->hw.reserved_ram_size = le32_to_cpup(val);
-
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found reserved ram size ie 0x%d\n",
-				   ar->hw.reserved_ram_size);
-			break;
-		case ATH6KL_FW_IE_CAPABILITIES:
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found firmware capabilities ie (%zd B)\n",
-				   ie_len);
-
-			for (i = 0; i < ATH6KL_FW_CAPABILITY_MAX; i++) {
-				index = i / 8;
-				bit = i % 8;
-
-				if (index == ie_len)
-					break;
-
-				if (data[index] & (1 << bit))
-					__set_bit(i, ar->fw_capabilities);
-			}
-
-			ath6kl_dbg_dump(ATH6KL_DBG_BOOT, "capabilities", "",
-					ar->fw_capabilities,
-					sizeof(ar->fw_capabilities));
-			break;
-		case ATH6KL_FW_IE_PATCH_ADDR:
-			if (ie_len != sizeof(*val))
-				break;
-
-			val = (__le32 *) data;
-			ar->hw.dataset_patch_addr = le32_to_cpup(val);
-
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found patch address ie 0x%x\n",
-				   ar->hw.dataset_patch_addr);
-			break;
-		case ATH6KL_FW_IE_BOARD_ADDR:
-			if (ie_len != sizeof(*val))
-				break;
-
-			val = (__le32 *) data;
-			ar->hw.board_addr = le32_to_cpup(val);
-
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found board address ie 0x%x\n",
-				   ar->hw.board_addr);
-			break;
-		case ATH6KL_FW_IE_VIF_MAX:
-			if (ie_len != sizeof(*val))
-				break;
-
-			val = (__le32 *) data;
-			ar->vif_max = min_t(unsigned int, le32_to_cpup(val),
-					    ATH6KL_VIF_MAX);
-
-			if (ar->vif_max > 1 && !ar->p2p)
-				ar->max_norm_iface = 2;
-
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "found vif max ie %d\n", ar->vif_max);
-			break;
-		default:
-			ath6kl_dbg(ATH6KL_DBG_BOOT, "Unknown fw ie: %u\n",
-				   le32_to_cpup(&hdr->id));
-			break;
-		}
-
-		len -= ie_len;
-		data += ie_len;
-	};
-
-	__set_bit(ATH6KL_FW_CAPABILITY_MAC_ACL, ar->fw_capabilities);
-
-	ret = 0;
-out:
-	release_firmware(fw);
-
-	return ret;
-}
-
-static int ath6kl_fetch_firmwares(struct ath6kl *ar)
-{
-	int ret;
-
-	ret = ath6kl_fetch_board_file(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_fetch_testmode_file(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API4_FILE);
-	if (ret == 0) {
-		ar->fw_api = 4;
-		goto out;
-	}
-
-	ret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API3_FILE);
-	if (ret == 0) {
-		ar->fw_api = 3;
-		goto out;
-	}
-
-	ret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API2_FILE);
-	if (ret == 0) {
-		ar->fw_api = 2;
-		goto out;
-	}
-
-	ret = ath6kl_fetch_fw_api1(ar);
-	if (ret)
-		return ret;
-
-	ar->fw_api = 1;
-
-out:
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "using fw api %d\n", ar->fw_api);
-
-	return 0;
-}
-
-static int ath6kl_upload_board_file(struct ath6kl *ar)
-{
-	u32 board_address, board_ext_address, param;
-	u32 board_data_size, board_ext_data_size;
-	int ret;
-
-	if (WARN_ON(ar->fw_board == NULL))
-		return -ENOENT;
-
-	/*
-	 * Determine where in Target RAM to write Board Data.
-	 * For AR6004, host determine Target RAM address for
-	 * writing board data.
-	 */
-	if (ar->hw.board_addr != 0) {
-		board_address = ar->hw.board_addr;
-		ath6kl_bmi_write(ar,
-				ath6kl_get_hi_item_addr(ar,
-				HI_ITEM(hi_board_data)),
-				(u8 *) &board_address, 4);
-	} else {
-		ath6kl_bmi_read(ar,
-				ath6kl_get_hi_item_addr(ar,
-				HI_ITEM(hi_board_data)),
-				(u8 *) &board_address, 4);
-	}
-
-	/* determine where in target ram to write extended board data */
-	ath6kl_bmi_read(ar,
-			ath6kl_get_hi_item_addr(ar,
-			HI_ITEM(hi_board_ext_data)),
-			(u8 *) &board_ext_address, 4);
-
-	if (ar->target_type == TARGET_TYPE_AR6003 &&
-	    board_ext_address == 0) {
-		ath6kl_err("Failed to get board file target address.\n");
-		return -EINVAL;
-	}
-
-	switch (ar->target_type) {
-	case TARGET_TYPE_AR6003:
-		board_data_size = AR6003_BOARD_DATA_SZ;
-		board_ext_data_size = AR6003_BOARD_EXT_DATA_SZ;
-		if (ar->fw_board_len > (board_data_size + board_ext_data_size))
-			board_ext_data_size = AR6003_BOARD_EXT_DATA_SZ_V2;
-		break;
-	case TARGET_TYPE_AR6004:
-		board_data_size = AR6004_BOARD_DATA_SZ;
-		board_ext_data_size = AR6004_BOARD_EXT_DATA_SZ;
-		break;
-	default:
-		WARN_ON(1);
-		return -EINVAL;
-		break;
-	}
-
-	if (board_ext_address &&
-	    ar->fw_board_len == (board_data_size + board_ext_data_size)) {
-
-		/* write extended board data */
-		ath6kl_dbg(ATH6KL_DBG_BOOT,
-			   "writing extended board data to 0x%x (%d B)\n",
-			   board_ext_address, board_ext_data_size);
-
-		ret = ath6kl_bmi_write(ar, board_ext_address,
-				       ar->fw_board + board_data_size,
-				       board_ext_data_size);
-		if (ret) {
-			ath6kl_err("Failed to write extended board data: %d\n",
-				   ret);
-			return ret;
-		}
-
-		/* record that extended board data is initialized */
-		param = (board_ext_data_size << 16) | 1;
-
-		ath6kl_bmi_write(ar,
-				 ath6kl_get_hi_item_addr(ar,
-				 HI_ITEM(hi_board_ext_data_config)),
-				 (unsigned char *) &param, 4);
-	}
-
-	if (ar->fw_board_len < board_data_size) {
-		ath6kl_err("Too small board file: %zu\n", ar->fw_board_len);
-		ret = -EINVAL;
-		return ret;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "writing board file to 0x%x (%d B)\n",
-		   board_address, board_data_size);
-
-	ret = ath6kl_bmi_write(ar, board_address, ar->fw_board,
-			       board_data_size);
-
-	if (ret) {
-		ath6kl_err("Board file bmi write failed: %d\n", ret);
-		return ret;
-	}
-
-	/* record the fact that Board Data IS initialized */
-	param = 1;
-	ath6kl_bmi_write(ar,
-			 ath6kl_get_hi_item_addr(ar,
-			 HI_ITEM(hi_board_data_initialized)),
-			 (u8 *)&param, 4);
-
-	return ret;
-}
-
-static int ath6kl_upload_otp(struct ath6kl *ar)
-{
-	u32 address, param;
-	bool from_hw = false;
-	int ret;
-
-	if (ar->fw_otp == NULL)
-		return 0;
-
-	address = ar->hw.app_load_addr;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "writing otp to 0x%x (%zd B)\n", address,
-		   ar->fw_otp_len);
-
-	ret = ath6kl_bmi_fast_download(ar, address, ar->fw_otp,
-				       ar->fw_otp_len);
-	if (ret) {
-		ath6kl_err("Failed to upload OTP file: %d\n", ret);
-		return ret;
-	}
-
-	/* read firmware start address */
-	ret = ath6kl_bmi_read(ar,
-			      ath6kl_get_hi_item_addr(ar,
-						      HI_ITEM(hi_app_start)),
-			      (u8 *) &address, sizeof(address));
-
-	if (ret) {
-		ath6kl_err("Failed to read hi_app_start: %d\n", ret);
-		return ret;
-	}
-
-	if (ar->hw.app_start_override_addr == 0) {
-		ar->hw.app_start_override_addr = address;
-		from_hw = true;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "app_start_override_addr%s 0x%x\n",
-		   from_hw ? " (from hw)" : "",
-		   ar->hw.app_start_override_addr);
-
-	/* execute the OTP code */
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "executing OTP at 0x%x\n",
-		   ar->hw.app_start_override_addr);
-
-#ifdef CONFIG_MACH_PX
-	/* SOFTMAC has higher priority than OTP MAC */
-	param = 1;
-#else
-	param = 0;
-#endif
-
-	ath6kl_bmi_execute(ar, ar->hw.app_start_override_addr, &param);
-
-	return ret;
-}
-
-static int ath6kl_upload_firmware(struct ath6kl *ar)
-{
-	u32 address;
-	int ret;
-
-	if (WARN_ON(ar->fw == NULL))
-		return 0;
-
-	address = ar->hw.app_load_addr;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "writing firmware to 0x%x (%zd B)\n",
-		   address, ar->fw_len);
-
-	ret = ath6kl_bmi_fast_download(ar, address, ar->fw, ar->fw_len);
-
-	if (ret) {
-		ath6kl_err("Failed to write firmware: %d\n", ret);
-		return ret;
-	}
-
-	/*
-	 * Set starting address for firmware
-	 * Don't need to setup app_start override addr on AR6004
-	 */
-	if (ar->target_type != TARGET_TYPE_AR6004) {
-		address = ar->hw.app_start_override_addr;
-		ath6kl_bmi_set_app_start(ar, address);
-	}
-	return ret;
-}
-
-static int ath6kl_upload_patch(struct ath6kl *ar)
-{
-	u32 address, param;
-	int ret;
-
-	if (ar->fw_patch == NULL)
-		return 0;
-
-	address = ar->hw.dataset_patch_addr;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "writing patch to 0x%x (%zd B)\n",
-		   address, ar->fw_patch_len);
-
-	ret = ath6kl_bmi_write(ar, address, ar->fw_patch, ar->fw_patch_len);
-	if (ret) {
-		ath6kl_err("Failed to write patch file: %d\n", ret);
-		return ret;
-	}
-
-	param = address;
-	ath6kl_bmi_write(ar,
-			 ath6kl_get_hi_item_addr(ar,
-			 HI_ITEM(hi_dset_list_head)),
-			 (unsigned char *) &param, 4);
-
-	return 0;
-}
-
-static int ath6kl_upload_testscript(struct ath6kl *ar)
-{
-	u32 address, param;
-	int ret;
-
-	if (testmode != 2)
-		return 0;
-
-	if (ar->fw_testscript == NULL)
-		return 0;
-
-	address = ar->hw.testscript_addr;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "writing testscript to 0x%x (%zd B)\n",
-		address, ar->fw_testscript_len);
-
-	ret = ath6kl_bmi_write(ar, address, ar->fw_testscript,
-		ar->fw_testscript_len);
-	if (ret) {
-		ath6kl_err("Failed to write testscript file: %d\n", ret);
-		return ret;
-	}
-
-	param = address;
-	ath6kl_bmi_write(ar,
-			ath6kl_get_hi_item_addr(ar,
-			HI_ITEM(hi_ota_testscript)),
-			(unsigned char *) &param, 4);
-
-	param = 4096;
-	ath6kl_bmi_write(ar,
-			ath6kl_get_hi_item_addr(ar,
-			HI_ITEM(hi_end_ram_reserve_sz)),
-			(unsigned char *) &param, 4);
-
-	param = 1;
-	ath6kl_bmi_write(ar,
-			ath6kl_get_hi_item_addr(ar,
-			HI_ITEM(hi_test_apps_related)),
-			(unsigned char *) &param, 4);
-
-	return 0;
-}
-
-static int ath6kl_init_upload(struct ath6kl *ar)
-{
-	u32 param, options, sleep, address;
-	int status = 0;
-
-	if (ar->target_type != TARGET_TYPE_AR6003 &&
-		ar->target_type != TARGET_TYPE_AR6004)
-		return -EINVAL;
-
-	/* temporarily disable system sleep */
-	address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;
-	status = ath6kl_bmi_reg_read(ar, address, &param);
-	if (status)
-		return status;
-
-	options = param;
-
-	param |= ATH6KL_OPTION_SLEEP_DISABLE;
-	status = ath6kl_bmi_reg_write(ar, address, param);
-	if (status)
-		return status;
-
-	address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;
-	status = ath6kl_bmi_reg_read(ar, address, &param);
-	if (status)
-		return status;
-
-	sleep = param;
-
-	param |= SM(SYSTEM_SLEEP_DISABLE, 1);
-	status = ath6kl_bmi_reg_write(ar, address, param);
-	if (status)
-		return status;
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "old options: %d, old sleep: %d\n",
-		   options, sleep);
-
-	/* program analog PLL register */
-	/* no need to control 40/44MHz clock on AR6004 */
-	if (ar->target_type != TARGET_TYPE_AR6004) {
-		status = ath6kl_bmi_reg_write(ar, ATH6KL_ANALOG_PLL_REGISTER,
-					      0xF9104001);
-
-		if (status)
-			return status;
-
-		/* Run at 80/88MHz by default */
-		param = SM(CPU_CLOCK_STANDARD, 1);
-
-		address = RTC_BASE_ADDRESS + CPU_CLOCK_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-	}
-
-	param = 0;
-	address = RTC_BASE_ADDRESS + LPO_CAL_ADDRESS;
-	param = SM(LPO_CAL_ENABLE, 1);
-	status = ath6kl_bmi_reg_write(ar, address, param);
-	if (status)
-		return status;
-
-	/* WAR to avoid SDIO CRC err */
-	if (ar->version.target_ver == AR6003_HW_2_0_VERSION ||
-	    ar->version.target_ver == AR6003_HW_2_1_1_VERSION) {
-		ath6kl_err("temporary war to avoid sdio crc error\n");
-
-		param = 0x28;
-		address = GPIO_BASE_ADDRESS + GPIO_PIN9_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-
-		param = 0x20;
-
-		address = GPIO_BASE_ADDRESS + GPIO_PIN10_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-
-		address = GPIO_BASE_ADDRESS + GPIO_PIN11_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-
-		address = GPIO_BASE_ADDRESS + GPIO_PIN12_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-
-		address = GPIO_BASE_ADDRESS + GPIO_PIN13_ADDRESS;
-		status = ath6kl_bmi_reg_write(ar, address, param);
-		if (status)
-			return status;
-	}
-
-	ath6kl_bmi_reg_write(ar, 0x540678, ar6k_clock);
-
-	/* write EEPROM data to Target RAM */
-	status = ath6kl_upload_board_file(ar);
-	if (status)
-		return status;
-
-	/* transfer One time Programmable data */
-	status = ath6kl_upload_otp(ar);
-	if (status)
-		return status;
-
-	/* Download Target firmware */
-	status = ath6kl_upload_firmware(ar);
-	if (status)
-		return status;
-
-	status = ath6kl_upload_patch(ar);
-	if (status)
-		return status;
-
-	/* Download the test script */
-	status = ath6kl_upload_testscript(ar);
-	if (status)
-		return status;
-
-	/* Restore system sleep */
-	address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;
-	status = ath6kl_bmi_reg_write(ar, address, sleep);
-	if (status)
-		return status;
-
-	address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;
-	param = options & ~0x20; /* enable ANI */
-	status = ath6kl_bmi_reg_write(ar, address, param);
-	if (status)
-		return status;
-
-	return status;
-}
-
-static int ath6kl_init_hw_params(struct ath6kl *ar)
-{
-	const struct ath6kl_hw *hw;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(hw_list); i++) {
-		hw = &hw_list[i];
-
-		if (hw->id == ar->version.target_ver)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(hw_list)) {
-		ath6kl_err("Unsupported hardware version: 0x%x\n",
-			   ar->version.target_ver);
-		return -EINVAL;
-	}
-
-	ar->hw = *hw;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "target_ver 0x%x target_type 0x%x dataset_patch 0x%x app_load_addr 0x%x\n",
-		   ar->version.target_ver, ar->target_type,
-		   ar->hw.dataset_patch_addr, ar->hw.app_load_addr);
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "app_start_override_addr 0x%x board_ext_data_addr 0x%x reserved_ram_size 0x%x",
-		   ar->hw.app_start_override_addr, ar->hw.board_ext_data_addr,
-		   ar->hw.reserved_ram_size);
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "refclk_hz %d uarttx_pin %d",
-		   ar->hw.refclk_hz, ar->hw.uarttx_pin);
-
-	return 0;
-}
-
-static const char *ath6kl_init_get_hif_name(enum ath6kl_hif_type type)
-{
-	switch (type) {
-	case ATH6KL_HIF_TYPE_SDIO:
-		return "sdio";
-	case ATH6KL_HIF_TYPE_USB:
-		return "usb";
-	}
-
-	return NULL;
-}
-
-static int __ath6kl_init_hw_start(struct ath6kl *ar)
-{
-	long timeleft;
-	int ret, i;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "hw start\n");
-
-	ret = ath6kl_hif_power_on(ar);
-	if (ret)
-		return ret;
-
-	ret = ath6kl_configure_target(ar);
-	if (ret)
-		goto err_power_off;
-
-	ret = ath6kl_init_upload(ar);
-	if (ret)
-		goto err_power_off;
-
-	/* Do we need to finish the BMI phase */
-	/* FIXME: return error from ath6kl_bmi_done() */
-	if (ath6kl_bmi_done(ar)) {
-		ret = -EIO;
-		goto err_power_off;
-	}
-
-	/*
-	 * The reason we have to wait for the target here is that the
-	 * driver layer has to init BMI in order to set the host block
-	 * size.
-	 */
-	if (ath6kl_htc_wait_target(ar->htc_target)) {
-		ret = -EIO;
-		goto err_power_off;
-	}
-
-	if (ath6kl_init_service_ep(ar)) {
-		ret = -EIO;
-		goto err_cleanup_scatter;
-	}
-
-	/* setup credit distribution */
-	ath6kl_credit_setup(ar->htc_target, &ar->credit_state_info);
-
-	/* start HTC */
-	ret = ath6kl_htc_start(ar->htc_target);
-	if (ret) {
-		/* FIXME: call this */
-		ath6kl_cookie_cleanup(ar);
-		goto err_cleanup_scatter;
-	}
-
-	/* Wait for Wmi event to be ready */
-	timeleft = wait_event_interruptible_timeout(ar->event_wq,
-						    test_bit(WMI_READY,
-							     &ar->flag),
-						    WMI_TIMEOUT);
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "firmware booted\n");
-
-
-	if (test_and_clear_bit(FIRST_BOOT, &ar->flag)) {
-		ath6kl_info("%s %s fw %s api %d%s\n",
-			    ar->hw.name,
-			    ath6kl_init_get_hif_name(ar->hif_type),
-			    ar->wiphy->fw_version,
-			    ar->fw_api,
-			    test_bit(TESTMODE, &ar->flag) ? " testmode" : "");
-	}
-
-	if (ar->version.abi_ver != ATH6KL_ABI_VERSION) {
-		ath6kl_err("abi version mismatch: host(0x%x), target(0x%x)\n",
-			   ATH6KL_ABI_VERSION, ar->version.abi_ver);
-		ret = -EIO;
-		goto err_htc_stop;
-	}
-
-	if (!timeleft || signal_pending(current)) {
-		clear_bit(WMI_READY, &ar->flag);
-		ath6kl_err("wmi is not ready or wait was interrupted\n");
-		ret = -EIO;
-		goto err_htc_stop;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: wmi is ready\n", __func__);
-
-	/* communicate the wmi protocol verision to the target */
-	/* FIXME: return error */
-	if ((ath6kl_set_host_app_area(ar)) != 0)
-		ath6kl_err("unable to set the host app area\n");
-
-	for (i = 0; i < ar->vif_max; i++) {
-		ret = ath6kl_target_config_wlan_params(ar, i);
-		if (ret)
-			goto err_htc_stop;
-	}
-
-	return 0;
-
-err_htc_stop:
-	ath6kl_htc_stop(ar->htc_target);
-err_cleanup_scatter:
-	ath6kl_hif_cleanup_scatter(ar);
-err_power_off:
-	ath6kl_hif_power_off(ar);
-
-	return ret;
-}
-
-int ath6kl_init_hw_start(struct ath6kl *ar)
-{
-	int err;
-
-	err = __ath6kl_init_hw_start(ar);
-	if (err)
-		return err;
-	ar->state = ATH6KL_STATE_ON;
-	return 0;
-}
-
-static int __ath6kl_init_hw_stop(struct ath6kl *ar)
-{
-	int ret;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "hw stop\n");
-
-	ath6kl_htc_stop(ar->htc_target);
-
-	ath6kl_hif_stop(ar);
-
-	ath6kl_bmi_reset(ar);
-
-	ret = ath6kl_hif_power_off(ar);
-	if (ret)
-		ath6kl_warn("failed to power off hif: %d\n", ret);
-
-	return 0;
-}
-
-int ath6kl_init_hw_stop(struct ath6kl *ar)
-{
-	int err;
-
-	err = __ath6kl_init_hw_stop(ar);
-	if (err)
-		return err;
-	ar->state = ATH6KL_STATE_OFF;
-	return 0;
-}
-
-int ath6kl_core_init(struct ath6kl *ar)
-{
-	struct ath6kl_bmi_target_info targ_info;
-	struct net_device *ndev;
-	int ret = 0, i;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-	struct net_device *ndev_p2p0;
-#endif
-	ar->ath6kl_wq = create_singlethread_workqueue("ath6kl");
-	if (!ar->ath6kl_wq)
-		return -ENOMEM;
-
-	ret = ath6kl_bmi_init(ar);
-	if (ret)
-		goto err_wq;
-
-	/*
-	 * Turn on power to get hardware (target) version and leave power
-	 * on delibrately as we will boot the hardware anyway within few
-	 * seconds.
-	 */
-	ret = ath6kl_hif_power_on(ar);
-	if (ret)
-		goto err_bmi_cleanup;
-
-	ret = ath6kl_bmi_get_target_info(ar, &targ_info);
-	if (ret)
-		goto err_power_off;
-
-	ar->version.target_ver = le32_to_cpu(targ_info.version);
-	ar->target_type = le32_to_cpu(targ_info.type);
-	ar->wiphy->hw_version = le32_to_cpu(targ_info.version);
-
-	ret = ath6kl_init_hw_params(ar);
-	if (ret)
-		goto err_power_off;
-
-	ar->htc_target = ath6kl_htc_create(ar);
-
-	if (!ar->htc_target) {
-		ret = -ENOMEM;
-		goto err_power_off;
-	}
-
-	ret = ath6kl_fetch_firmwares(ar);
-	if (ret)
-		goto err_htc_cleanup;
-	ath6kl_mangle_mac_address(ar, locally_administered_bit);
-
-	/* FIXME: we should free all firmwares in the error cases below */
-
-	/* Indicate that WMI is enabled (although not ready yet) */
-	set_bit(WMI_ENABLED, &ar->flag);
-	ar->wmi = ath6kl_wmi_init(ar);
-	if (!ar->wmi) {
-		ath6kl_err("failed to initialize wmi\n");
-		ret = -EIO;
-		goto err_htc_cleanup;
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: got wmi @ 0x%p.\n", __func__, ar->wmi);
-
-	ret = ath6kl_register_ieee80211_hw(ar);
-	if (ret)
-		goto err_node_cleanup;
-
-	ret = ath6kl_debug_init(ar);
-	if (ret) {
-		wiphy_unregister(ar->wiphy);
-		goto err_node_cleanup;
-	}
-
-	for (i = 0; i < ar->vif_max; i++)
-		ar->avail_idx_map |= BIT(i);
-
-	rtnl_lock();
-
-	/* Add an initial station interface */
-	ndev = ath6kl_interface_add(ar, "wlan%d", NL80211_IFTYPE_STATION, 0,
-				    INFRA_NETWORK);
-
-	rtnl_unlock();
-
-	if (!ndev) {
-		ath6kl_err("Failed to instantiate a network device\n");
-		ret = -ENOMEM;
-		wiphy_unregister(ar->wiphy);
-		goto err_debug_init;
-	}
-
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "%s: name=%s dev=0x%p, ar=0x%p\n",
-			__func__, ndev->name, ndev, ar);
-
-	/* setup access class priority mappings */
-	ar->ac_stream_pri_map[WMM_AC_BK] = 0; /* lowest  */
-	ar->ac_stream_pri_map[WMM_AC_BE] = 1;
-	ar->ac_stream_pri_map[WMM_AC_VI] = 2;
-	ar->ac_stream_pri_map[WMM_AC_VO] = 3; /* highest */
-
-	/* allocate some buffers that handle larger AMSDU frames */
-	ath6kl_refill_amsdu_rxbufs(ar, ATH6KL_MAX_AMSDU_RX_BUFFERS);
-
-	ath6kl_cookie_init(ar);
-
-	ar->conf_flags = ATH6KL_CONF_IGNORE_ERP_BARKER |
-			 ATH6KL_CONF_ENABLE_11N | ATH6KL_CONF_ENABLE_TX_BURST;
-
-	if (suspend_mode &&
-	     suspend_mode >= WLAN_POWER_STATE_CUT_PWR &&
-	     suspend_mode <= WLAN_POWER_STATE_WOW)
-		ar->suspend_mode = suspend_mode;
-	else
-		ar->suspend_mode = 0;
-
-	if (suspend_mode == WLAN_POWER_STATE_WOW &&
-	    (wow_mode == WLAN_POWER_STATE_CUT_PWR ||
-	     wow_mode == WLAN_POWER_STATE_DEEP_SLEEP))
-		ar->wow_suspend_mode = wow_mode;
-	else
-		ar->wow_suspend_mode = 0;
-
-	ar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM |
-			    WIPHY_FLAG_HAVE_AP_SME |
-			    WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |
-			    WIPHY_FLAG_SUPPORTS_ACS;
-
-	if (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, ar->fw_capabilities))
-		ar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
-
-	ar->wiphy->probe_resp_offload =
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P |
-		NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U;
-
-	set_bit(FIRST_BOOT, &ar->flag);
-
-	ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
-
-	ret = ath6kl_init_hw_start(ar);
-	if (ret) {
-		ath6kl_err("Failed to start hardware: %d\n", ret);
-		goto err_rxbuf_cleanup;
-	}
-
-	/* give our connected endpoints some buffers */
-	ath6kl_rx_refill(ar->htc_target, ar->ctrl_ep);
-	ath6kl_rx_refill(ar->htc_target, ar->ac2ep_map[WMM_AC_BE]);
-
-	/*
-	 * Set mac address which is received in ready event
-	 * FIXME: Move to ath6kl_interface_add()
-	 */
-	memcpy(ndev->dev_addr, ar->mac_addr, ETH_ALEN);
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-	rtnl_lock();
-	ndev_p2p0 = ath6kl_cfg80211_add_p2p0_iface(ar);
-	rtnl_unlock();
-
-	if (!ndev_p2p0) {
-		ath6kl_err("Failed to create p2p0 iface\n");
-		ret = -ENOMEM;
-		goto err_rxbuf_cleanup;
-	}
-#endif
-	if (heart_beat_poll &&
-	    test_bit(ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL,
-		     ar->fw_capabilities))
-		ar->fw_recovery.hb_poll = heart_beat_poll;
-
-	ath6kl_recovery_init(ar);
-
-	return ret;
-
-err_rxbuf_cleanup:
-	ath6kl_htc_flush_rx_buf(ar->htc_target);
-	ath6kl_cleanup_amsdu_rxbufs(ar);
-	rtnl_lock();
-	ath6kl_deinit_if_data(netdev_priv(ndev));
-	rtnl_unlock();
-	wiphy_unregister(ar->wiphy);
-err_debug_init:
-	ath6kl_debug_cleanup(ar);
-err_node_cleanup:
-	ath6kl_cleanup_android_resource(ar);
-	ath6kl_wmi_shutdown(ar->wmi);
-	clear_bit(WMI_ENABLED, &ar->flag);
-	ar->wmi = NULL;
-err_htc_cleanup:
-	ath6kl_htc_cleanup(ar->htc_target);
-err_power_off:
-	ath6kl_hif_power_off(ar);
-err_bmi_cleanup:
-	ath6kl_bmi_cleanup(ar);
-err_wq:
-	destroy_workqueue(ar->ath6kl_wq);
-
-	return ret;
-}
-
-void ath6kl_init_hw_restart(struct ath6kl *ar)
-{
-	clear_bit(WMI_READY, &ar->flag);
-
-	ath6kl_cfg80211_stop_all(ar);
-
-	if (__ath6kl_init_hw_stop(ar)) {
-		ath6kl_dbg(ATH6KL_DBG_RECOVERY, "Failed to stop during fw error recovery\n");
-		return;
-	}
-
-	if (__ath6kl_init_hw_start(ar)) {
-		ath6kl_dbg(ATH6KL_DBG_RECOVERY, "Failed to restart during fw error recovery\n");
-		return;
-	}
-}
-
-void ath6kl_cleanup_vif(struct ath6kl_vif *vif, bool wmi_ready)
-{
-	static u8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	bool discon_issued;
-
-	netif_stop_queue(vif->ndev);
-
-	clear_bit(WLAN_ENABLED, &vif->flags);
-
-	if (wmi_ready) {
-		discon_issued = test_bit(CONNECTED, &vif->flags) ||
-				test_bit(CONNECT_PEND, &vif->flags);
-		ath6kl_disconnect(vif);
-		del_timer(&vif->disconnect_timer);
-
-		if (discon_issued)
-			ath6kl_disconnect_event(vif, DISCONNECT_CMD,
-						(vif->nw_type & AP_NETWORK) ?
-						bcast_mac : vif->bssid,
-						0, NULL, 0);
-	}
-
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
-	}
-
-	/* need to clean up enhanced bmiss detection fw state */
-	ath6kl_cfg80211_sta_bmiss_enhance(vif, false);
-}
-
-void ath6kl_stop_txrx(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif, *tmp_vif;
-	int i;
-
-	set_bit(DESTROY_IN_PROGRESS, &ar->flag);
-
-	if (down_interruptible(&ar->sem)) {
-		ath6kl_err("down_interruptible failed\n");
-		return;
-	}
-
-	for (i = 0; i < AP_MAX_NUM_STA; i++)
-		aggr_reset_state(ar->sta_list[i].aggr_conn);
-
-	spin_lock_bh(&ar->list_lock);
-	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
-		list_del(&vif->list);
-		spin_unlock_bh(&ar->list_lock);
-		ath6kl_cleanup_vif(vif, test_bit(WMI_READY, &ar->flag));
-		rtnl_lock();
-		ath6kl_deinit_if_data(vif);
-		rtnl_unlock();
-		spin_lock_bh(&ar->list_lock);
-	}
-	spin_unlock_bh(&ar->list_lock);
-
-	clear_bit(WMI_READY, &ar->flag);
-
-	del_timer_sync(&ar->fw_recovery.hb_timer);
-
-	/*
-	 * After wmi_shudown all WMI events will be dropped. We
-	 * need to cleanup the buffers allocated in AP mode and
-	 * give disconnect notification to stack, which usually
-	 * happens in the disconnect_event. Simulate the disconnect
-	 * event by calling the function directly. Sometimes
-	 * disconnect_event will be received when the debug logs
-	 * are collected.
-	 */
-	ath6kl_wmi_shutdown(ar->wmi);
-
-	clear_bit(WMI_ENABLED, &ar->flag);
-	if (ar->htc_target) {
-		ath6kl_dbg(ATH6KL_DBG_TRC, "%s: shut down htc\n", __func__);
-		ath6kl_htc_stop(ar->htc_target);
-	}
-
-	/*
-	 * Try to reset the device if we can. The driver may have been
-	 * configure NOT to reset the target during a debug session.
-	 */
-	ath6kl_dbg(ATH6KL_DBG_TRC,
-			"attempting to reset target on instance destroy\n");
-	ath6kl_reset_device(ar, ar->target_type, true, true);
-
-	clear_bit(WLAN_ENABLED, &ar->flag);
-}
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c
index 635f332..2b112d5 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c
@@ -88,6 +88,8 @@ static void ath6kl_sta_cleanup(struct ath6kl *ar, u8 i)
 	spin_lock_bh(&sta->psq_lock);
 	skb_queue_purge(&sta->psq);
 	skb_queue_purge(&sta->apsdq);
+	sta->apsdq_depth = 0;
+	sta->psq_depth = 0;
 
 	if (sta->mgmt_psq_len != 0) {
 		list_for_each_entry_safe(entry, tmp, &sta->mgmt_psq, list) {
@@ -110,7 +112,7 @@ static void ath6kl_sta_cleanup(struct ath6kl *ar, u8 i)
 	aggr_reset_state(sta->aggr_conn);
 }
 
-static u8 ath6kl_remove_sta(struct ath6kl *ar, u8 *mac, u16 reason)
+u8 ath6kl_remove_sta(struct ath6kl *ar, u8 *mac, u16 reason)
 {
 	u8 i, removed = 0;
 
@@ -204,6 +206,60 @@ void ath6kl_cookie_cleanup(struct ath6kl *ar)
 	ar->wmi_cookie_count = 0;
 }
 
+void ath6kl_cookie_vif_balance_init(struct ath6kl *ar)
+{
+	int ave_cookie_vif;
+	unsigned int vif_max = ar->vif_max;
+	struct ath6kl_vif_cookie_cfg *cfg;
+
+	ave_cookie_vif = MAX_COOKIE_NUM / vif_max;
+
+	cfg = &ar->vif_cookie_cfg;
+	cfg->min_cookies = ave_cookie_vif / 16;
+	cfg->mid_cookies = ave_cookie_vif + cfg->min_cookies;
+	cfg->max_cookies = MAX_COOKIE_NUM - cfg->min_cookies * (vif_max - 1);
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "cookie:min:%d mid:%d max:%d\n",
+		   cfg->min_cookies, cfg->mid_cookies, cfg->max_cookies);
+}
+
+bool ath6kl_is_other_vif_cookie_busy(struct ath6kl *ar,
+				     struct ath6kl_vif *cur_vif)
+{
+	struct ath6kl_vif *vif, *tmp_vif;
+	struct ath6kl_vif_cookie_cfg *cfg;
+	bool busy = false;
+
+	cfg = &ar->vif_cookie_cfg;
+	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
+		if (vif == cur_vif)
+			continue;
+		if (vif->cur_data_cookies > cfg->min_cookies) {
+			busy = true;
+			break;
+		}
+	}
+
+	return busy;
+}
+
+bool ath6kl_is_other_vif_connected(struct ath6kl *ar,
+				   struct ath6kl_vif *cur_vif)
+{
+	struct ath6kl_vif *vif, *tmp_vif;
+	bool connected = false;
+
+	list_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {
+		if (vif == cur_vif)
+			continue;
+		if (test_bit(CONNECTED, &vif->flags)) {
+			connected = true;
+			break;
+		}
+	}
+
+	return connected;
+}
+
 void ath6kl_free_cookie(struct ath6kl *ar, struct ath6kl_cookie *cookie,
 			bool isctrl)
 {
@@ -478,7 +534,7 @@ void ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel)
 
 void ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,
 				u8 keymgmt, u8 ucipher, u8 auth,
-				u8 assoc_req_len, u8 *assoc_info, u8 apsd_info)
+				u16 assoc_req_len, u8 *assoc_info, u8 apsd_info)
 {
 	u8 *ies = NULL, *wpa_ie = NULL, *pos;
 	size_t ies_len = 0;
@@ -576,7 +632,8 @@ void ath6kl_disconnect(struct ath6kl_vif *vif)
 
 /* WMI Event handlers */
 
-void ath6kl_ready_event(void *devt, u8 *datap, u32 sw_ver, u32 abi_ver)
+void ath6kl_ready_event(void *devt, u8 *datap, u32 sw_ver, u32 abi_ver,
+			enum wmi_phy_cap cap)
 {
 	struct ath6kl *ar = devt;
 
@@ -588,6 +645,7 @@ void ath6kl_ready_event(void *devt, u8 *datap, u32 sw_ver, u32 abi_ver)
 
 	ar->version.wlan_ver = sw_ver;
 	ar->version.abi_ver = abi_ver;
+	ar->hw.cap = cap;
 
 	if (strlen(ar->wiphy->fw_version) == 0) {
 		snprintf(ar->wiphy->fw_version,
@@ -609,6 +667,13 @@ void ath6kl_scan_complete_evt(struct ath6kl_vif *vif, int status)
 	struct ath6kl *ar = vif->ar;
 	bool aborted = false;
 
+	if (!test_bit(ATH6KL_FW_CAPABILITY_REGDOMAIN_V2, ar->fw_capabilities)) {
+		if (test_bit(SCHED_SCANNING, &vif->flags)) {
+			/* when schedule scan, should not come here */
+			WARN_ON(1);
+		}
+	}
+
 	if (status != WMI_SCAN_STATUS_SUCCESS)
 		aborted = true;
 
@@ -679,8 +744,8 @@ static void ath6kl_check_ch_switch(struct ath6kl *ar, u16 channel)
 
 void ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel, u8 *bssid,
 			  u16 listen_int, u16 beacon_int,
-			  enum network_type net_type, u8 beacon_ie_len,
-			  u8 assoc_req_len, u8 assoc_resp_len,
+			  enum network_type net_type, u16 beacon_ie_len,
+			  u16 assoc_req_len, u16 assoc_resp_len,
 			  u8 *assoc_info)
 {
 	struct ath6kl *ar = vif->ar;
@@ -758,6 +823,7 @@ static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
 		(struct wmi_target_stats *) ptr;
 	struct ath6kl *ar = vif->ar;
 	struct target_stats *stats = &vif->target_stats;
+	struct target_stats_dup *stats_dup = &vif->target_stats_dup;
 	struct tkip_ccmp_stats *ccmp_stats;
 	u8 ac;
 
@@ -768,6 +834,7 @@ static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
 
 	stats->tx_pkt += le32_to_cpu(tgt_stats->stats.tx.pkt);
 	stats->tx_byte += le32_to_cpu(tgt_stats->stats.tx.byte);
+	stats_dup->tx_byte += le32_to_cpu(tgt_stats->stats.tx.byte);
 	stats->tx_ucast_pkt += le32_to_cpu(tgt_stats->stats.tx.ucast_pkt);
 	stats->tx_ucast_byte += le32_to_cpu(tgt_stats->stats.tx.ucast_byte);
 	stats->tx_mcast_pkt += le32_to_cpu(tgt_stats->stats.tx.mcast_pkt);
@@ -776,22 +843,37 @@ static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
 	stats->tx_bcast_byte += le32_to_cpu(tgt_stats->stats.tx.bcast_byte);
 	stats->tx_rts_success_cnt +=
 		le32_to_cpu(tgt_stats->stats.tx.rts_success_cnt);
+	stats_dup->tx_rts_success_cnt +=
+		le32_to_cpu(tgt_stats->stats.tx.rts_success_cnt);
 
-	for (ac = 0; ac < WMM_NUM_AC; ac++)
+	for (ac = 0; ac < WMM_NUM_AC; ac++) {
 		stats->tx_pkt_per_ac[ac] +=
 			le32_to_cpu(tgt_stats->stats.tx.pkt_per_ac[ac]);
+		stats_dup->tx_pkt_per_ac[ac] +=
+			le32_to_cpu(tgt_stats->stats.tx.pkt_per_ac[ac]);
+		stats_dup->tx_retry_cnt[ac] +=
+			le32_to_cpu(tgt_stats->stats.tx.retry_cnt);
+		stats_dup->tx_fail_cnt[ac] +=
+			le32_to_cpu(tgt_stats->stats.tx.fail_cnt);
+		stats_dup->tx_mult_retry_cnt[ac] +=
+			le32_to_cpu(tgt_stats->stats.tx.mult_retry_cnt);
+	}
 
 	stats->tx_err += le32_to_cpu(tgt_stats->stats.tx.err);
+	stats_dup->tx_err += le32_to_cpu(tgt_stats->stats.tx.err);
 	stats->tx_fail_cnt += le32_to_cpu(tgt_stats->stats.tx.fail_cnt);
 	stats->tx_retry_cnt += le32_to_cpu(tgt_stats->stats.tx.retry_cnt);
 	stats->tx_mult_retry_cnt +=
 		le32_to_cpu(tgt_stats->stats.tx.mult_retry_cnt);
 	stats->tx_rts_fail_cnt +=
 		le32_to_cpu(tgt_stats->stats.tx.rts_fail_cnt);
+	stats_dup->tx_rts_fail_cnt +=
+		le32_to_cpu(tgt_stats->stats.tx.rts_fail_cnt);
 	stats->tx_ucast_rate =
 	    ath6kl_wmi_get_rate(a_sle32_to_cpu(tgt_stats->stats.tx.ucast_rate));
 
 	stats->rx_pkt += le32_to_cpu(tgt_stats->stats.rx.pkt);
+	stats_dup->rx_pkt += le32_to_cpu(tgt_stats->stats.rx.pkt);
 	stats->rx_byte += le32_to_cpu(tgt_stats->stats.rx.byte);
 	stats->rx_ucast_pkt += le32_to_cpu(tgt_stats->stats.rx.ucast_pkt);
 	stats->rx_ucast_byte += le32_to_cpu(tgt_stats->stats.rx.ucast_byte);
@@ -801,11 +883,13 @@ static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
 	stats->rx_bcast_byte += le32_to_cpu(tgt_stats->stats.rx.bcast_byte);
 	stats->rx_frgment_pkt += le32_to_cpu(tgt_stats->stats.rx.frgment_pkt);
 	stats->rx_err += le32_to_cpu(tgt_stats->stats.rx.err);
+	stats_dup->rx_err += le32_to_cpu(tgt_stats->stats.rx.err);
 	stats->rx_crc_err += le32_to_cpu(tgt_stats->stats.rx.crc_err);
 	stats->rx_key_cache_miss +=
 		le32_to_cpu(tgt_stats->stats.rx.key_cache_miss);
 	stats->rx_decrypt_err += le32_to_cpu(tgt_stats->stats.rx.decrypt_err);
 	stats->rx_dupl_frame += le32_to_cpu(tgt_stats->stats.rx.dupl_frame);
+	stats_dup->rx_dupl_frame += le32_to_cpu(tgt_stats->stats.rx.dupl_frame);
 	stats->rx_ucast_rate =
 	    ath6kl_wmi_get_rate(a_sle32_to_cpu(tgt_stats->stats.rx.ucast_rate));
 
@@ -957,6 +1041,7 @@ void ath6kl_pspoll_event(struct ath6kl_vif *vif, u8 aid)
 		kfree(mgmt_buf);
 	} else {
 		skb = skb_dequeue(&conn->psq);
+		conn->psq_depth--;
 		spin_unlock_bh(&conn->psq_lock);
 
 		conn->sta_flags |= STA_PS_POLLED;
@@ -1045,6 +1130,13 @@ void ath6kl_disconnect_event(struct ath6kl_vif *vif, u8 reason, u8 *bssid,
 					     GFP_KERNEL);
 		}
 
+		if (prot_reason_status == WMI_AP_REASON_NEW_STA) {
+			/* send new client notification to user space */
+			cfg80211_conn_failed(vif->ndev, bssid,
+					     NL80211_CONN_FAIL_NEW_CLIENT,
+					     GFP_KERNEL);
+		}
+
 		if (!ath6kl_remove_sta(ar, bssid, prot_reason_status))
 			return;
 
@@ -1159,10 +1251,12 @@ static int ath6kl_open(struct net_device *dev)
 static int ath6kl_close(struct net_device *dev)
 {
 	struct ath6kl_vif *vif = netdev_priv(dev);
+	struct ath6kl *ar = vif->ar;
 
 	netif_stop_queue(dev);
 
-	ath6kl_cfg80211_stop(vif);
+	if (test_bit(WMI_READY, &ar->flag))
+		ath6kl_cfg80211_stop(vif);
 
 	clear_bit(WLAN_ENABLED, &vif->flags);
 
@@ -1336,11 +1430,283 @@ out:
 	list_splice_tail(&mc_filter_new, &vif->mc_filter);
 }
 
-static int ath6kl_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+
+static inline void ath6kl_pack_tlv(char *buf, char type, char size,
+				   char *val, int *tlen)
+{
+	if (*tlen > ATH6KL_PRI_IOCTL_REPLY_BUF_MAX)
+		return;
+
+	*buf++ = type;
+	*buf++ = size;
+	memcpy(buf, val, size);
+	*tlen += size + 2;
+}
+
+static int ath6kl_update_stats(struct ath6kl *ar, struct ath6kl_vif *vif,
+			       void __user *user_buf)
 {
+	struct target_stats_dup *stats;
+	char *buf;
+	int tlen = 0;
+	long left;
+	size_t ret;
+
+	if (down_interruptible(&ar->sem))
+		goto exit;
+
+	set_bit(STATS_UPDATE_PEND, &vif->flags);
+
+	if (ath6kl_wmi_get_stats_cmd(ar->wmi, 0)) {
+		up(&ar->sem);
+		goto exit;
+	}
+
+	left = wait_event_interruptible_timeout(ar->event_wq,
+						!test_bit(STATS_UPDATE_PEND,
+						&vif->flags), WMI_TIMEOUT);
+	up(&ar->sem);
+
+	if (left <= 0)
+		goto exit;
+
+	stats = &vif->target_stats_dup;
+
+	buf = kzalloc(ATH6KL_PRI_IOCTL_REPLY_BUF_MAX, GFP_KERNEL);
+	if (!buf)
+		goto exit;
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RETRY_CNT,
+			sizeof(stats->tx_retry_cnt),
+			(char *)&stats->tx_retry_cnt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_MUL_RETRY_CNT,
+			sizeof(stats->tx_mult_retry_cnt),
+			(char *)&stats->tx_mult_retry_cnt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_TX_FRM_CNT,
+			sizeof(stats->tx_pkt_per_ac),
+			(char *)&stats->tx_pkt_per_ac, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RX_FRM_CNT,
+			sizeof(stats->rx_pkt),
+			(char *)&stats->rx_pkt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_FRM_DUP_CNT,
+			sizeof(stats->rx_dupl_frame),
+			(char *)&stats->rx_dupl_frame, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_FAIL_CNT,
+			sizeof(stats->tx_fail_cnt),
+			(char *)&stats->tx_fail_cnt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RTS_FAIL_CNT,
+			sizeof(stats->tx_rts_fail_cnt),
+			(char *)&stats->tx_rts_fail_cnt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_ACK_FAIL_CNT,
+			sizeof(stats->tx_err),
+			(char *)&stats->tx_err, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RTS_SUC_CNT,
+			sizeof(stats->tx_rts_success_cnt),
+			(char *)&stats->tx_rts_success_cnt, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RX_DISCARD_CNT,
+			sizeof(stats->rx_err),
+			(char *)&stats->rx_err, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_RX_ERROR_CNT,
+			sizeof(stats->rx_err),
+			(char *)&stats->rx_err, &tlen);
+
+	ath6kl_pack_tlv(buf + tlen, WLAN_STATS_TX_BYTE_CNT,
+			sizeof(stats->tx_byte),
+			(char *)&stats->tx_byte, &tlen);
+
+	ret = copy_to_user(user_buf, buf, tlen);
+	if (ret)
+		ath6kl_err("failed to copy target stats to user buffer\n");
+
+	kfree(buf);
+exit:
 	return 0;
 }
 
+static int _from_hex(char c)
+{
+	int ret = 0;
+
+	if ((c >= '0') && (c <= '9'))
+		ret = (c - '0');
+	else if ((c >= 'a') && (c <= 'f'))
+		ret = (c - 'a' + 0x0a);
+	else if ((c >= 'A') && (c <= 'F'))
+		ret = (c - 'A' + 0x0A);
+
+	return ret;
+}
+
+static void hexstr_bytearray(char *hexStr, u8 *byteArray, u8 numBytes)
+{
+	u8 i;
+
+	for (i = 0; i < numBytes; i++)
+		byteArray[i] = 16 * _from_hex(hexStr[2 * i + 0]) +
+			       _from_hex(hexStr[2 * i + 1]);
+}
+
+int ath6kl_ioctl_pkt_filter_set(struct ath6kl_vif *vif,
+				char *buf,
+				int len)
+{
+	struct ath6kl *ar = vif->ar;
+	char *sptr, *token;
+	char filter[CPKT_PATTERN_SIZE], mask[CPKT_MASK_SIZE];
+	int ret;
+	u8 op, id, act, size, offset;
+
+	if (len <= 0)
+		return -EFAULT;
+
+	sptr = buf;
+
+	token = strsep(&sptr, " ");
+	if (!token || kstrtou8(token, 0, &op))
+		return -EINVAL;
+
+	token = strsep(&sptr, " ");
+	if (!token || kstrtou8(token, 0, &id))
+		return -EINVAL;
+
+	if (!op) {
+		/* del case */
+		ret = ath6kl_wmi_del_pkt_filter_pattern_cmd(ar->wmi,
+						vif->fw_vif_idx, id);
+		return ret;
+	}
+
+	/* add case */
+	token = strsep(&sptr, " ");
+	if (!token || kstrtou8(token, 0, &act))
+		return -EINVAL;
+
+	token = strsep(&sptr, " ");
+	if (!token || kstrtou8(token, 0, &size))
+		return -EINVAL;
+	if (size > CPKT_PATTERN_SIZE)
+		return -EINVAL;
+
+	token = strsep(&sptr, " ");
+	if (!token || kstrtou8(token, 0, &offset))
+		return -EINVAL;
+
+	token = strsep(&sptr, " ");
+	if (!token ||
+	    strnlen(token, CPKT_PATTERN_SIZE << 1) >> 1 != size)
+		return -EINVAL;
+	hexstr_bytearray(token, filter, size);
+
+	token = strsep(&sptr, " ");
+	if (!token ||
+	    strnlen(token, CPKT_MASK_SIZE << 1) >> 1 != size)
+		return -EINVAL;
+	hexstr_bytearray(token, mask, size);
+
+	ret = ath6kl_wmi_add_pkt_filter_pattern_cmd(ar->wmi,
+						    vif->fw_vif_idx, id,
+						    act, size, offset,
+						    filter, mask);
+
+	return ret;
+}
+
+static int ath6kl_ioctl_wext_priv(struct net_device *dev,
+				  struct ifreq *rq, int cmd)
+{
+	struct ath6kl_wifi_priv_cmd hr_cmd;
+	struct ath6kl_vif *vif = netdev_priv(dev);
+	void *data = (void *)(rq->ifr_data);
+	char *user_cmd = NULL;
+	int ret = 0, offset = 0, priv_cmd = 0;
+
+	if (copy_from_user(&hr_cmd,
+			   data,
+			   sizeof(struct ath6kl_wifi_priv_cmd)))
+		return -EIO;
+
+	if (hr_cmd.buf == NULL || hr_cmd.used_len <= 0)
+		return -EINVAL;
+
+	user_cmd = kzalloc(hr_cmd.used_len + 1, GFP_KERNEL);
+	if (!user_cmd)
+		return -ENOMEM;
+
+	if (copy_from_user(user_cmd,
+			   hr_cmd.buf,
+			   hr_cmd.used_len)) {
+		kfree(user_cmd);
+		return -EIO;
+	}
+	user_cmd[hr_cmd.used_len] = '\0';
+
+	if (0 == strncasecmp(user_cmd, "ATH6KL PKT_FILTER ", 18)) {
+		priv_cmd = ATH6KL_XIOCTL_PKT_FILTER_ADD_DEL;
+		offset = 18;
+	}
+
+	switch (priv_cmd) {
+	case ATH6KL_XIOCTL_PKT_FILTER_ADD_DEL:
+		ret = ath6kl_ioctl_pkt_filter_set(vif, user_cmd + offset,
+						  hr_cmd.used_len - offset);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+
+	}
+
+	kfree(user_cmd);
+
+	return ret;
+}
+
+static int ath6kl_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct ath6kl_vif *vif = netdev_priv(dev);
+	struct ath6kl *ar = vif->ar;
+	int ret = 0;
+
+	if (!ar || !vif) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	if (!test_bit(WMI_READY, &vif->ar->flag) ||
+	    !test_bit(WLAN_ENABLED, &vif->flags)) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	switch (cmd) {
+	case ATH6KL_PRIV_GET_WLAN_STATS:
+		ret = ath6kl_update_stats(ar, vif, rq->ifr_data);
+		break;
+	case ATH6KL_IOCTL_WEXT_PRIV26:
+		ret = ath6kl_ioctl_wext_priv(dev, rq, cmd);
+		break;
+	default:
+		break;
+	}
+exit:
+	if (ret)
+		ath6kl_err("io status:%d cmd:%d\n",
+			   ret, cmd);
+	else
+		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "io status:%d cmd:%d\n",
+			   ret, cmd);
+	return ret;
+}
 
 static struct net_device_ops ath6kl_netdev_ops = {
 	.ndo_open               = ath6kl_open,
@@ -1365,5 +1731,9 @@ void init_netdev(struct net_device *dev)
 				sizeof(struct wmi_data_hdr) + HTC_HDR_LENGTH
 				+ WMI_MAX_TX_META_SZ + ATH6KL_HTC_ALIGN_BYTES;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
+	dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
+#endif
+
 	return;
 }
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c.orig b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c.orig
deleted file mode 100644
index 227bb1b..0000000
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/main.c.orig
+++ /dev/null
@@ -1,1372 +0,0 @@
-/*
- * Copyright (c) 2004-2011 Atheros Communications Inc.
- * Copyright (c) 2011-2012 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "core.h"
-#include "hif-ops.h"
-#include "cfg80211.h"
-#include "target.h"
-#include "debug.h"
-#include "wmiconfig.h"
-
-struct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 *node_addr)
-{
-	struct ath6kl *ar = vif->ar;
-	struct ath6kl_sta *conn = NULL;
-	u8 i, max_conn;
-
-	max_conn = (vif->nw_type == AP_NETWORK) ? AP_MAX_NUM_STA : 0;
-
-	for (i = 0; i < max_conn; i++) {
-		if (memcmp(node_addr, ar->sta_list[i].mac, ETH_ALEN) == 0) {
-			conn = &ar->sta_list[i];
-			break;
-		}
-	}
-
-	return conn;
-}
-
-struct ath6kl_sta *ath6kl_find_sta_by_aid(struct ath6kl *ar, u8 aid)
-{
-	struct ath6kl_sta *conn = NULL;
-	u8 ctr;
-
-	for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {
-		if (ar->sta_list[ctr].aid == aid) {
-			conn = &ar->sta_list[ctr];
-			break;
-		}
-	}
-	return conn;
-}
-
-static void ath6kl_add_new_sta(struct ath6kl_vif *vif, u8 *mac, u16 aid,
-			       u8 *wpaie, size_t ielen, u8 keymgmt,
-			       u8 ucipher, u8 auth, u8 apsd_info)
-{
-	struct ath6kl *ar = vif->ar;
-	struct ath6kl_sta *sta;
-	u8 free_slot;
-
-	free_slot = aid - 1;
-
-	sta = &ar->sta_list[free_slot];
-	memcpy(sta->mac, mac, ETH_ALEN);
-	if (ielen <= ATH6KL_MAX_IE)
-		memcpy(sta->wpa_ie, wpaie, ielen);
-	sta->aid = aid;
-	sta->keymgmt = keymgmt;
-	sta->ucipher = ucipher;
-	sta->auth = auth;
-	sta->apsd_info = apsd_info;
-
-	ar->sta_list_index = ar->sta_list_index | (1 << free_slot);
-	ar->ap_stats.sta[free_slot].aid = cpu_to_le32(aid);
-	aggr_conn_init(vif, vif->aggr_cntxt, sta->aggr_conn);
-}
-
-static void ath6kl_sta_cleanup(struct ath6kl *ar, u8 i)
-{
-	struct ath6kl_sta *sta = &ar->sta_list[i];
-	struct ath6kl_mgmt_buff *entry, *tmp;
-
-	/* empty the queued pkts in the PS queue if any */
-	spin_lock_bh(&sta->psq_lock);
-	skb_queue_purge(&sta->psq);
-	skb_queue_purge(&sta->apsdq);
-
-	if (sta->mgmt_psq_len != 0) {
-		list_for_each_entry_safe(entry, tmp, &sta->mgmt_psq, list) {
-			kfree(entry);
-		}
-		INIT_LIST_HEAD(&sta->mgmt_psq);
-		sta->mgmt_psq_len = 0;
-	}
-
-	spin_unlock_bh(&sta->psq_lock);
-
-	memset(&ar->ap_stats.sta[sta->aid - 1], 0,
-	       sizeof(struct wmi_per_sta_stat));
-	memset(sta->mac, 0, ETH_ALEN);
-	memset(sta->wpa_ie, 0, ATH6KL_MAX_IE);
-	sta->aid = 0;
-	sta->sta_flags = 0;
-
-	ar->sta_list_index = ar->sta_list_index & ~(1 << i);
-	aggr_reset_state(sta->aggr_conn);
-}
-
-static u8 ath6kl_remove_sta(struct ath6kl *ar, u8 *mac, u16 reason)
-{
-	u8 i, removed = 0;
-
-	if (is_zero_ether_addr(mac))
-		return removed;
-
-	if (is_broadcast_ether_addr(mac)) {
-		ath6kl_dbg(ATH6KL_DBG_TRC, "deleting all station\n");
-
-		for (i = 0; i < AP_MAX_NUM_STA; i++) {
-			if (!is_zero_ether_addr(ar->sta_list[i].mac)) {
-				ath6kl_sta_cleanup(ar, i);
-				removed = 1;
-			}
-		}
-	} else {
-		for (i = 0; i < AP_MAX_NUM_STA; i++) {
-			if (memcmp(ar->sta_list[i].mac, mac, ETH_ALEN) == 0) {
-				ath6kl_dbg(ATH6KL_DBG_TRC,
-					   "deleting station %pM aid=%d reason=%d\n",
-					   mac, ar->sta_list[i].aid, reason);
-				ath6kl_sta_cleanup(ar, i);
-				removed = 1;
-				break;
-			}
-		}
-	}
-
-	return removed;
-}
-
-enum htc_endpoint_id ath6kl_ac2_endpoint_id(void *devt, u8 ac)
-{
-	struct ath6kl *ar = devt;
-	return ar->ac2ep_map[ac];
-}
-
-struct ath6kl_cookie *ath6kl_alloc_cookie(struct ath6kl *ar, bool isctrl)
-{
-	struct ath6kl_cookie *cookie;
-
-	/* If this cookie is for control packet*/
-	if (isctrl) {
-		cookie = ar->wmi_cookie_list;
-		if (cookie != NULL) {
-			ar->wmi_cookie_list = cookie->arc_list_next;
-			ar->wmi_cookie_count--;
-		}
-	} else {
-		cookie = ar->cookie_list;
-		if (cookie != NULL) {
-			ar->cookie_list = cookie->arc_list_next;
-			ar->cookie_count--;
-		}
-	}
-
-	return cookie;
-}
-
-void ath6kl_cookie_init(struct ath6kl *ar)
-{
-	u32 i;
-
-	/* Initilize data cookie list */
-	ar->cookie_list = NULL;
-	ar->cookie_count = 0;
-
-	memset(ar->cookie_mem, 0, sizeof(ar->cookie_mem));
-
-	for (i = 0; i < MAX_COOKIE_NUM; i++)
-		ath6kl_free_cookie(ar, &ar->cookie_mem[i], false);
-
-	/* Initilize control cookie list */
-	ar->wmi_cookie_list = NULL;
-	ar->wmi_cookie_count = 0;
-
-	memset(ar->wmi_cookie_mem, 0, sizeof(ar->wmi_cookie_mem));
-
-	for (i = 0; i < WMI_MAX_COOKIE_NUM; i++)
-		ath6kl_free_cookie(ar, &ar->wmi_cookie_mem[i], true);
-}
-
-void ath6kl_cookie_cleanup(struct ath6kl *ar)
-{
-	/* Cleanup the data cookie */
-	ar->cookie_list = NULL;
-	ar->cookie_count = 0;
-
-	/* Cleanup the control cookie */
-	ar->wmi_cookie_list = NULL;
-	ar->wmi_cookie_count = 0;
-}
-
-void ath6kl_free_cookie(struct ath6kl *ar, struct ath6kl_cookie *cookie,
-			bool isctrl)
-{
-	/* Insert first */
-
-	if (!ar || !cookie)
-		return;
-
-	/* If it is control cookie */
-	if (isctrl) {
-		cookie->arc_list_next = ar->wmi_cookie_list;
-		ar->wmi_cookie_list = cookie;
-		ar->wmi_cookie_count++;
-	} else {
-		cookie->arc_list_next = ar->cookie_list;
-		ar->cookie_list = cookie;
-		ar->cookie_count++;
-	}
-}
-
-/*
- * Read from the hardware through its diagnostic window. No cooperation
- * from the firmware is required for this.
- */
-int ath6kl_diag_read32(struct ath6kl *ar, u32 address, u32 *value)
-{
-	int ret;
-
-	ret = ath6kl_hif_diag_read32(ar, address, value);
-	if (ret) {
-		ath6kl_warn("failed to read32 through diagnose window: %d\n",
-			    ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*
- * Write to the ATH6KL through its diagnostic window. No cooperation from
- * the Target is required for this.
- */
-int ath6kl_diag_write32(struct ath6kl *ar, u32 address, __le32 value)
-{
-	int ret;
-
-	ret = ath6kl_hif_diag_write32(ar, address, value);
-
-	if (ret) {
-		ath6kl_err("failed to write 0x%x during diagnose window to 0x%d\n",
-			   address, value);
-		return ret;
-	}
-
-	return 0;
-}
-
-int ath6kl_diag_read(struct ath6kl *ar, u32 address, void *data, u32 length)
-{
-	u32 count, *buf = data;
-	int ret;
-
-	if (WARN_ON(length % 4))
-		return -EINVAL;
-
-	for (count = 0; count < length / 4; count++, address += 4) {
-		ret = ath6kl_diag_read32(ar, address, &buf[count]);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-int ath6kl_diag_write(struct ath6kl *ar, u32 address, void *data, u32 length)
-{
-	u32 count;
-	__le32 *buf = data;
-	int ret;
-
-	if (WARN_ON(length % 4))
-		return -EINVAL;
-
-	for (count = 0; count < length / 4; count++, address += 4) {
-		ret = ath6kl_diag_write32(ar, address, buf[count]);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-int ath6kl_read_fwlogs(struct ath6kl *ar)
-{
-	struct ath6kl_dbglog_hdr debug_hdr;
-	struct ath6kl_dbglog_buf debug_buf;
-	u32 address, length, dropped, firstbuf, debug_hdr_addr;
-	int ret, loop;
-	u8 *buf;
-
-	buf = kmalloc(ATH6KL_FWLOG_PAYLOAD_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	address = TARG_VTOP(ar->target_type,
-			    ath6kl_get_hi_item_addr(ar,
-						    HI_ITEM(hi_dbglog_hdr)));
-
-	ret = ath6kl_diag_read32(ar, address, &debug_hdr_addr);
-	if (ret)
-		goto out;
-
-	/* Get the contents of the ring buffer */
-	if (debug_hdr_addr == 0) {
-		ath6kl_warn("Invalid address for debug_hdr_addr\n");
-		ret = -EINVAL;
-		goto out;
-	}
-
-	address = TARG_VTOP(ar->target_type, debug_hdr_addr);
-	ath6kl_diag_read(ar, address, &debug_hdr, sizeof(debug_hdr));
-
-	address = TARG_VTOP(ar->target_type,
-			    le32_to_cpu(debug_hdr.dbuf_addr));
-	firstbuf = address;
-	dropped = le32_to_cpu(debug_hdr.dropped);
-	ath6kl_diag_read(ar, address, &debug_buf, sizeof(debug_buf));
-
-	loop = 100;
-
-	do {
-		address = TARG_VTOP(ar->target_type,
-				    le32_to_cpu(debug_buf.buffer_addr));
-		length = le32_to_cpu(debug_buf.length);
-
-		if (length != 0 && (le32_to_cpu(debug_buf.length) <=
-				    le32_to_cpu(debug_buf.bufsize))) {
-			length = ALIGN(length, 4);
-
-			ret = ath6kl_diag_read(ar, address,
-					       buf, length);
-			if (ret)
-				goto out;
-
-			ath6kl_debug_fwlog_event(ar, buf, length);
-		}
-
-		address = TARG_VTOP(ar->target_type,
-				    le32_to_cpu(debug_buf.next));
-		ath6kl_diag_read(ar, address, &debug_buf, sizeof(debug_buf));
-		if (ret)
-			goto out;
-
-		loop--;
-
-		if (WARN_ON(loop == 0)) {
-			ret = -ETIMEDOUT;
-			goto out;
-		}
-	} while (address != firstbuf);
-
-out:
-	kfree(buf);
-
-	return ret;
-}
-
-/* FIXME: move to a better place, target.h? */
-#define AR6003_RESET_CONTROL_ADDRESS 0x00004000
-#define AR6004_RESET_CONTROL_ADDRESS 0x00004000
-
-void ath6kl_reset_device(struct ath6kl *ar, u32 target_type,
-			 bool wait_fot_compltn, bool cold_reset)
-{
-	int status = 0;
-	u32 address;
-	__le32 data;
-
-	if (target_type != TARGET_TYPE_AR6003 &&
-		target_type != TARGET_TYPE_AR6004)
-		return;
-
-	data = cold_reset ? cpu_to_le32(RESET_CONTROL_COLD_RST) :
-			    cpu_to_le32(RESET_CONTROL_MBOX_RST);
-
-	switch (target_type) {
-	case TARGET_TYPE_AR6003:
-		address = AR6003_RESET_CONTROL_ADDRESS;
-		break;
-	case TARGET_TYPE_AR6004:
-		address = AR6004_RESET_CONTROL_ADDRESS;
-		break;
-	}
-
-	status = ath6kl_diag_write32(ar, address, data);
-
-	if (status)
-		ath6kl_err("failed to reset target\n");
-}
-
-static void ath6kl_install_static_wep_keys(struct ath6kl_vif *vif)
-{
-	u8 index;
-	u8 keyusage;
-
-	for (index = 0; index <= WMI_MAX_KEY_INDEX; index++) {
-		if (vif->wep_key_list[index].key_len) {
-			keyusage = GROUP_USAGE;
-			if (index == vif->def_txkey_index)
-				keyusage |= TX_USAGE;
-
-			ath6kl_wmi_addkey_cmd(vif->ar->wmi, vif->fw_vif_idx,
-					      index,
-					      WEP_CRYPT,
-					      keyusage,
-					      vif->wep_key_list[index].key_len,
-					      NULL, 0,
-					      vif->wep_key_list[index].key,
-					      KEY_OP_INIT_VAL, NULL,
-					      NO_SYNC_WMIFLAG);
-		}
-	}
-}
-
-void ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel)
-{
-	struct ath6kl *ar = vif->ar;
-	struct ath6kl_req_key *ik;
-	int res;
-	u8 key_rsc[ATH6KL_KEY_SEQ_LEN];
-
-	ik = &ar->ap_mode_bkey;
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "AP mode started on %u MHz\n", channel);
-
-	switch (vif->auth_mode) {
-	case NONE_AUTH:
-		if (vif->prwise_crypto == WEP_CRYPT)
-			ath6kl_install_static_wep_keys(vif);
-		if (!ik->valid || ik->key_type != WAPI_CRYPT)
-			break;
-		/* for WAPI, we need to set the delayed group key, continue: */
-	case WPA_PSK_AUTH:
-	case WPA2_PSK_AUTH:
-	case (WPA_PSK_AUTH | WPA2_PSK_AUTH):
-		if (!ik->valid)
-			break;
-
-		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "Delayed addkey for "
-			   "the initial group key for AP mode\n");
-		memset(key_rsc, 0, sizeof(key_rsc));
-		res = ath6kl_wmi_addkey_cmd(
-			ar->wmi, vif->fw_vif_idx, ik->key_index, ik->key_type,
-			GROUP_USAGE, ik->key_len, key_rsc, ATH6KL_KEY_SEQ_LEN,
-			ik->key,
-			KEY_OP_INIT_VAL, NULL, SYNC_BOTH_WMIFLAG);
-		if (res) {
-			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "Delayed "
-				   "addkey failed: %d\n", res);
-		}
-		break;
-	}
-
-	if (ar->last_ch != channel)
-		/* we actually don't know the phymode, default to HT20 */
-		ath6kl_cfg80211_ch_switch_notify(vif, channel, WMI_11G_HT20);
-
-	ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx, NONE_BSS_FILTER, 0);
-	set_bit(CONNECTED, &vif->flags);
-	netif_carrier_on(vif->ndev);
-}
-
-void ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,
-				u8 keymgmt, u8 ucipher, u8 auth,
-				u8 assoc_req_len, u8 *assoc_info, u8 apsd_info)
-{
-	u8 *ies = NULL, *wpa_ie = NULL, *pos;
-	size_t ies_len = 0;
-	struct station_info sinfo;
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "new station %pM aid=%d\n", mac_addr, aid);
-
-	if (assoc_req_len > sizeof(struct ieee80211_hdr_3addr)) {
-		struct ieee80211_mgmt *mgmt =
-			(struct ieee80211_mgmt *) assoc_info;
-		if (ieee80211_is_assoc_req(mgmt->frame_control) &&
-		    assoc_req_len >= sizeof(struct ieee80211_hdr_3addr) +
-		    sizeof(mgmt->u.assoc_req)) {
-			ies = mgmt->u.assoc_req.variable;
-			ies_len = assoc_info + assoc_req_len - ies;
-		} else if (ieee80211_is_reassoc_req(mgmt->frame_control) &&
-			   assoc_req_len >= sizeof(struct ieee80211_hdr_3addr)
-			   + sizeof(mgmt->u.reassoc_req)) {
-			ies = mgmt->u.reassoc_req.variable;
-			ies_len = assoc_info + assoc_req_len - ies;
-		}
-	}
-
-	pos = ies;
-	while (pos && pos + 1 < ies + ies_len) {
-		if (pos + 2 + pos[1] > ies + ies_len)
-			break;
-		if (pos[0] == WLAN_EID_RSN)
-			wpa_ie = pos; /* RSN IE */
-		else if (pos[0] == WLAN_EID_VENDOR_SPECIFIC &&
-			 pos[1] >= 4 &&
-			 pos[2] == 0x00 && pos[3] == 0x50 && pos[4] == 0xf2) {
-			if (pos[5] == 0x01)
-				wpa_ie = pos; /* WPA IE */
-			else if (pos[5] == 0x04) {
-				wpa_ie = pos; /* WPS IE */
-				break; /* overrides WPA/RSN IE */
-			}
-		} else if (pos[0] == 0x44 && wpa_ie == NULL) {
-			/*
-			 * Note: WAPI Parameter Set IE re-uses Element ID that
-			 * was officially allocated for BSS AC Access Delay. As
-			 * such, we need to be a bit more careful on when
-			 * parsing the frame. However, BSS AC Access Delay
-			 * element is not supposed to be included in
-			 * (Re)Association Request frames, so this should not
-			 * cause problems.
-			 */
-			wpa_ie = pos; /* WAPI IE */
-			break;
-		}
-		pos += 2 + pos[1];
-	}
-
-	ath6kl_add_new_sta(vif, mac_addr, aid, wpa_ie,
-			   wpa_ie ? 2 + wpa_ie[1] : 0,
-			   keymgmt, ucipher, auth, apsd_info);
-
-	/* send event to application */
-	memset(&sinfo, 0, sizeof(sinfo));
-
-	/* TODO: sinfo.generation */
-
-	sinfo.assoc_req_ies = ies;
-	sinfo.assoc_req_ies_len = ies_len;
-	sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
-
-	cfg80211_new_sta(vif->ndev, mac_addr, &sinfo, GFP_KERNEL);
-
-	netif_wake_queue(vif->ndev);
-}
-
-void disconnect_timer_handler(unsigned long ptr)
-{
-	struct net_device *dev = (struct net_device *)ptr;
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	ath6kl_init_profile_info(vif);
-	ath6kl_disconnect(vif);
-}
-
-void ath6kl_disconnect(struct ath6kl_vif *vif)
-{
-	if (test_bit(CONNECTED, &vif->flags) ||
-	    test_bit(CONNECT_PEND, &vif->flags)) {
-		ath6kl_wmi_disconnect_cmd(vif->ar->wmi, vif->fw_vif_idx);
-		/*
-		 * Disconnect command is issued, clear the connect pending
-		 * flag. The connected flag will be cleared in
-		 * disconnect event notification.
-		 */
-		clear_bit(CONNECT_PEND, &vif->flags);
-	}
-}
-
-/* WMI Event handlers */
-
-void ath6kl_ready_event(void *devt, u8 *datap, u32 sw_ver, u32 abi_ver)
-{
-	struct ath6kl *ar = devt;
-
-	memcpy(ar->mac_addr, datap, ETH_ALEN);
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "ready event mac addr %pM sw_ver 0x%x abi_ver 0x%x\n",
-		   ar->mac_addr, sw_ver, abi_ver);
-
-	ar->version.wlan_ver = sw_ver;
-	ar->version.abi_ver = abi_ver;
-
-	if (strlen(ar->wiphy->fw_version) == 0) {
-		snprintf(ar->wiphy->fw_version,
-			 sizeof(ar->wiphy->fw_version),
-			 "%u.%u.%u.%u",
-			 (ar->version.wlan_ver & 0xf0000000) >> 28,
-			 (ar->version.wlan_ver & 0x0f000000) >> 24,
-			 (ar->version.wlan_ver & 0x00ff0000) >> 16,
-			 (ar->version.wlan_ver & 0x0000ffff));
-	}
-
-	/* indicate to the waiting thread that the ready event was received */
-	set_bit(WMI_READY, &ar->flag);
-	wake_up(&ar->event_wq);
-}
-
-void ath6kl_scan_complete_evt(struct ath6kl_vif *vif, int status)
-{
-	struct ath6kl *ar = vif->ar;
-	bool aborted = false;
-
-	if (status != WMI_SCAN_STATUS_SUCCESS)
-		aborted = true;
-
-	ath6kl_cfg80211_scan_complete_event(vif, aborted);
-
-	if (!ar->usr_bss_filter) {
-		clear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);
-		ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-					 NONE_BSS_FILTER, 0);
-	}
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "scan complete: %d\n", status);
-}
-
-static int ath6kl_commit_ch_switch(struct ath6kl_vif *vif, u16 channel)
-{
-
-	struct ath6kl *ar = vif->ar;
-
-	vif->next_chan = channel;
-	vif->profile.ch = cpu_to_le16(channel);
-
-	switch (vif->nw_type) {
-	case AP_NETWORK:
-		/*
-		 * reconfigure any saved RSN IE capabilites in the beacon /
-		 * probe response to stay in sync with the supplicant.
-		 */
-		if (vif->rsn_capab &&
-		    test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,
-			     ar->fw_capabilities))
-			ath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,
-					      WLAN_EID_RSN, WMI_RSN_IE_CAPB,
-					      (const u8 *) &vif->rsn_capab,
-					      sizeof(vif->rsn_capab));
-
-		return ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx,
-						    &vif->profile);
-	default:
-		ath6kl_err("won't switch channels nw_type=%d\n", vif->nw_type);
-		return -ENOTSUPP;
-	}
-}
-
-static void ath6kl_check_ch_switch(struct ath6kl *ar, u16 channel)
-{
-
-	struct ath6kl_vif *vif;
-	int res = 0;
-
-	if (!ar->want_ch_switch)
-		return;
-
-	spin_lock_bh(&ar->list_lock);
-	list_for_each_entry(vif, &ar->vif_list, list) {
-		if (ar->want_ch_switch & (1 << vif->fw_vif_idx))
-			res = ath6kl_commit_ch_switch(vif, channel);
-
-		/* if channel switch failed, oh well we tried */
-		ar->want_ch_switch &= ~(1 << vif->fw_vif_idx);
-
-		if (res)
-			ath6kl_err("channel switch failed nw_type %d res %d\n",
-				   vif->nw_type, res);
-	}
-	spin_unlock_bh(&ar->list_lock);
-}
-
-void ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel, u8 *bssid,
-			  u16 listen_int, u16 beacon_int,
-			  enum network_type net_type, u8 beacon_ie_len,
-			  u8 assoc_req_len, u8 assoc_resp_len,
-			  u8 *assoc_info)
-{
-	struct ath6kl *ar = vif->ar;
-
-	ath6kl_cfg80211_connect_event(vif, channel, bssid,
-				      listen_int, beacon_int,
-				      net_type, beacon_ie_len,
-				      assoc_req_len, assoc_resp_len,
-				      assoc_info);
-
-	memcpy(vif->bssid, bssid, sizeof(vif->bssid));
-	vif->bss_ch = channel;
-
-	if ((vif->nw_type == INFRA_NETWORK)) {
-		ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,
-					      vif->listen_intvl_t, 0);
-		ath6kl_check_ch_switch(ar, channel);
-	}
-
-	netif_wake_queue(vif->ndev);
-
-	/* Update connect & link status atomically */
-	spin_lock_bh(&vif->if_lock);
-	set_bit(CONNECTED, &vif->flags);
-	clear_bit(CONNECT_PEND, &vif->flags);
-	netif_carrier_on(vif->ndev);
-	spin_unlock_bh(&vif->if_lock);
-
-	aggr_reset_state(vif->aggr_cntxt->aggr_conn);
-	vif->reconnect_flag = 0;
-
-	if ((vif->nw_type == ADHOC_NETWORK) && ar->ibss_ps_enable) {
-		memset(ar->node_map, 0, sizeof(ar->node_map));
-		ar->node_num = 0;
-		ar->next_ep_id = ENDPOINT_2;
-	}
-
-	if (!ar->usr_bss_filter) {
-		set_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);
-		ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-					 CURRENT_BSS_FILTER, 0);
-	}
-}
-
-void ath6kl_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid, bool ismcast)
-{
-	struct ath6kl_sta *sta;
-	struct ath6kl *ar = vif->ar;
-	u8 tsc[6];
-
-	/*
-	 * For AP case, keyid will have aid of STA which sent pkt with
-	 * MIC error. Use this aid to get MAC & send it to hostapd.
-	 */
-	if (vif->nw_type == AP_NETWORK) {
-		sta = ath6kl_find_sta_by_aid(ar, (keyid >> 2));
-		if (!sta)
-			return;
-
-		ath6kl_dbg(ATH6KL_DBG_TRC,
-			   "ap tkip mic error received from aid=%d\n", keyid);
-
-		memset(tsc, 0, sizeof(tsc)); /* FIX: get correct TSC */
-		cfg80211_michael_mic_failure(vif->ndev, sta->mac,
-					     NL80211_KEYTYPE_PAIRWISE, keyid,
-					     tsc, GFP_KERNEL);
-	} else
-		ath6kl_cfg80211_tkip_micerr_event(vif, keyid, ismcast);
-
-}
-
-static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
-{
-	struct wmi_target_stats *tgt_stats =
-		(struct wmi_target_stats *) ptr;
-	struct ath6kl *ar = vif->ar;
-	struct target_stats *stats = &vif->target_stats;
-	struct tkip_ccmp_stats *ccmp_stats;
-	u8 ac;
-
-	if (len < sizeof(*tgt_stats))
-		return;
-
-	ath6kl_dbg(ATH6KL_DBG_TRC, "updating target stats\n");
-
-	stats->tx_pkt += le32_to_cpu(tgt_stats->stats.tx.pkt);
-	stats->tx_byte += le32_to_cpu(tgt_stats->stats.tx.byte);
-	stats->tx_ucast_pkt += le32_to_cpu(tgt_stats->stats.tx.ucast_pkt);
-	stats->tx_ucast_byte += le32_to_cpu(tgt_stats->stats.tx.ucast_byte);
-	stats->tx_mcast_pkt += le32_to_cpu(tgt_stats->stats.tx.mcast_pkt);
-	stats->tx_mcast_byte += le32_to_cpu(tgt_stats->stats.tx.mcast_byte);
-	stats->tx_bcast_pkt  += le32_to_cpu(tgt_stats->stats.tx.bcast_pkt);
-	stats->tx_bcast_byte += le32_to_cpu(tgt_stats->stats.tx.bcast_byte);
-	stats->tx_rts_success_cnt +=
-		le32_to_cpu(tgt_stats->stats.tx.rts_success_cnt);
-
-	for (ac = 0; ac < WMM_NUM_AC; ac++)
-		stats->tx_pkt_per_ac[ac] +=
-			le32_to_cpu(tgt_stats->stats.tx.pkt_per_ac[ac]);
-
-	stats->tx_err += le32_to_cpu(tgt_stats->stats.tx.err);
-	stats->tx_fail_cnt += le32_to_cpu(tgt_stats->stats.tx.fail_cnt);
-	stats->tx_retry_cnt += le32_to_cpu(tgt_stats->stats.tx.retry_cnt);
-	stats->tx_mult_retry_cnt +=
-		le32_to_cpu(tgt_stats->stats.tx.mult_retry_cnt);
-	stats->tx_rts_fail_cnt +=
-		le32_to_cpu(tgt_stats->stats.tx.rts_fail_cnt);
-	stats->tx_ucast_rate =
-	    ath6kl_wmi_get_rate(a_sle32_to_cpu(tgt_stats->stats.tx.ucast_rate));
-
-	stats->rx_pkt += le32_to_cpu(tgt_stats->stats.rx.pkt);
-	stats->rx_byte += le32_to_cpu(tgt_stats->stats.rx.byte);
-	stats->rx_ucast_pkt += le32_to_cpu(tgt_stats->stats.rx.ucast_pkt);
-	stats->rx_ucast_byte += le32_to_cpu(tgt_stats->stats.rx.ucast_byte);
-	stats->rx_mcast_pkt += le32_to_cpu(tgt_stats->stats.rx.mcast_pkt);
-	stats->rx_mcast_byte += le32_to_cpu(tgt_stats->stats.rx.mcast_byte);
-	stats->rx_bcast_pkt += le32_to_cpu(tgt_stats->stats.rx.bcast_pkt);
-	stats->rx_bcast_byte += le32_to_cpu(tgt_stats->stats.rx.bcast_byte);
-	stats->rx_frgment_pkt += le32_to_cpu(tgt_stats->stats.rx.frgment_pkt);
-	stats->rx_err += le32_to_cpu(tgt_stats->stats.rx.err);
-	stats->rx_crc_err += le32_to_cpu(tgt_stats->stats.rx.crc_err);
-	stats->rx_key_cache_miss +=
-		le32_to_cpu(tgt_stats->stats.rx.key_cache_miss);
-	stats->rx_decrypt_err += le32_to_cpu(tgt_stats->stats.rx.decrypt_err);
-	stats->rx_dupl_frame += le32_to_cpu(tgt_stats->stats.rx.dupl_frame);
-	stats->rx_ucast_rate =
-	    ath6kl_wmi_get_rate(a_sle32_to_cpu(tgt_stats->stats.rx.ucast_rate));
-
-	ccmp_stats = &tgt_stats->stats.tkip_ccmp_stats;
-
-	stats->tkip_local_mic_fail +=
-		le32_to_cpu(ccmp_stats->tkip_local_mic_fail);
-	stats->tkip_cnter_measures_invoked +=
-		le32_to_cpu(ccmp_stats->tkip_cnter_measures_invoked);
-	stats->tkip_fmt_err += le32_to_cpu(ccmp_stats->tkip_fmt_err);
-
-	stats->ccmp_fmt_err += le32_to_cpu(ccmp_stats->ccmp_fmt_err);
-	stats->ccmp_replays += le32_to_cpu(ccmp_stats->ccmp_replays);
-
-	stats->pwr_save_fail_cnt +=
-		le32_to_cpu(tgt_stats->pm_stats.pwr_save_failure_cnt);
-	stats->noise_floor_calib =
-		a_sle32_to_cpu(tgt_stats->noise_floor_calib);
-
-	stats->cs_bmiss_cnt +=
-		le32_to_cpu(tgt_stats->cserv_stats.cs_bmiss_cnt);
-	stats->cs_low_rssi_cnt +=
-		le32_to_cpu(tgt_stats->cserv_stats.cs_low_rssi_cnt);
-	stats->cs_connect_cnt +=
-		le16_to_cpu(tgt_stats->cserv_stats.cs_connect_cnt);
-	stats->cs_discon_cnt +=
-		le16_to_cpu(tgt_stats->cserv_stats.cs_discon_cnt);
-
-	stats->cs_ave_beacon_rssi =
-		a_sle16_to_cpu(tgt_stats->cserv_stats.cs_ave_beacon_rssi);
-
-	stats->cs_last_roam_msec =
-		tgt_stats->cserv_stats.cs_last_roam_msec;
-	stats->cs_snr = tgt_stats->cserv_stats.cs_snr;
-	stats->cs_rssi = a_sle16_to_cpu(tgt_stats->cserv_stats.cs_rssi);
-
-	stats->lq_val = le32_to_cpu(tgt_stats->lq_val);
-
-	stats->wow_pkt_dropped +=
-		le32_to_cpu(tgt_stats->wow_stats.wow_pkt_dropped);
-	stats->wow_host_pkt_wakeups +=
-		tgt_stats->wow_stats.wow_host_pkt_wakeups;
-	stats->wow_host_evt_wakeups +=
-		tgt_stats->wow_stats.wow_host_evt_wakeups;
-	stats->wow_evt_discarded +=
-		le16_to_cpu(tgt_stats->wow_stats.wow_evt_discarded);
-
-	stats->arp_received = le32_to_cpu(tgt_stats->arp_stats.arp_received);
-	stats->arp_replied = le32_to_cpu(tgt_stats->arp_stats.arp_replied);
-	stats->arp_matched = le32_to_cpu(tgt_stats->arp_stats.arp_matched);
-
-	ath6kl_wmicfg_send_stats(vif, stats);
-
-	if (test_bit(STATS_UPDATE_PEND, &vif->flags)) {
-		clear_bit(STATS_UPDATE_PEND, &vif->flags);
-		wake_up(&ar->event_wq);
-	}
-}
-
-static void ath6kl_add_le32(__le32 *var, __le32 val)
-{
-	*var = cpu_to_le32(le32_to_cpu(*var) + le32_to_cpu(val));
-}
-
-void ath6kl_tgt_stats_event(struct ath6kl_vif *vif, u8 *ptr, u32 len)
-{
-	struct wmi_ap_mode_stat *p = (struct wmi_ap_mode_stat *) ptr;
-	struct ath6kl *ar = vif->ar;
-	struct wmi_ap_mode_stat *ap = &ar->ap_stats;
-	struct wmi_per_sta_stat *st_ap, *st_p;
-	u8 ac;
-
-	if (vif->nw_type == AP_NETWORK) {
-		if (len < sizeof(*p))
-			return;
-
-		for (ac = 0; ac < AP_MAX_NUM_STA; ac++) {
-			st_ap = &ap->sta[ac];
-			st_p = &p->sta[ac];
-
-			ath6kl_add_le32(&st_ap->tx_bytes, st_p->tx_bytes);
-			ath6kl_add_le32(&st_ap->tx_pkts, st_p->tx_pkts);
-			ath6kl_add_le32(&st_ap->tx_error, st_p->tx_error);
-			ath6kl_add_le32(&st_ap->tx_discard, st_p->tx_discard);
-			ath6kl_add_le32(&st_ap->rx_bytes, st_p->rx_bytes);
-			ath6kl_add_le32(&st_ap->rx_pkts, st_p->rx_pkts);
-			ath6kl_add_le32(&st_ap->rx_error, st_p->rx_error);
-			ath6kl_add_le32(&st_ap->rx_discard, st_p->rx_discard);
-		}
-
-	} else {
-		ath6kl_update_target_stats(vif, ptr, len);
-	}
-}
-
-void ath6kl_wakeup_event(void *dev)
-{
-	struct ath6kl *ar = (struct ath6kl *) dev;
-
-	wake_up(&ar->event_wq);
-}
-
-void ath6kl_txpwr_rx_evt(void *devt, u8 tx_pwr)
-{
-	struct ath6kl *ar = (struct ath6kl *) devt;
-
-	ar->tx_pwr = tx_pwr;
-	wake_up(&ar->event_wq);
-}
-
-void ath6kl_pspoll_event(struct ath6kl_vif *vif, u8 aid)
-{
-	struct ath6kl_sta *conn;
-	struct sk_buff *skb;
-	bool psq_empty = false;
-	struct ath6kl *ar = vif->ar;
-	struct ath6kl_mgmt_buff *mgmt_buf;
-
-	conn = ath6kl_find_sta_by_aid(ar, aid);
-
-	if (!conn)
-		return;
-	/*
-	 * Send out a packet queued on ps queue. When the ps queue
-	 * becomes empty update the PVB for this station.
-	 */
-	spin_lock_bh(&conn->psq_lock);
-	psq_empty  = skb_queue_empty(&conn->psq) && (conn->mgmt_psq_len == 0);
-	spin_unlock_bh(&conn->psq_lock);
-
-	if (psq_empty)
-		/* TODO: Send out a NULL data frame */
-		return;
-
-	spin_lock_bh(&conn->psq_lock);
-	if (conn->mgmt_psq_len > 0) {
-		mgmt_buf = list_first_entry(&conn->mgmt_psq,
-					struct ath6kl_mgmt_buff, list);
-		list_del(&mgmt_buf->list);
-		conn->mgmt_psq_len--;
-		spin_unlock_bh(&conn->psq_lock);
-
-		conn->sta_flags |= STA_PS_POLLED;
-		ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx,
-					 mgmt_buf->id, mgmt_buf->freq,
-					 mgmt_buf->wait, mgmt_buf->buf,
-					 mgmt_buf->len, mgmt_buf->no_cck);
-		conn->sta_flags &= ~STA_PS_POLLED;
-		kfree(mgmt_buf);
-	} else {
-		skb = skb_dequeue(&conn->psq);
-		spin_unlock_bh(&conn->psq_lock);
-
-		conn->sta_flags |= STA_PS_POLLED;
-		ath6kl_data_tx(skb, vif->ndev);
-		conn->sta_flags &= ~STA_PS_POLLED;
-	}
-
-	spin_lock_bh(&conn->psq_lock);
-	psq_empty  = skb_queue_empty(&conn->psq) && (conn->mgmt_psq_len == 0);
-	spin_unlock_bh(&conn->psq_lock);
-
-	if (psq_empty)
-		ath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx, conn->aid, 0);
-}
-
-void ath6kl_dtimexpiry_event(struct ath6kl_vif *vif)
-{
-	bool mcastq_empty = false;
-	struct sk_buff *skb;
-	struct ath6kl *ar = vif->ar;
-
-	/*
-	 * If there are no associated STAs, ignore the DTIM expiry event.
-	 * There can be potential race conditions where the last associated
-	 * STA may disconnect & before the host could clear the 'Indicate
-	 * DTIM' request to the firmware, the firmware would have just
-	 * indicated a DTIM expiry event. The race is between 'clear DTIM
-	 * expiry cmd' going from the host to the firmware & the DTIM
-	 * expiry event happening from the firmware to the host.
-	 */
-	if (!ar->sta_list_index)
-		return;
-
-	spin_lock_bh(&ar->mcastpsq_lock);
-	mcastq_empty = skb_queue_empty(&ar->mcastpsq);
-	spin_unlock_bh(&ar->mcastpsq_lock);
-
-	if (mcastq_empty)
-		return;
-
-	/* set the STA flag to dtim_expired for the frame to go out */
-	set_bit(DTIM_EXPIRED, &vif->flags);
-
-	spin_lock_bh(&ar->mcastpsq_lock);
-	while ((skb = skb_dequeue(&ar->mcastpsq)) != NULL) {
-		spin_unlock_bh(&ar->mcastpsq_lock);
-
-		ath6kl_data_tx(skb, vif->ndev);
-
-		spin_lock_bh(&ar->mcastpsq_lock);
-	}
-	spin_unlock_bh(&ar->mcastpsq_lock);
-
-	clear_bit(DTIM_EXPIRED, &vif->flags);
-
-	/* clear the LSB of the BitMapCtl field of the TIM IE */
-	ath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx, MCAST_AID, 0);
-}
-
-void ath6kl_disconnect_event(struct ath6kl_vif *vif, u8 reason, u8 *bssid,
-			     u8 assoc_resp_len, u8 *assoc_info,
-			     u16 prot_reason_status)
-{
-	struct ath6kl *ar = vif->ar;
-
-	if (vif->nw_type == AP_NETWORK) {
-		/* disconnect due to other STA vif switching channels */
-		if (reason == BSS_DISCONNECTED &&
-		    prot_reason_status == WMI_AP_REASON_STA_ROAM) {
-			ar->want_ch_switch |= 1 << vif->fw_vif_idx;
-			/* bail back to this channel if STA vif fails connect */
-			ar->last_ch = le16_to_cpu(vif->profile.ch);
-		}
-
-		if (prot_reason_status == WMI_AP_REASON_MAX_STA) {
-			/* send max client reached notification to user space */
-			cfg80211_conn_failed(vif->ndev, bssid,
-					     NL80211_CONN_FAIL_MAX_CLIENTS,
-					     GFP_KERNEL);
-		}
-
-		if (prot_reason_status == WMI_AP_REASON_ACL) {
-			/* send blocked client notification to user space */
-			cfg80211_conn_failed(vif->ndev, bssid,
-					     NL80211_CONN_FAIL_BLOCKED_CLIENT,
-					     GFP_KERNEL);
-		}
-
-		if (!ath6kl_remove_sta(ar, bssid, prot_reason_status))
-			return;
-
-		/* if no more associated STAs, empty the mcast PS q */
-		if (ar->sta_list_index == 0) {
-			spin_lock_bh(&ar->mcastpsq_lock);
-			skb_queue_purge(&ar->mcastpsq);
-			spin_unlock_bh(&ar->mcastpsq_lock);
-
-			/* clear the LSB of the TIM IE's BitMapCtl field */
-			if (test_bit(WMI_READY, &ar->flag))
-				ath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,
-						       MCAST_AID, 0);
-		}
-
-		if (!is_broadcast_ether_addr(bssid)) {
-			/* send event to application */
-			cfg80211_del_sta(vif->ndev, bssid, GFP_KERNEL);
-		}
-
-		if (memcmp(vif->ndev->dev_addr, bssid, ETH_ALEN) == 0) {
-			memset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));
-			clear_bit(CONNECTED, &vif->flags);
-		}
-		return;
-	}
-
-	ath6kl_cfg80211_disconnect_event(vif, reason, bssid,
-				       assoc_resp_len, assoc_info,
-				       prot_reason_status);
-
-	aggr_reset_state(vif->aggr_cntxt->aggr_conn);
-
-	del_timer(&vif->disconnect_timer);
-
-	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "disconnect reason is %d\n", reason);
-
-	/*
-	 * If the event is due to disconnect cmd from the host, only they
-	 * the target would stop trying to connect. Under any other
-	 * condition, target would keep trying to connect.
-	 */
-	if (reason == DISCONNECT_CMD) {
-		if (!ar->usr_bss_filter && test_bit(WMI_READY, &ar->flag))
-			ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
-						 NONE_BSS_FILTER, 0);
-	} else {
-		set_bit(CONNECT_PEND, &vif->flags);
-		if (((reason == ASSOC_FAILED) &&
-		    (prot_reason_status == 0x11)) ||
-		    ((reason == ASSOC_FAILED) && (prot_reason_status == 0x0)
-		     && (vif->reconnect_flag == 1))) {
-			set_bit(CONNECTED, &vif->flags);
-			return;
-		}
-	}
-
-	/* restart disconnected concurrent vifs waiting for new channel */
-	ath6kl_check_ch_switch(ar, ar->last_ch);
-
-	/* update connect & link status atomically */
-	spin_lock_bh(&vif->if_lock);
-	clear_bit(CONNECTED, &vif->flags);
-	netif_carrier_off(vif->ndev);
-	spin_unlock_bh(&vif->if_lock);
-
-	if ((reason != CSERV_DISCONNECT) || (vif->reconnect_flag != 1))
-		vif->reconnect_flag = 0;
-
-	if (reason != CSERV_DISCONNECT)
-		ar->user_key_ctrl = 0;
-
-	netif_stop_queue(vif->ndev);
-	memset(vif->bssid, 0, sizeof(vif->bssid));
-	vif->bss_ch = 0;
-
-	ath6kl_tx_data_cleanup(ar);
-}
-
-struct ath6kl_vif *ath6kl_vif_first(struct ath6kl *ar)
-{
-	struct ath6kl_vif *vif;
-
-	spin_lock_bh(&ar->list_lock);
-	if (list_empty(&ar->vif_list)) {
-		spin_unlock_bh(&ar->list_lock);
-		return NULL;
-	}
-
-	vif = list_first_entry(&ar->vif_list, struct ath6kl_vif, list);
-
-	spin_unlock_bh(&ar->list_lock);
-
-	return vif;
-}
-
-static int ath6kl_open(struct net_device *dev)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	set_bit(WLAN_ENABLED, &vif->flags);
-
-	if (test_bit(CONNECTED, &vif->flags)) {
-		netif_carrier_on(dev);
-		netif_wake_queue(dev);
-	} else
-		netif_carrier_off(dev);
-
-	return 0;
-}
-
-static int ath6kl_close(struct net_device *dev)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	netif_stop_queue(dev);
-
-	ath6kl_cfg80211_stop(vif);
-
-	clear_bit(WLAN_ENABLED, &vif->flags);
-
-	return 0;
-}
-
-static struct net_device_stats *ath6kl_get_stats(struct net_device *dev)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-
-	return &vif->net_stats;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
-static int ath6kl_set_features(struct net_device *dev, u32 features)
-{
-	struct ath6kl_vif *vif = netdev_priv(dev);
-	struct ath6kl *ar = vif->ar;
-	int err = 0;
-
-	if ((features & NETIF_F_RXCSUM) &&
-	    (ar->rx_meta_ver != WMI_META_VERSION_2)) {
-		ar->rx_meta_ver = WMI_META_VERSION_2;
-		err = ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi,
-							 vif->fw_vif_idx,
-							 ar->rx_meta_ver, 0, 0);
-		if (err) {
-			dev->features = features & ~NETIF_F_RXCSUM;
-			return err;
-		}
-	} else if (!(features & NETIF_F_RXCSUM) &&
-		   (ar->rx_meta_ver == WMI_META_VERSION_2)) {
-		ar->rx_meta_ver = 0;
-		err = ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi,
-							 vif->fw_vif_idx,
-							 ar->rx_meta_ver, 0, 0);
-		if (err) {
-			dev->features = features | NETIF_F_RXCSUM;
-			return err;
-		}
-
-	}
-
-	return err;
-}
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) */
-
-static void ath6kl_set_multicast_list(struct net_device *ndev)
-{
-	struct ath6kl_vif *vif = netdev_priv(ndev);
-	bool mc_all_on = false;
-	int mc_count = netdev_mc_count(ndev);
-	struct netdev_hw_addr *ha;
-	bool found;
-	struct ath6kl_mc_filter *mc_filter, *tmp;
-	struct list_head mc_filter_new;
-	int ret;
-
-	if (!test_bit(WMI_READY, &vif->ar->flag) ||
-	    !test_bit(WLAN_ENABLED, &vif->flags))
-		return;
-
-	/* Enable multicast-all filter. */
-	mc_all_on = !!(ndev->flags & IFF_PROMISC) ||
-		    !!(ndev->flags & IFF_ALLMULTI) ||
-		    !!(mc_count > ATH6K_MAX_MC_FILTERS_PER_LIST);
-
-	if (mc_all_on)
-		set_bit(NETDEV_MCAST_ALL_ON, &vif->flags);
-	else
-		clear_bit(NETDEV_MCAST_ALL_ON, &vif->flags);
-
-	mc_all_on = mc_all_on || (vif->ar->state == ATH6KL_STATE_ON);
-
-	if (!(ndev->flags & IFF_MULTICAST)) {
-		mc_all_on = false;
-		set_bit(NETDEV_MCAST_ALL_OFF, &vif->flags);
-	} else {
-		clear_bit(NETDEV_MCAST_ALL_OFF, &vif->flags);
-	}
-
-	/* Enable/disable "multicast-all" filter*/
-	ath6kl_dbg(ATH6KL_DBG_TRC, "%s multicast-all filter\n",
-		    mc_all_on ? "enabling" : "disabling");
-	ret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi, vif->fw_vif_idx,
-					  mc_all_on);
-
-	if (ret) {
-		ath6kl_warn("Failed to %s multicast-all receive\n",
-			    mc_all_on ? "enable" : "disable");
-		return;
-	}
-
-	if (test_bit(NETDEV_MCAST_ALL_ON, &vif->flags))
-		return;
-
-	/* Keep the driver and firmware mcast list in sync. */
-	list_for_each_entry_safe(mc_filter, tmp, &vif->mc_filter, list) {
-		found = false;
-		netdev_for_each_mc_addr(ha, ndev) {
-			if (memcmp(ha->addr, mc_filter->hw_addr,
-			    ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE) == 0) {
-				found = true;
-				break;
-			}
-		}
-
-		if (!found) {
-			/*
-			 * Delete the filter which was previously set
-			 * but not in the new request.
-			 */
-			ath6kl_dbg(ATH6KL_DBG_TRC,
-				   "Removing %pM from multicast filter\n",
-				   mc_filter->hw_addr);
-			ret = ath6kl_wmi_add_del_mcast_filter_cmd(vif->ar->wmi,
-					vif->fw_vif_idx, mc_filter->hw_addr,
-					false);
-			if (ret) {
-				ath6kl_warn("Failed to remove multicast filter:%pM\n",
-					     mc_filter->hw_addr);
-				return;
-			}
-
-			list_del(&mc_filter->list);
-			kfree(mc_filter);
-		}
-	}
-
-	INIT_LIST_HEAD(&mc_filter_new);
-
-	netdev_for_each_mc_addr(ha, ndev) {
-		found = false;
-		list_for_each_entry(mc_filter, &vif->mc_filter, list) {
-			if (memcmp(ha->addr, mc_filter->hw_addr,
-			    ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE) == 0) {
-				found = true;
-				break;
-			}
-		}
-
-		if (!found) {
-			mc_filter = kzalloc(sizeof(struct ath6kl_mc_filter),
-					    GFP_ATOMIC);
-			if (!mc_filter) {
-				WARN_ON(1);
-				goto out;
-			}
-
-			memcpy(mc_filter->hw_addr, ha->addr,
-			       ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE);
-			/* Set the multicast filter */
-			ath6kl_dbg(ATH6KL_DBG_TRC,
-				   "Adding %pM to multicast filter list\n",
-				   mc_filter->hw_addr);
-			ret = ath6kl_wmi_add_del_mcast_filter_cmd(vif->ar->wmi,
-					vif->fw_vif_idx, mc_filter->hw_addr,
-					true);
-			if (ret) {
-				ath6kl_warn("Failed to add multicast filter :%pM\n",
-					     mc_filter->hw_addr);
-				kfree(mc_filter);
-				goto out;
-			}
-
-			list_add_tail(&mc_filter->list, &mc_filter_new);
-		}
-	}
-
-out:
-	list_splice_tail(&mc_filter_new, &vif->mc_filter);
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-static int ath6kl_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	return 0;
-}
-#endif
-
-static struct net_device_ops ath6kl_netdev_ops = {
-	.ndo_open               = ath6kl_open,
-	.ndo_stop               = ath6kl_close,
-	.ndo_start_xmit         = ath6kl_data_tx,
-	.ndo_get_stats          = ath6kl_get_stats,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
-	.ndo_set_features       = ath6kl_set_features,
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) */
-	.ndo_set_rx_mode	= ath6kl_set_multicast_list,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-	.ndo_do_ioctl           = ath6kl_ioctl,
-#endif
-};
-
-void init_netdev(struct net_device *dev)
-{
-	netdev_attach_ops(dev, &ath6kl_netdev_ops);
-	dev->destructor = free_netdev;
-	dev->watchdog_timeo = ATH6KL_TX_TIMEOUT;
-
-	dev->needed_headroom = ETH_HLEN;
-	dev->needed_headroom += sizeof(struct ath6kl_llc_snap_hdr) +
-				sizeof(struct wmi_data_hdr) + HTC_HDR_LENGTH
-				+ WMI_MAX_TX_META_SZ + ATH6KL_HTC_ALIGN_BYTES;
-
-	return;
-}
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/platform.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/platform.c
index f91ff5f..ec289a1 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/platform.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/platform.c
@@ -145,12 +145,17 @@ static struct platform_driver ath6kl_pm_device = {
 	},
 };
 
-void __init ath6kl_sdio_init_platform(void)
+int __init ath6kl_sdio_init_platform(void)
 {
 	char buf[3];
-	int length;
+	int length, ret;
 
-	platform_driver_register(&ath6kl_pm_device);
+	ret = platform_driver_register(&ath6kl_pm_device);
+	if (ret) {
+		printk(KERN_ERR "platform driver registration failed: %d\n",
+		       ret);
+		return ret;
+	}
 
 	length = snprintf(buf, sizeof(buf), "%d\n", 1 ? 1 : 0);
 	android_readwrite_file("/sys/devices/platform/" MMC_PLATFORM_DEV
@@ -160,12 +165,15 @@ void __init ath6kl_sdio_init_platform(void)
 			       "/polling", NULL, buf, length);
 
 	mdelay(50);
+
+	return ret;
 }
 
-void __exit ath6kl_sdio_exit_platform(void)
+void ath6kl_sdio_exit_platform(void)
 {
 	char buf[3];
 	int length;
+
 	platform_driver_unregister(&ath6kl_pm_device);
 
 	length = snprintf(buf, sizeof(buf), "%d\n", 1 ? 1 : 0);
@@ -182,20 +190,23 @@ void __exit ath6kl_sdio_exit_platform(void)
 
 int ath6kl_wait_for_init_comp(void)
 {
-	int left;
+	int left, ret = 0;
 
 	if (atomic_read(&init_done) == 1)
-		return 0;
+		return ret;
 
 	left = wait_event_interruptible_timeout(init_wq,
 						atomic_read(&init_done) == 1,
 						ATH6KL_INIT_TIMEOUT);
-	if (left == 0)
+	if (left == 0) {
 		printk(KERN_ERR "timeout while waiting for init operation\n");
-	else if (left < 0)
+		ret = -ETIMEDOUT;
+	} else if (left < 0) {
 		printk(KERN_ERR "wait for init operation failed: %d\n", left);
+		ret = left;
+	}
 
-	return 0;
+	return ret;
 }
 void ath6kl_notify_init_done(void)
 {
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/recovery.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/recovery.c
index 1e2fa7a..c842df4 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/recovery.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/recovery.c
@@ -34,19 +34,23 @@ static void ath6kl_recovery_work(struct work_struct *work)
 
 	ar->fw_recovery.err_reason = 0;
 
-	if (ar->fw_recovery.enable)
+	if (ar->fw_recovery.hb_poll)
 		mod_timer(&ar->fw_recovery.hb_timer, jiffies +
 			  msecs_to_jiffies(ar->fw_recovery.hb_poll));
 }
 
 void ath6kl_recovery_err_notify(struct ath6kl *ar, enum ath6kl_fw_err reason)
 {
+	if (!ar->fw_recovery.enable)
+		return;
+
 	ath6kl_dbg(ATH6KL_DBG_RECOVERY, "Fw error detected, reason:%d\n",
 		   reason);
 
 	set_bit(reason, &ar->fw_recovery.err_reason);
 
-	if (ar->fw_recovery.enable && ar->state != ATH6KL_STATE_RECOVERY)
+	if (!test_bit(RECOVERY_CLEANUP, &ar->flag) &&
+	    ar->state != ATH6KL_STATE_RECOVERY)
 		queue_work(ar->ath6kl_wq, &ar->fw_recovery.recovery_work);
 }
 
@@ -61,7 +65,9 @@ static void ath6kl_recovery_hb_timer(unsigned long data)
 	struct ath6kl *ar = (struct ath6kl *) data;
 	int err;
 
-	if (!ar->fw_recovery.enable || !test_bit(WMI_READY, &ar->flag))
+	if (test_bit(RECOVERY_CLEANUP, &ar->flag) ||
+	    !test_bit(WMI_READY, &ar->flag) || (ar->state == ATH6KL_STATE_RECOVERY) ||
+	    !ar->fw_recovery.hb_poll)
 		return;
 
 	if (ar->fw_recovery.hb_pending)
@@ -86,9 +92,6 @@ static void ath6kl_recovery_hb_timer(unsigned long data)
 		ath6kl_warn("Failed to send hb challenge request, err:%d\n",
 			    err);
 
-	if ((ar->state == ATH6KL_STATE_RECOVERY) || !ar->fw_recovery.enable)
-		return;
-
 	mod_timer(&ar->fw_recovery.hb_timer, jiffies +
 		  msecs_to_jiffies(ar->fw_recovery.hb_poll));
 }
@@ -97,7 +100,7 @@ void ath6kl_recovery_init(struct ath6kl *ar)
 {
 	struct ath6kl_fw_recovery *recovery = &ar->fw_recovery;
 
-	recovery->enable = true;
+	clear_bit(RECOVERY_CLEANUP, &ar->flag);
 	INIT_WORK(&recovery->recovery_work, ath6kl_recovery_work);
 	recovery->seq_num = 0;
 	recovery->hb_misscnt = 0;
@@ -113,7 +116,10 @@ void ath6kl_recovery_init(struct ath6kl *ar)
 
 void ath6kl_recovery_cleanup(struct ath6kl *ar)
 {
-	ar->fw_recovery.enable = false;
+	if (!ar->fw_recovery.enable)
+		return;
+
+	set_bit(RECOVERY_CLEANUP, &ar->flag);
 
 	del_timer_sync(&ar->fw_recovery.hb_timer);
 	cancel_work_sync(&ar->fw_recovery.recovery_work);
@@ -121,6 +127,9 @@ void ath6kl_recovery_cleanup(struct ath6kl *ar)
 
 void ath6kl_recovery_suspend(struct ath6kl *ar)
 {
+	if (!ar->fw_recovery.enable)
+		return;
+
 	ath6kl_recovery_cleanup(ar);
 
 	if (!ar->fw_recovery.err_reason)
@@ -136,7 +145,10 @@ void ath6kl_recovery_suspend(struct ath6kl *ar)
 
 void ath6kl_recovery_resume(struct ath6kl *ar)
 {
-	ar->fw_recovery.enable = true;
+	if (!ar->fw_recovery.enable)
+		return;
+
+	clear_bit(RECOVERY_CLEANUP, &ar->flag);
 
 	if (!ar->fw_recovery.hb_poll)
 		return;
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c
index f1b12ad..5c3ccf2 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c
@@ -597,10 +597,7 @@ static void ath6kl_sdio_irq_disable(struct ath6kl *ar)
 	if (atomic_read(&ar_sdio->irq_handling)) {
 		sdio_release_host(ar_sdio->func);
 
-		ret = wait_event_interruptible(ar_sdio->irq_wq,
-				ath6kl_sdio_is_on_irq(ar));
-		if (ret)
-			return;
+		wait_event(ar_sdio->irq_wq, ath6kl_sdio_is_on_irq(ar));
 
 		sdio_claim_host(ar_sdio->func);
 	}
@@ -1348,7 +1345,7 @@ static int ath6kl_sdio_probe(struct sdio_func *func,
 	}
 
 	ret = ath6kl_core_init(ar);
-	ath6kl_info("Current ath6kl driver version is: 3.4.0.23\n");
+	ath6kl_info("Current ath6kl driver version is: 3.4.0.158\n");
 	if (ret) {
 		ath6kl_err("Failed to init ath6kl core\n");
 		goto err_core_alloc;
@@ -1410,17 +1407,24 @@ static int __init ath6kl_sdio_init(void)
 {
 	int ret;
 
-	ath6kl_sdio_init_platform();
+	ret = ath6kl_sdio_init_platform();
+	if (ret)
+		return ret;
 
 	init_waitqueue_head(&init_wq);
 
 	ret = sdio_register_driver(&ath6kl_sdio_driver);
 	if (ret) {
 		ath6kl_err("sdio driver registration failed: %d\n", ret);
+		ath6kl_sdio_exit_platform();
 		return ret;
 	}
 
 	ret = ath6kl_wait_for_init_comp();
+	if (ret) {
+		sdio_unregister_driver(&ath6kl_sdio_driver);
+		ath6kl_sdio_exit_platform();
+	}
 
 	return ret;
 }
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c.orig b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c.orig
deleted file mode 100644
index 74a5698..0000000
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/sdio.c.orig
+++ /dev/null
@@ -1,1455 +0,0 @@
-/*
- * Copyright (c) 2004-2011 Atheros Communications Inc.
- * Copyright (c) 2011-2012 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include <linux/module.h>
-#include <linux/mmc/card.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/sdio_func.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/mmc/sdio.h>
-#include <linux/mmc/sd.h>
-#include "hif.h"
-#include "hif-ops.h"
-#include "target.h"
-#include "debug.h"
-#include "cfg80211.h"
-
-struct ath6kl_sdio {
-	struct sdio_func *func;
-
-	spinlock_t lock;
-
-	/* free list */
-	struct list_head bus_req_freeq;
-
-	/* available bus requests */
-	struct bus_request bus_req[BUS_REQUEST_MAX_NUM];
-
-	struct ath6kl *ar;
-
-	u8 *dma_buffer;
-
-	/* protects access to dma_buffer */
-	struct mutex dma_buffer_mutex;
-
-	/* scatter request list head */
-	struct list_head scat_req;
-
-	atomic_t irq_handling;
-	wait_queue_head_t irq_wq;
-
-	spinlock_t scat_lock;
-	bool scatter_enabled;
-
-	bool is_disabled;
-	const struct sdio_device_id *id;
-	struct work_struct wr_async_work;
-	struct list_head wr_asyncq;
-	spinlock_t wr_async_lock;
-};
-
-#define CMD53_ARG_READ          0
-#define CMD53_ARG_WRITE         1
-#define CMD53_ARG_BLOCK_BASIS   1
-#define CMD53_ARG_FIXED_ADDRESS 0
-#define CMD53_ARG_INCR_ADDRESS  1
-
-extern wait_queue_head_t init_wq;
-
-static inline struct ath6kl_sdio *ath6kl_sdio_priv(struct ath6kl *ar)
-{
-	return ar->hif_priv;
-}
-
-/*
- * Macro to check if DMA buffer is WORD-aligned and DMA-able.
- * Most host controllers assume the buffer is DMA'able and will
- * bug-check otherwise (i.e. buffers on the stack). virt_addr_valid
- * check fails on stack memory.
- */
-static inline bool buf_needs_bounce(u8 *buf)
-{
-	return ((unsigned long) buf & 0x3) || !virt_addr_valid(buf);
-}
-
-static void ath6kl_sdio_set_mbox_info(struct ath6kl *ar)
-{
-	struct ath6kl_mbox_info *mbox_info = &ar->mbox_info;
-
-	/* EP1 has an extended range */
-	mbox_info->htc_addr = HIF_MBOX_BASE_ADDR;
-	mbox_info->htc_ext_addr = HIF_MBOX0_EXT_BASE_ADDR;
-	mbox_info->htc_ext_sz = HIF_MBOX0_EXT_WIDTH;
-	mbox_info->block_size = HIF_MBOX_BLOCK_SIZE;
-	mbox_info->gmbox_addr = HIF_GMBOX_BASE_ADDR;
-	mbox_info->gmbox_sz = HIF_GMBOX_WIDTH;
-}
-
-static inline void ath6kl_sdio_set_cmd53_arg(u32 *arg, u8 rw, u8 func,
-					     u8 mode, u8 opcode, u32 addr,
-					     u16 blksz)
-{
-	*arg = (((rw & 1) << 31) |
-		((func & 0x7) << 28) |
-		((mode & 1) << 27) |
-		((opcode & 1) << 26) |
-		((addr & 0x1FFFF) << 9) |
-		(blksz & 0x1FF));
-}
-
-static inline void ath6kl_sdio_set_cmd52_arg(u32 *arg, u8 write, u8 raw,
-					     unsigned int address,
-					     unsigned char val)
-{
-	const u8 func = 0;
-
-	*arg = ((write & 1) << 31) |
-	       ((func & 0x7) << 28) |
-	       ((raw & 1) << 27) |
-	       (1 << 26) |
-	       ((address & 0x1FFFF) << 9) |
-	       (1 << 8) |
-	       (val & 0xFF);
-}
-
-static int ath6kl_sdio_func0_cmd52_wr_byte(struct mmc_card *card,
-					   unsigned int address,
-					   unsigned char byte)
-{
-	struct mmc_command io_cmd;
-
-	memset(&io_cmd, 0, sizeof(io_cmd));
-	ath6kl_sdio_set_cmd52_arg(&io_cmd.arg, 1, 0, address, byte);
-	io_cmd.opcode = SD_IO_RW_DIRECT;
-	io_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;
-
-	return mmc_wait_for_cmd(card->host, &io_cmd, 0);
-}
-
-static int ath6kl_sdio_io(struct sdio_func *func, u32 request, u32 addr,
-			  u8 *buf, u32 len)
-{
-	int ret = 0;
-
-	sdio_claim_host(func);
-
-	if (request & HIF_WRITE) {
-		/* FIXME: looks like ugly workaround for something */
-		if (addr >= HIF_MBOX_BASE_ADDR &&
-		    addr <= HIF_MBOX_END_ADDR)
-			addr += (HIF_MBOX_WIDTH - len);
-
-		/* FIXME: this also looks like ugly workaround */
-		if (addr == HIF_MBOX0_EXT_BASE_ADDR)
-			addr += HIF_MBOX0_EXT_WIDTH - len;
-
-		if (request & HIF_FIXED_ADDRESS)
-			ret = sdio_writesb(func, addr, buf, len);
-		else
-			ret = sdio_memcpy_toio(func, addr, buf, len);
-	} else {
-		if (request & HIF_FIXED_ADDRESS)
-			ret = sdio_readsb(func, buf, addr, len);
-		else
-			ret = sdio_memcpy_fromio(func, buf, addr, len);
-	}
-
-	sdio_release_host(func);
-
-	ath6kl_dbg(ATH6KL_DBG_SDIO, "%s addr 0x%x%s buf 0x%p len %d\n",
-		   request & HIF_WRITE ? "wr" : "rd", addr,
-		   request & HIF_FIXED_ADDRESS ? " (fixed)" : "", buf, len);
-	ath6kl_dbg_dump(ATH6KL_DBG_SDIO_DUMP, NULL, "sdio ", buf, len);
-
-	return ret;
-}
-
-static struct bus_request *ath6kl_sdio_alloc_busreq(struct ath6kl_sdio *ar_sdio)
-{
-	struct bus_request *bus_req;
-
-	spin_lock_bh(&ar_sdio->lock);
-
-	if (list_empty(&ar_sdio->bus_req_freeq)) {
-		spin_unlock_bh(&ar_sdio->lock);
-		return NULL;
-	}
-
-	bus_req = list_first_entry(&ar_sdio->bus_req_freeq,
-				   struct bus_request, list);
-	list_del(&bus_req->list);
-
-	spin_unlock_bh(&ar_sdio->lock);
-	ath6kl_dbg(ATH6KL_DBG_SCATTER, "%s: bus request 0x%p\n",
-		   __func__, bus_req);
-
-	return bus_req;
-}
-
-static void ath6kl_sdio_free_bus_req(struct ath6kl_sdio *ar_sdio,
-				     struct bus_request *bus_req)
-{
-	ath6kl_dbg(ATH6KL_DBG_SCATTER, "%s: bus request 0x%p\n",
-		   __func__, bus_req);
-
-	spin_lock_bh(&ar_sdio->lock);
-	list_add_tail(&bus_req->list, &ar_sdio->bus_req_freeq);
-	spin_unlock_bh(&ar_sdio->lock);
-}
-
-static void ath6kl_sdio_setup_scat_data(struct hif_scatter_req *scat_req,
-					struct mmc_data *data)
-{
-	struct scatterlist *sg;
-	int i;
-
-	data->blksz = HIF_MBOX_BLOCK_SIZE;
-	data->blocks = scat_req->len / HIF_MBOX_BLOCK_SIZE;
-
-	ath6kl_dbg(ATH6KL_DBG_SCATTER,
-		   "hif-scatter: (%s) addr: 0x%X, (block len: %d, block count: %d) , (tot:%d,sg:%d)\n",
-		   (scat_req->req & HIF_WRITE) ? "WR" : "RD", scat_req->addr,
-		   data->blksz, data->blocks, scat_req->len,
-		   scat_req->scat_entries);
-
-	data->flags = (scat_req->req & HIF_WRITE) ? MMC_DATA_WRITE :
-						    MMC_DATA_READ;
-
-	/* fill SG entries */
-	sg = scat_req->sgentries;
-	sg_init_table(sg, scat_req->scat_entries);
-
-	/* assemble SG list */
-	for (i = 0; i < scat_req->scat_entries; i++, sg++) {
-		ath6kl_dbg(ATH6KL_DBG_SCATTER, "%d: addr:0x%p, len:%d\n",
-			   i, scat_req->scat_list[i].buf,
-			   scat_req->scat_list[i].len);
-
-		sg_set_buf(sg, scat_req->scat_list[i].buf,
-			   scat_req->scat_list[i].len);
-	}
-
-	/* set scatter-gather table for request */
-	data->sg = scat_req->sgentries;
-	data->sg_len = scat_req->scat_entries;
-}
-
-static int ath6kl_sdio_scat_rw(struct ath6kl_sdio *ar_sdio,
-			       struct bus_request *req)
-{
-	struct mmc_request mmc_req;
-	struct mmc_command cmd;
-	struct mmc_data data;
-	struct hif_scatter_req *scat_req;
-	u8 opcode, rw;
-	int status, len;
-
-	scat_req = req->scat_req;
-
-	if (scat_req->virt_scat) {
-		len = scat_req->len;
-		if (scat_req->req & HIF_BLOCK_BASIS)
-			len = round_down(len, HIF_MBOX_BLOCK_SIZE);
-
-		status = ath6kl_sdio_io(ar_sdio->func, scat_req->req,
-					scat_req->addr, scat_req->virt_dma_buf,
-					len);
-		goto scat_complete;
-	}
-
-	memset(&mmc_req, 0, sizeof(struct mmc_request));
-	memset(&cmd, 0, sizeof(struct mmc_command));
-	memset(&data, 0, sizeof(struct mmc_data));
-
-	ath6kl_sdio_setup_scat_data(scat_req, &data);
-
-	opcode = (scat_req->req & HIF_FIXED_ADDRESS) ?
-		  CMD53_ARG_FIXED_ADDRESS : CMD53_ARG_INCR_ADDRESS;
-
-	rw = (scat_req->req & HIF_WRITE) ? CMD53_ARG_WRITE : CMD53_ARG_READ;
-
-	/* Fixup the address so that the last byte will fall on MBOX EOM */
-	if (scat_req->req & HIF_WRITE) {
-		if (scat_req->addr == HIF_MBOX_BASE_ADDR)
-			scat_req->addr += HIF_MBOX_WIDTH - scat_req->len;
-		else
-			/* Uses extended address range */
-			scat_req->addr += HIF_MBOX0_EXT_WIDTH - scat_req->len;
-	}
-
-	/* set command argument */
-	ath6kl_sdio_set_cmd53_arg(&cmd.arg, rw, ar_sdio->func->num,
-				  CMD53_ARG_BLOCK_BASIS, opcode, scat_req->addr,
-				  data.blocks);
-
-	cmd.opcode = SD_IO_RW_EXTENDED;
-	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
-
-	mmc_req.cmd = &cmd;
-	mmc_req.data = &data;
-
-	sdio_claim_host(ar_sdio->func);
-
-	mmc_set_data_timeout(&data, ar_sdio->func->card);
-	/* synchronous call to process request */
-	mmc_wait_for_req(ar_sdio->func->card->host, &mmc_req);
-
-	sdio_release_host(ar_sdio->func);
-
-	status = cmd.error ? cmd.error : data.error;
-
-scat_complete:
-	scat_req->status = status;
-
-	if (scat_req->status)
-		ath6kl_err("Scatter write request failed:%d\n",
-			   scat_req->status);
-
-	if (scat_req->req & HIF_ASYNCHRONOUS)
-		scat_req->complete(ar_sdio->ar->htc_target, scat_req);
-
-	return status;
-}
-
-static int ath6kl_sdio_alloc_prep_scat_req(struct ath6kl_sdio *ar_sdio,
-					   int n_scat_entry, int n_scat_req,
-					   bool virt_scat)
-{
-	struct hif_scatter_req *s_req;
-	struct bus_request *bus_req;
-	int i, scat_req_sz, scat_list_sz, sg_sz, buf_sz;
-	u8 *virt_buf;
-
-	scat_list_sz = (n_scat_entry - 1) * sizeof(struct hif_scatter_item);
-	scat_req_sz = sizeof(*s_req) + scat_list_sz;
-
-	if (!virt_scat)
-		sg_sz = sizeof(struct scatterlist) * n_scat_entry;
-	else
-		buf_sz =  2 * L1_CACHE_BYTES +
-			  ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;
-
-	for (i = 0; i < n_scat_req; i++) {
-		/* allocate the scatter request */
-		s_req = kzalloc(scat_req_sz, GFP_KERNEL);
-		if (!s_req)
-			return -ENOMEM;
-
-		if (virt_scat) {
-			virt_buf = kzalloc(buf_sz, GFP_KERNEL);
-			if (!virt_buf) {
-				kfree(s_req);
-				return -ENOMEM;
-			}
-
-			s_req->virt_dma_buf =
-				(u8 *)L1_CACHE_ALIGN((unsigned long)virt_buf);
-		} else {
-			/* allocate sglist */
-			s_req->sgentries = kzalloc(sg_sz, GFP_KERNEL);
-
-			if (!s_req->sgentries) {
-				kfree(s_req);
-				return -ENOMEM;
-			}
-		}
-
-		/* allocate a bus request for this scatter request */
-		bus_req = ath6kl_sdio_alloc_busreq(ar_sdio);
-		if (!bus_req) {
-			kfree(s_req->sgentries);
-			kfree(s_req->virt_dma_buf);
-			kfree(s_req);
-			return -ENOMEM;
-		}
-
-		/* assign the scatter request to this bus request */
-		bus_req->scat_req = s_req;
-		s_req->busrequest = bus_req;
-
-		s_req->virt_scat = virt_scat;
-
-		/* add it to the scatter pool */
-		hif_scatter_req_add(ar_sdio->ar, s_req);
-	}
-
-	return 0;
-}
-
-static int ath6kl_sdio_read_write_sync(struct ath6kl *ar, u32 addr, u8 *buf,
-				       u32 len, u32 request)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	u8  *tbuf = NULL;
-	int ret;
-	bool bounced = false;
-
-	if (request & HIF_BLOCK_BASIS)
-		len = round_down(len, HIF_MBOX_BLOCK_SIZE);
-
-	if (buf_needs_bounce(buf)) {
-		if (!ar_sdio->dma_buffer)
-			return -ENOMEM;
-		mutex_lock(&ar_sdio->dma_buffer_mutex);
-		tbuf = ar_sdio->dma_buffer;
-
-		if (request & HIF_WRITE)
-			memcpy(tbuf, buf, len);
-
-		bounced = true;
-	} else
-		tbuf = buf;
-
-	ret = ath6kl_sdio_io(ar_sdio->func, request, addr, tbuf, len);
-	if ((request & HIF_READ) && bounced)
-		memcpy(buf, tbuf, len);
-
-	if (bounced)
-		mutex_unlock(&ar_sdio->dma_buffer_mutex);
-
-	return ret;
-}
-
-static void __ath6kl_sdio_write_async(struct ath6kl_sdio *ar_sdio,
-				      struct bus_request *req)
-{
-	if (req->scat_req)
-		ath6kl_sdio_scat_rw(ar_sdio, req);
-	else {
-		void *context;
-		int status;
-
-		status = ath6kl_sdio_read_write_sync(ar_sdio->ar, req->address,
-						     req->buffer, req->length,
-						     req->request);
-		context = req->packet;
-		ath6kl_sdio_free_bus_req(ar_sdio, req);
-		ath6kl_hif_rw_comp_handler(context, status);
-	}
-}
-
-static void ath6kl_sdio_write_async_work(struct work_struct *work)
-{
-	struct ath6kl_sdio *ar_sdio;
-	struct bus_request *req, *tmp_req;
-
-	ar_sdio = container_of(work, struct ath6kl_sdio, wr_async_work);
-
-	spin_lock_bh(&ar_sdio->wr_async_lock);
-	list_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {
-		list_del(&req->list);
-		spin_unlock_bh(&ar_sdio->wr_async_lock);
-		__ath6kl_sdio_write_async(ar_sdio, req);
-		spin_lock_bh(&ar_sdio->wr_async_lock);
-	}
-	spin_unlock_bh(&ar_sdio->wr_async_lock);
-}
-
-static void ath6kl_sdio_irq_handler(struct sdio_func *func)
-{
-	int status;
-	struct ath6kl_sdio *ar_sdio;
-
-	ath6kl_dbg(ATH6KL_DBG_SDIO, "irq\n");
-
-	ar_sdio = sdio_get_drvdata(func);
-	atomic_set(&ar_sdio->irq_handling, 1);
-	/*
-	 * Release the host during interrups so we can pick it back up when
-	 * we process commands.
-	 */
-	sdio_release_host(ar_sdio->func);
-
-	status = ath6kl_hif_intr_bh_handler(ar_sdio->ar);
-	sdio_claim_host(ar_sdio->func);
-	atomic_set(&ar_sdio->irq_handling, 0);
-	wake_up(&ar_sdio->irq_wq);
-
-	WARN_ON(status && status != -ECANCELED);
-}
-
-static int ath6kl_sdio_power_on(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct sdio_func *func = ar_sdio->func;
-	int ret = 0;
-
-	if (!ar_sdio->is_disabled)
-		return 0;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "sdio power on\n");
-
-	sdio_claim_host(func);
-
-	ret = sdio_enable_func(func);
-	if (ret) {
-		ath6kl_err("Unable to enable sdio func: %d)\n", ret);
-		sdio_release_host(func);
-		return ret;
-	}
-
-	sdio_release_host(func);
-
-	/*
-	 * Wait for hardware to initialise. It should take a lot less than
-	 * 10 ms but let's be conservative here.
-	 */
-	msleep(10);
-
-	ar_sdio->is_disabled = false;
-
-	return ret;
-}
-
-static int ath6kl_sdio_power_off(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	int ret;
-
-	if (ar_sdio->is_disabled)
-		return 0;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT, "sdio power off\n");
-
-	/* Disable the card */
-	sdio_claim_host(ar_sdio->func);
-	ret = sdio_disable_func(ar_sdio->func);
-	sdio_release_host(ar_sdio->func);
-
-	if (ret)
-		return ret;
-
-	ar_sdio->is_disabled = true;
-
-	return ret;
-}
-
-static int ath6kl_sdio_write_async(struct ath6kl *ar, u32 address, u8 *buffer,
-				   u32 length, u32 request,
-				   struct htc_packet *packet)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct bus_request *bus_req;
-
-	bus_req = ath6kl_sdio_alloc_busreq(ar_sdio);
-
-	if (!bus_req)
-		return -ENOMEM;
-
-	bus_req->address = address;
-	bus_req->buffer = buffer;
-	bus_req->length = length;
-	bus_req->request = request;
-	bus_req->packet = packet;
-
-	spin_lock_bh(&ar_sdio->wr_async_lock);
-	list_add_tail(&bus_req->list, &ar_sdio->wr_asyncq);
-	spin_unlock_bh(&ar_sdio->wr_async_lock);
-	queue_work(ar->ath6kl_wq, &ar_sdio->wr_async_work);
-
-	return 0;
-}
-
-static void ath6kl_sdio_irq_enable(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	int ret;
-
-	sdio_claim_host(ar_sdio->func);
-
-	/* Register the isr */
-	ret =  sdio_claim_irq(ar_sdio->func, ath6kl_sdio_irq_handler);
-	if (ret)
-		ath6kl_err("Failed to claim sdio irq: %d\n", ret);
-
-	sdio_release_host(ar_sdio->func);
-}
-
-static bool ath6kl_sdio_is_on_irq(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-
-	return !atomic_read(&ar_sdio->irq_handling);
-}
-
-static void ath6kl_sdio_irq_disable(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	int ret;
-
-	sdio_claim_host(ar_sdio->func);
-
-	if (atomic_read(&ar_sdio->irq_handling)) {
-		sdio_release_host(ar_sdio->func);
-
-		ret = wait_event_interruptible(ar_sdio->irq_wq,
-				ath6kl_sdio_is_on_irq(ar));
-		if (ret)
-			return;
-
-		sdio_claim_host(ar_sdio->func);
-	}
-
-	ret = sdio_release_irq(ar_sdio->func);
-	if (ret)
-		ath6kl_err("Failed to release sdio irq: %d\n", ret);
-
-	sdio_release_host(ar_sdio->func);
-}
-
-static struct hif_scatter_req *ath6kl_sdio_scatter_req_get(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct hif_scatter_req *node = NULL;
-
-	spin_lock_bh(&ar_sdio->scat_lock);
-
-	if (!list_empty(&ar_sdio->scat_req)) {
-		node = list_first_entry(&ar_sdio->scat_req,
-					struct hif_scatter_req, list);
-		list_del(&node->list);
-
-		node->scat_q_depth = get_queue_depth(&ar_sdio->scat_req);
-	}
-
-	spin_unlock_bh(&ar_sdio->scat_lock);
-
-	return node;
-}
-
-static void ath6kl_sdio_scatter_req_add(struct ath6kl *ar,
-					struct hif_scatter_req *s_req)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-
-	spin_lock_bh(&ar_sdio->scat_lock);
-
-	list_add_tail(&s_req->list, &ar_sdio->scat_req);
-
-	spin_unlock_bh(&ar_sdio->scat_lock);
-
-}
-
-/* scatter gather read write request */
-static int ath6kl_sdio_async_rw_scatter(struct ath6kl *ar,
-					struct hif_scatter_req *scat_req)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	u32 request = scat_req->req;
-	int status = 0;
-
-	if (!scat_req->len)
-		return -EINVAL;
-
-	ath6kl_dbg(ATH6KL_DBG_SCATTER,
-		"hif-scatter: total len: %d scatter entries: %d\n",
-		scat_req->len, scat_req->scat_entries);
-
-	if (request & HIF_SYNCHRONOUS)
-		status = ath6kl_sdio_scat_rw(ar_sdio, scat_req->busrequest);
-	else {
-		spin_lock_bh(&ar_sdio->wr_async_lock);
-		list_add_tail(&scat_req->busrequest->list, &ar_sdio->wr_asyncq);
-		spin_unlock_bh(&ar_sdio->wr_async_lock);
-		queue_work(ar->ath6kl_wq, &ar_sdio->wr_async_work);
-	}
-
-	return status;
-}
-
-/* clean up scatter support */
-static void ath6kl_sdio_cleanup_scatter(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct hif_scatter_req *s_req, *tmp_req;
-
-	/* empty the free list */
-	spin_lock_bh(&ar_sdio->scat_lock);
-	list_for_each_entry_safe(s_req, tmp_req, &ar_sdio->scat_req, list) {
-		list_del(&s_req->list);
-		spin_unlock_bh(&ar_sdio->scat_lock);
-
-		/*
-		 * FIXME: should we also call completion handler with
-		 * ath6kl_hif_rw_comp_handler() with status -ECANCELED so
-		 * that the packet is properly freed?
-		 */
-		if (s_req->busrequest)
-			ath6kl_sdio_free_bus_req(ar_sdio, s_req->busrequest);
-		kfree(s_req->virt_dma_buf);
-		kfree(s_req->sgentries);
-		kfree(s_req);
-
-		spin_lock_bh(&ar_sdio->scat_lock);
-	}
-	spin_unlock_bh(&ar_sdio->scat_lock);
-}
-
-/* setup of HIF scatter resources */
-static int ath6kl_sdio_enable_scatter(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct htc_target *target = ar->htc_target;
-	int ret;
-	bool virt_scat = false;
-
-	if (ar_sdio->scatter_enabled)
-		return 0;
-
-	ar_sdio->scatter_enabled = true;
-
-	/* check if host supports scatter and it meets our requirements */
-	if (ar_sdio->func->card->host->max_segs < MAX_SCATTER_ENTRIES_PER_REQ) {
-		ath6kl_err("host only supports scatter of :%d entries, need: %d\n",
-			   ar_sdio->func->card->host->max_segs,
-			   MAX_SCATTER_ENTRIES_PER_REQ);
-		virt_scat = true;
-	}
-
-	if (!virt_scat) {
-		ret = ath6kl_sdio_alloc_prep_scat_req(ar_sdio,
-				MAX_SCATTER_ENTRIES_PER_REQ,
-				MAX_SCATTER_REQUESTS, virt_scat);
-
-		if (!ret) {
-			ath6kl_dbg(ATH6KL_DBG_BOOT,
-				   "hif-scatter enabled requests %d entries %d\n",
-				   MAX_SCATTER_REQUESTS,
-				   MAX_SCATTER_ENTRIES_PER_REQ);
-
-			target->max_scat_entries = MAX_SCATTER_ENTRIES_PER_REQ;
-			target->max_xfer_szper_scatreq =
-						MAX_SCATTER_REQ_TRANSFER_SIZE;
-		} else {
-			ath6kl_sdio_cleanup_scatter(ar);
-			ath6kl_warn("hif scatter resource setup failed, trying virtual scatter method\n");
-		}
-	}
-
-	if (virt_scat || ret) {
-		ret = ath6kl_sdio_alloc_prep_scat_req(ar_sdio,
-				ATH6KL_SCATTER_ENTRIES_PER_REQ,
-				ATH6KL_SCATTER_REQS, virt_scat);
-
-		if (ret) {
-			ath6kl_err("failed to alloc virtual scatter resources !\n");
-			ath6kl_sdio_cleanup_scatter(ar);
-			return ret;
-		}
-
-		ath6kl_dbg(ATH6KL_DBG_BOOT,
-			   "virtual scatter enabled requests %d entries %d\n",
-			   ATH6KL_SCATTER_REQS, ATH6KL_SCATTER_ENTRIES_PER_REQ);
-
-		target->max_scat_entries = ATH6KL_SCATTER_ENTRIES_PER_REQ;
-		target->max_xfer_szper_scatreq =
-					ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;
-	}
-
-	return 0;
-}
-
-static int ath6kl_sdio_config(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct sdio_func *func = ar_sdio->func;
-	int ret;
-
-	sdio_claim_host(func);
-
-	if ((ar_sdio->id->device & MANUFACTURER_ID_ATH6KL_BASE_MASK) >=
-	    MANUFACTURER_ID_AR6003_BASE) {
-		/* enable 4-bit ASYNC interrupt on AR6003 or later */
-		ret = ath6kl_sdio_func0_cmd52_wr_byte(func->card,
-						CCCR_SDIO_IRQ_MODE_REG,
-						SDIO_IRQ_MODE_ASYNC_4BIT_IRQ);
-		if (ret) {
-			ath6kl_err("Failed to enable 4-bit async irq mode %d\n",
-				   ret);
-			goto out;
-		}
-
-		ath6kl_dbg(ATH6KL_DBG_BOOT, "4-bit async irq mode enabled\n");
-	}
-
-	/* give us some time to enable, in ms */
-	func->enable_timeout = 100;
-
-	ret = sdio_set_block_size(func, HIF_MBOX_BLOCK_SIZE);
-	if (ret) {
-		ath6kl_err("Set sdio block size %d failed: %d)\n",
-			   HIF_MBOX_BLOCK_SIZE, ret);
-		goto out;
-	}
-
-out:
-	sdio_release_host(func);
-
-	return ret;
-}
-
-static int ath6kl_set_sdio_pm_caps(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct sdio_func *func = ar_sdio->func;
-	mmc_pm_flag_t flags;
-	int ret;
-
-	flags = sdio_get_host_pm_caps(func);
-
-	ath6kl_dbg(ATH6KL_DBG_SUSPEND, "sdio suspend pm_caps 0x%x\n", flags);
-
-	if (!(flags & MMC_PM_WAKE_SDIO_IRQ) ||
-	    !(flags & MMC_PM_KEEP_POWER))
-		return -EINVAL;
-
-	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
-	if (ret) {
-		ath6kl_err("set sdio keep pwr flag failed: %d\n", ret);
-		return ret;
-	}
-
-	/* sdio irq wakes up host */
-	ret = sdio_set_host_pm_flags(func, MMC_PM_WAKE_SDIO_IRQ);
-	if (ret)
-		ath6kl_err("set sdio wake irq flag failed: %d\n", ret);
-
-	return ret;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-static int ath6kl_sdio_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct sdio_func *func = ar_sdio->func;
-	mmc_pm_flag_t flags;
-	bool try_deepsleep = false;
-	int ret;
-
-	if (ar->suspend_mode == WLAN_POWER_STATE_WOW ||
-	    (!ar->suspend_mode && wow)) {
-
-		ret = ath6kl_set_sdio_pm_caps(ar);
-		if (ret)
-			goto cut_pwr;
-
-		ret = ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_WOW, wow);
-		if (ret && ret != -ENOTCONN)
-			ath6kl_err("wow suspend failed: %d\n", ret);
-
-		if (ret && (!ar->wow_suspend_mode ||
-		    ar->wow_suspend_mode == WLAN_POWER_STATE_DEEP_SLEEP))
-				try_deepsleep = true;
-		else if (ret &&
-			 ar->wow_suspend_mode == WLAN_POWER_STATE_CUT_PWR)
-				goto cut_pwr;
-		if (!ret)
-			return 0;
-	}
-
-	if (ar->suspend_mode == WLAN_POWER_STATE_DEEP_SLEEP ||
-	    !ar->suspend_mode || try_deepsleep) {
-
-		flags = sdio_get_host_pm_caps(func);
-		if (!(flags & MMC_PM_KEEP_POWER))
-			goto cut_pwr;
-
-		ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
-		if (ret)
-			goto cut_pwr;
-
-		/*
-		 * Workaround to support Deep Sleep with MSM, set the host pm
-		 * flag as MMC_PM_WAKE_SDIO_IRQ to allow SDCC deiver to disable
-		 * the sdc2_clock and internally allows MSM to enter
-		 * TCXO shutdown properly.
-		 */
-		if ((flags & MMC_PM_WAKE_SDIO_IRQ)) {
-			ret = sdio_set_host_pm_flags(func,
-						MMC_PM_WAKE_SDIO_IRQ);
-			if (ret)
-				goto cut_pwr;
-		}
-
-		ret = ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_DEEPSLEEP,
-					      NULL);
-		if (ret)
-			goto cut_pwr;
-
-		return 0;
-	}
-
-cut_pwr:
-	if (func->card && func->card->host)
-		func->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;
-
-	return ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_CUTPOWER, NULL);
-}
-
-static int ath6kl_sdio_resume(struct ath6kl *ar)
-{
-	switch (ar->state) {
-	case ATH6KL_STATE_OFF:
-	case ATH6KL_STATE_CUTPOWER:
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND,
-			   "sdio resume configuring sdio\n");
-
-		/* need to set sdio settings after power is cut from sdio */
-		ath6kl_sdio_config(ar);
-		break;
-
-	case ATH6KL_STATE_ON:
-		break;
-
-	case ATH6KL_STATE_DEEPSLEEP:
-		break;
-
-	case ATH6KL_STATE_WOW:
-		break;
-
-	case ATH6KL_STATE_SUSPENDING:
-		break;
-
-	case ATH6KL_STATE_RESUMING:
-		break;
-
-	case ATH6KL_STATE_RECOVERY:
-		break;
-	}
-
-	ath6kl_cfg80211_resume(ar);
-
-	return 0;
-}
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)) */
-
-/* set the window address register (using 4-byte register access ). */
-static int ath6kl_set_addrwin_reg(struct ath6kl *ar, u32 reg_addr, u32 addr)
-{
-	int status;
-	u8 addr_val[4];
-	s32 i;
-
-	/*
-	 * Write bytes 1,2,3 of the register to set the upper address bytes,
-	 * the LSB is written last to initiate the access cycle
-	 */
-
-	for (i = 1; i <= 3; i++) {
-		/*
-		 * Fill the buffer with the address byte value we want to
-		 * hit 4 times.
-		 */
-		memset(addr_val, ((u8 *)&addr)[i], 4);
-
-		/*
-		 * Hit each byte of the register address with a 4-byte
-		 * write operation to the same address, this is a harmless
-		 * operation.
-		 */
-		status = ath6kl_sdio_read_write_sync(ar, reg_addr + i, addr_val,
-					     4, HIF_WR_SYNC_BYTE_FIX);
-		if (status)
-			break;
-	}
-
-	if (status) {
-		ath6kl_err("%s: failed to write initial bytes of 0x%x "
-			   "to window reg: 0x%X\n", __func__,
-			   addr, reg_addr);
-		return status;
-	}
-
-	/*
-	 * Write the address register again, this time write the whole
-	 * 4-byte value. The effect here is that the LSB write causes the
-	 * cycle to start, the extra 3 byte write to bytes 1,2,3 has no
-	 * effect since we are writing the same values again
-	 */
-	status = ath6kl_sdio_read_write_sync(ar, reg_addr, (u8 *)(&addr),
-				     4, HIF_WR_SYNC_BYTE_INC);
-
-	if (status) {
-		ath6kl_err("%s: failed to write 0x%x to window reg: 0x%X\n",
-			   __func__, addr, reg_addr);
-		return status;
-	}
-
-	return 0;
-}
-
-static int ath6kl_sdio_diag_read32(struct ath6kl *ar, u32 address, u32 *data)
-{
-	int status;
-
-	/* set window register to start read cycle */
-	status = ath6kl_set_addrwin_reg(ar, WINDOW_READ_ADDR_ADDRESS,
-					address);
-
-	if (status)
-		return status;
-
-	/* read the data */
-	status = ath6kl_sdio_read_write_sync(ar, WINDOW_DATA_ADDRESS,
-				(u8 *)data, sizeof(u32), HIF_RD_SYNC_BYTE_INC);
-	if (status) {
-		ath6kl_err("%s: failed to read from window data addr\n",
-			__func__);
-		return status;
-	}
-
-	return status;
-}
-
-static int ath6kl_sdio_diag_write32(struct ath6kl *ar, u32 address,
-				    __le32 data)
-{
-	int status;
-	u32 val = (__force u32) data;
-
-	/* set write data */
-	status = ath6kl_sdio_read_write_sync(ar, WINDOW_DATA_ADDRESS,
-				(u8 *) &val, sizeof(u32), HIF_WR_SYNC_BYTE_INC);
-	if (status) {
-		ath6kl_err("%s: failed to write 0x%x to window data addr\n",
-			   __func__, data);
-		return status;
-	}
-
-	/* set window register, which starts the write cycle */
-	return ath6kl_set_addrwin_reg(ar, WINDOW_WRITE_ADDR_ADDRESS,
-				      address);
-}
-
-static int ath6kl_sdio_bmi_credits(struct ath6kl *ar)
-{
-	u32 addr;
-	unsigned long timeout;
-	int ret;
-
-	ar->bmi.cmd_credits = 0;
-
-	/* Read the counter register to get the command credits */
-	addr = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;
-
-	timeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);
-	while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
-
-		/*
-		 * Hit the credit counter with a 4-byte access, the first byte
-		 * read will hit the counter and cause a decrement, while the
-		 * remaining 3 bytes has no effect. The rationale behind this
-		 * is to make all HIF accesses 4-byte aligned.
-		 */
-		ret = ath6kl_sdio_read_write_sync(ar, addr,
-					 (u8 *)&ar->bmi.cmd_credits, 4,
-					 HIF_RD_SYNC_BYTE_INC);
-		if (ret) {
-			ath6kl_err("Unable to decrement the command credit "
-						"count register: %d\n", ret);
-			return ret;
-		}
-
-		/* The counter is only 8 bits.
-		 * Ignore anything in the upper 3 bytes
-		 */
-		ar->bmi.cmd_credits &= 0xFF;
-	}
-
-	if (!ar->bmi.cmd_credits) {
-		ath6kl_err("bmi communication timeout\n");
-		return -ETIMEDOUT;
-	}
-
-	return 0;
-}
-
-static int ath6kl_bmi_get_rx_lkahd(struct ath6kl *ar)
-{
-	unsigned long timeout;
-	u32 rx_word = 0;
-	int ret = 0;
-
-	timeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);
-	while ((time_before(jiffies, timeout)) && !rx_word) {
-		ret = ath6kl_sdio_read_write_sync(ar,
-					RX_LOOKAHEAD_VALID_ADDRESS,
-					(u8 *)&rx_word, sizeof(rx_word),
-					HIF_RD_SYNC_BYTE_INC);
-		if (ret) {
-			ath6kl_err("unable to read RX_LOOKAHEAD_VALID\n");
-			return ret;
-		}
-
-		 /* all we really want is one bit */
-		rx_word &= (1 << ENDPOINT1);
-	}
-
-	if (!rx_word) {
-		ath6kl_err("bmi_recv_buf FIFO empty\n");
-		return -EINVAL;
-	}
-
-	return ret;
-}
-
-static int ath6kl_sdio_bmi_write(struct ath6kl *ar, u8 *buf, u32 len)
-{
-	int ret;
-	u32 addr;
-
-	ret = ath6kl_sdio_bmi_credits(ar);
-	if (ret)
-		return ret;
-
-	addr = ar->mbox_info.htc_addr;
-
-	ret = ath6kl_sdio_read_write_sync(ar, addr, buf, len,
-					  HIF_WR_SYNC_BYTE_INC);
-	if (ret)
-		ath6kl_err("unable to send the bmi data to the device\n");
-
-	return ret;
-}
-
-static int ath6kl_sdio_bmi_read(struct ath6kl *ar, u8 *buf, u32 len)
-{
-	int ret;
-	u32 addr;
-
-	/*
-	 * During normal bootup, small reads may be required.
-	 * Rather than issue an HIF Read and then wait as the Target
-	 * adds successive bytes to the FIFO, we wait here until
-	 * we know that response data is available.
-	 *
-	 * This allows us to cleanly timeout on an unexpected
-	 * Target failure rather than risk problems at the HIF level.
-	 * In particular, this avoids SDIO timeouts and possibly garbage
-	 * data on some host controllers.  And on an interconnect
-	 * such as Compact Flash (as well as some SDIO masters) which
-	 * does not provide any indication on data timeout, it avoids
-	 * a potential hang or garbage response.
-	 *
-	 * Synchronization is more difficult for reads larger than the
-	 * size of the MBOX FIFO (128B), because the Target is unable
-	 * to push the 129th byte of data until AFTER the Host posts an
-	 * HIF Read and removes some FIFO data.  So for large reads the
-	 * Host proceeds to post an HIF Read BEFORE all the data is
-	 * actually available to read.  Fortunately, large BMI reads do
-	 * not occur in practice -- they're supported for debug/development.
-	 *
-	 * So Host/Target BMI synchronization is divided into these cases:
-	 *  CASE 1: length < 4
-	 *        Should not happen
-	 *
-	 *  CASE 2: 4 <= length <= 128
-	 *        Wait for first 4 bytes to be in FIFO
-	 *        If CONSERVATIVE_BMI_READ is enabled, also wait for
-	 *        a BMI command credit, which indicates that the ENTIRE
-	 *        response is available in the the FIFO
-	 *
-	 *  CASE 3: length > 128
-	 *        Wait for the first 4 bytes to be in FIFO
-	 *
-	 * For most uses, a small timeout should be sufficient and we will
-	 * usually see a response quickly; but there may be some unusual
-	 * (debug) cases of BMI_EXECUTE where we want an larger timeout.
-	 * For now, we use an unbounded busy loop while waiting for
-	 * BMI_EXECUTE.
-	 *
-	 * If BMI_EXECUTE ever needs to support longer-latency execution,
-	 * especially in production, this code needs to be enhanced to sleep
-	 * and yield.  Also note that BMI_COMMUNICATION_TIMEOUT is currently
-	 * a function of Host processor speed.
-	 */
-	if (len >= 4) { /* NB: Currently, always true */
-		ret = ath6kl_bmi_get_rx_lkahd(ar);
-		if (ret)
-			return ret;
-	}
-
-	addr = ar->mbox_info.htc_addr;
-	ret = ath6kl_sdio_read_write_sync(ar, addr, buf, len,
-				  HIF_RD_SYNC_BYTE_INC);
-	if (ret) {
-		ath6kl_err("Unable to read the bmi data from the device: %d\n",
-			   ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static void ath6kl_sdio_stop(struct ath6kl *ar)
-{
-	struct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);
-	struct bus_request *req, *tmp_req;
-	void *context;
-
-	/* FIXME: make sure that wq is not queued again */
-
-	cancel_work_sync(&ar_sdio->wr_async_work);
-
-	spin_lock_bh(&ar_sdio->wr_async_lock);
-
-	list_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {
-		list_del(&req->list);
-
-		if (req->scat_req) {
-			/* this is a scatter gather request */
-			req->scat_req->status = -ECANCELED;
-			req->scat_req->complete(ar_sdio->ar->htc_target,
-						req->scat_req);
-		} else {
-			context = req->packet;
-			ath6kl_sdio_free_bus_req(ar_sdio, req);
-			ath6kl_hif_rw_comp_handler(context, -ECANCELED);
-		}
-	}
-
-	spin_unlock_bh(&ar_sdio->wr_async_lock);
-
-	WARN_ON(get_queue_depth(&ar_sdio->scat_req) != 4);
-}
-
-static const struct ath6kl_hif_ops ath6kl_sdio_ops = {
-	.read_write_sync = ath6kl_sdio_read_write_sync,
-	.write_async = ath6kl_sdio_write_async,
-	.irq_enable = ath6kl_sdio_irq_enable,
-	.irq_disable = ath6kl_sdio_irq_disable,
-	.scatter_req_get = ath6kl_sdio_scatter_req_get,
-	.scatter_req_add = ath6kl_sdio_scatter_req_add,
-	.enable_scatter = ath6kl_sdio_enable_scatter,
-	.scat_req_rw = ath6kl_sdio_async_rw_scatter,
-	.cleanup_scatter = ath6kl_sdio_cleanup_scatter,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	.suspend = ath6kl_sdio_suspend,
-	.resume = ath6kl_sdio_resume,
-#endif
-	.diag_read32 = ath6kl_sdio_diag_read32,
-	.diag_write32 = ath6kl_sdio_diag_write32,
-	.bmi_read = ath6kl_sdio_bmi_read,
-	.bmi_write = ath6kl_sdio_bmi_write,
-	.power_on = ath6kl_sdio_power_on,
-	.power_off = ath6kl_sdio_power_off,
-	.stop = ath6kl_sdio_stop,
-};
-
-#if defined(CONFIG_PM_SLEEP) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-
-/*
- * Empty handlers so that mmc subsystem doesn't remove us entirely during
- * suspend. We instead follow cfg80211 suspend/resume handlers.
- */
-static int ath6kl_sdio_pm_suspend(struct device *device)
-{
-	ath6kl_dbg(ATH6KL_DBG_SUSPEND, "sdio pm suspend\n");
-
-	return 0;
-}
-
-static int ath6kl_sdio_pm_resume(struct device *device)
-{
-	ath6kl_dbg(ATH6KL_DBG_SUSPEND, "sdio pm resume\n");
-
-	return 0;
-}
-
-static SIMPLE_DEV_PM_OPS(ath6kl_sdio_pm_ops, ath6kl_sdio_pm_suspend,
-			 ath6kl_sdio_pm_resume);
-
-#define ATH6KL_SDIO_PM_OPS (&ath6kl_sdio_pm_ops)
-
-#else
-
-#define ATH6KL_SDIO_PM_OPS NULL
-
-#endif /* CONFIG_PM_SLEEP */
-
-static int ath6kl_sdio_probe(struct sdio_func *func,
-			     const struct sdio_device_id *id)
-{
-	int ret;
-	struct ath6kl_sdio *ar_sdio;
-	struct ath6kl *ar;
-	int count;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "sdio new func %d vendor 0x%x device 0x%x block 0x%x/0x%x\n",
-		   func->num, func->vendor, func->device,
-		   func->max_blksize, func->cur_blksize);
-
-	ar_sdio = kzalloc(sizeof(struct ath6kl_sdio), GFP_KERNEL);
-	if (!ar_sdio)
-		return -ENOMEM;
-
-	ar_sdio->dma_buffer = kzalloc(HIF_DMA_BUFFER_SIZE, GFP_KERNEL);
-	if (!ar_sdio->dma_buffer) {
-		ret = -ENOMEM;
-		goto err_hif;
-	}
-
-	ar_sdio->func = func;
-	sdio_set_drvdata(func, ar_sdio);
-
-	ar_sdio->id = id;
-	ar_sdio->is_disabled = true;
-
-	spin_lock_init(&ar_sdio->lock);
-	spin_lock_init(&ar_sdio->scat_lock);
-	spin_lock_init(&ar_sdio->wr_async_lock);
-	mutex_init(&ar_sdio->dma_buffer_mutex);
-
-	INIT_LIST_HEAD(&ar_sdio->scat_req);
-	INIT_LIST_HEAD(&ar_sdio->bus_req_freeq);
-	INIT_LIST_HEAD(&ar_sdio->wr_asyncq);
-
-	INIT_WORK(&ar_sdio->wr_async_work, ath6kl_sdio_write_async_work);
-	init_waitqueue_head(&ar_sdio->irq_wq);
-
-	for (count = 0; count < BUS_REQUEST_MAX_NUM; count++)
-		ath6kl_sdio_free_bus_req(ar_sdio, &ar_sdio->bus_req[count]);
-
-	ar = ath6kl_core_alloc(&ar_sdio->func->dev);
-	if (!ar) {
-		ath6kl_err("Failed to alloc ath6kl core\n");
-		ret = -ENOMEM;
-		goto err_dma;
-	}
-
-	ar_sdio->ar = ar;
-	ar->hif_type = ATH6KL_HIF_TYPE_SDIO;
-	ar->hif_priv = ar_sdio;
-	ar->hif_ops = &ath6kl_sdio_ops;
-	ar->bmi.max_data_size = 256;
-
-	ath6kl_sdio_set_mbox_info(ar);
-
-	ret = ath6kl_sdio_config(ar);
-	if (ret) {
-		ath6kl_err("Failed to config sdio: %d\n", ret);
-		goto err_core_alloc;
-	}
-
-	ret = ath6kl_core_init(ar);
-	if (ret) {
-		ath6kl_err("Failed to init ath6kl core\n");
-		goto err_core_alloc;
-	}
-
-	ath6kl_notify_init_done();
-	return ret;
-
-err_core_alloc:
-	ath6kl_core_free(ar_sdio->ar);
-err_dma:
-	kfree(ar_sdio->dma_buffer);
-err_hif:
-	kfree(ar_sdio);
-
-	return ret;
-}
-
-static void ath6kl_sdio_remove(struct sdio_func *func)
-{
-	struct ath6kl_sdio *ar_sdio;
-
-	ath6kl_dbg(ATH6KL_DBG_BOOT,
-		   "sdio removed func %d vendor 0x%x device 0x%x\n",
-		   func->num, func->vendor, func->device);
-
-	ar_sdio = sdio_get_drvdata(func);
-
-	ath6kl_stop_txrx(ar_sdio->ar);
-	cancel_work_sync(&ar_sdio->wr_async_work);
-
-	ath6kl_core_cleanup(ar_sdio->ar);
-
-	kfree(ar_sdio->dma_buffer);
-	kfree(ar_sdio);
-}
-
-static const struct sdio_device_id ath6kl_sdio_devices[] = {
-	{SDIO_DEVICE(MANUFACTURER_CODE, (MANUFACTURER_ID_AR6003_BASE | 0x0))},
-	{SDIO_DEVICE(MANUFACTURER_CODE, (MANUFACTURER_ID_AR6003_BASE | 0x1))},
-	{SDIO_DEVICE(MANUFACTURER_CODE, (MANUFACTURER_ID_AR6004_BASE | 0x0))},
-	{SDIO_DEVICE(MANUFACTURER_CODE, (MANUFACTURER_ID_AR6004_BASE | 0x1))},
-	{},
-};
-
-MODULE_DEVICE_TABLE(sdio, ath6kl_sdio_devices);
-
-static struct sdio_driver ath6kl_sdio_driver = {
-	.name = "ath6kl_sdio",
-	.id_table = ath6kl_sdio_devices,
-	.probe = ath6kl_sdio_probe,
-	.remove = ath6kl_sdio_remove,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	.drv.pm = ATH6KL_SDIO_PM_OPS,
-#endif
-};
-
-static int __init ath6kl_sdio_init(void)
-{
-	int ret;
-
-	ath6kl_sdio_init_platform();
-
-	init_waitqueue_head(&init_wq);
-
-	ret = sdio_register_driver(&ath6kl_sdio_driver);
-	if (ret) {
-		ath6kl_err("sdio driver registration failed: %d\n", ret);
-		return ret;
-	}
-
-	ret = ath6kl_wait_for_init_comp();
-
-	return ret;
-}
-
-static void __exit ath6kl_sdio_exit(void)
-{
-	sdio_unregister_driver(&ath6kl_sdio_driver);
-	ath6kl_sdio_exit_platform();
-}
-
-module_init(ath6kl_sdio_init);
-module_exit(ath6kl_sdio_exit);
-
-MODULE_AUTHOR("Atheros Communications, Inc.");
-MODULE_DESCRIPTION("Driver support for Atheros AR600x SDIO devices");
-MODULE_LICENSE("Dual BSD/GPL");
-
-MODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR "/" AR6003_HW_2_0_OTP_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR "/" AR6003_HW_2_0_FIRMWARE_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR "/" AR6003_HW_2_0_PATCH_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_0_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_0_DEFAULT_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR "/" AR6003_HW_2_1_1_OTP_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR "/" AR6003_HW_2_1_1_FIRMWARE_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR "/" AR6003_HW_2_1_1_PATCH_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_1_1_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6003_HW_2_1_1_DEFAULT_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_0_FW_DIR "/" AR6004_HW_1_0_FIRMWARE_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_0_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_0_DEFAULT_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_1_FW_DIR "/" AR6004_HW_1_1_FIRMWARE_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_1_BOARD_DATA_FILE);
-MODULE_FIRMWARE(AR6004_HW_1_1_DEFAULT_BOARD_DATA_FILE);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/softmac.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/softmac.c
index f09ee66..7d2fca1 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/softmac.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/softmac.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2011 Atheros Communications Inc.
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/target.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/target.h
index a98c12b..76f0208 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/target.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/target.h
@@ -18,6 +18,11 @@
 #ifndef TARGET_H
 #define TARGET_H
 
+#define AR6003_BOARD_DATA_ADDR         0x00540654
+#define AR6003_BOARD_DATA_INIT_ADDR    0x00540658
+#define AR6003_BOARD_DATA_OFFSET       4
+#define AR6003_RD_OFFSET               12
+
 #define AR6003_BOARD_DATA_SZ		1024
 #define AR6003_BOARD_EXT_DATA_SZ	768
 #define AR6003_BOARD_EXT_DATA_SZ_V2	1024
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/txrx.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/txrx.c
index c8b73b7..a1c6656 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/txrx.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/txrx.c
@@ -25,6 +25,53 @@
 #define ATH6KL_TID_MASK 0xf
 #define ATH6KL_AID_SHIFT 4
 
+static bool ath6kl_is_dhcp_pkt(struct sk_buff *skb, u8 *msg)
+{
+	struct dhcp_packet *dhcp = (struct dhcp_packet *) skb->data;
+
+	if ((ntohs(dhcp->eth_hdr.h_proto) != ETH_P_IP) ||
+	    (dhcp->bootp_hdr.iph.protocol != IPPROTO_UDP))
+		return false;
+
+	if ((ntohs(dhcp->bootp_hdr.udph.dest) != 67) && /* port 67 */
+	    (ntohs(dhcp->bootp_hdr.udph.dest) != 68))   /* port 68 */
+		return false;
+
+	if ((dhcp->bootp_hdr.exten[4] != ATH6KL_DHCP_OPCODE_MSG_TYPE) ||
+	    (dhcp->bootp_hdr.exten[5] != ATH6KL_DHCP_MSG_TYPE_LEN))
+		return false;
+
+	*msg = dhcp->bootp_hdr.exten[6];
+
+	ath6kl_dbg(ATH6KL_DBG_ANY, "dhcp pkt - type: %d\n", *msg);
+
+	return true;
+}
+
+static int ath6kl_sniff_dhcp_pkt(struct ath6kl *ar, struct ath6kl_vif *vif,
+				struct sk_buff *skb, u16 type)
+{
+	u8 dhcp_msg;
+	int ret = 0;
+
+	if (vif->nw_type != INFRA_NETWORK)
+		return ret;
+
+	if (type != WMI_BTCOEX_DBG_CMD_DHCP_TX &&
+	    type != WMI_BTCOEX_DBG_CMD_DHCP_RX)
+		return ret;
+
+	if (!ath6kl_is_dhcp_pkt(skb, &dhcp_msg))
+		return ret;
+
+	ret = ath6kl_wmi_set_btcoex_debug_cmd(ar->wmi, vif->fw_vif_idx, 0, 0,
+					      0, dhcp_msg, type);
+	if (ret)
+		ath6kl_err("Failed to send dhcp pkt status: %d\n", ret);
+
+	return ret;
+}
+
 static inline u8 ath6kl_get_tid(u8 tid_mux)
 {
 	return tid_mux & ATH6KL_TID_MASK;
@@ -101,7 +148,7 @@ static bool ath6kl_process_uapsdq(struct ath6kl_sta *conn,
 				u32 *flags)
 {
 	struct ath6kl *ar = vif->ar;
-	bool is_apsdq_empty = false;
+	bool is_apsdq_empty = false, is_apsdq_full = false;
 	struct ethhdr *datap = (struct ethhdr *) skb->data;
 	u8 up = 0, traffic_class, *ip_hdr;
 	u16 ether_type;
@@ -152,7 +199,16 @@ static bool ath6kl_process_uapsdq(struct ath6kl_sta *conn,
 	/* Queue the frames if the STA is sleeping */
 	spin_lock_bh(&conn->psq_lock);
 	is_apsdq_empty = skb_queue_empty(&conn->apsdq);
+	is_apsdq_full = (conn->apsdq_depth >= MAX_APSD_DEPTH_FOR_EACH_CONN) ? true : false;
+	/*apsq queue's depth is too large, drop it directly*/
+	if (is_apsdq_full) {
+		spin_unlock_bh(&conn->psq_lock);
+		dev_kfree_skb(skb);
+		*flags |= WMI_DATA_HDR_FLAGS_UAPSD;
+		return true;
+	}
 	skb_queue_tail(&conn->apsdq, skb);
+	conn->apsdq_depth++;
 	spin_unlock_bh(&conn->psq_lock);
 
 	/*
@@ -175,6 +231,7 @@ static bool ath6kl_process_psq(struct ath6kl_sta *conn,
 				u32 *flags)
 {
 	bool is_psq_empty = false;
+	bool is_psq_full = false;
 	struct ath6kl *ar = vif->ar;
 
 	if (conn->sta_flags & STA_PS_POLLED) {
@@ -188,7 +245,14 @@ static bool ath6kl_process_psq(struct ath6kl_sta *conn,
 	/* Queue the frames if the STA is sleeping */
 	spin_lock_bh(&conn->psq_lock);
 	is_psq_empty = skb_queue_empty(&conn->psq);
+	is_psq_full = (conn->psq_depth >= MAX_PSQ_DEPTH_FOR_EACH_CONN) ? true : false;
+	if (is_psq_full) {
+		spin_unlock_bh(&conn->psq_lock);
+		dev_kfree_skb(skb);
+		return true;
+	}
 	skb_queue_tail(&conn->psq, skb);
+	conn->psq_depth++;
 	spin_unlock_bh(&conn->psq_lock);
 
 	/*
@@ -286,6 +350,9 @@ int ath6kl_control_tx(void *devt, struct sk_buff *skb,
 	struct ath6kl *ar = devt;
 	int status = 0;
 	struct ath6kl_cookie *cookie = NULL;
+	struct ath6kl_vif *vif;
+	struct wmi_data_hdr *data_hdr;
+	u8 if_idx;
 
 	if (WARN_ON_ONCE(ar->state == ATH6KL_STATE_WOW)) {
 		dev_kfree_skb(skb);
@@ -320,6 +387,18 @@ int ath6kl_control_tx(void *devt, struct sk_buff *skb,
 		status = -ENOMEM;
 		goto fail_ctrl_tx;
 	}
+	if (ar->vif_cookie_cfg.load_balance && eid != ar->ctrl_ep) {
+		data_hdr = (struct wmi_data_hdr *)skb->data;
+		if_idx = wmi_data_hdr_get_if_idx(data_hdr);
+		vif = ath6kl_get_vif_by_index(ar, if_idx);
+		if (vif) {
+			spin_lock_bh(&vif->if_lock);
+			vif->cur_data_cookies++;
+			spin_unlock_bh(&vif->if_lock);
+		} else
+			WARN_ON_ONCE(1);
+	}
+
 
 	ar->tx_pending[eid]++;
 
@@ -396,6 +475,11 @@ int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
 			csum_dest = skb->csum_offset + csum_start;
 		}
 
+		ret = ath6kl_sniff_dhcp_pkt(ar, vif, skb,
+					    WMI_BTCOEX_DBG_CMD_DHCP_TX);
+		if (ret)
+			goto fail_tx;
+
 		if (skb_headroom(skb) < dev->needed_headroom) {
 			struct sk_buff *tmp_skb = skb;
 
@@ -471,6 +555,11 @@ int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
 		spin_unlock_bh(&ar->lock);
 		goto fail_tx;
 	}
+	if (ar->vif_cookie_cfg.load_balance && eid != ar->ctrl_ep) {
+		spin_lock_bh(&vif->if_lock);
+		vif->cur_data_cookies++;
+		spin_unlock_bh(&vif->if_lock);
+	}
 
 	/* update counts while the lock is held */
 	ar->tx_pending[eid]++;
@@ -588,9 +677,15 @@ enum htc_send_full_action ath6kl_tx_queue_full(struct htc_target *target,
 {
 	struct ath6kl *ar = target->dev->ar;
 	struct ath6kl_vif *vif;
+	u8 if_idx;
+	struct ath6kl_vif_cookie_cfg *cookie_cfg;
+	struct wmi_data_hdr *data_hdr;
+
 	enum htc_endpoint_id endpoint = packet->endpoint;
 	enum htc_send_full_action action = HTC_SEND_FULL_KEEP;
 
+	cookie_cfg = &ar->vif_cookie_cfg;
+
 	if (endpoint == ar->ctrl_ep) {
 		/*
 		 * Under normal WMI if this is getting full, then something
@@ -600,7 +695,9 @@ enum htc_send_full_action ath6kl_tx_queue_full(struct htc_target *target,
 		 */
 		set_bit(WMI_CTRL_EP_FULL, &ar->flag);
 		ath6kl_err("wmi ctrl ep is full\n");
+
 		ath6kl_recovery_err_notify(ar, ATH6KL_FW_EP_FULL);
+
 		return action;
 	}
 
@@ -611,7 +708,7 @@ enum htc_send_full_action ath6kl_tx_queue_full(struct htc_target *target,
 	 * The last MAX_HI_COOKIE_NUM "batch" of cookies are reserved for
 	 * the highest active stream.
 	 */
-	if (ar->ac_stream_pri_map[ar->ep2ac_map[endpoint]] <
+	if (ar->ac_stream_pri_map[ar->ep2ac_map[endpoint]] <=
 	    ar->hiac_stream_active_pri &&
 	    ar->cookie_count <=
 			target->endpoint[endpoint].tx_drop_packet_threshold)
@@ -621,6 +718,25 @@ enum htc_send_full_action ath6kl_tx_queue_full(struct htc_target *target,
 		 */
 		action = HTC_SEND_FULL_DROP;
 
+	if (cookie_cfg->load_balance &&
+	    action != HTC_SEND_FULL_DROP) {
+		data_hdr = (struct wmi_data_hdr *) packet->buf;
+		if_idx = wmi_data_hdr_get_if_idx(data_hdr);
+		vif = ath6kl_get_vif_by_index(ar, if_idx);
+		if (vif) {
+			/* drop if it reaches max and other vif is conntected */
+			if (vif->cur_data_cookies > cookie_cfg->max_cookies &&
+				ath6kl_is_other_vif_connected(ar, vif))
+				action = HTC_SEND_FULL_DROP;
+			/* drop if it reaches mid and other vif is busy */
+			else if (vif->cur_data_cookies >
+				 cookie_cfg->mid_cookies) {
+				if (ath6kl_is_other_vif_cookie_busy(ar, vif))
+					action = HTC_SEND_FULL_DROP;
+			}
+		}
+	}
+
 	/* FIXME: Locking */
 	spin_lock_bh(&ar->list_lock);
 	list_for_each_entry(vif, &ar->vif_list, list) {
@@ -704,6 +820,10 @@ void ath6kl_tx_complete(void *context, struct list_head *packet_queue)
 					  list);
 		list_del(&packet->list);
 
+		if (WARN_ON_ONCE(packet->endpoint == ENDPOINT_UNUSED ||
+				 packet->endpoint >= ENDPOINT_MAX))
+			continue;
+
 		ath6kl_cookie = (struct ath6kl_cookie *)packet->pkt_cntxt;
 		if (WARN_ON_ONCE(!ath6kl_cookie))
 			continue;
@@ -783,6 +903,14 @@ void ath6kl_tx_complete(void *context, struct list_head *packet_queue)
 
 		ath6kl_tx_clear_node_map(vif, eid, map_no);
 
+		if (ar->vif_cookie_cfg.load_balance &&
+		    eid != ar->ctrl_ep) {
+			spin_lock_bh(&vif->if_lock);
+			vif->cur_data_cookies--;
+			spin_unlock_bh(&vif->if_lock);
+			WARN_ON_ONCE(vif->cur_data_cookies < 0);
+		}
+
 		ath6kl_free_cookie(ar, ath6kl_cookie, eid == ar->ctrl_ep);
 
 		if (test_bit(NETQ_STOPPED, &vif->flags))
@@ -1201,8 +1329,12 @@ static bool aggr_process_recv_frm(struct aggr_info_conn *agg_conn, u8 tid,
 
 	aggr_deque_frms(agg_conn, tid, 0, 1);
 
-	if (agg_conn->timer_scheduled)
+	if (agg_conn->timer_scheduled) {
+		spin_lock_bh(&rxtid->lock);
+		rxtid->progress = true;
+		spin_unlock_bh(&rxtid->lock);
 		return is_queued;
+	}
 
 	for (idx = 0 ; idx < rxtid->hold_q_sz; idx++) {
 		spin_lock_bh(&rxtid->lock);
@@ -1265,6 +1397,7 @@ static void ath6kl_uapsd_trigger_frame_rx(struct ath6kl_vif *vif,
 
 		spin_lock_bh(&conn->psq_lock);
 		skb = skb_dequeue(&conn->apsdq);
+		conn->apsdq_depth--;
 		is_apsdq_empty = skb_queue_empty(&conn->apsdq);
 		spin_unlock_bh(&conn->psq_lock);
 
@@ -1313,10 +1446,11 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 	struct ath6kl_sta *conn = NULL;
 	struct sk_buff *skb1 = NULL;
 	struct ethhdr *datap = NULL;
-	struct ath6kl_vif *vif;
+	struct ath6kl_vif *vif = NULL;
 	struct aggr_info_conn *aggr_conn;
 	u16 seq_no, offset;
 	u8 tid, if_idx;
+	int ret;
 
 	ath6kl_dbg(ATH6KL_DBG_WLAN_RX,
 		   "%s: ar=0x%p eid=%d, skb=0x%p, data=0x%p, len=0x%x status:%d",
@@ -1331,6 +1465,15 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 	skb_put(skb, packet->act_len + HTC_HDR_LENGTH);
 	skb_pull(skb, HTC_HDR_LENGTH);
 
+	ath6kl_dbg_dump(ATH6KL_DBG_RAW_BYTES, __func__, "rx ",
+			skb->data, skb->len);
+
+	if (list_empty(&ar->vif_list) &&
+	    ept == ar->ctrl_ep) {
+		skb->dev = NULL;
+		goto skip_vif;
+	}
+
 	if (ept == ar->ctrl_ep) {
 		if_idx =
 		wmi_cmd_hdr_get_if_idx((struct wmi_cmd_hdr *) skb->data);
@@ -1356,10 +1499,6 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 
 	spin_unlock_bh(&vif->if_lock);
 
-
-	ath6kl_dbg_dump(ATH6KL_DBG_RAW_BYTES, __func__, "rx ",
-			skb->data, skb->len);
-
 	skb->dev = vif->ndev;
 
 	if (!test_bit(WMI_ENABLED, &ar->flag)) {
@@ -1369,6 +1508,7 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 		return;
 	}
 
+skip_vif:
 	if (ept == ar->ctrl_ep) {
 		ath6kl_check_wow_status(ar, skb, true);
 		ath6kl_wmi_control_rx(ar->wmi, skb);
@@ -1480,6 +1620,7 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 				}
 				conn->mgmt_psq_len = 0;
 				while ((skbuff = skb_dequeue(&conn->psq))) {
+					conn->psq_depth--;
 					spin_unlock_bh(&conn->psq_lock);
 					ath6kl_data_tx(skbuff, vif->ndev);
 					spin_lock_bh(&conn->psq_lock);
@@ -1487,6 +1628,7 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 
 				is_apsdq_empty = skb_queue_empty(&conn->apsdq);
 				while ((skbuff = skb_dequeue(&conn->apsdq))) {
+					conn->apsdq_depth--;
 					spin_unlock_bh(&conn->psq_lock);
 					ath6kl_data_tx(skbuff, vif->ndev);
 					spin_lock_bh(&conn->psq_lock);
@@ -1594,6 +1736,13 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 
 	datap = (struct ethhdr *) skb->data;
 
+	ret = ath6kl_sniff_dhcp_pkt(ar, vif, skb,
+				    WMI_BTCOEX_DBG_CMD_DHCP_RX);
+	if (ret) {
+		dev_kfree_skb(skb);
+		return;
+	}
+
 	if (is_unicast_ether_addr(datap->h_dest)) {
 		if (vif->nw_type == AP_NETWORK) {
 			conn = ath6kl_find_sta(vif, datap->h_source);
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.c b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.c
index ba65879..d848710 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -524,6 +524,8 @@ static int ath6kl_wmi_tx_status_event_rx(struct wmi *wmi, u8 *datap, int len,
 					 struct ath6kl_vif *vif)
 {
 	struct wmi_tx_status_event *ev;
+	u8 *last_mgmt_tx_frame = NULL;
+	size_t last_mgmt_tx_frame_len = 0;
 	u32 id;
 
 	if (len < sizeof(*ev))
@@ -533,14 +535,20 @@ static int ath6kl_wmi_tx_status_event_rx(struct wmi *wmi, u8 *datap, int len,
 	id = le32_to_cpu(ev->id);
 	ath6kl_dbg(ATH6KL_DBG_WMI, "tx_status: id=%x ack_status=%u\n",
 		   id, ev->ack_status);
-	if (wmi->last_mgmt_tx_frame) {
+
+	spin_lock_bh(&wmi->lock);
+	last_mgmt_tx_frame = wmi->last_mgmt_tx_frame;
+	last_mgmt_tx_frame_len = wmi->last_mgmt_tx_frame_len;
+	wmi->last_mgmt_tx_frame = NULL;
+	wmi->last_mgmt_tx_frame_len = 0;
+	spin_unlock_bh(&wmi->lock);
+
+	if (last_mgmt_tx_frame) {
 		cfg80211_mgmt_tx_status(vif->ndev, id,
-					wmi->last_mgmt_tx_frame,
-					wmi->last_mgmt_tx_frame_len,
+					last_mgmt_tx_frame,
+					last_mgmt_tx_frame_len,
 					!!ev->ack_status, GFP_ATOMIC);
-		kfree(wmi->last_mgmt_tx_frame);
-		wmi->last_mgmt_tx_frame = NULL;
-		wmi->last_mgmt_tx_frame_len = 0;
+		kfree(last_mgmt_tx_frame);
 	}
 
 	return 0;
@@ -691,13 +699,17 @@ static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
 static int ath6kl_wmi_ready_event_rx(struct wmi *wmi, u8 *datap, int len)
 {
 	struct wmi_ready_event_2 *ev = (struct wmi_ready_event_2 *) datap;
+	struct ath6kl *ar = wmi->parent_dev;
 
 	if (len < sizeof(struct wmi_ready_event_2))
 		return -EINVAL;
 
 	ath6kl_ready_event(wmi->parent_dev, ev->mac_addr,
 			   le32_to_cpu(ev->sw_version),
-			   le32_to_cpu(ev->abi_version));
+			   le32_to_cpu(ev->abi_version), ev->phy_cap);
+
+	ar->ready_data = kmemdup(datap, len, GFP_KERNEL);
+	ar->ready_len = len;
 
 	return 0;
 }
@@ -772,45 +784,44 @@ int ath6kl_wmi_set_roam_mode_cmd(struct wmi *wmi, enum wmi_roam_mode mode)
 				   NO_SYNC_WMIFLAG);
 }
 
-static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
-				       struct ath6kl_vif *vif)
+
+static int ath6kl_wmi_connect_event(struct wmi *wmi, u8 *datap,
+				    struct ath6kl_vif *vif, u16 beacon_ie_len,
+				    u16 assoc_req_len, u16 assoc_resp_len,
+				    u8 *assoc_info)
 {
-	struct wmi_connect_event *ev;
+	union wmi_connect_common_info *u;
 	u8 *pie, *peie;
 
-	if (len < sizeof(struct wmi_connect_event))
-		return -EINVAL;
-
-	ev = (struct wmi_connect_event *) datap;
-
+	u = (union wmi_connect_common_info *) datap;
 	if (vif->nw_type == AP_NETWORK) {
 		/* AP mode start/STA connected event */
 		struct net_device *dev = vif->ndev;
-		if (memcmp(dev->dev_addr, ev->u.ap_bss.bssid, ETH_ALEN) == 0) {
+		if (memcmp(dev->dev_addr, u->ap_bss.bssid, ETH_ALEN) == 0) {
 			ath6kl_dbg(ATH6KL_DBG_WMI, "%s: freq %d bssid %pM "
 				   "(AP started)\n",
-				   __func__, le16_to_cpu(ev->u.ap_bss.ch),
-				   ev->u.ap_bss.bssid);
+				   __func__, le16_to_cpu(u->ap_bss.ch),
+				   u->ap_bss.bssid);
 			ath6kl_connect_ap_mode_bss(
-				vif, le16_to_cpu(ev->u.ap_bss.ch));
+				vif, le16_to_cpu(u->ap_bss.ch));
 		} else {
 			ath6kl_dbg(ATH6KL_DBG_WMI, "%s: aid %u mac_addr %pM "
 				   "auth=%u keymgmt=%u cipher=%u apsd_info=%u "
 				   "(STA connected)\n",
-				   __func__, ev->u.ap_sta.aid,
-				   ev->u.ap_sta.mac_addr,
-				   ev->u.ap_sta.auth,
-				   ev->u.ap_sta.keymgmt,
-				   le16_to_cpu(ev->u.ap_sta.cipher),
-				   ev->u.ap_sta.apsd_info);
+				   __func__, u->ap_sta.aid,
+				   u->ap_sta.mac_addr,
+				   u->ap_sta.auth,
+				   u->ap_sta.keymgmt,
+				   le16_to_cpu(u->ap_sta.cipher),
+				   u->ap_sta.apsd_info);
 
 			ath6kl_connect_ap_mode_sta(
-				vif, ev->u.ap_sta.aid, ev->u.ap_sta.mac_addr,
-				ev->u.ap_sta.keymgmt,
-				le16_to_cpu(ev->u.ap_sta.cipher),
-				ev->u.ap_sta.auth, ev->assoc_req_len,
-				ev->assoc_info + ev->beacon_ie_len,
-				ev->u.ap_sta.apsd_info);
+				vif, u->ap_sta.aid, u->ap_sta.mac_addr,
+				u->ap_sta.keymgmt,
+				le16_to_cpu(u->ap_sta.cipher),
+				u->ap_sta.auth, assoc_req_len,
+				assoc_info + beacon_ie_len,
+				u->ap_sta.apsd_info);
 		}
 		return 0;
 	}
@@ -819,18 +830,17 @@ static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
 
 	ath6kl_dbg(ATH6KL_DBG_WMI,
 		   "wmi event connect freq %d bssid %pM listen_intvl %d beacon_intvl %d type %d\n",
-		   le16_to_cpu(ev->u.sta.ch), ev->u.sta.bssid,
-		   le16_to_cpu(ev->u.sta.listen_intvl),
-		   le16_to_cpu(ev->u.sta.beacon_intvl),
-		   le32_to_cpu(ev->u.sta.nw_type));
+		   le16_to_cpu(u->sta.ch), u->sta.bssid,
+		   le16_to_cpu(u->sta.listen_intvl),
+		   le16_to_cpu(u->sta.beacon_intvl),
+		   le32_to_cpu(u->sta.nw_type));
 
 	/* Start of assoc rsp IEs */
-	pie = ev->assoc_info + ev->beacon_ie_len +
-	      ev->assoc_req_len + (sizeof(u16) * 3); /* capinfo, status, aid */
+	pie = assoc_info + beacon_ie_len +
+	      assoc_req_len + (sizeof(u16) * 3); /* capinfo, status, aid */
 
 	/* End of assoc rsp IEs */
-	peie = ev->assoc_info + ev->beacon_ie_len + ev->assoc_req_len +
-	    ev->assoc_resp_len;
+	peie = assoc_info + beacon_ie_len + assoc_req_len + assoc_resp_len;
 
 	while (pie < peie) {
 		switch (*pie) {
@@ -851,17 +861,47 @@ static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
 		pie += pie[1] + 2;
 	}
 
-	ath6kl_connect_event(vif, le16_to_cpu(ev->u.sta.ch),
-			     ev->u.sta.bssid,
-			     le16_to_cpu(ev->u.sta.listen_intvl),
-			     le16_to_cpu(ev->u.sta.beacon_intvl),
-			     le32_to_cpu(ev->u.sta.nw_type),
-			     ev->beacon_ie_len, ev->assoc_req_len,
-			     ev->assoc_resp_len, ev->assoc_info);
+	ath6kl_connect_event(vif, le16_to_cpu(u->sta.ch),
+			     u->sta.bssid,
+			     le16_to_cpu(u->sta.listen_intvl),
+			     le16_to_cpu(u->sta.beacon_intvl),
+			     le32_to_cpu(u->sta.nw_type),
+			     beacon_ie_len, assoc_req_len,
+			     assoc_resp_len, assoc_info);
 
 	return 0;
 }
 
+static int ath6kl_wmi_connect_event_rx_advanced(struct wmi *wmi, u8 *datap,
+						int len, struct ath6kl_vif *vif)
+{
+	struct wmi_connect_event_advanced *ev;
+
+	if (len < sizeof(struct wmi_connect_event_advanced))
+		return -EINVAL;
+
+	ev = (struct wmi_connect_event_advanced *) datap;
+
+	return ath6kl_wmi_connect_event(wmi, datap, vif, ev->beacon_ie_len,
+					ev->assoc_req_len, ev->assoc_resp_len,
+					ev->assoc_info);
+}
+
+static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap,
+				       int len, struct ath6kl_vif *vif)
+{
+	struct wmi_connect_event *ev;
+
+	if (len < sizeof(struct wmi_connect_event))
+		return -EINVAL;
+
+	ev = (struct wmi_connect_event *) datap;
+
+	return ath6kl_wmi_connect_event(wmi, datap, vif, ev->beacon_ie_len,
+					ev->assoc_req_len, ev->assoc_resp_len,
+					ev->assoc_info);
+}
+
 static struct country_code_to_enum_rd *
 ath6kl_regd_find_country(u16 countryCode)
 {
@@ -906,11 +946,10 @@ ath6kl_regd_find_country_by_rd(u16 regdmn)
 
 static void ath6kl_wmi_regdomain_event(struct wmi *wmi, u8 *datap, int len)
 {
-
+	struct ath6kl *ar;
 	struct ath6kl_wmi_regdomain *ev;
 	struct country_code_to_enum_rd *country = NULL;
 	struct reg_dmn_pair_mapping *regpair = NULL;
-	char alpha2[2];
 	u32 reg_code;
 
 	ev = (struct ath6kl_wmi_regdomain *) datap;
@@ -930,15 +969,20 @@ static void ath6kl_wmi_regdomain_event(struct wmi *wmi, u8 *datap, int len)
 				    reg_code);
 	}
 
-	if (country) {
-		alpha2[0] = country->isoName[0];
-		alpha2[1] = country->isoName[1];
+	if (!country)
+		return;
 
-		regulatory_hint(wmi->parent_dev->wiphy, alpha2);
+	ar = wmi->parent_dev;
+	ar->alpha2[0] = country->isoName[0];
+	ar->alpha2[1] = country->isoName[1];
 
-		ath6kl_dbg(ATH6KL_DBG_WMI, "Country alpha2 being used: %c%c\n",
-				alpha2[0], alpha2[1]);
-	}
+	if (list_empty(&ar->vif_list))
+		set_bit(REG_DOMAIN_HINT_PEND, &ar->flag);
+	else
+		regulatory_hint(ar->wiphy, ar->alpha2);
+
+	ath6kl_dbg(ATH6KL_DBG_WMI, "Country alpha2 being used: %c%c\n",
+		   ar->alpha2[0], ar->alpha2[1]);
 }
 
 static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
@@ -1941,8 +1985,11 @@ int ath6kl_wmi_beginscan_cmd(struct wmi *wmi, u8 if_idx,
 		    ar->wiphy->bands[band];
 		u32 ratemask = rates[band];
 		u8 *supp_rates = sc->supp_rates[band].rates;
-		num_rates = 0;
 
+		if (!sband)
+			continue;
+
+		num_rates = 0;
 		for (i = 0; i < sband->n_bitrates; i++) {
 			if ((BIT(i) & ratemask) == 0)
 				continue; /* skip rate */
@@ -2932,6 +2979,75 @@ int ath6kl_wmi_del_wow_pattern_cmd(struct wmi *wmi, u8 if_idx,
 	return ret;
 }
 
+int ath6kl_wmi_add_pkt_filter_pattern_cmd(struct wmi *wmi, u8 if_idx,
+					  u8 filter_id, u8 filter_act,
+					  u8 filter_size,
+					  u8 filter_offset, u8 *filter,
+					  u8 *mask)
+{
+	struct sk_buff *skb;
+	struct wmi_add_pkt_filter_pattern_cmd *cmd;
+	u16 size;
+	u8 *filter_mask;
+	int ret;
+
+	/* not valid for both awake and suspend */
+	if (!(filter_act & CPKT_ACTION_HOST_AWAKE_MASK) &&
+	    !(filter_act & CPKT_ACTION_HOST_SUSPEND_MASK))
+		return -EINVAL;
+
+	if (filter_id >= CPKT_MAX_FILTERS_PER_LIST ||
+	     filter_size > CPKT_PATTERN_SIZE)
+		return -EINVAL;
+	/*
+	 * Allocate additional memory in the buffer to hold
+	 * filter and mask value, which is twice of filter_size.
+	 */
+	size = sizeof(*cmd) + (2 * filter_size);
+
+	skb = ath6kl_wmi_get_new_buf(size);
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_add_pkt_filter_pattern_cmd *) skb->data;
+	cmd->filter_id = filter_id;
+	cmd->filter_act = filter_act;
+	cmd->filter_size = filter_size;
+	cmd->filter_offset = filter_offset;
+
+	memcpy(cmd->filter, filter, filter_size);
+
+	filter_mask = (u8 *) (cmd->filter + filter_size);
+	memcpy(filter_mask, mask, filter_size);
+
+	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,
+				  WMI_ADD_PKT_FILTER_PATTERN_CMDID,
+				  NO_SYNC_WMIFLAG);
+
+	return ret;
+}
+
+int ath6kl_wmi_del_pkt_filter_pattern_cmd(struct wmi *wmi,
+					  u8 if_idx, u8 filter_id)
+{
+	struct sk_buff *skb;
+	struct wmi_del_pkt_filter_pattern_cmd *cmd;
+	int ret;
+
+	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_del_pkt_filter_pattern_cmd *) skb->data;
+	cmd->filter_id = filter_id;
+
+	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,
+				  WMI_DEL_PKT_FILTER_PATTERN_CMDID,
+				  NO_SYNC_WMIFLAG);
+	return ret;
+}
+
+
 static int ath6kl_wmi_cmd_send_xtnd(struct wmi *wmi, struct sk_buff *skb,
 				    enum wmix_command_id cmd_id,
 				    enum wmi_sync_flag sync_flag)
@@ -3240,10 +3356,21 @@ int ath6kl_wmi_set_regdomain_cmd(struct wmi *wmi, const char *alpha2)
 
 s32 ath6kl_wmi_get_rate(s8 rate_index)
 {
+	u8 sgi = 0;
+
 	if (rate_index == RATE_AUTO)
 		return 0;
 
-	return wmi_rate_tbl[(u32) rate_index][0];
+	/* SGI is stored as the MSB of the rate_index */
+	if (rate_index & RATE_INDEX_MSB) {
+		rate_index &= RATE_INDEX_WITHOUT_SGI_MASK;
+		sgi = 1;
+	}
+
+	if (WARN_ON(rate_index > RATE_MCS_7_40))
+		rate_index = RATE_MCS_7_40;
+
+	return wmi_rate_tbl[(u32) rate_index][sgi];
 }
 
 static int ath6kl_wmi_get_pmkid_list_event_rx(struct wmi *wmi, u8 *datap,
@@ -3562,10 +3689,13 @@ static int ath6kl_wmi_send_action_cmd(struct wmi *wmi, u8 if_idx, u32 id,
 		return -ENOMEM;
 	}
 
-	kfree(wmi->last_mgmt_tx_frame);
 	memcpy(buf, data, data_len);
+
+	spin_lock_bh(&wmi->lock);
+	kfree(wmi->last_mgmt_tx_frame);
 	wmi->last_mgmt_tx_frame = buf;
 	wmi->last_mgmt_tx_frame_len = data_len;
+	spin_unlock_bh(&wmi->lock);
 
 	ath6kl_dbg(ATH6KL_DBG_WMI, "send_action_cmd: id=%u freq=%u wait=%u "
 		   "len=%u\n", id, freq, wait, data_len);
@@ -3600,10 +3730,13 @@ static int __ath6kl_wmi_send_mgmt_cmd(struct wmi *wmi, u8 if_idx, u32 id,
 		return -ENOMEM;
 	}
 
-	kfree(wmi->last_mgmt_tx_frame);
 	memcpy(buf, data, data_len);
+
+	spin_lock_bh(&wmi->lock);
+	kfree(wmi->last_mgmt_tx_frame);
 	wmi->last_mgmt_tx_frame = buf;
 	wmi->last_mgmt_tx_frame_len = data_len;
+	spin_unlock_bh(&wmi->lock);
 
 	ath6kl_dbg(ATH6KL_DBG_WMI, "send_action_cmd: id=%u freq=%u wait=%u "
 		   "len=%u\n", id, freq, wait, data_len);
@@ -3784,6 +3917,30 @@ int ath6kl_wmi_set_acl_list(struct wmi *wmi, u8 if_idx, int index,
 				   NO_SYNC_WMIFLAG);
 }
 
+int ath6kl_wmi_ap_set_num_sta(struct wmi *wmip, u8 if_idx, u8 num_sta)
+{
+	struct sk_buff *skb;
+	struct wmi_ap_num_sta_cmd *cm;
+	int res;
+
+	/*0x80 is used global connection setting*/
+	if (num_sta & 0x80) {
+		return  -EINVAL;
+	}
+	skb = ath6kl_wmi_get_new_buf(sizeof(*cm));
+	if (!skb)
+		return -ENOMEM;
+
+	cm = (struct wmi_ap_num_sta_cmd *) skb->data;
+	cm->num_sta = num_sta;
+
+	res = ath6kl_wmi_cmd_send(wmip, if_idx, skb, WMI_AP_SET_NUM_STA_CMDID,
+				  NO_SYNC_WMIFLAG);
+
+	return res;
+}
+
+
 static void ath6kl_wmi_hb_challenge_resp_event(struct wmi *wmi, u8 *datap,
 					       int len)
 {
@@ -3797,6 +3954,18 @@ static void ath6kl_wmi_hb_challenge_resp_event(struct wmi *wmi, u8 *datap,
 				 le32_to_cpu(cmd->cookie));
 }
 
+void ath6kl_wmi_send_rdy_evt_to_app(struct net_device *ndev, struct ath6kl *ar)
+{
+	if (!ar->ready_data)
+		return;
+
+	cfg80211_send_event_to_app(ndev, WMI_READY_EVENTID,
+				   ar->ready_data, ar->ready_len);
+	kfree(ar->ready_data);
+
+	ar->ready_data = NULL;
+}
+
 static int ath6kl_wmi_control_rx_xtnd(struct wmi *wmi, struct sk_buff *skb)
 {
 	struct wmix_cmd_hdr *cmd;
@@ -3835,38 +4004,139 @@ static int ath6kl_wmi_control_rx_xtnd(struct wmi *wmi, struct sk_buff *skb)
 
 	return ret;
 }
-
 static int ath6kl_wmi_roam_tbl_event_rx(struct wmi *wmi, u8 *datap, int len)
 {
 	return ath6kl_debug_roam_tbl_event(wmi->parent_dev, datap, len);
 }
 
+/* Process interface specific wmi events, caller would free the datap */
+static int ath6kl_wmi_proc_events_vif(struct net_device *dev, struct wmi *wmi,
+				      u16 if_idx, u16 id, u8 *datap, u32 len)
+{
+	struct ath6kl_vif *vif;
+	struct ath6kl *ar;
+	int ret;
+
+	vif = ath6kl_get_vif_by_index(wmi->parent_dev, if_idx);
+	if (!vif) {
+		ath6kl_dbg(ATH6KL_DBG_WMI,
+			   "Wmi event for unavailable vif, vif_index:%d\n",
+			    if_idx);
+		return -EINVAL;
+	}
+	ar = vif->ar;
+
+	switch (id) {
+	case WMI_CONNECT_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CONNECT_EVENTID\n");
+		if (test_bit(ATH6KL_FW_CAPABILITY_LARGE_CONNECT_IE,
+			     ar->fw_capabilities))
+			ret = ath6kl_wmi_connect_event_rx_advanced(wmi, datap,
+								   len, vif);
+		else
+			ret = ath6kl_wmi_connect_event_rx(wmi, datap, len, vif);
+		cfg80211_send_genevent_to_app(dev, id, datap, len);
+		break;
+	case WMI_DISCONNECT_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DISCONNECT_EVENTID\n");
+		ret = ath6kl_wmi_disconnect_event_rx(wmi, datap, len, vif);
+		cfg80211_send_event_to_app(dev, id, datap, len);
+		break;
+	case WMI_TKIP_MICERR_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TKIP_MICERR_EVENTID\n");
+		ret = ath6kl_wmi_tkip_micerr_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_BSSINFO_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_BSSINFO_EVENTID\n");
+		ret = ath6kl_wmi_bssinfo_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_NEIGHBOR_REPORT_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_NEIGHBOR_REPORT_EVENTID\n");
+		ret = ath6kl_wmi_neighbor_report_event_rx(wmi, datap, len,
+							  vif);
+		break;
+	case WMI_SCAN_COMPLETE_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_SCAN_COMPLETE_EVENTID\n");
+		ret = ath6kl_wmi_scan_complete_rx(wmi, datap, len, vif);
+		cfg80211_send_event_to_app(dev, id, datap, len);
+		break;
+	case WMI_REPORT_STATISTICS_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_REPORT_STATISTICS_EVENTID\n");
+		ret = ath6kl_wmi_stats_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_CAC_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CAC_EVENTID\n");
+		ret = ath6kl_wmi_cac_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_PSPOLL_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_PSPOLL_EVENTID\n");
+		ret = ath6kl_wmi_pspoll_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_DTIMEXPIRY_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DTIMEXPIRY_EVENTID\n");
+		ret = ath6kl_wmi_dtimexpiry_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_ADDBA_REQ_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_ADDBA_REQ_EVENTID\n");
+		ret = ath6kl_wmi_addba_req_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_DELBA_REQ_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DELBA_REQ_EVENTID\n");
+		ret = ath6kl_wmi_delba_req_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI,
+			   "WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID");
+		ret = ath6kl_wmi_host_sleep_mode_cmd_prcd_evt_rx(wmi, vif);
+		break;
+	case WMI_REMAIN_ON_CHNL_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_REMAIN_ON_CHNL_EVENTID\n");
+		ret = ath6kl_wmi_remain_on_chnl_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_CANCEL_REMAIN_ON_CHNL_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI,
+			   "WMI_CANCEL_REMAIN_ON_CHNL_EVENTID\n");
+		ret = ath6kl_wmi_cancel_remain_on_chnl_event_rx(wmi, datap,
+								len, vif);
+		break;
+	case WMI_TX_STATUS_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TX_STATUS_EVENTID\n");
+		ret = ath6kl_wmi_tx_status_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_RX_PROBE_REQ_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_RX_PROBE_REQ_EVENTID\n");
+		ret = ath6kl_wmi_rx_probe_req_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_RX_ACTION_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_RX_ACTION_EVENTID\n");
+		ret = ath6kl_wmi_rx_action_event_rx(wmi, datap, len, vif);
+		break;
+	case WMI_TXE_NOTIFY_EVENTID:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TXE_NOTIFY_EVENTID\n");
+		ret = ath6kl_wmi_txe_notify_event_rx(wmi, datap, len, vif);
+		break;
+	default:
+		ath6kl_dbg(ATH6KL_DBG_WMI, "unknown cmd id 0x%x\n", id);
+		return -EINVAL;
+	}
+
+	return ret;
+}
 /* Control Path */
-int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
+static int ath6kl_wmi_proc_events(struct wmi *wmi, struct sk_buff *skb)
 {
 	struct wmi_cmd_hdr *cmd;
-	struct ath6kl_vif *vif;
 	u32 len;
 	u16 id;
 	u8 if_idx;
 	u8 *datap;
 	int ret = 0;
 
-	if (WARN_ON(skb == NULL))
-		return -EINVAL;
-
-	if (skb->len < sizeof(struct wmi_cmd_hdr)) {
-		ath6kl_err("bad packet 1\n");
-		dev_kfree_skb(skb);
-		return -EINVAL;
-	}
-
 	cmd = (struct wmi_cmd_hdr *) skb->data;
 	id = le16_to_cpu(cmd->cmd_id);
 	if_idx = le16_to_cpu(cmd->info1) & WMI_CMD_HDR_IF_ID_MASK;
 
 	skb_pull(skb, sizeof(struct wmi_cmd_hdr));
-
 	datap = skb->data;
 	len = skb->len;
 
@@ -3874,15 +4144,6 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 	ath6kl_dbg_dump(ATH6KL_DBG_WMI_DUMP, NULL, "wmi rx ",
 			datap, len);
 
-	vif = ath6kl_get_vif_by_index(wmi->parent_dev, if_idx);
-	if (!vif) {
-		ath6kl_dbg(ATH6KL_DBG_WMI,
-			   "Wmi event for unavailable vif, vif_index:%d\n",
-			    if_idx);
-		dev_kfree_skb(skb);
-		return -EINVAL;
-	}
-
 	switch (id) {
 	case WMI_GET_BITRATE_CMDID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_GET_BITRATE_CMDID\n");
@@ -3899,31 +4160,12 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 	case WMI_READY_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_READY_EVENTID\n");
 		ret = ath6kl_wmi_ready_event_rx(wmi, datap, len);
-		cfg80211_send_event_to_app(skb->dev, id, datap, len);
-		break;
-	case WMI_CONNECT_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CONNECT_EVENTID\n");
-		ret = ath6kl_wmi_connect_event_rx(wmi, datap, len, vif);
-		cfg80211_send_genevent_to_app(skb->dev, id, datap, len);
-		break;
-	case WMI_DISCONNECT_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DISCONNECT_EVENTID\n");
-		ret = ath6kl_wmi_disconnect_event_rx(wmi, datap, len, vif);
-		cfg80211_send_event_to_app(skb->dev, id, datap, len);
 		break;
 	case WMI_PEER_NODE_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_PEER_NODE_EVENTID\n");
 		ret = ath6kl_wmi_peer_node_event_rx(wmi, datap, len);
 		cfg80211_send_event_to_app(skb->dev, id, datap, len);
 		break;
-	case WMI_TKIP_MICERR_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TKIP_MICERR_EVENTID\n");
-		ret = ath6kl_wmi_tkip_micerr_event_rx(wmi, datap, len, vif);
-		break;
-	case WMI_BSSINFO_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_BSSINFO_EVENTID\n");
-		ret = ath6kl_wmi_bssinfo_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_REGDOMAIN_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_REGDOMAIN_EVENTID\n");
 		ath6kl_wmi_regdomain_event(wmi, datap, len);
@@ -3933,24 +4175,10 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 		ret = ath6kl_wmi_pstream_timeout_event_rx(wmi, datap, len);
 		cfg80211_send_event_to_app(skb->dev, id, datap, len);
 		break;
-	case WMI_NEIGHBOR_REPORT_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_NEIGHBOR_REPORT_EVENTID\n");
-		ret = ath6kl_wmi_neighbor_report_event_rx(wmi, datap, len,
-							  vif);
-		break;
-	case WMI_SCAN_COMPLETE_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_SCAN_COMPLETE_EVENTID\n");
-		ret = ath6kl_wmi_scan_complete_rx(wmi, datap, len, vif);
-		cfg80211_send_event_to_app(skb->dev, id, datap, len);
-		break;
 	case WMI_CMDERROR_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CMDERROR_EVENTID\n");
 		ret = ath6kl_wmi_error_event_rx(wmi, datap, len);
 		break;
-	case WMI_REPORT_STATISTICS_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_REPORT_STATISTICS_EVENTID\n");
-		ret = ath6kl_wmi_stats_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_RSSI_THRESHOLD_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_RSSI_THRESHOLD_EVENTID\n");
 		ret = ath6kl_wmi_rssi_threshold_event_rx(wmi, datap, len);
@@ -3972,10 +4200,6 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_EXTENSION_EVENTID\n");
 		ret = ath6kl_wmi_control_rx_xtnd(wmi, skb);
 		break;
-	case WMI_CAC_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CAC_EVENTID\n");
-		ret = ath6kl_wmi_cac_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_CHANNEL_CHANGE_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CHANNEL_CHANGE_EVENTID\n");
 		break;
@@ -4017,28 +4241,12 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_GET_PMKID_LIST_EVENTID\n");
 		ret = ath6kl_wmi_get_pmkid_list_event_rx(wmi, datap, len);
 		break;
-	case WMI_PSPOLL_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_PSPOLL_EVENTID\n");
-		ret = ath6kl_wmi_pspoll_event_rx(wmi, datap, len, vif);
-		break;
-	case WMI_DTIMEXPIRY_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DTIMEXPIRY_EVENTID\n");
-		ret = ath6kl_wmi_dtimexpiry_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_SET_PARAMS_REPLY_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_SET_PARAMS_REPLY_EVENTID\n");
 		break;
-	case WMI_ADDBA_REQ_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_ADDBA_REQ_EVENTID\n");
-		ret = ath6kl_wmi_addba_req_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_ADDBA_RESP_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_ADDBA_RESP_EVENTID\n");
 		break;
-	case WMI_DELBA_REQ_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DELBA_REQ_EVENTID\n");
-		ret = ath6kl_wmi_delba_req_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_REPORT_BTCOEX_CONFIG_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI,
 			   "WMI_REPORT_BTCOEX_CONFIG_EVENTID\n");
@@ -4051,48 +4259,18 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TX_COMPLETE_EVENTID\n");
 		ret = ath6kl_wmi_tx_complete_event_rx(datap, len);
 		break;
-	case WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI,
-			   "WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID");
-		ret = ath6kl_wmi_host_sleep_mode_cmd_prcd_evt_rx(wmi, vif);
-		break;
-	case WMI_REMAIN_ON_CHNL_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_REMAIN_ON_CHNL_EVENTID\n");
-		ret = ath6kl_wmi_remain_on_chnl_event_rx(wmi, datap, len, vif);
-		break;
-	case WMI_CANCEL_REMAIN_ON_CHNL_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI,
-			   "WMI_CANCEL_REMAIN_ON_CHNL_EVENTID\n");
-		ret = ath6kl_wmi_cancel_remain_on_chnl_event_rx(wmi, datap,
-								len, vif);
-		break;
-	case WMI_TX_STATUS_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TX_STATUS_EVENTID\n");
-		ret = ath6kl_wmi_tx_status_event_rx(wmi, datap, len, vif);
-		break;
-	case WMI_RX_PROBE_REQ_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_RX_PROBE_REQ_EVENTID\n");
-		ret = ath6kl_wmi_rx_probe_req_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_P2P_CAPABILITIES_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_P2P_CAPABILITIES_EVENTID\n");
 		ret = ath6kl_wmi_p2p_capabilities_event_rx(datap, len);
 		break;
-	case WMI_RX_ACTION_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_RX_ACTION_EVENTID\n");
-		ret = ath6kl_wmi_rx_action_event_rx(wmi, datap, len, vif);
-		break;
 	case WMI_P2P_INFO_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_P2P_INFO_EVENTID\n");
 		ret = ath6kl_wmi_p2p_info_event_rx(datap, len);
 		break;
-	case WMI_TXE_NOTIFY_EVENTID:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_TXE_NOTIFY_EVENTID\n");
-		ret = ath6kl_wmi_txe_notify_event_rx(wmi, datap, len, vif);
-		break;
 	default:
-		ath6kl_dbg(ATH6KL_DBG_WMI, "unknown cmd id 0x%x\n", id);
-		ret = -EINVAL;
+		/* may be the event is interface specific */
+		ret = ath6kl_wmi_proc_events_vif(skb->dev, wmi, if_idx,
+						 id, datap, len);
 		break;
 	}
 
@@ -4101,6 +4279,21 @@ int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
 	return ret;
 }
 
+/* Control Path */
+int ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)
+{
+	if (WARN_ON(skb == NULL))
+		return -EINVAL;
+
+	if (skb->len < sizeof(struct wmi_cmd_hdr)) {
+		ath6kl_err("bad packet 1\n");
+		dev_kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	return ath6kl_wmi_proc_events(wmi, skb);
+}
+
 void ath6kl_wmi_reset(struct wmi *wmi)
 {
 	spin_lock_bh(&wmi->lock);
@@ -4135,6 +4328,34 @@ void ath6kl_wmi_shutdown(struct wmi *wmi)
 	if (!wmi)
 		return;
 
+	spin_lock_bh(&wmi->lock);
 	kfree(wmi->last_mgmt_tx_frame);
+	wmi->last_mgmt_tx_frame = NULL;
+	spin_unlock_bh(&wmi->lock);
+
 	kfree(wmi);
 }
+
+int ath6kl_wmi_set_btcoex_debug_cmd(struct wmi *wmi, u8 if_idx, u32 param1,
+				    u32 param2, u32 param3, u32 param4,
+				    u32 param5)
+{
+	struct sk_buff *skb;
+	struct wmi_set_btcoex_debug_cmd *cmd;
+	int ret;
+
+	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_set_btcoex_debug_cmd *) skb->data;
+	cmd->dbg_param1 = cpu_to_le32(param1);
+	cmd->dbg_param2 = cpu_to_le32(param2);
+	cmd->dbg_param3 = cpu_to_le32(param3);
+	cmd->dbg_param4 = cpu_to_le32(param4);
+	cmd->dbg_param5 = cpu_to_le32(param5);
+
+	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_BTCOEX_DEBUG_CMDID,
+				  NO_SYNC_WMIFLAG);
+	return ret;
+}
diff --git a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.h b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.h
index 19304eb..df9367b 100644
--- a/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.h
+++ b/wlan/atheros/compat-wireless/drivers/net/wireless/ath/ath6kl/wmi.h
@@ -637,6 +637,10 @@ enum wmi_cmd_id {
 	WMI_SET_RECOVERY_TEST_PARAMETER_CMDID, /*0xf094*/
 
 	WMI_ENABLE_SCHED_SCAN_CMDID,
+
+	WMI_ADD_PKT_FILTER_PATTERN_CMDID,
+
+	WMI_DEL_PKT_FILTER_PATTERN_CMDID,
 };
 
 enum wmi_mgmt_frame_type {
@@ -1420,6 +1424,7 @@ enum wmi_event_id {
 	WMI_HCI_EVENT_EVENTID,
 	WMI_ACL_DATA_EVENTID,
 	WMI_REPORT_SLEEP_STATE_EVENTID,
+	WMI_WAPI_REKEY_EVENTID,
 	WMI_REPORT_BTCOEX_STATS_EVENTID,
 	WMI_REPORT_BTCOEX_CONFIG_EVENTID,
 	WMI_GET_PMK_EVENTID,
@@ -1510,38 +1515,61 @@ struct wmi_ready_event_2 {
 	u8 phy_cap;
 } __packed;
 
+/* WMI_PHY_CAPABILITY */
+enum wmi_phy_cap {
+	WMI_11A_CAP = 0x01,
+	WMI_11G_CAP = 0x02,
+	WMI_11AG_CAP = 0x03,
+	WMI_11AN_CAP = 0x04,
+	WMI_11GN_CAP = 0x05,
+	WMI_11AGN_CAP = 0x06,
+};
+
+
+union wmi_connect_common_info {
+	struct {
+		__le16 ch;
+		u8 bssid[ETH_ALEN];
+		__le16 listen_intvl;
+		__le16 beacon_intvl;
+		__le32 nw_type;
+	} sta;
+	struct {
+		u8 phymode;
+		u8 aid;
+		u8 mac_addr[ETH_ALEN];
+		u8 auth;
+		u8 keymgmt;
+		__le16 cipher;
+		u8 apsd_info;
+		u8 unused[3];
+	} ap_sta;
+	struct {
+		__le16 ch;
+		u8 bssid[ETH_ALEN];
+		u8 unused[8];
+	} ap_bss;
+} __packed;
+
 /* Connect Event */
 struct wmi_connect_event {
-	union {
-		struct {
-			__le16 ch;
-			u8 bssid[ETH_ALEN];
-			__le16 listen_intvl;
-			__le16 beacon_intvl;
-			__le32 nw_type;
-		} sta;
-		struct {
-			u8 phymode;
-			u8 aid;
-			u8 mac_addr[ETH_ALEN];
-			u8 auth;
-			u8 keymgmt;
-			__le16 cipher;
-			u8 apsd_info;
-			u8 unused[3];
-		} ap_sta;
-		struct {
-			__le16 ch;
-			u8 bssid[ETH_ALEN];
-			u8 unused[8];
-		} ap_bss;
-	} u;
+	union wmi_connect_common_info u;
 	u8 beacon_ie_len;
 	u8 assoc_req_len;
 	u8 assoc_resp_len;
 	u8 assoc_info[1];
 } __packed;
 
+/* Connect Event for large IE*/
+struct wmi_connect_event_advanced {
+	union wmi_connect_common_info u;
+	u16 beacon_ie_len;
+	u16 assoc_req_len;
+	u16 assoc_resp_len;
+	u8 assoc_info[1];
+} __packed;
+
+
 /* Disconnect Event */
 enum wmi_disconnect_reason {
 	NO_NETWORK_AVAIL = 0x01,
@@ -1571,6 +1599,7 @@ enum ap_disconnect_reason {
 	WMI_AP_REASON_ACL		= 105,
 	WMI_AP_REASON_STA_ROAM		= 106,
 	WMI_AP_REASON_DFS_CHANNEL	= 107,
+	WMI_AP_REASON_NEW_STA		= 108,
 };
 
 #define ATH6KL_COUNTRY_RD_SHIFT        16
@@ -1781,6 +1810,9 @@ struct rx_stats {
 	a_sle32 ucast_rate;
 } __packed;
 
+#define RATE_INDEX_WITHOUT_SGI_MASK     0x7f
+#define RATE_INDEX_MSB     0x80
+
 struct tkip_ccmp_stats {
 	__le32 tkip_local_mic_fail;
 	__le32 tkip_cnter_measures_invoked;
@@ -2132,6 +2164,28 @@ struct wmi_txe_notify_event {
 	__le32 pkts;
 } __packed;
 
+#define CPKT_MAX_FILTERS_PER_LIST	12
+#define CPKT_PATTERN_SIZE		64
+#define CPKT_MASK_SIZE			64
+
+#define CPKT_ACTION_DROP		0
+#define CPKT_ACTION_ALLOW		1
+#define CPKT_ACTION_DROP_ALOW_MASK	0x1
+#define CPKT_ACTION_HOST_AWAKE_MASK	0x2
+#define CPKT_ACTION_HOST_SUSPEND_MASK	0x4
+
+struct wmi_add_pkt_filter_pattern_cmd {
+	u8 filter_id;
+	u8 filter_act;
+	u8 filter_size;
+	u8 filter_offset;
+	u8 filter[0];
+} __packed;
+
+struct wmi_del_pkt_filter_pattern_cmd {
+	u8 filter_id;
+} __packed;
+
 /* WMI_SET_AKMP_PARAMS_CMD */
 
 struct wmi_pmkid {
@@ -2352,6 +2406,10 @@ struct wmi_ap_acl_policy_cmd {
 	u8 policy;
 } __packed;
 
+struct wmi_ap_num_sta_cmd{
+    u8     num_sta;
+} __packed;
+
 /* End of AP mode definitions */
 
 struct wmi_remain_on_chnl_cmd {
@@ -2400,6 +2458,22 @@ struct wmi_set_appie_extended_cmd {
 	u8 ie_info[0];
 } __packed;
 
+enum wmi_btcoex_debug_cmd_type {
+	WMI_BTCOEX_DBG_CMD_BT_ON      = 0xFEFE,
+	WMI_BTCOEX_DBG_CMD_BT_OFF     = 0xEFEF,
+	WMI_BTCOEX_DBG_CMD_DHCP_TX    = 0xFDFD,
+	WMI_BTCOEX_DBG_CMD_DHCP_RX    = 0xDFDF,
+	WMI_BTCOEX_DBG_CMD_UNKNOWN    = 0xFFFF,
+};
+
+struct wmi_set_btcoex_debug_cmd {
+	__le32 dbg_param1;
+	__le32 dbg_param2;
+	__le32 dbg_param3;
+	__le32 dbg_param4;
+	__le32 dbg_param5;  /* enum wmi_btcoex_debug_cmd_type */
+} __packed;
+
 struct wmi_remain_on_chnl_event {
 	__le32 freq;
 	__le32 duration;
@@ -2638,6 +2712,7 @@ int ath6kl_wmi_get_tx_pwr_cmd(struct wmi *wmi, u8 if_idx);
 int ath6kl_wmi_get_roam_tbl_cmd(struct wmi *wmi);
 
 int ath6kl_wmi_set_wmm_txop(struct wmi *wmi, u8 if_idx, enum wmi_txop_cfg cfg);
+int ath6kl_wmi_ap_set_num_sta(struct wmi *wmip, u8 if_idx, u8 num_sta);
 int ath6kl_wmi_set_keepalive_cmd(struct wmi *wmi, u8 if_idx,
 				 u8 keep_alive_intvl);
 int ath6kl_wmi_set_htcap_cmd(struct wmi *wmi, u8 if_idx,
@@ -2662,6 +2737,15 @@ int ath6kl_wmi_add_wow_pattern_cmd(struct wmi *wmi, u8 if_idx,
 				   const u8 *mask);
 int ath6kl_wmi_del_wow_pattern_cmd(struct wmi *wmi, u8 if_idx,
 				   u16 list_id, u16 filter_id);
+
+int ath6kl_wmi_add_pkt_filter_pattern_cmd(struct wmi *wmi, u8 if_idx,
+					  u8 filter_id, u8 filter_act,
+					  u8 filter_size,
+					  u8 filter_offset, u8 *filter,
+					  u8 *mask);
+int ath6kl_wmi_del_pkt_filter_pattern_cmd(struct wmi *wmi, u8 if_idx,
+					  u8 filter_id);
+
 int ath6kl_wmi_set_rssi_filter_cmd(struct wmi *wmi, u8 if_idx, s8 rssi);
 int ath6kl_wmi_set_roam_lrssi_cmd(struct wmi *wmi, u8 lrssi);
 int ath6kl_wmi_force_roam_cmd(struct wmi *wmi, const u8 *bssid);
@@ -2733,6 +2817,8 @@ int ath6kl_wmi_info_req_cmd(struct wmi *wmi, u8 if_idx, u32 info_req_flags);
 
 int ath6kl_wmi_cancel_remain_on_chnl_cmd(struct wmi *wmi, u8 if_idx);
 
+void ath6kl_wmi_send_rdy_evt_to_app(struct net_device *ndev, struct ath6kl *ar);
+
 int ath6kl_wmi_set_appie_cmd(struct wmi *wmi, u8 if_idx, u8 mgmt_frm_type,
 			     const u8 *ie, u8 ie_len);
 int ath6kl_wmi_set_ch_params(struct wmi *wmi, u8 if_idx,
@@ -2745,5 +2831,8 @@ struct ath6kl_vif *ath6kl_get_vif_by_index(struct ath6kl *ar, u8 if_idx);
 void *ath6kl_wmi_init(struct ath6kl *devt);
 void ath6kl_wmi_shutdown(struct wmi *wmi);
 void ath6kl_wmi_reset(struct wmi *wmi);
+int ath6kl_wmi_set_btcoex_debug_cmd(struct wmi *wmi, u8 if_idx, u32 param1,
+				    u32 param2, u32 param3, u32 param4,
+				    u32 param5);
 
 #endif /* WMI_H */
diff --git a/wlan/atheros/compat-wireless/include/linux/nl80211.h b/wlan/atheros/compat-wireless/include/linux/nl80211.h
index 00b7d14..bcf8e8c 100644
--- a/wlan/atheros/compat-wireless/include/linux/nl80211.h
+++ b/wlan/atheros/compat-wireless/include/linux/nl80211.h
@@ -2951,10 +2951,13 @@ enum nl80211_acl_policy_attr {
  * @NL80211_CONN_FAIL_MAX_CLIENTS: Maximum number of clients that can be
  *	handled by the AP is reached.
  * @NL80211_CONN_FAIL_BLOCKED_CLIENT: Client's MAC is in the AP's blocklist.
+ * @NL80211_CONN_FAIL_NEW_CLIENT: Client's MAC is not available either in
+ * 	the accept list or in the deny list.
  * */
 enum nl80211_connect_failed_reason {
 	NL80211_CONN_FAIL_MAX_CLIENTS,
 	NL80211_CONN_FAIL_BLOCKED_CLIENT,
+	NL80211_CONN_FAIL_NEW_CLIENT,
 };
 
 #endif /* __LINUX_NL80211_H */
-- 
1.8.0

