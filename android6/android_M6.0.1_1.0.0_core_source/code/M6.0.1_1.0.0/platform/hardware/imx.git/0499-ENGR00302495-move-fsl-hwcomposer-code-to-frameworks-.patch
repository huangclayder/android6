From 35da4d6e527e15601cba492b421a4c6c6707dd5e Mon Sep 17 00:00:00 2001
From: Liu Xiaowen <b37945@freescale.com>
Date: Mon, 10 Mar 2014 15:14:46 +0800
Subject: [PATCH 499/635] ENGR00302495 move fsl hwcomposer code to
 frameworks/fsl-android-property.git

move fsl hwcomposer code to frameworks/fsl-android-property.git

Signed-off-by: Liu Xiaowen <b37945@freescale.com>
---
 mx6/hwcomposer/Android.mk        |   7 +-
 mx6/hwcomposer/hwc_composite.cpp | 733 ---------------------------------------
 mx6/hwcomposer/hwc_context.h     |  26 +-
 mx6/hwcomposer/hwc_display.cpp   |  11 +-
 mx6/hwcomposer/hwcomposer.cpp    | 488 ++++----------------------
 5 files changed, 82 insertions(+), 1183 deletions(-)
 delete mode 100644 mx6/hwcomposer/hwc_composite.cpp

diff --git a/mx6/hwcomposer/Android.mk b/mx6/hwcomposer/Android.mk
index 632c134..efb7c5a 100644
--- a/mx6/hwcomposer/Android.mk
+++ b/mx6/hwcomposer/Android.mk
@@ -29,16 +29,13 @@ LOCAL_SHARED_LIBRARIES :=			\
 	libui					\
 	libhardware				\
 	libhardware_legacy			\
-	libbinder \
-    libg2d \
-    libsync
+	libbinder
 
 LOCAL_SRC_FILES :=				\
 	hwcomposer.cpp				\
 	hwc_vsync.cpp				\
 	hwc_display.cpp				\
-	hwc_uevent.cpp \
-    hwc_composite.cpp
+	hwc_uevent.cpp
 
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
 LOCAL_C_INCLUDES += hardware/imx/mx6/libgralloc_wrapper \
diff --git a/mx6/hwcomposer/hwc_composite.cpp b/mx6/hwcomposer/hwc_composite.cpp
deleted file mode 100644
index 7abb2fa..0000000
--- a/mx6/hwcomposer/hwc_composite.cpp
+++ /dev/null
@@ -1,733 +0,0 @@
-/*
- * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-#include <math.h>
-
-#define HWC_REMOVE_DEPRECATED_VERSIONS 1
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-#include <utils/threads.h>
-#include <ui/Rect.h>
-#include <ui/Region.h>
-#include <hardware/hwcomposer.h>
-#include <hardware_legacy/uevent.h>
-#include <utils/StrongPointer.h>
-
-#include <linux/mxcfb.h>
-#include <linux/ioctl.h>
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_context.h"
-#include "hwc_vsync.h"
-#include "hwc_uevent.h"
-#include "hwc_display.h"
-#include <g2d.h>
-#include <system/graphics.h>
-
-
-#define MAX_HWC_RECTS 4
-typedef struct hwc_reg {
-    hwc_region_t reg;
-    hwc_rect_t rect[MAX_HWC_RECTS];
-} hwc_reg_t;
-
-extern "C" int get_aligned_size(buffer_handle_t hnd, int *width, int *height);
-
-static bool validateRect(hwc_rect_t& rect)
-{
-    if ((rect.left < 0) || (rect.top < 0) || (rect.right < 0) ||
-        (rect.bottom < 0) || (rect.right - rect.left <= 0) ||
-        (rect.bottom - rect.top <= 0)) {
-        return false;
-    }
-    return true;
-}
-
-static enum g2d_format convertFormat(int format)
-{
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            return G2D_RGBA8888;
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-            return G2D_RGBX8888;
-        case HAL_PIXEL_FORMAT_RGB_565:
-            return G2D_RGB565;
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-            return G2D_BGRA8888;
-
-        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
-            return G2D_NV21;
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-            return G2D_NV12;
-
-        case HAL_PIXEL_FORMAT_YCbCr_420_P:
-            return G2D_I420;
-        case HAL_PIXEL_FORMAT_YV12:
-            return G2D_YV12;
-
-        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-            return G2D_NV16;
-        case HAL_PIXEL_FORMAT_YCbCr_422_I:
-            return G2D_YUYV;
-
-        default:
-            ALOGE("unsupported format:0x%x", format);
-            return G2D_RGBA8888;
-    }
-}
-
-static enum g2d_rotation convertRotation(int transform)
-{
-    switch (transform) {
-        case 0:
-            return G2D_ROTATION_0;
-        case HAL_TRANSFORM_ROT_90:
-            return G2D_ROTATION_90;
-        case HAL_TRANSFORM_FLIP_H | HAL_TRANSFORM_FLIP_V:
-            return G2D_ROTATION_180;
-        case HAL_TRANSFORM_FLIP_H | HAL_TRANSFORM_FLIP_V |
-             HAL_TRANSFORM_ROT_90:
-            return G2D_ROTATION_270;
-        case HAL_TRANSFORM_FLIP_H:
-            return G2D_FLIP_H;
-        case HAL_TRANSFORM_FLIP_V:
-            return G2D_FLIP_V;
-        default:
-            return G2D_ROTATION_0;
-    }
-}
-
-static int convertBlending(int blending, struct g2d_surface& src,
-                        struct g2d_surface& dst)
-{
-    switch (blending) {
-        case HWC_BLENDING_PREMULT:
-            src.blendfunc = G2D_ONE;
-            dst.blendfunc = G2D_ONE_MINUS_SRC_ALPHA;
-            break;
-
-        case HWC_BLENDING_COVERAGE:
-            src.blendfunc = G2D_SRC_ALPHA;
-            dst.blendfunc = G2D_ONE_MINUS_SRC_ALPHA;
-            break;
-
-        case HWC_BLENDING_DIM:
-            src.blendfunc = G2D_ONE;
-            dst.blendfunc = G2D_ONE_MINUS_SRC_ALPHA;
-            break;
-
-        default:
-            src.blendfunc = G2D_ONE;
-            dst.blendfunc = G2D_ONE_MINUS_SRC_ALPHA;
-            break;
-    }
-
-    return 0;
-}
-
-static int setG2dSurface(struct g2d_surface& surface,
-             struct private_handle_t *handle, hwc_rect_t& rect)
-{
-    int alignWidth, alignHeight;
-    int ret = get_aligned_size(handle, &alignWidth, &alignHeight);
-    if (ret != 0) {
-        alignHeight = handle->height;
-    }
-    surface.format = convertFormat(handle->format);
-    surface.planes[0] = handle->phys;
-    surface.stride = handle->flags >> 16;
-    switch (surface.format) {
-        case G2D_RGB565:
-            surface.planes[0] += surface.stride * 2 * (alignHeight - handle->height);
-            break;
-
-        case G2D_RGBA8888:
-        case G2D_BGRA8888:
-        case G2D_RGBX8888:
-            surface.planes[0] += surface.stride * 4 * (alignHeight - handle->height);
-            break;
-
-        case G2D_YUYV:
-            break;
-
-        case G2D_NV16:
-        case G2D_NV12:
-        case G2D_NV21:
-            surface.planes[1] = handle->phys + surface.stride * alignHeight;
-            break;
-
-        case G2D_I420:
-        case G2D_YV12: {
-            int stride = surface.stride;
-            int c_stride = (stride/2+15)/16*16;
-            surface.planes[1] = handle->phys + stride * alignHeight;
-            surface.planes[2] = surface.planes[1] + c_stride * alignHeight/2;
-            } break;
-
-        default:
-            ALOGI("does not support format:%d", surface.format);
-            break;
-    }
-    surface.left = rect.left;
-    surface.top = rect.top;
-    surface.right = rect.right;
-    surface.bottom = rect.bottom;
-    surface.width = handle->width;
-    surface.height = handle->height;
-
-    return 0;
-}
-
-static inline int min(int a, int b) {
-    return (a<b) ? a : b;
-}
-
-static inline int max(int a, int b) {
-    return (a>b) ? a : b;
-}
-
-void convertScalerToInt(hwc_frect_t& in, hwc_rect_t& out)
-{
-    out.left = (int)(ceilf(in.left));
-    out.top = (int)(ceilf(in.top));
-    out.right = (int)(floorf(in.right));
-    out.bottom = (int)(floorf(in.bottom));
-}
-
-static bool isEmpty(const hwc_rect_t & hs)
-{
-    return (hs.left > hs.right || hs.top > hs.bottom);
-}
-
-static bool isIntersect(const hwc_rect_t* lhs, const hwc_rect_t* rhs)
-{
-    if (lhs == NULL || rhs == NULL) {
-        return false;
-    }
-
-    if ((lhs->right < rhs->left) || (lhs->bottom < rhs->top) ||
-        (lhs->left > rhs->right) || (lhs->top > rhs->bottom)) {
-        return false;
-    }
-
-    return true;
-}
-
-static void intersect(hwc_rect_t* out, const hwc_rect_t* lhs,
-            const hwc_rect_t* rhs)
-{
-    if (out == NULL || lhs == NULL || rhs == NULL) {
-        return;
-    }
-
-    out->left = max(lhs->left, rhs->left);
-    out->top = max(lhs->top, rhs->top);
-    out->right = min(lhs->right, rhs->right);
-    out->bottom = min(lhs->bottom, rhs->bottom);
-}
-
-static void unite(hwc_rect_t* out, const hwc_rect_t* lhs,
-            const hwc_rect_t* rhs)
-{
-    if (out == NULL || lhs == NULL || rhs == NULL) {
-        return;
-    }
-
-    out->left = min(lhs->left, rhs->left);
-    out->top = min(lhs->top, rhs->top);
-    out->right = max(lhs->right, rhs->right);
-    out->bottom = max(lhs->bottom, rhs->bottom);
-}
-
-static void subtract(hwc_region_t* out, const hwc_rect_t& lhs,
-            const hwc_rect_t& rhs)
-{
-    if (out == NULL/* || lhs == NULL || rhs == NULL*/) {
-        return;
-    }
-
-    if (!isIntersect(&lhs, &rhs)) {
-        ((hwc_rect_t*)out->rects)[out->numRects].left = lhs.left;
-        ((hwc_rect_t*)out->rects)[out->numRects].top = lhs.top;
-        ((hwc_rect_t*)out->rects)[out->numRects].right = lhs.right;
-        ((hwc_rect_t*)out->rects)[out->numRects].bottom = lhs.bottom;
-    }
-    else if (!isEmpty(lhs)) {
-        if (lhs.top < rhs.top) { // top rect
-            ((hwc_rect_t*)out->rects)[out->numRects].left = lhs.left;
-            ((hwc_rect_t*)out->rects)[out->numRects].top = lhs.top;
-            ((hwc_rect_t*)out->rects)[out->numRects].right = lhs.right;
-            ((hwc_rect_t*)out->rects)[out->numRects].bottom = rhs.top;
-            out->numRects ++;
-        }
-
-        const int32_t top = max(lhs.top, rhs.top);
-        const int32_t bot = min(lhs.bottom, rhs.bottom);
-        if (top < bot) {
-            if (lhs.left < rhs.left) { // left-side rect
-                ((hwc_rect_t*)out->rects)[out->numRects].left = lhs.left;
-                ((hwc_rect_t*)out->rects)[out->numRects].top = top;
-                ((hwc_rect_t*)out->rects)[out->numRects].right = rhs.left;
-                ((hwc_rect_t*)out->rects)[out->numRects].bottom = bot;
-                out->numRects ++;
-            }
-
-            if (lhs.right > rhs.right) { // right-side rect
-                ((hwc_rect_t*)out->rects)[out->numRects].left = rhs.right;
-                ((hwc_rect_t*)out->rects)[out->numRects].top = top;
-                ((hwc_rect_t*)out->rects)[out->numRects].right = lhs.right;
-                ((hwc_rect_t*)out->rects)[out->numRects].bottom = bot;
-                out->numRects ++;
-            }
-        }
-
-        if (lhs.bottom > rhs.bottom) { // bottom rect
-            ((hwc_rect_t*)out->rects)[out->numRects].left = lhs.left;
-            ((hwc_rect_t*)out->rects)[out->numRects].top = rhs.bottom;
-            ((hwc_rect_t*)out->rects)[out->numRects].right = lhs.right;
-            ((hwc_rect_t*)out->rects)[out->numRects].bottom = lhs.bottom;
-            out->numRects ++;
-        }
-    }
-}
-
-static void clipRects(hwc_rect_t& src, hwc_rect_t& dst,
-                     const hwc_rect_t& dstClip, int rotation)
-{
-    hwc_rect_t drect = dst;
-    hwc_rect_t srect = src;
-    int32_t srcW, srcH, dstW, dstH, deltaX, deltaY;
-    intersect(&dst, &dstClip, &drect);
-
-    //rotate 90
-    if (rotation == HAL_TRANSFORM_ROT_90) {
-        dstW = drect.bottom - drect.top;
-        dstH = drect.right - drect.left;
-        deltaX = dst.top - drect.top;
-        deltaY = -dst.right + drect.right;
-    }
-    //virtical flip
-    else if (rotation == HAL_TRANSFORM_FLIP_V) {
-        dstW = drect.right - drect.left;
-        dstH = drect.bottom - drect.top;
-        deltaX = dst.left - drect.left;
-        deltaY = -dst.bottom + drect.bottom;
-    }
-    //horizontal flip
-    else if (rotation == HAL_TRANSFORM_FLIP_H) {
-        dstW = drect.right - drect.left;
-        dstH = drect.bottom - drect.top;
-        deltaX = -dst.right + drect.right;
-        deltaY = dst.top - drect.top;
-    }
-    //rotate 270
-    else if (rotation == (HAL_TRANSFORM_FLIP_H | HAL_TRANSFORM_FLIP_V |
-             HAL_TRANSFORM_ROT_90)) {
-        dstW = drect.bottom - drect.top;
-        dstH = drect.right - drect.left;
-        deltaY = dst.left - drect.left;
-        deltaX = -dst.bottom + drect.bottom;
-    }
-    //rotate 180
-    else if (rotation == (HAL_TRANSFORM_FLIP_H | HAL_TRANSFORM_FLIP_V)) {
-        dstW = drect.right - drect.left;
-        dstH = drect.bottom - drect.top;
-        deltaY = -dst.bottom + drect.bottom;
-        deltaX = -dst.right + drect.right;
-    }
-    //rotate 0
-    else {
-        dstW = drect.right - drect.left;
-        dstH = drect.bottom - drect.top;
-        deltaX = dst.left - drect.left;
-        deltaY = dst.top - drect.top;
-    }
-    srcW = srect.right - srect.left;
-    srcH = srect.bottom - srect.top;
-
-    deltaX = deltaX * srcW / dstW;
-    deltaY = deltaY * srcH / dstH;
-
-    src.left = deltaX + srect.left;
-    src.top = deltaY + srect.top;
-    if (rotation & HAL_TRANSFORM_ROT_90) {
-        src.right = src.left + (dstClip.bottom - dstClip.top)* srcW / dstW;
-        src.bottom = src.top + (dstClip.right - dstClip.left)* srcH / dstH;
-    }
-    else {
-        src.right = src.left + (dstClip.right - dstClip.left) * srcW / dstW;
-        src.bottom = src.top + (dstClip.bottom - dstClip.top) * srcH / dstH;
-    }
-}
-
-int hwc_composite(struct hwc_context_t* ctx, hwc_layer_1_t* layer,
-         struct private_handle_t *dstHandle, hwc_rect_t* swap, bool firstLayer)
-{
-    if (ctx == NULL || ctx->g2d_handle == NULL || layer == NULL || dstHandle == NULL) {
-        ALOGE("%s: invalid parameters", __FUNCTION__);
-        return -EINVAL;
-    }
-
-    //sourceCrop change with version.
-    hwc_rect_t srect;
-    convertScalerToInt(layer->sourceCropf, srect);
-    if (!validateRect(srect) && layer->blending != HWC_BLENDING_DIM) {
-        ALOGE("%s: invalid sourceCrop(l:%d,t:%d,r:%d,b:%d)", __FUNCTION__,
-                 srect.left, srect.top, srect.right, srect.bottom);
-        return -EINVAL;
-    }
-
-    hwc_rect_t drect = layer->displayFrame;
-    if (!validateRect(drect)) {
-        ALOGE("%s: invalid displayFrame(l:%d,t:%d,r:%d,b:%d)", __FUNCTION__,
-                 drect.left, drect.top, drect.right, drect.bottom);
-        return -EINVAL;
-    }
-
-    struct g2d_surface dSurface;
-    memset(&dSurface, 0, sizeof(dSurface));
-
-    for (size_t i=0; i<layer->visibleRegionScreen.numRects; i++) {
-        convertScalerToInt(layer->sourceCropf, srect);
-        drect = layer->displayFrame;
-        if (!validateRect((hwc_rect_t&)layer->visibleRegionScreen.rects[i])) {
-            ALOGI("invalid clip rect");
-            continue;
-        }
-
-        hwc_rect_t clip = layer->visibleRegionScreen.rects[i];
-        if (swap != NULL && !isEmpty(*swap) && isIntersect(swap, &clip)) {
-            intersect(&clip, &clip, swap);
-        }
-
-        clipRects(srect, drect, clip, layer->transform);
-        if (!validateRect(srect) && layer->blending != HWC_BLENDING_DIM) {
-            ALOGV("%s: invalid srect(l:%d,t:%d,r:%d,b:%d)", __FUNCTION__,
-                    srect.left, srect.top, srect.right, srect.bottom);
-            hwc_rect_t src;
-            convertScalerToInt(layer->sourceCropf, src);
-            hwc_rect_t& vis = (hwc_rect_t&)layer->visibleRegionScreen.rects[i];
-            hwc_rect_t& dis = layer->displayFrame;
-            ALOGV("sourceCrop(l:%d,t:%d,r:%d,b:%d), visible(l:%d,t:%d,r:%d,b:%d), "
-                    "display(l:%d,t:%d,r:%d,b:%d)",
-                    src.left, src.top, src.right, src.bottom,
-                    vis.left, vis.top, vis.right, vis.bottom,
-                    dis.left, dis.top, dis.right, dis.bottom);
-            if (swap != NULL) {
-                ALOGV("swap(l:%d,t:%d,r:%d,b:%d)",
-                 swap->left, swap->top, swap->right, swap->bottom);
-            }
-            continue;
-        }
-
-        if (!validateRect(drect)) {
-            ALOGI("%s: invalid drect(l:%d,t:%d,r:%d,b:%d)", __FUNCTION__,
-                    drect.left, drect.top, drect.right, drect.bottom);
-            continue;
-        }
-
-        ALOGV("draw: src(l:%d,t:%d,r:%d,b:%d), dst(l:%d,t:%d,r:%d,b:%d)",
-                srect.left, srect.top, srect.right, srect.bottom,
-                drect.left, drect.top, drect.right, drect.bottom);
-
-        setG2dSurface(dSurface, dstHandle, drect);
-        dSurface.rot = convertRotation(layer->transform);
-
-        struct g2d_surface sSurface;
-        memset(&sSurface, 0, sizeof(sSurface));
-
-        if (layer->blending != HWC_BLENDING_DIM) {
-            struct private_handle_t *priv_handle;
-            priv_handle = (struct private_handle_t *)(layer->handle);
-            setG2dSurface(sSurface, priv_handle, srect);
-        }
-        else {
-            sSurface.clrcolor = 0xff000000;
-            sSurface.format = G2D_RGBA8888;
-        }
-
-        if (firstLayer && layer->blending == HWC_BLENDING_DIM) {
-            continue;
-        }
-
-        ALOGV("blit rot:%d, blending:0x%x, alpha:%d", layer->transform,
-                layer->blending, layer->planeAlpha);
-
-        if (!firstLayer) {
-            convertBlending(layer->blending, sSurface, dSurface);
-        }
-        sSurface.global_alpha = layer->planeAlpha;
-
-        if (layer->blending != HWC_BLENDING_NONE && !firstLayer) {
-            g2d_enable(ctx->g2d_handle, G2D_GLOBAL_ALPHA);
-            if (layer->blending == HWC_BLENDING_DIM) {
-                ALOGV("enable blend dim");
-                g2d_enable(ctx->g2d_handle, G2D_BLEND_DIM);
-            }
-            else {
-                g2d_enable(ctx->g2d_handle, G2D_BLEND);
-            }
-        }
-
-        g2d_blit(ctx->g2d_handle, &sSurface, &dSurface);
-
-        if (layer->blending != HWC_BLENDING_NONE && !firstLayer) {
-            if (layer->blending == HWC_BLENDING_DIM) {
-                g2d_disable(ctx->g2d_handle, G2D_BLEND_DIM);
-            }
-            else {
-                g2d_disable(ctx->g2d_handle, G2D_BLEND);
-            }
-            g2d_disable(ctx->g2d_handle, G2D_GLOBAL_ALPHA);
-        }
-    }
-
-    return 0;
-}
-
-int hwc_copyBack(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                struct private_handle_t *srcHandle, int swapIndex, int disp)
-{
-    if (ctx == NULL || ctx->g2d_handle == NULL || srcHandle == NULL || dstHandle == NULL) {
-        ALOGE("%s: invalid parameters", __FUNCTION__);
-        return -EINVAL;
-    }
-
-    hwc_rect_t& swapRect = ctx->mDispInfo[disp].mSwapRect[swapIndex];
-    hwc_rect_t uniRect;
-    memset(&uniRect, 0, sizeof(uniRect));
-    int index = (swapIndex + 1)%HWC_MAX_FRAMEBUFFER;
-    while (index != swapIndex) {
-        unite(&uniRect, &uniRect, &(ctx->mDispInfo[disp].mSwapRect[index]));
-        index = (index + 1)%HWC_MAX_FRAMEBUFFER;
-    }
-
-    hwc_reg_t resReg;
-    resReg.reg.numRects = 0;
-    resReg.reg.rects = resReg.rect;
-    hwc_region_t &resRegion = resReg.reg;
-    subtract(&resRegion, uniRect, swapRect);
-
-    struct g2d_surface dSurface;
-    memset(&dSurface, 0, sizeof(dSurface));
-    for (size_t i=0; i<resRegion.numRects; i++) {
-        ALOGV("%s(l:%d,t:%d,r:%d,b:%d)", __FUNCTION__,
-            resRegion.rects[i].left, resRegion.rects[i].top,
-            resRegion.rects[i].right, resRegion.rects[i].bottom);
-        if (!validateRect((hwc_rect_t&)resRegion.rects[i])) {
-            ALOGI("invalid rect");
-            continue;
-        }
-
-        setG2dSurface(dSurface, dstHandle, (hwc_rect_t&)resRegion.rects[i]);
-        struct g2d_surface sSurface;
-        memset(&sSurface, 0, sizeof(sSurface));
-        setG2dSurface(sSurface, srcHandle, (hwc_rect_t&)resRegion.rects[i]);
-        g2d_blit(ctx->g2d_handle, &sSurface, &dSurface);
-    }
-
-    return 0;
-}
-
-bool hwc_hasSameContent(struct hwc_context_t* ctx, int src,
-            int dst, hwc_display_contents_1_t** lists)
-{
-    if (ctx == NULL || lists == NULL || src == dst) {
-        ALOGE("%s invalid ctx, lists or src==dst", __FUNCTION__);
-        return false;
-    }
-
-    hwc_display_contents_1_t* sList = lists[src];
-    hwc_display_contents_1_t* dList = lists[dst];
-    if (sList->numHwLayers != dList->numHwLayers) {
-        return false;
-    }
-
-    int numLayers = sList->numHwLayers;
-    for (int i=0; i<numLayers-1; i++) {
-        if (sList->hwLayers[i].handle != dList->hwLayers[i].handle) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-int hwc_resize(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    struct private_handle_t *srcHandle)
-{
-    if (ctx == NULL || ctx->g2d_handle == NULL || srcHandle == NULL || dstHandle == NULL) {
-        ALOGE("%s invalid ctx", __FUNCTION__);
-        return -EINVAL;
-    }
-
-    hwc_rect_t srect;
-    srect.left = 0;
-    srect.top = 0;
-    srect.right = srcHandle->width;
-    srect.bottom = srcHandle->height;
-
-    hwc_rect_t drect;
-    int deltaW = 0, deltaH = 0;
-    int dstW = dstHandle->width;
-    int dstH = dstHandle->height;
-    if (dstW * srcHandle->height >= dstH * srcHandle->width) {
-        dstW = dstH * srcHandle->width / srcHandle->height;
-    }
-    else {
-        dstH = dstW * srcHandle->height / srcHandle->width;
-    }
-
-    deltaW = dstHandle->width - dstW;
-    deltaH = dstHandle->height - dstH;
-    drect.left = deltaW / 2;
-    drect.top = deltaH / 2;
-    drect.right = drect.left + dstW;
-    drect.bottom = drect.top + dstH;
-
-    g2d_surface sSurface, dSurface;
-    memset(&sSurface, 0, sizeof(sSurface));
-    memset(&dSurface, 0, sizeof(dSurface));
-    setG2dSurface(sSurface, srcHandle, srect);
-    setG2dSurface(dSurface, dstHandle, drect);
-
-    g2d_blit(ctx->g2d_handle, &sSurface, &dSurface);
-
-    return 0;
-}
-
-int hwc_updateSwapRect(struct hwc_context_t* ctx, int disp,
-                 android_native_buffer_t* nbuf)
-{
-    if (ctx == NULL) {
-        ALOGE("%s invalid ctx", __FUNCTION__);
-        return -EINVAL;
-    }
-
-    int index = ctx->mDispInfo[disp].mSwapIndex;
-    ctx->mDispInfo[disp].mSwapIndex = (index + 1)%HWC_MAX_FRAMEBUFFER;
-    hwc_rect_t& swapRect = ctx->mDispInfo[disp].mSwapRect[index];
-    if (nbuf != NULL) {
-        int origin = (int) nbuf->common.reserved[0];
-        int size = (int) nbuf->common.reserved[1];
-        if (origin != 0 && size != 0) {
-            swapRect.left = origin >> 16;
-            swapRect.top = origin & 0xFFFF;
-            swapRect.right = swapRect.left + (size >> 16);
-            swapRect.bottom = swapRect.top + (size & 0xFFFF);
-            ALOGV("swapRect:(l:%d,t:%d,r:%d,b:%d)",
-                swapRect.left, swapRect.top, swapRect.right, swapRect.bottom);
-            return index;
-        }
-    }
-
-    swapRect.left = 0;
-    swapRect.top = 0;
-    swapRect.right = ctx->mDispInfo[disp].xres;
-    swapRect.bottom = ctx->mDispInfo[disp].yres;
-    ALOGV("swapRect:(l:%d,t:%d,r:%d,b:%d)",
-        swapRect.left, swapRect.top, swapRect.right, swapRect.bottom);
-    return index;
-}
-
-int hwc_clearWormHole(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    hwc_display_contents_1_t* list, int disp, hwc_rect_t* swap)
-{
-    if (ctx == NULL || dstHandle == NULL || list == NULL) {
-        return -EINVAL;
-    }
-
-    Region opaque;
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        if ((layer->blending == HWC_BLENDING_NONE) ||
-                (i==0 && layer->blending == HWC_BLENDING_PREMULT) ||
-                ((i!=0) && (layer->blending == HWC_BLENDING_DIM) &&
-                 layer->planeAlpha == 0xff)) {
-            for (size_t n=0; n<layer->visibleRegionScreen.numRects; n++) {
-                Rect rect;
-                const hwc_rect_t &hrect = layer->visibleRegionScreen.rects[n];
-                ALOGV("opaque: src(l:%d,t:%d,r:%d,b:%d)",
-                        rect.left, rect.top, rect.right, rect.bottom);
-                if (!validateRect((hwc_rect_t &)hrect)) {
-                    continue;
-                }
-                memcpy(&rect, &hrect, sizeof(hrect));
-                opaque.orSelf(rect);
-            }
-        }
-    }
-
-    Rect dispRect(ctx->mDispInfo[disp].xres, ctx->mDispInfo[disp].yres);
-    Region screen(dispRect);
-    screen.subtractSelf(opaque);
-    const Rect *holes = NULL;
-    size_t numRect = 0;
-    holes = screen.getArray(&numRect);
-
-    struct g2d_surface surface;
-    memset(&surface, 0, sizeof(surface));
-    for (size_t i=0; i<numRect; i++) {
-        if (holes[i].isEmpty()) {
-            continue;
-        }
-
-        hwc_rect_t rect;
-        memcpy(&rect, &holes[i], sizeof(rect));
-        if (swap != NULL) {
-            intersect(&rect, &rect, swap);
-        }
-        if (!validateRect(rect)) {
-            continue;
-        }
-        ALOGV("clearhole: hole(l:%d,t:%d,r:%d,b:%d)",
-                rect.left, rect.top, rect.right, rect.bottom);
-        setG2dSurface(surface, dstHandle, rect);
-        surface.clrcolor = 0xff << 24;
-        g2d_clear(ctx->g2d_handle, &surface);
-    }
-
-    return 0;
-}
-
-int hwc_clearRect(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    hwc_rect_t &rect)
-{
-    if (ctx == NULL || dstHandle == NULL) {
-        return -EINVAL;
-    }
-
-    if (!validateRect(rect)) {
-        return -EINVAL;
-    }
-
-    struct g2d_surface surface;
-    memset(&surface, 0, sizeof(surface));
-
-    setG2dSurface(surface, dstHandle, rect);
-    surface.clrcolor = 0xff << 24;
-    g2d_clear(ctx->g2d_handle, &surface);
-
-    return 0;
-}
-
diff --git a/mx6/hwcomposer/hwc_context.h b/mx6/hwcomposer/hwc_context.h
index cc3de6d..fbae66a 100644
--- a/mx6/hwcomposer/hwc_context.h
+++ b/mx6/hwcomposer/hwc_context.h
@@ -39,6 +39,7 @@
 #include "hwc_uevent.h"
 /*****************************************************************************/
 #define HWC_VIV_HARDWARE_MODULE_ID "hwcomposer_viv"
+#define HWC_FSL_HARDWARE_MODULE_ID "hwcomposer_fsl"
 #define HWC_MAIN_FB "/dev/graphics/fb0"
 #define HWC_MAX_FB 6
 #define HWC_PATH_LENGTH 256
@@ -74,21 +75,24 @@ typedef struct {
     int ydpi;
     int blank;
     int format;
-
-    sp<ANativeWindow> mDisplaySurface;
-    hwc_region_t mWormHole;
-    bool mG2dProcs;
-    //struct g2d_buf* mCurrentBuffer;
-    //buffer_handle_t mLastHandle;
-    int mSwapIndex;
-    hwc_rect_t mSwapRect[HWC_MAX_FRAMEBUFFER];
 } displayInfo;
 
+struct hwc_context_t;
+
+struct hwc_operations {
+    void (*setDisplayInfo)(int disp, struct hwc_context_t* ctx);
+    int (*prepare)(struct hwc_context_t* ctx,
+                    size_t numDisplays, hwc_display_contents_1_t** displays);
+    int (*set)(struct hwc_context_t* ctx,
+                size_t numDisplays, hwc_display_contents_1_t** displays);
+    int (*blank)(struct hwc_context_t* ctx, int disp, int blank);
+    int (*close)(struct hwc_context_t* ctx);
+};
+
 struct hwc_context_t {
     hwc_composer_device_1 device;
     /* our private state goes below here */
     displayInfo mDispInfo[HWC_NUM_DISPLAY_TYPES];
-    void* g2d_handle;
 
     bool m_vsync_enable;
 
@@ -101,6 +105,10 @@ struct hwc_context_t {
     hw_module_t const *m_gralloc_module;
 
     framebuffer_device_t* mFbDev[HWC_NUM_DISPLAY_TYPES];
+
+    //fsl private property and operations.
+    void* m_priv;
+    hwc_operations* m_hwc_ops;
 };
 
 #endif
diff --git a/mx6/hwcomposer/hwc_display.cpp b/mx6/hwcomposer/hwc_display.cpp
index 3555c65..b2649e6 100644
--- a/mx6/hwcomposer/hwc_display.cpp
+++ b/mx6/hwcomposer/hwc_display.cpp
@@ -210,14 +210,6 @@ int hwc_get_framebuffer_info(displayInfo *pInfo)
           info.height, pInfo->ydpi / 1000.0, refreshRate,
           pInfo->format);
 
-    pInfo->mSwapIndex = 0;
-    for (int i=0; i<HWC_MAX_FRAMEBUFFER; i++) {
-        pInfo->mSwapRect[i].left = 0;
-        pInfo->mSwapRect[i].top = 0;
-        pInfo->mSwapRect[i].right = pInfo->xres;
-        pInfo->mSwapRect[i].bottom = pInfo->yres;
-    }
-
     return NO_ERROR;
 }
 
@@ -231,6 +223,9 @@ int hwc_get_display_info(struct hwc_context_t* ctx)
         displayInfo *pInfo = &ctx->mDispInfo[dispid];
         if(pInfo->connected) {
             err = hwc_get_framebuffer_info(pInfo);
+            if (!err && ctx->m_hwc_ops) {
+                ctx->m_hwc_ops->setDisplayInfo(dispid, ctx);
+            }
         }
     }
 
diff --git a/mx6/hwcomposer/hwcomposer.cpp b/mx6/hwcomposer/hwcomposer.cpp
index 69dac57..df5d96f 100644
--- a/mx6/hwcomposer/hwcomposer.cpp
+++ b/mx6/hwcomposer/hwcomposer.cpp
@@ -53,21 +53,6 @@ static PFNEGLPOSTBUFFERVIVPROC _eglPostBufferVIV;
 static int hwc_device_open(const struct hw_module_t* module, const char* name,
         struct hw_device_t** device);
 
-extern int hwc_composite(struct hwc_context_t* ctx, hwc_layer_1_t* layer,
-                    struct private_handle_t *dstHandle, hwc_rect_t* swap, bool firstLayer);
-extern int hwc_clearWormHole(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    hwc_display_contents_1_t* list, int disp, hwc_rect_t* swap);
-extern int hwc_clearRect(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    hwc_rect_t &rect);
-extern int hwc_copyBack(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    struct private_handle_t *srcHandle, int swapIndex, int disp);
-extern int hwc_resize(struct hwc_context_t* ctx, struct private_handle_t *dstHandle,
-                    struct private_handle_t *srcHandle);
-extern int hwc_updateSwapRect(struct hwc_context_t* ctx, int disp,
-                 android_native_buffer_t* nbuf);
-extern bool hwc_hasSameContent(struct hwc_context_t* ctx, int src,
-            int dst, hwc_display_contents_1_t** lists);
-
 static struct hw_module_methods_t hwc_module_methods = {
     open: hwc_device_open
 };
@@ -121,8 +106,8 @@ static int hwc_device_close(struct hw_device_t *dev)
                 close(ctx->mDispInfo[i].fd);
         }
 
-        if (ctx->g2d_handle != NULL) {
-            g2d_close(ctx->g2d_handle);
+        if (ctx->m_hwc_ops != NULL) {
+            ctx->m_hwc_ops->close(ctx);
         }
 
         if(ctx->m_viv_hwc) {
@@ -134,267 +119,6 @@ static int hwc_device_close(struct hw_device_t *dev)
     return 0;
 }
 
-static bool checkG2dProcs(struct hwc_context_t* ctx,
-                    hwc_display_contents_1_t* list)
-{
-    if (ctx == NULL || list == NULL) {
-        return false;
-    }
-
-    hwc_layer_1_t* targetLayer = &list->hwLayers[list->numHwLayers-1];
-    struct private_handle_t *targetHandle;
-    targetHandle = (struct private_handle_t *)targetLayer->handle;
-    if (targetHandle == NULL) {
-        ALOGI("prepare: targetHandle is null");
-        return false;
-    }
-
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        if (layer->flags & HWC_SKIP_LAYER) {
-            ALOGV("skip layer");
-            return false;
-        }
-
-        if ((layer->blending & 0xFFFF) == HWC_BLENDING_DIM) {
-            ALOGV("dim layer");
-            continue;
-        }
-
-        if (layer->handle == NULL) {
-            ALOGV("layer handle is null");
-            return false;
-        }
-    }
-
-    return true;
-}
-
-static int hwc_prepare_physical(struct hwc_context_t* ctx, int disp,
-                         hwc_display_contents_1_t* list)
-{
-    if (ctx == NULL || ctx->g2d_handle == NULL || list == NULL) {
-        ctx->mDispInfo[disp].mG2dProcs = false;
-        ALOGV("%s: disp:%d invalid parameter", __FUNCTION__, disp);
-        return 0;
-    }
-
-    if (!ctx->mDispInfo[disp].connected) {
-        ALOGE("physical display:%d is diconnected", disp);
-        ctx->mDispInfo[disp].mG2dProcs = false;
-        return -EINVAL;
-    }
-
-    bool g2dProcs = checkG2dProcs(ctx, list);
-    if (!g2dProcs) {
-        ALOGV("pass to 3D to handle");
-        ctx->mDispInfo[disp].mG2dProcs = false;
-        return 0;
-    }
-
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        layer->compositionType = HWC_G2D;
-    }
-    ctx->mDispInfo[disp].mG2dProcs = true;
-
-    return 0;
-}
-
-static int hwc_prepare_virtual(struct hwc_context_t* ctx, int disp,
-                         hwc_display_contents_1_t* list)
-{
-    if (ctx == NULL || ctx->g2d_handle == NULL || list == NULL) {
-        ctx->mDispInfo[disp].mG2dProcs = false;
-        ALOGV("%s: disp:%d invalid parameter", __FUNCTION__, disp);
-        return 0;
-    }
-
-    bool g2dProcs = checkG2dProcs(ctx, list);
-    if (!g2dProcs) {
-        ALOGV("pass to 3D to handle");
-        ctx->mDispInfo[disp].mG2dProcs = false;
-        return 0;
-    }
-
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        layer->compositionType = HWC_G2D;
-    }
-    ctx->mDispInfo[disp].mG2dProcs = true;
-
-    return 0;
-}
-
-static int hwc_set_physical(struct hwc_context_t* ctx, int disp,
-                         hwc_display_contents_1_t** contents)
-{
-    hwc_display_contents_1_t* list = contents[disp];
-    if (ctx == NULL || list == NULL) {
-        ALOGV("%s: disp:%d invalid parameter", __FUNCTION__, disp);
-        return 0;
-    }
-
-    // to do copyback when use swap retangle.
-    hwc_layer_1_t* targetLayer = &list->hwLayers[list->numHwLayers-1];
-    struct private_handle_t *targetHandle;
-    targetHandle = (struct private_handle_t *)targetLayer->handle;
-
-    if (!ctx->mDispInfo[disp].mG2dProcs) {
-        if (targetHandle != NULL && ctx->mDispInfo[disp].connected) {
-            ctx->mFbDev[disp]->post(ctx->mFbDev[disp], targetHandle);
-        }
-        hwc_updateSwapRect(ctx, disp, NULL);
-        return 0;
-    }
-
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        if (layer->compositionType != HWC_G2D) {
-            ALOGE("invalid compositionType:%d", layer->compositionType);
-            return -EINVAL;
-        }
-    }
-
-    //framebuffer handle.
-    android_native_buffer_t *fbuffer = NULL;
-    struct private_handle_t *frameHandle;
-    fbuffer = (ANativeWindowBuffer *) _eglGetRenderBufferVIV(targetHandle);
-    if (fbuffer == NULL) {
-        ALOGE("get render buffer failed!");
-        return -EINVAL;
-    }
-
-    frameHandle = (struct private_handle_t *)(fbuffer->handle);
-    if (frameHandle == NULL) {
-        ALOGE("invalid frame buffer handle");
-        return -EINVAL;
-    }
-
-    int index = hwc_updateSwapRect(ctx, disp, fbuffer);
-    if (index < 0) {
-        ALOGE("invalid index");
-        return -EINVAL;
-    }
-
-    hwc_rect_t& swapRect = ctx->mDispInfo[disp].mSwapRect[index];
-    hwc_clearWormHole(ctx, frameHandle, list, disp, &swapRect);
-
-    bool resized = false;
-    if (disp != HWC_DISPLAY_PRIMARY &&
-        hwc_hasSameContent(ctx, HWC_DISPLAY_PRIMARY, disp, contents)) {
-        hwc_display_contents_1_t* sList = contents[HWC_DISPLAY_PRIMARY];
-        hwc_layer_1_t* primaryLayer = &sList->hwLayers[sList->numHwLayers-1];
-        struct private_handle_t *primaryHandle = NULL;
-        primaryHandle = (struct private_handle_t *)primaryLayer->handle;
-        if (primaryHandle != NULL) {
-            hwc_resize(ctx, frameHandle, primaryHandle);
-            resized = true;
-        }
-    }
-
-    if (!resized) {
-        for (size_t i=0; i<list->numHwLayers-1; i++) {
-            layer = &list->hwLayers[i];
-            int fenceFd = layer->acquireFenceFd;
-            if (fenceFd > 0) {
-                ALOGI("fenceFd:%d", fenceFd);
-                sync_wait(fenceFd, -1);
-                close(fenceFd);
-                layer->acquireFenceFd = -1;
-            }
-            hwc_composite(ctx, layer, frameHandle, &swapRect, i==0);
-        }
-
-        hwc_copyBack(ctx, frameHandle, targetHandle, index, disp);
-    }
-    g2d_finish(ctx->g2d_handle);
-
-    _eglPostBufferVIV(fbuffer);
-
-    targetHandle = (struct private_handle_t *)targetLayer->handle;
-    if (targetHandle != NULL && ctx->mDispInfo[disp].connected && ctx->mDispInfo[disp].blank == 0) {
-        ctx->mFbDev[disp]->post(ctx->mFbDev[disp], targetHandle);
-    }
-
-    return 0;
-}
-
-static int hwc_set_virtual(struct hwc_context_t* ctx, int disp,
-                         hwc_display_contents_1_t** contents)
-{
-    hwc_display_contents_1_t* list = contents[disp];
-    if (ctx == NULL || list == NULL) {
-        return 0;
-    }
-
-    if (list->outbuf == NULL) {
-        ALOGE("invalid outbuf for virtual display");
-        return -EINVAL;
-    }
-
-    struct private_handle_t *frameHandle;
-    frameHandle = (struct private_handle_t *)(list->outbuf);
-    if (frameHandle == NULL) {
-        ALOGE("invalid frame buffer handle");
-        return -EINVAL;
-    }
-
-    if (!ctx->mDispInfo[disp].mG2dProcs) {
-        return 0;
-    }
-
-    hwc_layer_1_t* layer = NULL;
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        if (layer->compositionType != HWC_G2D) {
-            ALOGE("invalid compositionType:%d", layer->compositionType);
-            return -EINVAL;
-        }
-    }
-
-    int fenceFd = list->outbufAcquireFenceFd;
-    if (fenceFd != -1) {
-        sync_wait(fenceFd, -1);
-        close(fenceFd);
-        list->outbufAcquireFenceFd = -1;
-    }
-
-    if (disp != HWC_DISPLAY_PRIMARY &&
-        hwc_hasSameContent(ctx, HWC_DISPLAY_PRIMARY, disp, contents)) {
-        hwc_display_contents_1_t* sList = contents[HWC_DISPLAY_PRIMARY];
-        hwc_layer_1_t* primaryLayer = &sList->hwLayers[sList->numHwLayers-1];
-        struct private_handle_t *primaryHandle = NULL;
-        primaryHandle = (struct private_handle_t *)primaryLayer->handle;
-        if (primaryHandle != NULL) {
-            hwc_resize(ctx, frameHandle, primaryHandle);
-            g2d_finish(ctx->g2d_handle);
-            return 0;
-        }
-    }
-
-    for (size_t i=0; i<list->numHwLayers-1; i++) {
-        layer = &list->hwLayers[i];
-        int fenceFd = layer->acquireFenceFd;
-        if (fenceFd > 0) {
-            ALOGI("fenceFd:%d", fenceFd);
-            sync_wait(fenceFd, -1);
-            close(fenceFd);
-            layer->acquireFenceFd = -1;
-        }
-
-        hwc_composite(ctx, layer, frameHandle, NULL, i==0);
-    }
-
-    g2d_finish(ctx->g2d_handle);
-
-    return 0;
-}
-
 static int hwc_prepare(hwc_composer_device_1_t *dev,
         size_t numDisplays, hwc_display_contents_1_t** displays)
 {
@@ -413,34 +137,8 @@ static int hwc_prepare(hwc_composer_device_1_t *dev,
         return ctx->m_viv_hwc->prepare(ctx->m_viv_hwc, numDisplays, displays);
     }
 
-    if (ctx->g2d_handle == NULL) {
-        g2d_open(&ctx->g2d_handle);
-        if (ctx->g2d_handle == NULL) {
-            ALOGE("%s invalid g2d_handle", __FUNCTION__);
-            return 0;
-        }
-    }
-
-    char property[PROPERTY_VALUE_MAX];
-    property_get("service.bootanim.exit", property, "0");
-    if(!atoi(property)) numDisplays = numDisplays >= 1 ? 1 : 0;
-
-    for (size_t i = 0; i < numDisplays; i++) {
-        hwc_display_contents_1_t *list = displays[i];
-        switch(i) {
-            case HWC_DISPLAY_PRIMARY:
-                ret = hwc_prepare_physical(ctx, i, displays[i]);
-                break;
-            case HWC_DISPLAY_EXTERNAL:
-                ret = hwc_prepare_physical(ctx, i, displays[i]);
-                break;
-            case HWC_DISPLAY_VIRTUAL:
-                ret = hwc_prepare_virtual(ctx, i, displays[i]);
-                break;
-            default:
-                ALOGI("invalid display id:%d", i);
-                break;
-        }
+    if (ctx->m_hwc_ops) {
+        return ctx->m_hwc_ops->prepare(ctx, numDisplays, displays);
     }
 
     return ret;
@@ -457,59 +155,38 @@ static int hwc_set(struct hwc_composer_device_1 *dev,
     int ret = 0;
     struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
 
-    if(ctx->m_viv_hwc) {
+    hwc_display_contents_1_t *primary = displays[HWC_DISPLAY_PRIMARY];
+    hwc_display_contents_1_t *external = displays[HWC_DISPLAY_EXTERNAL];
+
+    if(ctx->m_viv_hwc || ctx->m_hwc_ops) {
         char property[PROPERTY_VALUE_MAX];
         property_get("service.bootanim.exit", property, "0");
         if(!atoi(property)) numDisplays = numDisplays >= 1 ? 1 : 0;
 
-        int err = ctx->m_viv_hwc->set(ctx->m_viv_hwc, numDisplays, displays);
-        if(err) return err;
-
-        hwc_display_contents_1_t *primary_contents = displays[HWC_DISPLAY_PRIMARY];
-        hwc_display_contents_1_t *external_contents = displays[HWC_DISPLAY_EXTERNAL];
-        if (primary_contents && ctx->mDispInfo[HWC_DISPLAY_PRIMARY].blank == 0) {
-            hwc_layer_1 *fbt = &primary_contents->hwLayers[primary_contents->numHwLayers - 1];
-            if(ctx->mFbDev[HWC_DISPLAY_PRIMARY] != NULL)
-                ctx->mFbDev[HWC_DISPLAY_PRIMARY]->post(ctx->mFbDev[HWC_DISPLAY_PRIMARY],  fbt->handle);
+        if (ctx->m_viv_hwc) {
+            ret = ctx->m_viv_hwc->set(ctx->m_viv_hwc, numDisplays, displays);
         }
-
-        if (external_contents && ctx->mDispInfo[HWC_DISPLAY_EXTERNAL].blank == 0) {
-            hwc_layer_1 *fbt = &external_contents->hwLayers[external_contents->numHwLayers - 1];
-            if(ctx->mFbDev[HWC_DISPLAY_EXTERNAL] != NULL)
-                ctx->mFbDev[HWC_DISPLAY_EXTERNAL]->post(ctx->mFbDev[HWC_DISPLAY_EXTERNAL], fbt->handle);
+        else {
+            ret = ctx->m_hwc_ops->set(ctx, numDisplays, displays);
         }
-
-        return 0;
+        if(ret) return ret;
     }
 
-    if (ctx->g2d_handle == NULL) {
-        ALOGI("%s invalid g2d_handle", __FUNCTION__);
-        return 0;
+    if (primary && ctx->mDispInfo[HWC_DISPLAY_PRIMARY].blank == 0) {
+        hwc_layer_1 *fbt = &primary->hwLayers[primary->numHwLayers-1];
+        if(ctx->mFbDev[HWC_DISPLAY_PRIMARY] != NULL)
+            ctx->mFbDev[HWC_DISPLAY_PRIMARY]->post(
+                     ctx->mFbDev[HWC_DISPLAY_PRIMARY],  fbt->handle);
     }
 
-    char property[PROPERTY_VALUE_MAX];
-    property_get("service.bootanim.exit", property, "0");
-    if(!atoi(property)) numDisplays = numDisplays >= 1 ? 1 : 0;
-
-    for (size_t i = 0; i < numDisplays;i++) {
-        hwc_display_contents_1_t *list = displays[i];
-        switch(i) {
-            case HWC_DISPLAY_PRIMARY:
-                ret = hwc_set_physical(ctx, i, displays);
-                break;
-            case HWC_DISPLAY_EXTERNAL:
-                ret = hwc_set_physical(ctx, i, displays);
-                break;
-            case HWC_DISPLAY_VIRTUAL:
-                ret = hwc_set_virtual(ctx, i, displays);
-                break;
-            default:
-                ALOGI("invalid display id:%d", i);
-                break;
-        }
+    if (external && ctx->mDispInfo[HWC_DISPLAY_EXTERNAL].blank == 0) {
+        hwc_layer_1 *fbt = &external->hwLayers[external->numHwLayers-1];
+        if(ctx->mFbDev[HWC_DISPLAY_EXTERNAL] != NULL)
+            ctx->mFbDev[HWC_DISPLAY_EXTERNAL]->post(
+                     ctx->mFbDev[HWC_DISPLAY_EXTERNAL], fbt->handle);
     }
 
-    return ret;
+    return 0;
 }
 
 static void hwc_registerProcs(struct hwc_composer_device_1* dev,
@@ -562,6 +239,10 @@ static int hwc_blank(struct hwc_composer_device_1 *dev, int disp, int blank)
         ctx->m_viv_hwc->blank(ctx->m_viv_hwc, disp, blank);
     }
 
+    if (ctx->m_hwc_ops) {
+        ctx->m_hwc_ops->blank(ctx, disp, blank);
+    }
+
     ctx->mDispInfo[disp].blank = blank;
 
     //HDMI need to keep unblank since audio need to be able to output
@@ -646,37 +327,6 @@ static int hwc_getDisplayAttributes(struct hwc_composer_device_1 *dev,
     return 0;
 }
 
-static int hwc_setDisplaySurface(struct hwc_composer_device_1 *dev,
-        int disp, ANativeWindow* window)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-    if (!ctx || disp < 0 || disp >= HWC_NUM_DISPLAY_TYPES) {
-        return -EINVAL;
-    }
-
-    ALOGI("%s: disp:%d", __FUNCTION__, disp);
-    ctx->mDispInfo[disp].mDisplaySurface = window;
-
-    return 0;
-}
-
-static int hwc_setDisplayWormHole(struct hwc_composer_device_1 *dev,
-        int disp, hwc_region_t& hole)
-{
-    struct hwc_context_t* ctx = (struct hwc_context_t*)dev;
-    if (!ctx || disp < 0 || disp >= HWC_NUM_DISPLAY_TYPES) {
-        return -EINVAL;
-    }
-
-    ALOGI("%s: disp:%d", __FUNCTION__, disp);
-    ctx->mDispInfo[disp].mWormHole.numRects = hole.numRects;
-    if (hole.numRects > 0 && hole.rects != NULL) {
-        ctx->mDispInfo[disp].mWormHole.rects = (const hwc_rect_t*)malloc(hole.numRects*sizeof(hwc_rect_t));
-        memcpy((void*)ctx->mDispInfo[disp].mWormHole.rects, hole.rects, hole.numRects*sizeof(hwc_rect_t));
-    }
-
-    return 0;
-}
 /*****************************************************************************/
 
 static int hwc_device_open(const struct hw_module_t* module, const char* name,
@@ -706,15 +356,43 @@ static int hwc_device_open(const struct hw_module_t* module, const char* name,
         dev->device.blank = hwc_blank;
         dev->device.getDisplayConfigs = hwc_getDisplayConfigs;
         dev->device.getDisplayAttributes = hwc_getDisplayAttributes;
-        //dev->device.setDisplaySurface = hwc_setDisplaySurface;
 
         /* our private state goes below here */
         dev->m_vsync_thread = new VSyncThread(dev);
         dev->m_uevent_thread = new UeventThread(dev);
-        hwc_get_display_info(dev);
 
+        bool using_viv_hwc = false;
+        const hw_module_t *hwc_module;
+        if(hw_get_module(HWC_VIV_HARDWARE_MODULE_ID,
+                    (const hw_module_t**)&hwc_module) < 0) {
+            ALOGE("Error! hw_get_module viv_hwc failed");
+        }
+        else if(hwc_open_1(hwc_module, &(dev->m_viv_hwc)) != 0) {
+            ALOGE("Error! viv_hwc open failed");
+        }
+        else {
+            ALOGI("using viv hwc!");
+            using_viv_hwc = true;
+        }
+
+        if (!using_viv_hwc) {
+            if (hw_get_module(HWC_FSL_HARDWARE_MODULE_ID,
+                    (const hw_module_t**)&hwc_module) < 0) {
+                ALOGE("Error! hw_get_module fsl_hwc failed");
+            }
+            else if (hwc_open_1(hwc_module, (hwc_composer_device_1_t**)&dev) != 0) {
+                //set m_hwc_ops and m_priv;
+                ALOGE("Error! hw_get_module fsl_hwc failed");
+            }
+            else {
+                ALOGI("using fsl hwc!");
+            }
+        }
+
+        hwc_get_display_info(dev);
         hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &dev->m_gralloc_module);
-        struct private_module_t *priv_m = (struct private_module_t *)dev->m_gralloc_module;
+        struct private_module_t *priv_m =
+                         (struct private_module_t *)dev->m_gralloc_module;
 
         for(int dispid=0; dispid<HWC_NUM_DISPLAY_TYPES; dispid++) {
             if(dev->mDispInfo[dispid].connected && dev->m_gralloc_module != NULL) {
@@ -729,57 +407,11 @@ static int hwc_device_open(const struct hw_module_t* module, const char* name,
             }
         }
 
-        char property[PROPERTY_VALUE_MAX];
-        property_get("sys.fsl.hwc", property, "0");
-        if(!atoi(property)) {
-            const hw_module_t *hwc_module;
-            if(hw_get_module(HWC_VIV_HARDWARE_MODULE_ID,
-                        (const hw_module_t**)&hwc_module) < 0) {
-                ALOGE("Error! hw_get_module viv_hwc failed");
-            }
-            else if(hwc_open_1(hwc_module, &(dev->m_viv_hwc)) != 0) {
-                ALOGE("Error! viv_hwc open failed");
-            }
-            else {
-                ALOGI("using viv hwc!");
-                goto nor_exit;
-            }
-        }
-
-        if (_eglGetRenderBufferVIV == NULL || _eglPostBufferVIV == NULL)
-        {
-            _eglGetRenderBufferVIV = (PFNEGLGETRENDERBUFFERVIVPROC)
-                eglGetProcAddress("eglGetRenderBufferVIV");
-
-            if (_eglGetRenderBufferVIV == NULL)
-            {
-                ALOGE("eglGetRenderBufferVIV not found!");
-                status = -EINVAL;
-                goto err_exit;
-            }
-
-            _eglPostBufferVIV = (PFNEGLPOSTBUFFERVIVPROC)
-                eglGetProcAddress("eglPostBufferVIV");
-
-            if (_eglPostBufferVIV == NULL)
-            {
-                ALOGE("eglPostBufferVIV not found!");
-                status = -EINVAL;
-                goto err_exit;
-            }
-        }
-        ALOGI("using fsl hwc!");
-
-nor_exit:
         *device = &dev->device.common;
-	    ALOGI("%s,%d", __FUNCTION__, __LINE__);
+	ALOGI("%s,%d", __FUNCTION__, __LINE__);
         return 0;
     }
 
-err_exit:
-	if(dev){
-	    free(dev);
-	}
     /****************************************/
     return status;
 }
-- 
1.8.0

